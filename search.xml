<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode - 刷題之旅的總結與心得</title>
      <link href="/posts/leetcode-sum-up/"/>
      <url>/posts/leetcode-sum-up/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>這裡是我寫Leetcode總結核心概念的地方，不同的情境會使用到的武器不同，這裡我會描述在什麼樣的情境滿足下，適合的資料結構或是演算法。而這個演算法的核心概念是什麼，同時我也會紀錄一些我在刷題時的心得，以及刷題的時間，來慢慢看到成長與進步。</p><div class="note info flat"><p><a href="https://docs.google.com/spreadsheets/d/1hPIzYcGlZV36lumGjxdZLx4_HmuvYNmc_RIRpt8uN18/edit?usp=sharing">Leetcode時間紀錄</a></p></div><h1 id="Hash-Table">Hash Table</h1><h2 id="情境1-快速找元素">情境1: 快速找元素</h2><ul><li>通常使用 Hash 的關鍵在於要<em>用 O(1) 的時間複雜度來查找元素</em>，這樣就可以不用遍歷整個 list 從 O(n) 變成 O(1) 的時間內完成整個問題。</li><li>相關題目：<ul><li><a href="/posts/leetcode-1-two-sum">leetcode-1-two-sum</a>: 給定一個 target 數值，從 list 中找到兩個數字相加等於 target</li><li><a href="/posts/leetcode-12-integer-to-roman">leetcode-12-integer-to-roman</a>: 整數轉羅馬數字</li><li><a href="/posts/leetcode-13-roman-to-integer">leetcode-13-roman-to-integer</a>: 羅馬數字轉整數</li></ul></li></ul><h2 id="情境2-比對無序的東西">情境2: 比對無序的東西</h2><ul><li>如果要比對兩個無序的東西，像是兩個字串是否是 Anagram，這時候可以使用 Hash 來記錄每個字元出現的次數，然後比對兩個 Hash 是否相同。</li><li>相關題目：<ul><li><a href="/posts/leetcode-49-group-anagrams">leetcode-49-group-anagrams</a>: 儘管字母打亂，但是只要字母相同就算一類</li></ul></li></ul><h2 id="情境3-找連續的不重複元素">情境3: 找連續的不重複元素</h2><ul><li>找連續的數字，核心關鍵就是指標的移動，如果想要確保時間複雜度為O(n)表示每個數字只會被遍歷一次，肯定要使用 Hash 的方式來找。</li><li>題目有可能會搭配 sliding window，像是有的題目會要求從字串<em>找出不重複的子字串</em>，這時候就可以使用 Hash 來記錄出現過的元素，並且在遇到重複的元素時，可以快速的移動左指針。</li><li>相關題目：<ul><li><a href="/posts/leetcode-3-longest-substring-without-repeating-characters">leetcode-3-longest-substring-without-repeating-characters</a>: 找出最長的不重複子字串</li><li><a href="/posts/leetcode-128-longest-consecutive-sequence">leetcode-128-longest-consecutive-sequence</a>: 找出最長的連續數字</li></ul></li></ul><h2 id="情境4-替換原本的node">情境4:替換原本的node</h2><ul><li>如果今天有需求把 <code>old_node</code> 變成 <code>new_node</code> 簡單來說就是建立一個一模一樣的 linked list，可以使用 HashTable 直接把 <code>old_node</code> 當作 key，<code>new_node</code> 當作 value。這樣不管是串 next 還是串 random 都只要拿 old_node 去找，就可以找到 new_node，然後開始串。</li><li>相關題目：<ul><li><a href="/posts/leetcode-138-copy-list-with-random-pointer">leetcode-138-copy-list-with-random-pointer</a>: 複製一個有 random node 的 linked list</li></ul></li></ul><h1 id="Stack-Queue">Stack &amp; Queue</h1><h2 id="情境1-後進先出問題">情境1: 後進先出問題</h2><ul><li>如果處理對稱性問題，像是括號匹配，先進後出的特性可以使用stack，<code>&#123;[()]&#125;</code> 可以觀察到 <code>(</code> 是最後進去，但是也是第一個 pop 出來（LIFO）。</li><li>在簡化路徑的題目中，會有很多 <code>..</code> 這種代表往上一層的目錄，這時候也可以使用stack，把目錄放入stack，遇到 <code>..</code> 就 pop 出來，<em>因為當前的目錄已經不會再用到了</em>。</li><li>相關題目：<ul><li><a href="/posts/leetcode-20-valid-parentheses">leetcode-20-valid-parentheses</a>: 檢查括號是否匹配</li><li><a href="/posts/leetcode-71-simplify-path">leetcode-71-simplify-path</a>: 簡化路徑</li></ul></li></ul><h2 id="情境2-數字計算，括弧的優先">情境2: 數字計算，括弧的優先</h2><ul><li>像是逆波蘭這樣的題目，關鍵就是<em>當計算完後，要把結果再 push 回去 stack 裡面</em>，這樣下次遇到運算符號時，才可以再次的把上一次的計算結果一起pop出來。</li><li>或是要處理括號優先計算的問題，如果當前的 <code>(</code> 還沒結果就碰到新的<code>(</code>，我們可以把計算到一半的數值 push 進 stack，等到出現 <code>)</code> 再把結果 pop 出來，進行計算。</li><li>相關題目：<ul><li><a href="/posts/leetcode-150-evaluate-reverse-polish-notation">leetcode-150-evaluate-reverse-polish-notation</a>：逆波蘭表示法</li><li><a href="/posts/leetcode-224-basic-calculator">leetcode-224-basic-calculator</a>: 這題是Hard很難，要處理括號前的正負符號已改變括號內的正負值</li></ul></li></ul><h2 id="情境3-時間複雜度O-1-卻能取得Max或Min">情境3: 時間複雜度O(1)卻能取得Max或Min</h2><ul><li>如果要設計一個 Stack 的資料結構，可以取得最小值的 stack <code>getMin()</code>，並且<code>getMin()</code><em>要求時間複雜度為 O(1)</em>。這樣的設計最大的困難在於，<code>pop</code> 或 <code>add</code> 時， <code>min</code> 也要有所更新。因此，我們可以另外建立一個 min_stack 凡是碰到更小的就塞進去，這樣就可以在 <code>pop</code> 的時候，一起把 <code>min_stack</code> 也 <code>pop</code>，以取得第二小的值。</li><li>相關題目：<ul><li><a href="/posts/leetcode-155-min-stack">leetcode-155-min-stack</a>：實作一個可以取得最小值的 stack</li><li><a href="/posts/leetcode-128-longest-consecutive-sequence">leetcode-128-longest-consecutive-sequence</a>: 找出最長的連續數字</li></ul></li></ul><h1 id="Linked-List">Linked List</h1><h2 id="情境1-判斷是否有循環">情境1: 判斷是否有循環</h2><ul><li>可以使用<em>兩個pointer，一個走比較快，一個走比較慢</em>，如果有循環，兩個pointer一定會相遇。</li><li>相關題目：<ul><li><a href="/posts/leetcode-141-linked-list-cycle">leetcode-141-linked-list-cycle</a>：檢查 linked list 是否有循環</li></ul></li></ul><h2 id="情境2-dummy-head-的使用">情境2: dummy head 的使用</h2><ul><li>如果題目需要碰到多個 listNode 的操作，並且<em>把兩個 ListNode 進行整合，變成一個新的 ListNode導致原本的head不是原本的head時，可以考慮使用 <code>dummy_head</code></em>，最後回傳的時後回傳 <code>dummy_node.next</code> 這樣就不用特別處理第一個node。</li><li>我們最怕的是在取listNode的值時發現他是None而導致錯誤，<em>因此我們可以使用 <code>digit1 = list1.val if list1 else 極值</code> 的方式</em>，儘管遇到 none 仍然可以繼續執行迴圈，直到兩個 list1 跟 list2 都觸底，以避免 None 的問題。</li><li>相關題目：<ul><li><a href="/posts/leetcode-2-add-two-numbers">leetcode-2-add-two-numbers</a>：兩個linked list相加</li><li><a href="/posts/leetcode-21-merge-two-sorted-lists">leetcode-21-merge-two-sorted-lists</a>：合併兩個有序的linked list</li></ul></li></ul><h2 id="情境3-雙指針法">情境3: 雙指針法</h2><ul><li><strong>反轉操作</strong>：<ul><li>如果今天要空間複雜度為O(1)的情況下，想要<em>透過反轉的方式做某些操作</em>，例如反轉linked list，或是取得倒數第n個node，這時候就可以使用雙指針法。只是怎麼跑這個指針的方式不一樣，一種是某個指針一直往前跑，然後<em>到目標位置執行操作</em>。另一個是比速度的，要<em>快的指針比慢的指針快n個位置</em>，以取得倒數第n個node。</li><li>這真的經典，今天要<em>有順序的進行反轉或是整批的改變位置移動，雙指針會是一個Linked List的重點</em>。想像有兩個指針，一個指針<code>cur</code>慢往前，另一個指針會是目標節點<code>target</code> (在這裡是<code>next</code>)，<code>target</code> 會串到想要放的目標 location(在這裡是<code>pre.next</code>)，<code>cur</code> 會一直往前移動(<code>cur.next</code> 變成 <code>pre.next</code>)，直到達到目標節點，這樣就可以完成操作。</li></ul></li><li><strong>依序比較</strong>：<ul><li>如果只是在<em>有序的linkedlist中比較<code>隔壁</code>的元素關係</em>使用1個pointer以比較鄰居就好，另一個pointer放previous的訊息，到時候滿足條件時，就要把<code>pre.next</code>串到 <code>cur</code> 或 <code>cur.next</code>也就是當前的節點上。</li></ul></li><li>相關題目：<ul><li>反轉操作<a href="/posts/leetcode-92-reverse-linked-list-II">leetcode-92-reverse-linked-list-II</a>: 反轉linked list的一部分</li><li>反轉操作<a href="/posts/leetcode-19-remove-nth-node-from-end-of-list">leetcode-19-remove-nth-node-from-end-of-list</a>: 刪除倒數第n個node</li><li>依序比較<a href="/posts/leetcode-82-remove-duplicates-from-sorted-list-ll">leetcode-82-remove-duplicates-from-sorted-list-ll</a>: 移除重複的元素</li></ul></li></ul><h2 id="情境4-排序">情境4: 排序</h2><ul><li>如果今天碰到比 x 小的節點都放在前面，比 x 大的節點都放在後面，這時候可以使用兩個linked list，一個是小於 x 的 linked list，一個是大於等於 x 的 linked list，最後再將兩個linked list合併即可。</li><li>相關題目：<ul><li><a href="/posts/leetcode-86-Partition-List">leetcode-86-partition-list</a></li></ul></li></ul><h2 id="情境2-環繞節點">情境2: 環繞節點</h2><ul><li>如果今天要回傳經歷過k次循環的linked list，這時候可以直接去思考最後的樣子長如何，當k是linked list的長度的倍數時，linked list會回到原本的樣子，因此我們可以先計算出linked list的長度，然後取餘數，這樣就可以得到我們要旋轉的步數。最後 <code>len - k - 1</code>這個節點的<code>next</code>是最後一個節點。</li><li>相關題目：<ul><li><a href="/posts/leetcode-61-Rotate-List">leetcode-61-rotate-list</a></li></ul></li></ul><h1 id="Recursion">Recursion</h1><p>回到核心，我們應該要知道最小問題的狀況是什麼，以及小問題與大問題相同的關聯性，<strong>這個關聯性就是要回傳的答案</strong>，裡面不確定的東西可以先假設已經得知，<strong>通常這個假設就是呼叫Recursion的地方</strong>，舉例來說：<br><strong>樹的左右子樹關係</strong></p><ul><li><a href="/posts/leetcode-101-Symmetric-Tree/">是否對稱 leetcode-101-Symmetric-Tree</a><ul><li>(關係式：當前的左右子樹第一個值相同且左右子樹對稱) <code>left_root.val == right_root.val &amp;&amp; recursion(left) == recursion(right)</code></li><li>(假設：左右子樹對稱) <code>recursion(left) == recursion(right)</code>。</li></ul></li><li><a href="/posts/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/">建立樹 leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal</a><ul><li>(關係式：回傳已經串好left跟right的root) <code>return root</code></li><li>(假設：左子樹已經建立好) <code>root.left = recursion(left)</code></li><li>(假設：右子樹已經建立好) <code>root.right = recursion(right)</code></li></ul></li><li><a href="/posts/leetcode-226-invert-binary-tree">左右子樹對調 leetcode-226-invert-binary-tree</a><ul><li>(關係式：<code>root.left, root.right = recursion(root.right), root.left = recursion(root.right)</code>)</li></ul></li><li><a href="/posts/leetcode-100-same-tree">2棵樹是否相同 leetcode-100-same-tree</a><ul><li>(關係式：<code>p.val == q.val and recursion(p.left, q.left) and recursion(p.right, q.right)</code>)</li><li>(最小的問題：都是 None 就代表 True，但是當其中一邊有值，另一邊沒有值，就不相同了)<br><strong>深度DFS關係</strong></li></ul></li><li><a href="/posts/leetcode-104-maximum-depth-of-binary-tree/">計算深度 leetcode-104-maximum-depth-of-binary-tree</a><ul><li>(關係式：左右子樹的最大深度 + 1) <code>max(recursion(left), recursion(right)) + 1</code></li></ul></li><li><a href="/posts/leetcode-129-sum-root-to-leaf-numbers">計算root到left的總和 leetcode-129-sum-root-to-leaf-numbers</a><ul><li>(關係式：當前總額 + 左右子樹的總和) <code>cur_sum + recursion(left) + recursion(right)</code></li></ul></li><li><a href="/posts/leetcode-112-path-sum">leetcode-112-path-sum</a>：在樹中找到是否有一條路徑的和等於target Sum<ul><li>(關係式：左或右子樹是否存在一條路徑滿足target Sum) <code>recursion(root.left, targetSum) or recursion(root.right, targetSum)</code></li></ul></li></ul><h1 id="Binary-Tree">Binary Tree</h1><h2 id="情境1-空間O-1-做成list">情境1: 空間O(1)做成list</h2><ul><li>要非常熟悉DFS的演算法，同時如果要求O(1)的空間複雜度，可以使用<code>Morris Traversal</code>，這樣可以在O(1)的空間複雜度下完成整個遍歷，只是他會改變樹的結構。</li><li>相關題目：<ul><li><a href="/posts/leetcode-114-flatten-binary-tree-to-linked-list">leetcode-114-flatten-binary-tree-to-linked-list</a> 要把一棵樹打平，並且只能使用in-place的方式?</li></ul></li></ul><h2 id="情境2-DFS-走到樹的最深處">情境2: DFS 走到樹的最深處</h2><ul><li><strong>從底往上找到某個節點</strong>：例如要在BST(二元搜尋樹)找到第<code>k</code>小的節點，我們需要先走到最left的節點，然後開始往上爬並計數是否已經達到<code>k</code>了。這時候我們的程式邏輯應該是 <code>inorder: 走到左最底 &gt; 計數(中間) &gt; 換右邊</code>。或是我們要找最小值，這時候他們都有個共通點，為了不要遍歷所有的inorder節點，我們應該<em>先使用<code>recursion(cur.left)</code>到最底，往下的過程要做紀錄<code>stack.append(cur)</code>，但是每次從<code>cur = stack.pop()</code>的時候，也要考慮到<code>cur.right</code>有沒有滿足條件</em>。<ul><li>相關題目：<ul><li><a href="/posts/leetcode-230-Kth-Smallest-Element-in-a-BST">leetcode-230-Kth-Smallest-Element-in-a-BST</a>：在BST中找到第k小的節點</li><li><a href="/posts/leetcode-173-Binary-Search-Tree-Iterator">leetcode-173-Binary-Search-Tree-Iterator</a>：實作一個BST的iterator每次<code>next</code>回傳下一個最小值</li></ul></li></ul></li><li><strong>共同的祖先節點</strong>：給<code>p</code>,<code>q</code>兩個節點，找到他們最近的共同<code>parent</code>。我們從也是從底下往上，當發現<em>當前節點左右子樹同時存在<code>q</code>或<code>p</code>時，就代表當前節點就是<code>parent</code>，如果只有一邊的子樹找到，那就回傳最先碰到的節點，也就是說<code>p</code>或<code>q</code>就是祖先</em>，只是看誰比較高。<ul><li>相關題目：<a href="/posts/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree">leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree</a>：在二元樹中找到兩個節點的最近共同祖先</li></ul></li><li><strong>inorder, postorder, preorder特性</strong>：有些題目會給你任意一種order，請你組出一個binary tree，這時候就要非常<em>熟悉<code>inorder</code>, <code>postorder</code>, <code>preorder</code>的特性</em>，<code>inorder</code>是左中右，<code>postorder</code>是左右中，<code>preorder</code>是中左右，這樣就可以很快的組出一個binary tree。<ul><li>相關題目：<ul><li><a href="/posts/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal">leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal</a>：給定preorder跟inorder</li><li><a href="/posts/leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal">leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal</a>：給定postorder跟inorder</li></ul></li></ul></li></ul><h2 id="情境2-BFS-level-order">情境2: BFS - level order</h2><ul><li><strong>水平操作</strong>：如果有題目要把node指向隔壁的時候，就要想到BFS。<ul><li>相關題目：<ul><li><a href="/posts/leetcode-117-populating-next-right-pointers-in-each-node-ii">leetcode-117-populating-next-right-pointers-in-each-node-ii</a> 這題就是要把每一層的node指向隔壁的node。</li></ul></li></ul></li><li><strong>取得每層的特定節點</strong>：如果需要取得每層最右邊的節點，優先走右邊，並且把最右邊的節點記錄，如果發現右邊已經觸底了，那就換左樹走，但是只有當高度比右樹高時，才要記錄。<ul><li>相關題目：<ul><li><a href="/posts/leetcode-199-Binary-Tree-Right-Side-View">leetcode-199-Binary-Tree-Right-Side-View</a> 這題是要取得每一層最右邊的節點</li></ul></li></ul></li></ul><h1 id="Dynamaic-Programming">Dynamaic Programming</h1><p>我覺得大部分DP問題，他的重點順序是：Recursive -&gt; Recursive + Memo -&gt; Iterative + Tabular -&gt; Iterative + Tabular + Space Optimized，因此很多時候我認為需要進展到<code>Iterative</code>的狀態，才能說是完美的解完一題DP問題。大概會有以下情境：</p><h2 id="情境1-當前『取』和『不取』的問題">情境1: 當前『取』和『不取』的問題</h2><ul><li><strong>從最小到最大找到最佳解</strong>：會建議先從背包最小的開始找，然後慢慢增加背包的大小，這樣可以確保每個背包的解都是最佳解。常見題目以下都是需要考量到<code>前一個的最佳解</code>+<code>是否要取目前的值</code>，更簡單的就是說<code>Take</code>與<code>Not_Take</code>的問題：<ul><li><a href="/posts/leetcode-322-Coin-Change">leetcode-322-Coin-Change</a>：找到最少的硬幣數量可以湊成目標值，雙層for loop，從1開始找到amount，然後每個amount都找到最佳的配置coin數量。<code>dp[amount]</code> 標示目前 amount 的最佳數量。透過比較<code>min(dp[i], dp[i-cur] + 1)</code> 來更新最佳解，比較若是取了當前的coin<code>dp[i-cur]+1</code>會不會更新最佳解？</li><li><a href="/posts/leetcode-198-House-Robber">leetcode-198-House-Robber</a>：不能連續偷兩間，找到最大的總和。<code>max(這間不偷+偷上間, 這間偷+偷上上間)</code>，<code>dp[i]</code>表示偷到第i間的最大總和。</li><li><a href="/posts/leetcode-139-Word-Break">leetcode-139-Word-Break</a>：找到是否可以拆分成字典中的字，紀錄每個長度單字的最佳數量，<code>dp[i+len(w)]</code>為True的條件是<code>dp[i]</code>為True表示前面<code>s[:i]</code>是可比拆分，且<code>s[i:i+len(w)]</code>有包含<code>w</code>時，表示當前的字串可以被拆分。</li><li><a href="/posts/leetcode-120-Triangle">leetcode-120-Triangle</a>：找到最小的路徑和，從最底層往上找，每次都找到最佳的路徑和</li><li><a href="/posts/leetcode-123-124-Best-Time-to-Buy-and-Sell-Stock/">leetcode-123-124-Best-Time-to-Buy-and-Sell-Stock</a>: 在 k 次的交易中，找出買故掉和賣掉股票的最佳時機點，可以攥到最多的錢。他也是一個<code>Take</code>與<code>Not_Take</code>的問題，只是他有兩個狀態，一個是<code>buy</code>，一個是<code>sell</code>。<ul><li><code>do_action = (sell if have_stack else prices[idx]) + helper(idx+1, not have_stack, count)</code> 表示賣掉當前的股票</li><li><code>not_do_action = helper(idx+1, have_stack, count)</code> 什麼都不做</li><li><code>min(dp[i][0], p - dp[i-1][1])</code> 表示當前最希望的成本，<code>dp[i][0]</code>表示當前的最佳成本，<code>p - dp[i-1][1]</code>表示當前的價格減去上一次的賣掉的所賺到的利潤。</li></ul></li><li><a href="/posts/leetcode-300-Longest-Increasing-Subsequence">leetcode-300-Longest-Increasing-Subsequence</a>: 給定一個整數數組 nums，找到一個最長的遞增子序列的長度。也因此，我們總是要考慮是否要拿當前的值，來找到最長的遞增子序列。但最重要的可以使用<code>Patience Sort</code>去解。<ul><li>取：<code>1 + helper(cur, i+1)</code></li><li>不取：<code>helper(last, i+1)</code></li><li><code>max(take, not_take)</code></li></ul></li></ul></li></ul><h2 id="情境2-走地圖">情境2: 走地圖</h2><ul><li>找到最佳路徑，又或是找到最大的正方形在一個matrix裡面找到最佳解的題目也是DP，通常從左下角或是右上角開始思考，並且挑選要從左下角或是右上角開始時，要記得選擇周邊的 cell 必須是已經計算過的，這樣才能透過小問題解決大問題。</li><li>相關題目<ul><li><a href="/posts/leetcode-221-Maximal-Square">leetcode-221-Maximal-Square</a>: 從左下角或是右上角開始思考，然後找出規律，<code>dp[i][j]</code>表示走到<code>i,j</code>的最佳解，並且挑選要從左下角或是右上角開始時，要記得選擇周邊的 cell 必須是已經計算過的，這樣才能透過小問題解決大問題。<code>dp[1][j] = 1 + min(dp[0][j], dp[0][j-1], dp[1][j-1])</code>是邊長的最佳解。</li><li><a href="/posts/leetcode-72-Edit-Distance/">leetcode-72-Edit-Distance</a>: 兩個單詞 word1 和 word2，找到將 word1 轉換為 word2 所需的最小操作數，也有走地圖的感覺，需要把整個Table繪製出來。</li><li><a href="/posts/leetcode-63-Unique-Paths-II/">leetcode-63-Unique-Paths-II/</a>: 找到最短路徑，但是中間可能會有石頭。因此碰到障礙物就要記得把路徑設定為 0，其他的就是從上面或是左邊來的路徑和</li><li><a href="/posts/leetcode-64-Minimum-Path-Sum/">leetcode-64-Minimum-Path-Sum</a>: 也是從左上角到右下角，找到最小的路徑和，這時候只要考慮上面或是左邊的路徑和即可。</li><li></li></ul></li></ul><h2 id="情境3-回文字串">情境3: 回文字串</h2><ul><li><a href="/posts/leetcode-5-Longest-Palindromic-Substring/">leetcode-5-Longest-Palindromic-Substring</a>: 找到最長的回文字串，如果我們鎖定一個中心點，然後往外擴展，當發現不是回文時，就立刻換下一個中心點，但是要記得考慮奇數偶數的問題。</li></ul><h1 id="Two-Pointer">Two Pointer</h1><h2 id="情境1-Sliding-Window">情境1: Sliding Window</h2><ul><li>我們要先知道 Sliding Window 的三個關鍵步驟：<ul><li>Expand out Window 擴展窗口的時機</li><li>Meet the condition and process the window 滿足條件並處理當前窗口的方式</li><li>Shrink the window 收縮窗口的時機</li></ul></li></ul><h2 id="情境2-已經排序的陣列">情境2: 已經排序的陣列</h2><ul><li>如果一個陣列已經排序，我們要從陣列中找出滿足條件的兩個數字，這時候可以使用兩個指標，一個指向頭，一個指向尾，然後根據條件來移動指標。<em>當兩個指標向中間移動時，我們可以確保指標外的數字絕對不會是答案，因為他是已經排序的陣列！</em></li><li>相關題目：<ul><li><a href="/posts/leetcode-167-Two-Sum-II-Input-Array-Is-Sorted">leetcode-167-two-sum-ii-input-array-is-sorted</a></li><li><a href="/posts//leetcode-11-Container-With-Most-Water">leetcode-11-container-with-most-water</a> 儘管高度無序，但是距離是有序的，決定是否要移動 pointer 時，只要考慮高度即可，<code>height[left] &lt; height[right]</code>，那麼我們就移動 left pointer，因為 <code>height[left]</code> 是最小的，所以我們要找更大的 height。移動的過程中透過<code>max_area</code>來紀錄最大的面積。</li><li><a href="/posts/leetcode-15-3sum">leetcode-15-3sum</a> 這題是要找到三個數字相加等於0，這時候可以先固定一個數字，然後使用兩個指標來找另外兩個數字，這樣就可以把三個數字的問題轉換成兩個數字的問題。</li></ul></li></ul><h2 id="情境3-子字串問題">情境3: 子字串問題</h2><ul><li>如果今天題目是要從字串中找到一個子字串，這時候可以使用兩個指標，一個指向子字串，一個指向母字串，然後根據條件來移動指標。</li><li>相關題目：<ul><li><a href="/posts/leetcode-392-Is-Subsequence">leetcode-392-is-subsequence</a>：<code>i</code>是子字串<code>j</code>是母字串，起點相同，如果發現<code>i</code>的字元等於<code>j</code>的字元，就把<code>i</code>往前移動，最後如果<code>i</code>走到底，就代表是子字串。</li><li><a href="/posts/leetcode-209-Minimum-Size-Subarray-Sum">leetcode-209-minimum-size-subarray-sum</a>：找到最短的子字串，使得子字串的和大於等於目標值，他是 two pointer 從左到右來擴展跟收縮 window，要檢查到 right pointer 觸底為止，所以不需要 while。<ul><li>停止擴展？  <code>window sum &gt;= target</code> 時</li><li>處理當前window? 計算當前 window 的總和數，以及當前 window 的長度是否有小於最小長度</li><li>收縮window? 當前 <code>window sum &gt;= target</code>，就開始透過移動 left 收縮 window</li><li>隨時記錄最佳解？<code>min_len</code> 來記錄最佳解</li></ul></li><li><a href="/posts/leetcode-30-Substring-with-Concatenation-of-All-Words">leetcode-30-substring-with-concatenation-of-all-words</a>：這題很難，提供<code>words</code>與<code>s</code>找出<code>s</code>中所有<code>words</code>的連續子串的起始索引。透過移動<code>i</code>來擴展window。<ul><li>停止擴展？ 當前的 <code>window</code> 不合法，也就是 <code>i</code> 是不合法的，我們要往下一個開始檢查</li><li>處理當前window? 當前 <code>window</code> 是合法的，我們要檢查是否已經找到所有的 <code>words</code> 且數量沒超過</li><li>收縮window? 當前的<code>window</code>還在合法範圍，只是數量不夠繼續擴張</li></ul></li></ul></li></ul><h1 id="常用演算法">常用演算法</h1><h2 id="摩爾投票法：找到最大宗">摩爾投票法：找到最大宗</h2><div class="note info flat"><p>題目：<a href="/posts/leetcode-169-majority-element">leetcode-169-majority-element</a><br>使用情境：如果想要知道最大宗是哪一類的，這樣可以在<strong>空間複雜度為O(1)的情境下，找到最大宗的族群</strong>。</p></div><p>這是1980 由 Boyer 和 Moore 兩人所提出的算法：英文是 Boyer-Moore Majority Vote Algorithm。這個函數實現了 Boyer-Moore 多數投票算法，這是一種在線性時間和常數空間內找到多數元素的方法。</p><p>他的思想很簡單，假設存在一個數字超過半數，而每個數字代表一個生物組群好了。(e.g. 1 = 恐龍, 2 = 獅子, 3 = 老虎, …) 現在有一組串列，<code>[1, 1, 2, 3, 1]</code> 透過指標的方式，循序比較，遇到自己人就+1，遇到其他物種就開打，因為戰鬥力一樣所以雙方人馬都一起滅絕，經過物競天擇後，數量仍然 &gt; 1的就是倖存者也就是數量最多的族群。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">nums</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    candidate = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">            candidate = num</span><br><span class="line">        count += (<span class="number">1</span> <span class="keyword">if</span> num == candidate <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><h2 id="Morris-Traversal：BST-to-遞增排序">Morris Traversal：BST to 遞增排序</h2><p>這是一種在O(1)的空間複雜度下完成遍歷的演算法，他的核心概念是在遍歷的過程中，把右子樹的最左邊節點指向當前的節點，這樣就可以在O(1)的空間複雜度下完成遍歷。<br>很多時候題目會要求 O(1) 空間複雜度，這時候我們可以使用 Morris Traversal 來達成，但是<em>此方法直接修改原始樹，但可以保證空間複雜度為 O(1)</em>，因此使用的時候要注意是否可以改動到原始樹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 1 的 left sub-tree 插入 right sub-tree 的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 將原本的right sub-tree 接到 left sub-tree 的最右邊節點</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 將 2 的 left sub-tree 插入 right sub-tree 的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 將原本的 right sub-tree 接到 left sub-tree 的最右邊節點</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><em>程式碼 preorder-morris-traversal</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flatten2</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; TreeNode:</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            <span class="comment"># 1. 先找到左樹最右邊的node rightmost</span></span><br><span class="line">            rightmost = cur.left</span><br><span class="line">            <span class="keyword">while</span> rightmost.right:</span><br><span class="line">                rightmost = rightmost.right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 把 cur 的右樹接到 rightmost.right, 然後再把 cur.right 接到 left</span></span><br><span class="line">            rightmost.right = cur.right</span><br><span class="line">            cur.right = cur.left</span><br><span class="line">            cur.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. cur 換成 cur.right</span></span><br><span class="line">        cur = cur.right</span><br></pre></td></tr></table></figure><h2 id="DFS-跟-BFS">DFS 跟 BFS</h2><p>DFS 跟 BFS 是最常見的兩種遍歷方式，DFS 是深度優先搜尋，BFS 是廣度優先搜尋，他們的核心概念是一樣的，只是遍歷的方式不同，DFS 是一直往下走，直到底部，然後再往上走，BFS 是一層一層的往下走，直到底部，然後再往下走。</p><p>建議直接看<a href="/posts/lecture-bfs-dfs">LeetCode 課前預習 - 掌握 BFS 與 DFS 指南</a></p><h2 id="Patience-Sort：最長的遞增子序列">Patience Sort：最長的遞增子序列</h2><p>有些題目需要<strong>找到最長的遞增子序列</strong>，我們需要先了解一下一個超級神奇的演算法！叫做<a href="https://en.wikipedia.org/wiki/Patience_sorting">Patience Sort</a>，他是一個卡牌遊戲，可以幫助我們找到最長的遞增子序列。我們先來介紹卡牌遊戲的規則：</p><p>首先，我們有一組卡牌，規則是：</p><ul><li>如果當前的卡牌比piles的最後一張卡牌還要大，那就直接放到最後一張卡牌的後面</li><li>如果當前的卡牌比piles的最後一張卡牌還要小，那就要找到一張比當前卡牌還要大的卡牌，然後放在上面，如果找不到的話，就要開一個新的pile<br><img src="https://i.imgur.com/s3XxiPt.png" alt=""><br><img src="https://i.imgur.com/XOMxkAH.png" alt=""></li></ul><p><em>最後你會發現，每個piles最上面的卡牌由左到右是遞增的</em><br><img src="https://i.imgur.com/2mmUOnD.png" alt=""></p><p><em>更神奇的事情發生了，這個piles的數量就是最長的遞增子序列的長度！因為每個piles一定可以找到一張牌可以排出遞減的牌組</em><br><img src="https://i.imgur.com/JQB7ylO.png" alt=""><br><img src="https://i.imgur.com/hMyA7m7.png" alt=""></p><p>相關題目：</p><ul><li><a href="/posts/leetcode-300-Longest-Increasing-Subsequence">leetcode-300-longest-increasing-subsequence</a>：找到最長的遞增子序列</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes - Replica 的幾種 Controller 比較 [Replication Controller vs ReplicaSet vs Deployment vs DaemonSet]</title>
      <link href="/posts/k8s-replication-controller/"/>
      <url>/posts/k8s-replication-controller/</url>
      
        <content type="html"><![CDATA[<h1 id="介紹">介紹</h1><ul><li>Replication Controller：確保有「固定數量」的 Pod 在運行。</li><li>ReplicaSet：和 Replication Controller 類似，但更靈活，可使用標籤篩選Pod，負責管理 Pod 的數量。</li><li>Deployment：管理和控制 ReplicaSet，讓你可以輕鬆升級、回滾和更新 Pod。</li><li>DaemonSet：確保每一台機器上都運行一個 Pod，適用於需要在每個 Node 上執行的服務。</li></ul><h1 id="Replication-Controller">Replication Controller</h1><ol><li>Replication Controller (RC)<br>Replication Controller 就像是一個「監視員」，它的工作是確保 Kubernetes 集群中有指定數量的 Pod 在運行。</li></ol><ul><li>想像你開了一家餐廳，你希望廚房裡總是有 3 位廚師在工作。Replication Controller 就是那個一直在監視廚房的人，如果發現少了廚師（Pod 故障了），它就會立刻找一個新的來補上。</li><li>同樣地，如果多出來的廚師（Pod）不需要，Replication Controller 也會請多餘的廚師離開，確保始終保持你指定的數量。</li></ul><p>簡單來說：Replication Controller 負責保持「指定數量」的 Pod 在運行。</p><h1 id="ReplicaSet-與-Deployment">ReplicaSet 與 Deployment</h1><h2 id="ReplicaSet">ReplicaSet</h2><p>ReplicaSet 是更進一步發展的版本，主要區別在於，ReplicaSet <em>支援更複雜的標籤（label）選擇器</em>，可以更靈活地找到並管理 Pod。</p><h2 id="Deployment">Deployment</h2><p>像是ReplicaSet的『管理者』，他負責管理和控制ReplicaSet，如果你的應用程式需要升級，Deployment 可以做到逐步替換 Pod，避免服務中斷，這是因為它採用了 滾動更新（Rolling Update） 的機制，這種機制可以讓新的 Pod 逐步取代舊的 Pod，而不是一次性地停止所有舊的 Pod。</p><p>Deployment 可以做到逐步替換 Pod，避免服務中斷，這是因為它採用了 滾動更新（Rolling Update） 的機制，這種機制可以讓新的 Pod 逐步取代舊的 Pod，而不是一次性地停止所有舊的 Pod。</p><p><strong>Deployment 的滾動更新</strong></p><ul><li>它先關掉一個舊的 Pod，然後啟動一個新的 Pod，確保在這個過程中總有 Pod 在處理請求。</li><li>這個過程會繼續下去，直到所有舊的 Pod 都被新的 Pod 替換掉。</li></ul><p><strong>具體運作方式</strong></p><ol><li>設定 replicas：假設你設定了 5 個 replicas（Pod 副本數量），代表 Kubernetes 集群會保持有 5 個 Pod 在運行。</li><li>逐步替換：<ul><li>Deployment 會先關掉一個舊的 Pod，然後立刻啟動一個新的 Pod。</li><li>等新 Pod 啟動並運行正常後，再關掉另一個舊的 Pod，啟動下一個新的 Pod。</li><li>這個過程會持續進行，直到所有 Pod 都被替換成新的版本。</li></ul></li></ol><p><strong>關於 Deployment 設定的彈性</strong><br>你可以透過設定 <code>maxUnavailable</code> 和 <code>maxSurge</code> 來控制替換的速度。</p><ul><li><code>maxUnavailable</code>：定義在更新過程中允許多少個 Pod 可以暫時不可用（例如，可以設定為 1，代表只允許一個 Pod 同時不可用）。</li><li><code>maxSurge</code>：定義在更新過程中允許超出 replicas 數量的額外 Pod 數量（例如，設定為 1，代表可以多啟動一個新的 Pod 以加速更新過程）。</li></ul><h1 id="DaemonSet">DaemonSet</h1><p>DaemonSet 是 Kubernetes 中的「全職員工分配員」，它的工作是確保**每一台機器（Node）**上都運行著一個 Pod。</p><ul><li>想像你是一位經理，你想要在每一個餐廳分店（Node）裡都安排一位清潔工（Pod）來清掃。DaemonSet 就是負責確保每一家分店都有一位清潔工的人。</li><li>不管你開了多少家分店，DaemonSet 都會自動在每家店安排一個 Pod，如果你關閉一家店，它也會自動移除該 Pod。</li></ul><p>簡單來說：DaemonSet 保證每個 Node 上都運行一個 Pod，適合需要在每台機器上都執行的應用程式，例如日誌收集、監控代理等。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Replication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes - 手把手教你搭建EFK日志收集系统於Kubernetes + 踩坑紀錄</title>
      <link href="/posts/k8s-EFK/"/>
      <url>/posts/k8s-EFK/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>如果你需要在Kubernetes上搭建EFK日志收集系統，這篇文章將會是你的最佳選擇。本篇文章將會帶你一步一步的搭建EFK日誌收集系統，並且會分享一些踩坑紀錄。整個文章的蓋架構如下：</p><p><img src="https://i.imgur.com/22bjFTK.png" alt=""><br>從上圖來看，這就是我們要搭建的EFK日誌收集系統。主要有以下工作：</p><ol><li><strong>建立 NFS Provisioner 服務</strong>:<ul><li>因為我們希望每次加入一個節點於Kubernetes集群時，都能夠自動在新的節點中建立ElasticSearch，也就是說每個節點都會有一個ElasticSearch駐守，而這群ElasticSearch會形成一個叢集。</li><li>然而，每個ElasticSearch都需要儲存資料，因此我們需要一個共享的儲存空間，這個共享的儲存空間就是NFS。</li><li>而NFS Provisioner就是可以根據ElasticSearch建立起時，發送一個NFS PVC，那Provisioner就會根據PVC建立一個NFS PV，並且將PV掛載到ElasticSearch的Pod中。</li></ul></li><li><strong>建立 ElasticSearch</strong>:<ul><li>ElasticSearch是一個分散式的搜尋引擎，我們將會在Kubernetes上建立一個ElasticSearch叢集。</li><li>但是我們希望讓每個 Kubernetes 叢集都有一個 Elasticsearch 節點，可以採用 <code>StatefulSet</code> 來部署 Elasticsearch，這樣可以確保每個節點都有一個 Elasticsearch Pod，並且能夠保留數據狀態。</li></ul></li><li><strong>建立Kibana</strong>:<ul><li>這沒什麼好說的，Kibana是一個用於視覺化Elasticsearch數據的工具，我們將會在Kubernetes上建立一個Kibana服務。</li></ul></li><li><strong>建立fluentd DaemonSet</strong>:<ul><li>fluentd是一個用於收集日誌的工具，我們將會在Kubernetes上建立一個fluentd DaemonSet，這樣可以收集所有節點上的日誌。</li><li>使用 DaemonSet 是因為我們希望每個節點都有一個fluentd Pod，這樣可以確保每個節點上的日誌都能被收集。</li></ul></li></ol><h1 id="1-建立ns以及svc">1 建立ns以及svc</h1><p>要先建立名為<code>es-cluster-svc</code>的<code>headless service</code>，這樣可以確保每個pod都有一個固定的名稱，這樣其他pod不需要知道要把log送到哪個pod，只要送到其中一個即可。</p><blockquote><p>新建立<code>kube-logging.yaml</code>的namespace</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">logging</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f kube-logging.yaml</span><br></pre></td></tr></table></figure><blockquote><p>建立 <code>headless service</code></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">es-cluster-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span>   <span class="comment"># 這裡是重點，要設定為None代表是headless service</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9200</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">rest</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9300</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">inter-node</span></span><br></pre></td></tr></table></figure><h1 id="2-安裝NFS-provisioner">2 安裝NFS provisioner</h1><ul><li>Ref: <a href="https://fabianlee.org/2022/01/12/kubernetes-nfs-mount-using-dynamic-volume-and-storage-class/">https://fabianlee.org/2022/01/12/kubernetes-nfs-mount-using-dynamic-volume-and-storage-class/</a></li></ul><p><img src="https://i.imgur.com/JQxm4VN.png" alt=""><br><a href="https://godleon.github.io/blog/Kubernetes/k8s-Config-StorageClass-with-NFS/">https://godleon.github.io/blog/Kubernetes/k8s-Config-StorageClass-with-NFS/</a></p><p>建立 NFS Provisioner 的目的是在 Kubernetes 集群中提供一個「<strong>動態的共享儲存解決方案</strong>」，讓Pod可以鬆地申請、使用和共享這些儲存空間。</p><ul><li><code>NFS provisioner</code>:<ul><li>負責建立 PV</li><li>負責建立NFS volume: (其實就是一般的 directory)，你在share directory會發現它會自動幫你根據pod切割環境</li></ul></li><li><code>Service Account</code>：<ul><li>這是用來管控 NFS provisioner 在 k8s 中可以運行的權限</li></ul></li><li><code>StorageClass：</code><ul><li>負責建立 PVC</li><li>呼叫 NFS provisioner 進行設定工作，並讓 PVC 與 PV 繫結</li></ul></li></ul><p><strong>流程:</strong><br>這邊我使用了兩個方法，一個是使用<code>nfs-subdir-external-provisioner</code>，另一個是使用<code>nfs-client-provisioner</code>，但是我發現<code>nfs-client-provisioner</code>在我的環境中無法正常運行，因此我最後選擇使用<code>nfs-subdir-external-provisioner</code>。</p><blockquote><p>我們要先建立provisioner (可以透過helm或手動建立)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># way1: 使用nfs-subdir-external-provisioner加入repo</span></span><br><span class="line">helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝</span></span><br><span class="line">helm install nfs-subdir-external-provisioner \</span><br><span class="line">nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \</span><br><span class="line">--<span class="built_in">set</span> nfs.server=34.80.7.234 \</span><br><span class="line">--<span class="built_in">set</span> nfs.path=/data/es \</span><br><span class="line">--<span class="built_in">set</span> storageClass.onDelete=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要解除安裝</span></span><br><span class="line">helm uninstall nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line"><span class="comment">## way2 採坑: 我發現使用stable不知道為何無法建立...provisioner無法正常運行</span></span><br><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定storiageClass.name</span></span><br><span class="line">helm install nfs-client-provisioner \</span><br><span class="line">stable/nfs-client-provisioner \</span><br><span class="line">--<span class="built_in">set</span> nfs.server=34.80.7.234 \</span><br><span class="line">--<span class="built_in">set</span> nfs.path=/data/es \</span><br><span class="line">--<span class="built_in">set</span> storageClass.name=nfs-client \</span><br><span class="line">--<span class="built_in">set</span> image.repository=quay.io/external_storage/nfs-client-provisioner-arm \</span><br><span class="line">--<span class="built_in">set</span> image.tag=latest \</span><br><span class="line">--<span class="built_in">set</span> storageClass.defaultClass=<span class="literal">true</span></span><br><span class="line">--<span class="built_in">set</span> image.repository=quay.io/external_storage/nfs-client-provisioner-arm</span><br><span class="line"></span><br><span class="line">helm uninstall nfs-client-provisioner</span><br></pre></td></tr></table></figure><div class="note info flat"><p>手動建立可以參考：<br><a href="https://godleon.github.io/blog/Kubernetes/k8s-Config-StorageClass-with-NFS/">https://godleon.github.io/blog/Kubernetes/k8s-Config-StorageClass-with-NFS/</a><br><a href="https://blog.csdn.net/make_progress/article/details/124638272">https://blog.csdn.net/make_progress/article/details/124638272</a></p></div><h1 id="3-建立elasticSearch-statefulSet">3 建立elasticSearch statefulSet</h1><h2 id="實作">實作</h2><blockquote><p>ElasticSearch StatefulSet Yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">es-cluster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">es-cluster-svc</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">elasticsearch</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.6.2</span></span><br><span class="line">        <span class="comment"># 限制cpu數量</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9200</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">rest</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9300</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">inter-node</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">        <span class="comment"># 設置掛載目錄</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line">        <span class="comment"># 設置環境變量</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 自訂義 clustenr name</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cluster.name</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">k8s-logs</span></span><br><span class="line">          <span class="comment"># 定義傑點名稱 使用metadata.name名稱</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node.name</span></span><br><span class="line">            <span class="attr">valueFrom:</span></span><br><span class="line">              <span class="attr">fieldRef:</span></span><br><span class="line">                <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">          <span class="comment"># 發現節點的地址, discover.seed_hosts的值應該包含所有master的候選節點</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">discovery.seed_hosts</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;es-cluster-svc&quot;</span></span><br><span class="line">          <span class="comment"># 初始化時 ES從中選出master節點，對應metadata.name名稱加編號從0開始</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cluster.initial_master_nodes</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;es-cluster-0,es-cluster-1,es-cluster-2&quot;</span></span><br><span class="line">  <span class="comment"># 至少多少個node來進行選舉master問題</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">discovery.zen.minimum_master_nodes</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">  <span class="comment"># 安全設置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.security.enabled</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">xpack.monitoring.collection.enabled</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">          <span class="comment"># 配置內存</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ES_JAVA_OPTS</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;-Xms512m -Xmx512m&quot;</span></span><br><span class="line">      <span class="comment"># 初始化容器</span></span><br><span class="line">      <span class="attr">initContainers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fix-permissions</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;chown -R 1000:1000 /usr/share/elasticsearch/data&quot;</span>]</span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">increase-vm-max-map</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;sysctl&quot;</span>, <span class="string">&quot;-w&quot;</span>, <span class="string">&quot;vm.max_map_count=262144&quot;</span>]</span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">increase-fd-ulimit</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ulimit -n 65536&quot;</span>]</span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">&quot;nfs-client&quot;</span> <span class="comment"># storageClass的名稱，你要先建立好喔!</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">5Gi</span> <span class="comment"># 通常可以寫大一點根據你的需求有些時候是500G</span></span><br></pre></td></tr></table></figure><blockquote><p>透過以下指令建立帳號密碼</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k <span class="built_in">exec</span> -it es-cluster-0 -n logging -- bin/elasticsearch-setup-passwords auto -b </span><br></pre></td></tr></table></figure><h2 id="流程說明">流程說明</h2><p>讓我用更簡單的方式來解釋這個流程，並逐步說明每一個部分的目的和作用：</p><h3 id="背景知識">背景知識</h3><p>首先，讓我們了解一些基本概念：</p><ul><li><strong>StorageClass（SC）</strong>：它是一種定義 Kubernetes 如何動態配置儲存資源的規則。例如，當你需要儲存空間時，StorageClass 會告訴 Kubernetes 如何創建它。</li><li><strong>PersistentVolumeClaim（PVC）</strong>：應用程序用來請求儲存空間的方式，類似於提出「我要一個特定大小的儲存空間」的需求。</li><li><strong>PersistentVolume（PV）</strong>：PVC 請求儲存後，實際創建出來的儲存資源就是 PV。</li><li><strong>NFS Provisioner</strong>：它是一個自動化工具，用來在 NFS 伺服器上為 PVC 動態配置儲存空間。</li></ul><h3 id="流程解釋">流程解釋</h3><p><strong>1. StorageClass 部分</strong></p><ol><li><strong>建立 PVC（PersistentVolumeClaim）</strong>：<ul><li>應用程序發出一個「我要儲存空間」的請求（建立 PVC）。</li></ul></li><li><strong>呼叫 NFS Provisioner</strong>：<ul><li>Kubernetes 根據 StorageClass 的配置，呼叫 NFS Provisioner，請求它去為 PVC 創建儲存空間。</li><li>NFS Provisioner 是你之前已經設定好的（在 step1 中已經部署），它知道如何在 NFS 伺服器上為 PVC 建立儲存空間。</li></ul></li><li><strong><code>k get sc</code> 確認 StorageClass</strong>：<ul><li>使用 <code>k get sc</code> 命令，你可以查看到 Kubernetes 中的 StorageClass 列表，並確認有一個叫 <code>nfs-client</code> 的 StorageClass，這代表 Kubernetes 會使用這個 StorageClass 來配置儲存。</li></ul></li><li><strong><code>k get pvc</code> 確認建立的 PVC</strong>：<ul><li>使用 <code>k get pvc</code>，你會看到 Kubernetes 已經依照應用程式需求，建立了三個 PVC，分別是 <code>data-es-cluster-0</code>、<code>data-es-cluster-1</code>、<code>data-es-cluster-2</code>。這些 PVC 代表 Elasticsearch 的三個節點需要各自的儲存空間。</li></ul></li></ol><p><strong>2. NFS Provisioner 部分</strong></p><ol><li><strong>NFS Provisioner 收到通知並開始建立 PV（PersistentVolume）</strong>：<ul><li>當 NFS Provisioner 收到 PVC 請求時，它開始在 NFS 伺服器上創建對應的目錄，並配置 PV，為這些 PVC 提供儲存空間。</li></ul></li><li><strong>建立 PV 與 NFS 之間的連結</strong>：<ul><li>每個 PV 都指向 NFS 上的一個對應目錄，這樣 PVC 可以直接存取它需要的儲存空間。</li></ul></li><li><strong><code>k get pv</code> 確認建立的 PV</strong>：<ul><li>使用 <code>k get pv</code>，你會看到三個 PV 已經被創建，分別用於 <code>data-es-cluster-0</code>、<code>data-es-cluster-1</code> 和 <code>data-es-cluster-2</code> 的儲存需求。</li></ul></li><li><strong><code>k get pod</code> 確認 NFS Provisioner 的運行情況</strong>：<ul><li>使用 <code>k get pod</code> 可以確認 NFS Provisioner 正在正常運行（名稱類似於 <code>nfs-subdir-external-provisioner-589f98599c-zxtps</code>）。</li></ul></li></ol><p><strong>總結</strong></p><ul><li><code>StorageClass</code> 定義了儲存配置規則，並在 PVC 提出請求時觸發 NFS Provisioner 自動創建 PV。</li><li><code>NFS Provisioner</code> 會在 NFS 伺服器上為每個 PVC 建立對應的儲存空間，並將它們與 Kubernetes PV 連結。</li><li>最終，當 Elasticsearch 的 Pod 啟動時，它們會自動獲得對應的儲存空間，這確保每個 Pod（<code>data-es-cluster-0</code>、<code>data-es-cluster-1</code>、<code>data-es-cluster-2</code>）都有專屬的儲存資料夾。</li></ul><p>這樣，你的 Elasticsearch 集群中的每個節點都可以擁有自己的持久化儲存空間，並且由 Kubernetes 進行自動化管理。</p><h2 id="結果驗證">結果驗證</h2><blockquote><p>成功添加之後應該要可以再logging namespace底下看到所有資源對象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get sts -n logging </span><br><span class="line">NAME         READY   AGE</span><br><span class="line">es-cluster   3/3     17m</span><br><span class="line"></span><br><span class="line">$ kubectl get pods -n logging </span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">es-cluster-0   1/1     Running   0          18m</span><br><span class="line">es-cluster-1   1/1     Running   0          18m</span><br><span class="line">es-cluster-2   1/1     Running   0          17m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ kubectl get svc -n logging </span><br><span class="line">NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">es-cluster-svc   ClusterIP   None         &lt;none&gt;        9200/TCP,9300/TCP   11m</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用port forward測試9200</p></blockquote><ul><li>我們使用port-forward暫時測試pod裡面是否有正常運行</li><li>可以參考<a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/port-forward-access-application-cluster/">官方 kubectl port-forward</a></li><li>kubectl port-forward 不会返回。你需要打開另一個terminal窗口來繼續操作。</li></ul><blockquote><p>termianl 1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 可以先查看pod的port位置</span><br><span class="line">$ kubectl get pod -n logging es-cluster-0 --template=&#x27;&#123;&#123;(index (index .spec.containers 0).ports 0).containerPort&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">$ kubectl port-forward es-cluster-0 9200:9200 --namespace=logging</span><br><span class="line">Forwarding from 127.0.0.1:9200 -&gt; 9200</span><br><span class="line">Forwarding from [::1]:9200 -&gt; 9200</span><br><span class="line"></span><br><span class="line">&lt;這時候請開另一個terminal&gt;</span><br></pre></td></tr></table></figure><blockquote><p>terminal 2</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:9200/_cluster/state?pretty</span><br></pre></td></tr></table></figure><ul><li>正常應該會看到類似如下訊息: 看到上面的信息就表明我们名为 k8s-logs 的 Elasticsearch 集群成功创建了3个节点：es-0，es-1，和es-2，当前主节点是 es-0。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;k8s-logs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compressed_size_in_bytes&quot;</span> <span class="punctuation">:</span> <span class="number">348</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;QD06dK7CQgids-GQZooNVw&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span> <span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;state_uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;mjNIWXAzQVuxNNOQ7xR-qg&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;master_node&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;IdM5B7cUQWqFgIHXBp0JDg&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;blocks&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;u7DoTpMmSCixOoictzHItA&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;es-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ephemeral_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;ZlBflnXKRMC4RvEACHIVdg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;transport_address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.4.191:9300&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attributes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;IdM5B7cUQWqFgIHXBp0JDg&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;es-0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ephemeral_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;JTk1FDdFQuWbSFAtBxdxAQ&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;transport_address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.2.215:9300&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attributes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;R8E7xcSUSbGbgrhAdyAKmQ&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;es-2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ephemeral_id&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;9wv6ke71Qqy9vk2LgJTqaA&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;transport_address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;10.244.40.4:9300&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attributes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="4-設定es的帳號密碼">4 設定es的帳號密碼</h1><p>找到user elastic 的 password 假設是 ArKsypD2Z2isKLz52wPe</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret generic elasticsearch-pw-elastic -n logging --from-literal password=ArKsypD2Z2isKLz52wPe</span><br></pre></td></tr></table></figure><h1 id="5-建立Kibana">5 建立Kibana</h1><h2 id="實作-2">實作</h2><blockquote><p>新建一个 <code>kibana.yaml</code> 的文件</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5601</span></span><br><span class="line">  <span class="comment"># 偉了方便測試我們將service設置為NodePort類型</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kibana</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.6.2</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">1000m</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="comment"># 使用以下變量設置es-cluster的端點直接使用k8s dns即可</span></span><br><span class="line">        <span class="comment"># 此端點對應svc名稱es-cluster-svc是一個headless service所以該域將解析es pod的ip地址列表</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ELASTICSEARCH_HOSTS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">http://es-cluster-svc:9200</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5601</span></span><br></pre></td></tr></table></figure><h2 id="結果驗證-2">結果驗證</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --namespace=logging</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">es-cluster-0             1/1     Running   0          28m</span><br><span class="line">es-cluster-1             1/1     Running   0          28m</span><br><span class="line">es-cluster-2             1/1     Running   0          28m</span><br><span class="line">kibana-d87c67f6d-bh8ct   0/1     Pending   0          66s</span><br><span class="line"></span><br><span class="line">$ kubectl get svc -n logging</span><br><span class="line">NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE</span><br><span class="line">es-cluster-svc   ClusterIP   None            &lt;none&gt;        9200/TCP,9300/TCP   31m</span><br><span class="line">kibana           NodePort    10.111.194.14   &lt;none&gt;        5601:32177/TCP      4m58s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看一下對外ip是多少</span></span><br><span class="line">$ curl ifconfig.io </span><br><span class="line">34.80.7.234 </span><br></pre></td></tr></table></figure><ul><li>可以去瀏覽器看 <a href="http://34.80.7.234:32177">http://34.80.7.234:32177</a><br><img src="https://i.imgur.com/uzG5HEm.png" alt=""></li></ul><h1 id="6-部屬fluentd-DaemonSet">6 部屬fluentd DaemonSet</h1><p>我們接下來要在每個Node上部屬一個fluentd，負責收集所有的Pod的log進行處理，並且將log傳送到ElasticSearch中。你可能會好奇…<br><strong>為什麼要用 DaemonSet？</strong><br><em>確保每個 Node 都有一個 Fluentd Pod</em></p><ul><li>DaemonSet 是 Kubernetes 用來確保每個 Node（節點）上都會運行一個 Pod 的機制。</li><li>在部署 Fluentd 時，我們希望每個 Kubernetes 節點上都運行一個 Fluentd 實例，這樣它就可以收集該節點上所有 Pod 的日誌。</li></ul><h2 id="設定檔介紹">設定檔介紹</h2><ul><li>Fluentd 的資料接收，<code>資料處理</code>與<code>資料導出</code>的資料流處理流程都<em>透過設定檔來進行設定</em></li><li>而 <code>td-agent</code> 的設定檔位於 <code>/etc/td-agent/td-agent.conf</code></li></ul><h3 id="Fluentd-config">Fluentd config</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 資料輸入(Input)來源設定</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 將 tag 符合 pattern 的資料輸出(Output)到設定的目的地。</span><br><span class="line"><span class="tag">&lt;<span class="name">match</span> <span class="attr">pattern</span>&gt;</span></span><br><span class="line">  # 資料處理與過濾方式。</span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">match</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="source">source</h3><div class="note info flat"><p><strong>設定 Fluentd 接收日誌的來源，並且將日誌數據轉換為 Fluentd 內部的事件格式。</strong></p></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">  @id fluentd-containers.log# 表示引用該日誌來源的唯一標識符，該標識可用於進一步過濾和路由結構化日誌數據</span><br><span class="line">  @type tail                             # Fluentd 內建的 tail 插件，用於監控文件變化並讀取文件內容</span><br><span class="line">  path /var/log/containers/*.log         # 掛載容器日誌文件的路徑</span><br><span class="line">  pos_file /var/log/es-containers.log.pos</span><br><span class="line">  tag raw.kubernetes.*                   # 設置日誌的 tag，用於標識日誌來源</span><br><span class="line">  read_from_head true</span><br><span class="line">  <span class="tag">&lt;<span class="name">parse</span>&gt;</span>                                # 多行日誌解析器</span><br><span class="line">    @type multi_format                   # 使用 multi-format-parser 解析器插件</span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">      format json                        # JSON 解析器</span><br><span class="line">      time_key time                      # 指定時間字段</span><br><span class="line">      time_format %Y-%m-%dT%H:%M:%S.%NZ  # 時間格式</span><br><span class="line">    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">      format /^(?<span class="tag">&lt;<span class="name">time</span>&gt;</span>.+) (?<span class="tag">&lt;<span class="name">stream</span>&gt;</span>stdout|stderr) [^ ]* (?<span class="tag">&lt;<span class="name">log</span>&gt;</span>.*)$/</span><br><span class="line">      time_format %Y-%m-%dT%H:%M:%S.%N%:z</span><br><span class="line">    <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="match">match</h3><div class="note info flat"><p><strong>設定 Fluentd發送日誌的目的地，並且將日誌數據轉換為 Elasticsearch 的格式。</strong></p></div><p><strong>match：</strong></p><ul><li>這個部分用來指定要處理哪些日誌，你可以把它想像成「我要處理什麼樣的日誌？」的設定。</li><li>我們用 <code>**</code>（兩個星號）來代表「所有的日誌」，意思是「不管什麼日誌都抓過來處理」。</li><li>這部分通常也稱為「output plugin」，因為它負責把資料送到特定的地方。</li></ul><p><strong>id：</strong></p><ul><li>就是一個「<strong>名稱</strong>」或「<strong>代號</strong>」，用來標示這個設定。這樣如果你有多個設定，就可以分辨它們。</li></ul><p><strong>type：</strong></p><ul><li>這部分是用來告訴 Fluentd「要把日誌送到哪裡」。</li><li>Fluentd 有很多內建的選項，例如把日誌存成檔案（file），或者送到另一台 Fluentd（forward）。</li><li>我們這裡選擇 <code>elasticsearch</code>，因為我們想把日誌送到 Elasticsearch。</li></ul><p><strong>log_level：</strong></p><ul><li>這設定用來指定「我要處理哪些等級的日誌」。</li><li>比如說設為 <code>info</code>，意思就是「我要處理 INFO 等級以上的日誌」，也就是 INFO、WARNING、ERROR 等等。</li></ul><p><strong>logstash_format：</strong></p><ul><li>設定 <code>logstash_format</code> 為 <code>true</code>，表示 Fluentd 會用 Logstash 的格式來發送日誌到 Elasticsearch。這樣可以讓 Elasticsearch 更容易讀取和處理這些日誌。</li></ul><p><strong>host / port：</strong></p><ul><li>這裡設定要把日誌送到的 Elasticsearch 伺服器的「地址 host」和「端口（port）」。</li><li>如果你的 Elasticsearch 沒有需要帳號或密碼，就直接設定地址和端口即可。</li></ul><p><strong>buffer：</strong></p><ul><li>「<code>緩衝區</code>」的意思，當 Elasticsearch 無法使用或網路出問題時，Fluentd 可以暫時把日誌存起來，等到可以傳送時再發送，這樣不會漏掉任何日誌。</li><li>這也有助於減少對磁碟的讀寫壓力，讓系統更穩定。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">match</span> **&gt;</span> </span><br><span class="line">@id elasticsearch </span><br><span class="line">@type elasticsearch</span><br><span class="line">@log_level info</span><br><span class="line"></span><br><span class="line">include_tag_key true</span><br><span class="line">type_name fluentd</span><br><span class="line"></span><br><span class="line">host &quot;#&#123;ENV[&#x27;OUTPUT_HOST&#x27;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">port &quot;#&#123;ENV[&#x27;OUTPUT_PORT&#x27;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">logstash_format true</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">buffer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@type file</span><br><span class="line"></span><br><span class="line">path /var/log/fluentd-buffers/kubernetes.system.buffer</span><br><span class="line"></span><br><span class="line">flush_mode interval</span><br><span class="line"></span><br><span class="line">retry_type exponential_backoff</span><br><span class="line"></span><br><span class="line">flush_thread_count 2</span><br><span class="line"></span><br><span class="line">flush_interval 5s</span><br><span class="line"></span><br><span class="line">retry_forever</span><br><span class="line"></span><br><span class="line">retry_max_interval 30</span><br><span class="line"></span><br><span class="line">chunk_limit_size &quot;#&#123;ENV[&#x27;OUTPUT_BUFFER_CHUNK_LIMIT&#x27;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">queue_limit_length &quot;#&#123;ENV[&#x27;OUTPUT_BUFFER_QUEUE_LIMIT&#x27;]&#125;&quot;</span><br><span class="line"></span><br><span class="line">overflow_action block</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">buffer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="filter">filter</h3><p>由於k8s cluster中應用太多，也有很多歷史數據，所以我們希望只有某些pod的log進行收集。比如我們只採集<code>logging=true</code>這個label標籤的pod log這時候就可以使用filter。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 删除无用的属性</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">kubernetes.</span>**&gt;</span></span><br><span class="line">  @type record_transformer</span><br><span class="line">  remove_keys $.docker.container_id,$.kubernetes.container_image_id,$.kubernetes.pod_id,$.kubernetes.namespace_id,$.kubernetes.master_url,$.kubernetes.labels.pod-template-hash</span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"># 只保留 $.kubernetes.labels.logging=true 的 pod 日誌</span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span> <span class="attr">kubernetes.</span>**&gt;</span></span><br><span class="line">  @id filter_log</span><br><span class="line">  @type grep</span><br><span class="line">  <span class="tag">&lt;<span class="name">regexp</span>&gt;</span></span><br><span class="line">    key $.kubernetes.labels.logging</span><br><span class="line">    pattern ^true$</span><br><span class="line">  <span class="tag">&lt;/<span class="name">regexp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="實作-3">實作</h2><p>要收集k8s cluster log直接使用DaemonSet來部屬Fluentd以確保在cluster中每個node上始終運行fluentd容器，當然也可以直接使用helm安裝但這裡先使用手動方式進行。</p><blockquote><p>首先我們先通過ConfigMap指定<code>Fluentd.config</code>文件</p></blockquote><ul><li>ConfigMap 是 Kubernetes 用來管理應用程序設定資料的一種資源。它讓你可以將應用程式的設定與程式碼分開管理，這樣可以讓應用程式更靈活、更容易被配置和更新。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">```yaml </span><br><span class="line">kind: ConfigMap</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: fluentd-config</span><br><span class="line">  namespace: logging</span><br><span class="line">data:</span><br><span class="line">  system.conf: |-</span><br><span class="line">    &lt;system&gt;</span><br><span class="line">      root_dir /tmp/fluentd-buffers/</span><br><span class="line">    &lt;/system&gt;</span><br><span class="line">  containers.input.conf: |-</span><br><span class="line">    &lt;<span class="built_in">source</span>&gt;</span><br><span class="line">      @<span class="built_in">id</span> fluentd-containers.log</span><br><span class="line">      @<span class="built_in">type</span> <span class="built_in">tail</span>                              <span class="comment"># Fluentd 内置的输入方式，其原理是不停地从源文件中获取新的日志。</span></span><br><span class="line">      path /var/log/containers/*.<span class="built_in">log</span>          <span class="comment"># 挂载的服务器Docker容器日志地址</span></span><br><span class="line">      pos_file /var/log/es-containers.log.pos</span><br><span class="line">      tag raw.kubernetes.*                    <span class="comment"># 设置日志标签</span></span><br><span class="line">      read_from_head <span class="literal">true</span></span><br><span class="line">      &lt;parse&gt;                                 <span class="comment"># 多行格式化成JSON</span></span><br><span class="line">        @<span class="built_in">type</span> multi_format                    <span class="comment"># 使用 multi-format-parser 解析器插件</span></span><br><span class="line">        &lt;pattern&gt;</span><br><span class="line">          format json                         <span class="comment"># JSON解析器</span></span><br><span class="line">          time_key time                       <span class="comment"># 指定事件时间的时间字段</span></span><br><span class="line">          time_format %Y-%m-%dT%H:%M:%S.%NZ   <span class="comment"># 时间格式</span></span><br><span class="line">        &lt;/pattern&gt;</span><br><span class="line">        &lt;pattern&gt;</span><br><span class="line">          format /^(?&lt;time&gt;.+) (?&lt;stream&gt;stdout|stderr) [^ ]* (?&lt;<span class="built_in">log</span>&gt;.*)$/</span><br><span class="line">          time_format %Y-%m-%dT%H:%M:%S.%N%:z</span><br><span class="line">        &lt;/pattern&gt;</span><br><span class="line">      &lt;/parse&gt;</span><br><span class="line">    &lt;/source&gt;</span><br><span class="line">    <span class="comment"># 在日志输出中检测异常，并将其作为一条日志转发 </span></span><br><span class="line">    <span class="comment"># https://github.com/GoogleCloudPlatform/fluent-plugin-detect-exceptions</span></span><br><span class="line">    &lt;match raw.kubernetes.**&gt;           <span class="comment"># 匹配tag为raw.kubernetes.**日志信息</span></span><br><span class="line">      @<span class="built_in">id</span> raw.kubernetes</span><br><span class="line">      @<span class="built_in">type</span> detect_exceptions           <span class="comment"># 使用detect-exceptions插件处理异常栈信息</span></span><br><span class="line">      remove_tag_prefix raw             <span class="comment"># 移除 raw 前缀</span></span><br><span class="line">      message <span class="built_in">log</span>                       </span><br><span class="line">      stream stream                     </span><br><span class="line">      multiline_flush_interval 5</span><br><span class="line">      max_bytes 500000</span><br><span class="line">      max_lines 1000</span><br><span class="line">    &lt;/match&gt;</span><br><span class="line"></span><br><span class="line">    &lt;filter **&gt;  <span class="comment"># 拼接日志</span></span><br><span class="line">      @<span class="built_in">id</span> filter_concat</span><br><span class="line">      @<span class="built_in">type</span> concat                <span class="comment"># Fluentd Filter 插件，用于连接多个事件中分隔的多行日志。</span></span><br><span class="line">      key message</span><br><span class="line">      multiline_end_regexp /\n$/  <span class="comment"># 以换行符“\n”拼接</span></span><br><span class="line">      separator <span class="string">&quot;&quot;</span></span><br><span class="line">    &lt;/filter&gt; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加 Kubernetes metadata 数据</span></span><br><span class="line">    &lt;filter kubernetes.**&gt;</span><br><span class="line">      @<span class="built_in">id</span> filter_kubernetes_metadata</span><br><span class="line">      @<span class="built_in">type</span> kubernetes_metadata</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修复 ES 中的 JSON 字段</span></span><br><span class="line">    <span class="comment"># 插件地址：https://github.com/repeatedly/fluent-plugin-multi-format-parser</span></span><br><span class="line">    &lt;filter kubernetes.**&gt;</span><br><span class="line">      @<span class="built_in">id</span> filter_parser</span><br><span class="line">      @<span class="built_in">type</span> parser                <span class="comment"># multi-format-parser多格式解析器插件</span></span><br><span class="line">      key_name <span class="built_in">log</span>                <span class="comment"># 在要解析的记录中指定字段名称。</span></span><br><span class="line">      reserve_data <span class="literal">true</span>           <span class="comment"># 在解析结果中保留原始键值对。</span></span><br><span class="line">      remove_key_name_field <span class="literal">true</span>  <span class="comment"># key_name 解析成功后删除字段。</span></span><br><span class="line">      &lt;parse&gt;</span><br><span class="line">        @<span class="built_in">type</span> multi_format</span><br><span class="line">        &lt;pattern&gt;</span><br><span class="line">          format json</span><br><span class="line">        &lt;/pattern&gt;</span><br><span class="line">        &lt;pattern&gt;</span><br><span class="line">          format none</span><br><span class="line">        &lt;/pattern&gt;</span><br><span class="line">      &lt;/parse&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除一些多余的属性</span></span><br><span class="line">    &lt;filter kubernetes.**&gt;</span><br><span class="line">      @<span class="built_in">type</span> record_transformer</span><br><span class="line">      remove_keys $.docker.container_id,$.kubernetes.container_image_id,$.kubernetes.pod_id,$.kubernetes.namespace_id,$.kubernetes.master_url,$.kubernetes.labels.pod-template-hash</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只保留具有logging=true标签的Pod日志</span></span><br><span class="line">    &lt;filter kubernetes.**&gt;</span><br><span class="line">      @<span class="built_in">id</span> filter_log</span><br><span class="line">      @<span class="built_in">type</span> grep</span><br><span class="line">      &lt;regexp&gt;</span><br><span class="line">        key $.kubernetes.labels.logging</span><br><span class="line">        pattern ^<span class="literal">true</span>$</span><br><span class="line">      &lt;/regexp&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">###### 监听配置，一般用于日志聚合用 ######</span></span><br><span class="line">  forward.input.conf: |-</span><br><span class="line">    <span class="comment"># 监听通过TCP发送的消息</span></span><br><span class="line">    &lt;<span class="built_in">source</span>&gt;</span><br><span class="line">      @<span class="built_in">id</span> forward</span><br><span class="line">      @<span class="built_in">type</span> forward</span><br><span class="line">    &lt;/source&gt;</span><br><span class="line"></span><br><span class="line">  output.conf: |-</span><br><span class="line">    &lt;match **&gt;</span><br><span class="line">      @<span class="built_in">id</span> elasticsearch</span><br><span class="line">      @<span class="built_in">type</span> elasticsearch</span><br><span class="line">      @log_level info</span><br><span class="line">      include_tag_key <span class="literal">true</span></span><br><span class="line">      host elasticsearch</span><br><span class="line">      port 9200</span><br><span class="line">      logstash_format <span class="literal">true</span></span><br><span class="line">      logstash_prefix k8s  <span class="comment"># 设置 index 前缀为 k8s</span></span><br><span class="line">      request_timeout    30s</span><br><span class="line">      &lt;buffer&gt;</span><br><span class="line">        @<span class="built_in">type</span> file</span><br><span class="line">        path /var/log/fluentd-buffers/kubernetes.system.buffer</span><br><span class="line">        flush_mode interval</span><br><span class="line">        retry_type exponential_backoff</span><br><span class="line">        flush_thread_count 2</span><br><span class="line">        flush_interval 5s</span><br><span class="line">        retry_forever</span><br><span class="line">        retry_max_interval 30</span><br><span class="line">        chunk_limit_size 2M</span><br><span class="line">        queue_limit_length 8</span><br><span class="line">        overflow_action block</span><br><span class="line">      &lt;/buffer&gt;</span><br><span class="line">    &lt;/match&gt;</span><br></pre></td></tr></table></figure><blockquote><p>接下來建立 fluentd DaemonSet</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># A cluster role in kubernetes contains rules that represent a set of permissions. </span></span><br><span class="line"><span class="comment"># For fluentd, we want to give permissions for pods and namespaces.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;namespaces&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;pods&quot;</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;get&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;watch&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;list&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">logging</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">addonmanager.kubernetes.io/mode:</span> <span class="string">Reconcile</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">fluentd-es</span></span><br><span class="line">        <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="comment"># 此注释确保如果节点被驱逐，fluentd不会被驱逐，支持关键的基于 pod 注释的优先级方案。 v1.16已經成priorityClassName: high-priority</span></span><br><span class="line">      <span class="comment"># annotations:</span></span><br><span class="line">        <span class="comment"># scheduler.alpha.kubernetes.io/critical-pod: &#x27;&#x27;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">fluentd-es</span></span><br><span class="line">      <span class="attr">priorityClassName:</span> <span class="string">high-priority</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd-es</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">quay.io/fluentd_elasticsearch/fluentd:v3.0.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FLUENTD_ARGS</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">--no-supervisor</span> <span class="string">-q</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FLUENT_ELASTICSEARCH_HOST</span></span><br><span class="line">          <span class="attr">value:</span> </span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">500Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">        <span class="comment"># 建議使用docker info 查看Docker Root Dire的位置是否為/var/lib/docker</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/fluent/config.d</span></span><br><span class="line">      <span class="comment"># 為了能夠靈活控制那些node的log可以被收集 所以添加了nodeSelector屬性</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">beta.kubernetes.io/fluentd-ds-ready:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="comment"># 我們cluster用kubeadm搭建因此default master有汙點 如果想要收集master node的log需要添加tolerations</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">fluentd-config</span></span><br></pre></td></tr></table></figure><h1 id="坑1-pvc-pending-not-bound">坑1: pvc pending not bound</h1><ul><li>ref: <a href="https://www.796t.com/article.php?id=397604">https://www.796t.com/article.php?id=397604</a></li><li>ref: <a href="https://www.796t.com/article.php?id=529912">https://www.796t.com/article.php?id=529912</a></li><li>ref: <a href="https://www.kubermatic.com/blog/keeping-the-state-of-apps-5-introduction-to-storage-classes/">https://www.kubermatic.com/blog/keeping-the-state-of-apps-5-introduction-to-storage-classes/</a></li></ul><h2 id="Problem1-SelfLink-was-empty">Problem1: SelfLink was empty</h2><ul><li>這個問題在Github找到的：<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/issues/25">https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/issues/25</a></li></ul><ol><li>發現pvc顯示waiting for a volume to be created 代表該pvc沒有對應到pv</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal  ExternalProvisioning  13s (x2 over 25s)  persistentvolume-controller  waiting for a volume to be created, either by external provisioner &quot;nfs-client&quot; or manually created by system administrator</span><br></pre></td></tr></table></figure><ol><li>然後檢視kubectl logs nfs-client-provisioner的日誌有如下資訊<code>selfLink was empty, can't make reference</code></li></ol><ul><li>表示 Kubernetes 嘗試為 PVC 創建 PV 時，發生了錯誤，因為 PVC 的 selfLink 是空的，無法創建引用。</li><li>會出現這個錯誤很大一部分的原因是，<em>selfLink 被移除了</em>，從 Kubernetes 1.20 開始，selfLink 屬性被逐步廢棄，並且在更高版本中（例如 1.24+）完全移除。因此，某些<em>較舊的外部 provisioner 或控制器如果仍然依賴於 selfLink 屬性來處理資源，就會遇到這個錯誤</em>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E1022 07:01:24.615869       1 controller.go:1004] provision &quot;default/test-claim&quot; class &quot;nfs-storage&quot;: unexpected error getting claim reference: selfLink was empty, can&#x27;t make reference</span><br></pre></td></tr></table></figure><h2 id="Solution1-增加-feature-gates-RemoveSelfLink-false">Solution1: 增加<code>--feature-gates=RemoveSelfLink=false</code></h2><p>selfLink  was empty 在k8s叢集 v1.20之前都存在，在v1.20之後被刪除，需要在<code>/etc/kubernetes/manifests/kube-apiserver.yaml</code> 新增引數增加 <code>--feature-gates=RemoveSelfLink=false</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 編輯</span></span><br><span class="line">vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - <span class="built_in">command</span>:</span><br><span class="line">    - kube-apiserver</span><br><span class="line">    - --feature-gates=RemoveSelfLink=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動</span></span><br><span class="line">kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml</span><br></pre></td></tr></table></figure><h2 id="Solution2-換-Helm">Solution2: 換 Helm</h2><p>更換能夠支持新版本的Helm Chart，如果你使用的是stable 的provisioner，我發現會有問題，因此改用另一個</p><blockquote><p>使用nfs-subdir-external-provisioner</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner</span><br><span class="line"></span><br><span class="line">helm install nfs-subdir-external-provisioner \</span><br><span class="line">nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \</span><br><span class="line">--<span class="built_in">set</span> nfs.server=&lt;ip&gt; \</span><br><span class="line">--<span class="built_in">set</span> nfs.path=/data/es \</span><br><span class="line">--<span class="built_in">set</span> storageClass.onDelete=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">helm uninstall nfs-subdir-external-provisioner</span><br></pre></td></tr></table></figure><h2 id="Solution3-把-PVC-刪掉重跑-StatefulSet">Solution3: 把 PVC 刪掉重跑 StatefulSet</h2><blockquote><p>前提: 如果你發現上述兩個解法試用過後還是不行</p></blockquote><ol><li>provisioner 是正常running的狀態</li><li>沒有selfLink的問題</li></ol><blockquote><p>試試看以下方法</p></blockquote><ol><li>先讓StatefulSet 下去，沒有statefulSet在跑</li><li>目前沒有任何 pvc 使用</li><li>確認storageClass的名稱有對應到StatefulSet的storageCalss</li><li>重新執行StatefulSet</li></ol><h1 id="坑2-CPU-不夠">坑2: CPU 不夠</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe node | less </span><br><span class="line">// CPI Requests 去看一下到底哪些pod佔用太多服務... 去調整他</span><br><span class="line">// 像是上面kibana因為占用1000m 也就是1整顆cpu太多了... </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fk7Rz7e.png" alt=""></p><h1 id="坑3-NFS-連線不到">坑3: NFS 連線不到</h1><ul><li>ref: <a href="https://blog.csdn.net/sean908/article/details/89208550">https://blog.csdn.net/sean908/article/details/89208550</a><br>可能是防火牆的問題</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看目前有哪些service有防火牆</span><br><span class="line">firewall-cmd --get-service</span><br><span class="line"></span><br><span class="line"># 添加以下服務</span><br><span class="line">firewall-cmd --add-service=nfs</span><br><span class="line">firewall-cmd --add-service=rpc-bind</span><br><span class="line">firewall-cmd --add-service=mountd</span><br></pre></td></tr></table></figure><h1 id="補充-StatefulSet">補充: StatefulSet</h1><p>通常我們平常所使用的Deployment 和 ReplicaSet 建立的 Pod 是「無狀態」（stateless）的，意思是這些 Pod 的狀態和資料不會被記錄下來或保留，重新啟動後就像全新的 Pod 一樣。如果你需要建立會保存狀態的服務，例如資料庫，則需要使用 StatefulSet 來創建，這樣它可以記住每個 Pod 的狀態和資料。</p><p>特點如下：<br><strong>儲存配置</strong></p><ul><li>當你使用 StatefulSet 建立 Pod 時，需要一個永久儲存空間（Persistent Volume, PV）。PV 會根據事先設定的儲存類型（storage class）自動配置。</li><li><em>即使你刪除或縮減 StatefulSet，這些儲存空間也不會被刪除，以確保你的數據不會被意外刪除。</em></li></ul><p><strong>需要 Headless Service</strong></p><ul><li>為了讓每個 Pod 可以正常在網路上通訊，StatefulSet 需要一個特殊的服務類型，稱為 Headless Service，來幫助管理 Pod 的網路連線，主要原因是 每個 Pod 都需要一個固定且獨特的網路身份，使它們能夠被其他 Pod 和服務以特定的名稱進行尋找和通訊。這與 Deployment 中的 Pod 有很大的不同，因為 Deployment 中的 Pod 是「無狀態的」，不需要擁有固定的網路身份。</li><li>Headless Service 可以確保 StatefulSet 中的每一個 Pod 都有一個固定的名稱（例如：app-0, app-1, app-2），並且需要有一個固定的網路位置，這樣其他 Pod 和服務才能找到它們。</li><li>Headless Service 的特點是 <code>clusterIP: None</code>，這樣Kubernetes就不會給這個服務分配一個單一的Cluster IP。舉例來說，當你有一個 <code>my-app</code> 的 Headless Service 並且有三個 StatefulSet 的 Pod（<code>my-app-0</code>、<code>my-app-1</code>、<code>my-app-2</code>），如果其他 Pod 或服務向 <code>my-app</code> 發送請求，這些請求會被分配到 所有三個 Pod 中的一個，我們不需要去知道到底要送到<code>my-app-0</code>還是<code>my-app-1</code>，這是由 Kubernetes 的 DNS 負責的，但是不管是<code>0,1,2</code>對我們來說都無所謂，我們只要送到其中一個即可。</li></ul><p><strong>有序性和正常終止</strong></p><ul><li>StatefulSet 會按順序創建和刪除 Pod，確保每個 Pod 有一個固定的編號和順序。如果你想要確保所有 Pod 都按照正確的順序關閉，最好先將 StatefulSet 的副本數（replicas）縮減為 0，再刪除它。</li></ul><h1 id="補充：SelfLink">補充：SelfLink</h1><p><strong>什麼是 SelfLink？</strong><br>selfLink 是 Kubernetes 資源物件的一個屬性，它就像是資源的「網址」，用來表示這個資源在 Kubernetes API 中的完整路徑。當你想要查詢、訪問或修改某個資源時，selfLink 可以幫助你找到它的確切位置，就像使用網址找到網頁一樣。Kubernetes 自己也會用這個 <code>selfLink</code> 來跟蹤資源的狀態，方便 API 與資源進行互動。</p><p>假設你有一個叫做 my-pod 的 Pod，selfLink 可能長這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/namespaces/default/pods/my-pod</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> EFK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes - 手把手教你如何在 Kubernetes 中建置 CI/CD - GitLab CI + Argo CD</title>
      <link href="/posts/k8s-cicd/"/>
      <url>/posts/k8s-cicd/</url>
      
        <content type="html"><![CDATA[<h1 id="0-介紹">0 介紹</h1><p>因為非常好奇通常怎麼在Kubernetes環境中建置CI/CD環境，因此我決定自己動手試試看，這篇文章將會介紹如何在Kubernetes中建置CI/CD環境，我們將會使用GitLab CI來建置CI環境，並且使用Argo CD來建置CD環境。</p><h2 id="前提概要">前提概要</h2><p>在開始本篇文章前，我們假設你已經間至少以下環境：</p><ol><li>Kubernetes 集群中的多個節點</li><li>已經安裝好 GitLab</li><li>已經在 Kubernetes 中建置好GitLKab Runner，詳細可以參考<a href="https://docs.gitlab.com/runner/install/kubernetes.html">GitLab Runner Helm Chart</a></li></ol><h2 id="GitLab-Harbor-建置">GitLab, Harbor 建置</h2><p>如果 2 還沒建置好，可以參考以下連結，會教你如何建置Harbor、GitLab：<a href="https://github.com/ShannonHung/VMWare-CICD/tree/main/CICD">https://github.com/ShannonHung/VMWare-CICD/tree/main/CICD</a></p><h2 id="GitLab-Runner-建置">GitLab Runner 建置</h2><p>如果 3 還沒建置好，可以參考以下連結，會教你如何建置GitLab Runner：<a href="https://docs.gitlab.com/runner/install/kubernetes.html">https://docs.gitlab.com/runner/install/kubernetes.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helm repo add gitlab https://charts.gitlab.io</span><br><span class="line"><span class="comment"># 之前有遇到小坑 --name已經註銷，因此要把name放在前面喔</span></span><br><span class="line">helm install gitlab-runner --namespace gitlab -f values.yaml gitlab/gitlab-runner</span><br></pre></td></tr></table></figure><blockquote><p><code>values.yaml</code>檔案如下，需要修改以下內容 (<a href="https://gitlab.com/gitlab-org/charts/gitlab-runner/blob/main/values.yaml?_gl=1%2ahqgr4h%2a_ga%2aNzM2NDE5NTc0LjE2NjIyODIxMDc.%2a_ga_ENFH3X7M5Y%2aMTY2Mjk0ODY0Ni4xNi4xLjE2NjI5NDkzNDkuMC4wLjA."><code>values.yaml</code>來源</a>)</p></blockquote><ul><li><code>gitlabeUrl</code>: 指定要註冊的GitLab</li><li><code>runnerRegistrationToken</code>: 指定要註冊的GitLab Runner Token，這邊需要注意的是需要使用<code>admin</code>的帳號進入gitlab，找到<code>ci runner</code>去產生一個新的token提供runner來註冊。</li><li><code>rbac.create</code>: 要調整成true否則無法run ci</li><li><code>config</code>: 所有想要額外的設定都會在這裡設定，可以參考</li></ul><details class="toggle" ><summary class="toggle-button" style="">`values.yaml` 內容說明</summary><div class="toggle-content"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## GitLab Runner Image</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## By default it&#x27;s using registry.gitlab.com/gitlab-org/gitlab-runner:alpine-v&#123;VERSION&#125;</span></span><br><span class="line"><span class="comment">## where &#123;VERSION&#125; is taken from Chart.yaml from appVersion field</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## DEPRECATED: Setting `image: registry.gitlab.com/gitlab-org/gitlab-runner:alpine-v11.6.0` is deprecated</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## ref: https://gitlab.com/gitlab-org/gitlab-runner/container_registry/29383?orderBy=NAME&amp;sort=asc&amp;search[]=alpine-v&amp;search[]=</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## <span class="doctag">Note:</span> If you change the image to the ubuntu release</span></span><br><span class="line"><span class="comment">##       don&#x27;t forget to change the securityContext;</span></span><br><span class="line"><span class="comment">##       these images run on different user IDs.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="string">registry.gitlab.com</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">gitlab-org/gitlab-runner</span></span><br><span class="line">  <span class="comment"># tag: alpine-v11.6.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify a imagePullPolicy for the main runner deployment</span></span><br><span class="line"><span class="comment">## &#x27;Always&#x27; if imageTag is &#x27;latest&#x27;, else set to &#x27;IfNotPresent&#x27;</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## <span class="doctag">Note:</span> it does not apply to job containers launched by this executor.</span></span><br><span class="line"><span class="comment">## Use `pull_policy` in [runners.kubernetes] to change it.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Specifying ImagePullSecrets on a Pod</span></span><br><span class="line"><span class="comment">## Kubernetes supports specifying container image registry keys on a Pod.</span></span><br><span class="line"><span class="comment">## ref: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># imagePullSecrets:</span></span><br><span class="line"><span class="comment">#   - name: &quot;image-pull-secret&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Timeout, in seconds, for liveness and readiness probes of a runner pod.</span></span><br><span class="line"><span class="comment"># probeTimeoutSeconds: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## How many runner pods to launch.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## <span class="doctag">Note:</span> Using more than one replica is not supported with a runnerToken. Use a runnerRegistrationToken</span></span><br><span class="line"><span class="comment">## to create multiple runner replicas.</span></span><br><span class="line"><span class="comment"># replicas: 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## How many old ReplicaSets for this Deployment you want to retain</span></span><br><span class="line"><span class="comment"># revisionHistoryLimit: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## The GitLab Server URL (with protocol) that want to register the runner against</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/commands/index.html#gitlab-runner-register</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">gitlabUrl:</span> <span class="string">https://git.prlab.io/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">## The Registration Token for adding new Runners to the GitLab Server. This must</span></span><br><span class="line"><span class="comment">## be retrieved from your GitLab Instance.</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/ce/ci/runners/index.html</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">runnerRegistrationToken:</span> <span class="string">&quot;hu-89CHyJuYT5VzK-4Rx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## The Runner Token for adding new Runners to the GitLab Server. This must</span></span><br><span class="line"><span class="comment">## be retrieved from your GitLab Instance. It is token of already registered runner.</span></span><br><span class="line"><span class="comment">## ref: (we don&#x27;t yet have docs for that, but we want to use existing token)</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># runnerToken: &quot;&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Unregister all runners before termination</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Updating the runner&#x27;s chart version or configuration will cause the runner container</span></span><br><span class="line"><span class="comment">## to be terminated and created again. This may cause your Gitlab instance to reference</span></span><br><span class="line"><span class="comment">## non-existant runners. Un-registering the runner before termination mitigates this issue.</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/commands/index.html#gitlab-runner-unregister</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># unregisterRunners: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## When stopping the runner, give it time to wait for its jobs to terminate.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Updating the runner&#x27;s chart version or configuration will cause the runner container</span></span><br><span class="line"><span class="comment">## to be terminated with a graceful stop request. terminationGracePeriodSeconds</span></span><br><span class="line"><span class="comment">## instructs Kubernetes to wait long enough for the runner pod to terminate gracefully.</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/commands/#signals</span></span><br><span class="line"><span class="attr">terminationGracePeriodSeconds:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Set the certsSecretName in order to pass custom certficates for GitLab Runner to use</span></span><br><span class="line"><span class="comment">## Provide resource name for a Kubernetes Secret Object in the same namespace,</span></span><br><span class="line"><span class="comment">## this is used to populate the /home/gitlab-runner/.gitlab-runner/certs/ directory</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/tls-self-signed.html#supported-options-for-self-signed-certificates-targeting-the-gitlab-server</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># certsSecretName:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure the maximum number of concurrent jobs</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">concurrent:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Defines in seconds how often to check GitLab for a new builds</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">checkInterval:</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure GitLab Runner&#x27;s logging level. Available values are: debug, info, warn, error, fatal, panic</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># logLevel:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure GitLab Runner&#x27;s logging format. Available values are: runner, text, json</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># logFormat:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure GitLab Runner&#x27;s Sentry DSN.</span></span><br><span class="line"><span class="comment">## ref https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># sentryDsn:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## A custom bash script that will be executed prior to the invocation</span></span><br><span class="line"><span class="comment">## gitlab-runner process</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#preEntrypointScript: |</span></span><br><span class="line"><span class="comment">#  echo &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify whether the runner should start the session server.</span></span><br><span class="line"><span class="comment">## Defaults to false</span></span><br><span class="line"><span class="comment">## ref:</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## When sessionServer is enabled, the user can either provide a public publicIP</span></span><br><span class="line"><span class="comment">## or either rely on the external IP auto discovery</span></span><br><span class="line"><span class="comment">## When a serviceAccountName is used with the automounting to the pod disable,</span></span><br><span class="line"><span class="comment">## we recommend the usage of the publicIP</span></span><br><span class="line"><span class="attr">sessionServer:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># annotations: &#123;&#125;</span></span><br><span class="line">  <span class="comment"># timeout: 1800</span></span><br><span class="line">  <span class="comment"># internalPort: 8093</span></span><br><span class="line">  <span class="comment"># externalPort: 9000</span></span><br><span class="line">  <span class="comment"># publicIP: &quot;&quot;</span></span><br><span class="line">  <span class="comment"># loadBalancerSourceRanges:</span></span><br><span class="line">  <span class="comment">#   - 1.2.3.4/32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## For RBAC support:</span></span><br><span class="line"><span class="attr">rbac:</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Define specific rbac permissions.</span></span><br><span class="line">  <span class="comment">## DEPRECATED: see .Values.rbac.rules</span></span><br><span class="line">  <span class="comment"># resources: [&quot;pods&quot;, &quot;pods/exec&quot;, &quot;secrets&quot;]</span></span><br><span class="line">  <span class="comment"># verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;patch&quot;, &quot;delete&quot;]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Define list of rules to be added to the rbac role permissions.</span></span><br><span class="line">  <span class="comment">## Each rule supports the keys:</span></span><br><span class="line">  <span class="comment">## - apiGroups: default &quot;&quot; (indicates the core API group) if missing or empty.</span></span><br><span class="line">  <span class="comment">## - resources: default &quot;*&quot; if missing or empty.</span></span><br><span class="line">  <span class="comment">## - verbs: default &quot;*&quot; if missing or empty.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Read more about the recommended rules on the following link</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/executors/kubernetes.html#configuring-executor-service-account</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="attr">rules:</span> []</span><br><span class="line">  <span class="comment"># - resources: [&quot;configmaps&quot;, &quot;pods&quot;, &quot;pods/attach&quot;, &quot;secrets&quot;, &quot;services&quot;]</span></span><br><span class="line">  <span class="comment">#   verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;patch&quot;, &quot;update&quot;, &quot;delete&quot;]</span></span><br><span class="line">  <span class="comment"># - apiGroups: [&quot;&quot;]</span></span><br><span class="line">  <span class="comment">#   resources: [&quot;pods/exec&quot;]</span></span><br><span class="line">  <span class="comment">#   verbs: [&quot;create&quot;, &quot;patch&quot;, &quot;delete&quot;]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Run the gitlab-bastion container with the ability to deploy/manage containers of jobs</span></span><br><span class="line">  <span class="comment">## cluster-wide or only within namespace</span></span><br><span class="line">  <span class="attr">clusterWideAccess:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Use the following Kubernetes Service Account name if RBAC is disabled in this Helm chart (see rbac.create)</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># serviceAccountName: default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify annotations for Service Accounts, useful for annotations such as eks.amazonaws.com/role-arn</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://docs.aws.amazon.com/eks/latest/userguide/specify-service-account-role.html</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># serviceAccountAnnotations: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Use podSecurity Policy</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/</span></span><br><span class="line">  <span class="attr">podSecurityPolicy:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">resourceNames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gitlab-runner</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify one or more imagePullSecrets used for pulling the runner image</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line"><span class="comment">##  imagePullSecrets: [prlab-harbor]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure integrated Prometheus metrics exporter</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/monitoring/#configuration-of-the-metrics-http-server</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">metrics:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Define a name for the metrics port</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="attr">portName:</span> <span class="string">metrics</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Provide a port number for the integrated Prometheus metrics exporter</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9252</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Configure a prometheus-operator serviceMonitor to allow autodetection of</span></span><br><span class="line">  <span class="comment">## the scraping target. Requires enabling the service resource below.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="attr">serviceMonitor:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## Provide additional labels to the service monitor ressource</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## labels: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## Define a scrape interval (otherwise prometheus default is used)</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## ref: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># interval: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## Specify the scrape protocol scheme e.g., https or http</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># scheme: &quot;http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## Supply a tls configuration for the service monitor</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## ref: https://github.com/helm/charts/blob/master/stable/prometheus-operator/crds/crd-servicemonitor.yaml</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># tlsConfig: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## The URI path where prometheus metrics can be scraped from</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># path: &quot;/metrics&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## A list of MetricRelabelConfigs to apply to samples before ingestion</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## ref: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># metricRelabelings: []</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## A list of RelabelConfigs to apply to samples before scraping</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## ref: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## relabelings: []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure a service resource e.g., to allow scraping metrics via</span></span><br><span class="line"><span class="comment">## prometheus-operator serviceMonitor</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Provide additonal labels for the service</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># labels: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Provide additonal annotations for the service</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># annotations: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Define a specific ClusterIP if you do not want a dynamic one</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#choosing-your-own-ip-address</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># clusterIP: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Define a list of one or more external IPs for this service</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-ips</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># externalIPs: []</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Provide a specific loadbalancerIP e.g., of an external Loadbalancer</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># loadBalancerIP: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Provide a list of source IP ranges to have access to this service</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#aws-nlb-support</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># loadBalancerSourceRanges: []</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify the service type e.g., ClusterIP, NodePort, Loadbalancer or ExternalName</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify the services metrics nodeport if you use a service of type nodePort</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># metrics:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## Specify the node port under which the prometheus metrics of the runner are made</span></span><br><span class="line">    <span class="comment">## available.</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#nodeport</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># nodePort: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Provide a list of additional ports to be exposed by this service</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># additionalPorts: []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configuration for the Pods that the runner launches for each new job</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">runners:</span></span><br><span class="line">  <span class="comment"># runner configuration, where the multi line strings is evaluated as</span></span><br><span class="line">  <span class="comment"># template so you can specify helm values inside of it.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># tpl: https://helm.sh/docs/howto/charts_tips_and_tricks/#using-the-tpl-function</span></span><br><span class="line">  <span class="comment"># runner configuration: https://docs.gitlab.com/runner/configuration/advanced-configuration.html</span></span><br><span class="line">  <span class="attr">config:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    [[runners]]</span></span><br><span class="line"><span class="string">      privileged = true</span></span><br><span class="line"><span class="string">      [runners.kubernetes]  </span></span><br><span class="line"><span class="string">        namespace = &quot;&#123;&#123;.Release.Namespace&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">        image = &quot;ubuntu:20.04&quot;</span></span><br><span class="line"><span class="string"></span>  <span class="comment">## Which executor should be used</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># executor: kubernetes</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Default container image to use for builds when none is specified</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># image: ubuntu:16.04</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify one or more imagePullSecrets</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> [<span class="string">prlab-harbor</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify the image pull policy: never, if-not-present, always. The cluster default will be used if not set.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># imagePullPolicy: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Defines number of concurrent requests for new job from GitLab</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># requestConcurrency: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify whether the runner should be locked to a specific project: true, false. Defaults to true.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line"><span class="comment">##  locked: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify the tags associated with the runner. Comma-separated list of tags.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/ee/ci/runners/configure_runners.html#use-tags-to-control-which-jobs-a-runner-can-run</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># tags: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify the name for the runner.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># name: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify the maximum timeout (in seconds) that will be set for job when using this Runner</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># maximumTimeout: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify if jobs without tags should be run.</span></span><br><span class="line">  <span class="comment">## If not specified, Runner will default to true if no tags were specified. In other case it will</span></span><br><span class="line">  <span class="comment">## default to false.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/ee/ci/runners/configure_runners.html#set-a-runner-to-run-untagged-jobs</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># runUntagged: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify whether the runner should only run protected branches.</span></span><br><span class="line">  <span class="comment">## Defaults to false.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/ee/ci/runners/configure_runners.html#prevent-runners-from-revealing-sensitive-information</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># protected: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Run all containers with the privileged flag enabled</span></span><br><span class="line">  <span class="comment">## This will allow the docker:dind image to run if you need to run Docker</span></span><br><span class="line">  <span class="comment">## commands. Please read the docs before turning this on:</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/executors/kubernetes.html#using-dockerdind</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># privileged: false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## The name of the secret containing runner-token and runner-registration-token</span></span><br><span class="line">  <span class="comment"># secret: gitlab-runner</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Namespace to run Kubernetes jobs in (defaults to the same namespace of this release)</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># namespace:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## The amount of time, in seconds, that needs to pass before the runner will</span></span><br><span class="line">  <span class="comment">## timeout attempting to connect to the container it has just created.</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/executors/kubernetes.html</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># pollTimeout: 180</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Set maximum build log size in kilobytes, by default set to 4096 (4MB)</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># outputLimit: 4096</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Distributed runners caching</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/configuration/autoscale.html#distributed-runners-caching</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## If you want to use s3 based distributing caching:</span></span><br><span class="line">  <span class="comment">## First of all you need to uncomment General settings and S3 settings sections.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Create a secret &#x27;s3access&#x27; containing &#x27;accesskey&#x27; &amp; &#x27;secretkey&#x27;</span></span><br><span class="line">  <span class="comment">## ref: https://aws.amazon.com/blogs/security/wheres-my-secret-access-key/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## $ kubectl create secret generic s3access \</span></span><br><span class="line">  <span class="comment">##   --from-literal=accesskey=&quot;YourAccessKey&quot; \</span></span><br><span class="line">  <span class="comment">##   --from-literal=secretkey=&quot;YourSecretKey&quot;</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/secret/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## If you want to use gcs based distributing caching:</span></span><br><span class="line">  <span class="comment">## First of all you need to uncomment General settings and GCS settings sections.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Access using credentials file:</span></span><br><span class="line">  <span class="comment">## Create a secret &#x27;google-application-credentials&#x27; containing your application credentials file.</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runnerscachegcs-section</span></span><br><span class="line">  <span class="comment">## You could configure</span></span><br><span class="line">  <span class="comment">## $ kubectl create secret generic google-application-credentials \</span></span><br><span class="line">  <span class="comment">##   --from-file=gcs-application-credentials-file=./path-to-your-google-application-credentials-file.json</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/secret/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Access using access-id and private-key:</span></span><br><span class="line">  <span class="comment">## Create a secret &#x27;gcsaccess&#x27; containing &#x27;gcs-access-id&#x27; &amp; &#x27;gcs-private-key&#x27;.</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runnerscachegcs-section</span></span><br><span class="line">  <span class="comment">## You could configure</span></span><br><span class="line">  <span class="comment">## $ kubectl create secret generic gcsaccess \</span></span><br><span class="line">  <span class="comment">##   --from-literal=gcs-access-id=&quot;YourAccessID&quot; \</span></span><br><span class="line">  <span class="comment">##   --from-literal=gcs-private-key=&quot;YourPrivateKey&quot;</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/secret/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## If you want to use Azure-based distributed caching:</span></span><br><span class="line">  <span class="comment">## First, uncomment General settings.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Create a secret &#x27;azureaccess&#x27; containing &#x27;azure-account-name&#x27; &amp; &#x27;azure-account-key&#x27;</span></span><br><span class="line">  <span class="comment">## ref: https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blobs-introduction</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## $ kubectl create secret generic azureaccess \</span></span><br><span class="line">  <span class="comment">##   --from-literal=azure-account-name=&quot;YourAccountName&quot; \</span></span><br><span class="line">  <span class="comment">##   --from-literal=azure-account-key=&quot;YourAccountKey&quot;</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/secret/</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cache:</span> &#123;&#125;</span><br><span class="line">    <span class="comment">## General settings</span></span><br><span class="line">    <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration and https://docs.gitlab.com/runner/install/kubernetes.html#using-cache-with-configuration-template</span></span><br><span class="line">    <span class="comment"># cacheType: s3</span></span><br><span class="line">    <span class="comment"># cachePath: &quot;gitlab_runner&quot;</span></span><br><span class="line">    <span class="comment"># cacheShared: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## S3 settings</span></span><br><span class="line">    <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration and https://docs.gitlab.com/runner/install/kubernetes.html#using-cache-with-configuration-template</span></span><br><span class="line">    <span class="comment"># s3ServerAddress: s3.amazonaws.com</span></span><br><span class="line">    <span class="comment"># s3BucketName:</span></span><br><span class="line">    <span class="comment"># s3BucketLocation:</span></span><br><span class="line">    <span class="comment"># s3CacheInsecure: false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## GCS settings</span></span><br><span class="line">    <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration and https://docs.gitlab.com/runner/install/kubernetes.html#using-cache-with-configuration-template</span></span><br><span class="line">    <span class="comment"># gcsBucketName:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">## S3 the name of the secret.</span></span><br><span class="line">    <span class="comment"># secretName: s3access</span></span><br><span class="line">    <span class="comment">## Use this line for access using gcs-access-id and gcs-private-key</span></span><br><span class="line">    <span class="comment"># secretName: gcsaccess</span></span><br><span class="line">    <span class="comment">## Use this line for access using google-application-credentials file</span></span><br><span class="line">    <span class="comment"># secretName: google-application-credentials</span></span><br><span class="line">    <span class="comment">## Use this line for access using Azure with azure-account-name and azure-account-key</span></span><br><span class="line">    <span class="comment"># secretName: azureaccess</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Build Container specific configuration</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="attr">builds:</span> &#123;&#125;</span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># cpuLimitOverwriteMaxAllowed: 400m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line">    <span class="comment"># memoryLimitOverwriteMaxAllowed: 512Mi</span></span><br><span class="line">    <span class="comment"># cpuRequests: 100m</span></span><br><span class="line">    <span class="comment"># cpuRequestsOverwriteMaxAllowed: 200m</span></span><br><span class="line">    <span class="comment"># memoryRequests: 128Mi</span></span><br><span class="line">    <span class="comment"># memoryRequestsOverwriteMaxAllowed: 256Mi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Service Container specific configuration</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="attr">services:</span> &#123;&#125;</span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line">    <span class="comment"># cpuRequests: 100m</span></span><br><span class="line">    <span class="comment"># memoryRequests: 128Mi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Helper Container specific configuration</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="attr">helpers:</span> &#123;&#125;</span><br><span class="line">    <span class="comment"># cpuLimit: 200m</span></span><br><span class="line">    <span class="comment"># memoryLimit: 256Mi</span></span><br><span class="line">    <span class="comment"># cpuRequests: 100m</span></span><br><span class="line">    <span class="comment"># memoryRequests: 128Mi</span></span><br><span class="line">    <span class="comment"># image: &quot;registry.gitlab.com/gitlab-org/gitlab-runner-helper:x86_64-$&#123;CI_RUNNER_REVISION&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Helper container security context configuration</span></span><br><span class="line">  <span class="comment">## Refer to https://docs.gitlab.com/runner/executors/kubernetes.html#using-security-context</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># pod_security_context:</span></span><br><span class="line">  <span class="comment">#   run_as_non_root: true</span></span><br><span class="line">  <span class="comment">#   run_as_user: 100</span></span><br><span class="line">  <span class="comment">#   run_as_group: 100</span></span><br><span class="line">  <span class="comment">#   fs_group: 65533</span></span><br><span class="line">  <span class="comment">#   supplemental_groups: [101, 102]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Service Account to be used for runners</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment"># serviceAccountName:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## If Gitlab is not reachable through $CI_SERVER_URL</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># cloneUrl:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify node labels for CI job pods assignment</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># nodeSelector: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify node tolerations for CI job pods assignment</span></span><br><span class="line">  <span class="comment">## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># nodeTolerations: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify pod labels for CI job pods</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># podLabels: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Specify annotations for job pods, useful for annotations such as iam.amazonaws.com/role</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># podAnnotations: &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## Configure environment variables that will be injected to the pods that are created while</span></span><br><span class="line">  <span class="comment">## the build is running. These variables are passed as parameters, i.e. `--env &quot;NAME=VALUE&quot;`,</span></span><br><span class="line">  <span class="comment">## to `gitlab-runner register` command.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## Note that `envVars` (see below) are only present in the runner pod, not the pods that are</span></span><br><span class="line">  <span class="comment">## created for each build.</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## ref: https://docs.gitlab.com/runner/commands/#gitlab-runner-register</span></span><br><span class="line">  <span class="comment">##</span></span><br><span class="line">  <span class="comment">## DEPRECATED: See https://docs.gitlab.com/runner/install/kubernetes.html#additional-configuration</span></span><br><span class="line">  <span class="comment"># env:</span></span><br><span class="line">  <span class="comment">#   NAME: VALUE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Specify the name of the scheduler which used to schedule runner pods.</span></span><br><span class="line"><span class="comment">## Kubernetes supports multiple scheduler configurations.</span></span><br><span class="line"><span class="comment">## ref: https://kubernetes.io/docs/reference/scheduling</span></span><br><span class="line"><span class="comment"># schedulerName: &quot;my-custom-scheduler&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure securitycontext for the main container</span></span><br><span class="line"><span class="comment">## ref: http://kubernetes.io/docs/user-guide/security-context/</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">capabilities:</span></span><br><span class="line">    <span class="attr">drop:</span> [<span class="string">&quot;ALL&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure securitycontext valid for the whole pod</span></span><br><span class="line"><span class="comment">## ref: http://kubernetes.io/docs/user-guide/security-context/</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">podSecurityContext:</span></span><br><span class="line">  <span class="attr">runAsUser:</span> <span class="number">100</span></span><br><span class="line">  <span class="comment"># runAsGroup: 65533</span></span><br><span class="line">  <span class="attr">fsGroup:</span> <span class="number">65533</span></span><br><span class="line">  <span class="comment"># supplementalGroups: [65533]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## <span class="doctag">Note:</span> values for the ubuntu image:</span></span><br><span class="line">  <span class="comment"># runAsUser: 999</span></span><br><span class="line">  <span class="comment"># fsGroup: 999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure resource requests and limits</span></span><br><span class="line"><span class="comment">## ref: http://kubernetes.io/docs/user-guide/compute-resources/</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">  <span class="comment"># limits:</span></span><br><span class="line">  <span class="comment">#   memory: 256Mi</span></span><br><span class="line">  <span class="comment">#   cpu: 200m</span></span><br><span class="line">  <span class="comment"># requests:</span></span><br><span class="line">  <span class="comment">#   memory: 128Mi</span></span><br><span class="line">  <span class="comment">#   cpu: 100m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Affinity for pod assignment</span></span><br><span class="line"><span class="comment">## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">affinity:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Node labels for pod assignment</span></span><br><span class="line"><span class="comment">## Ref: https://kubernetes.io/docs/user-guide/node-selection/</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">nodeSelector:</span> &#123;&#125;</span><br><span class="line">  <span class="comment"># Example: The gitlab runner manager should not run on spot instances so you can assign</span></span><br><span class="line">  <span class="comment"># them to the regular worker nodes only.</span></span><br><span class="line">  <span class="comment"># node-role.kubernetes.io/worker: &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## List of node taints to tolerate (requires Kubernetes &gt;= 1.6)</span></span><br><span class="line"><span class="comment">## Ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">tolerations:</span> []</span><br><span class="line">  <span class="comment"># Example: Regular worker nodes may have a taint, thus you need to tolerate the taint</span></span><br><span class="line">  <span class="comment"># when you assign the gitlab runner manager with nodeSelector or affinity to the nodes.</span></span><br><span class="line">  <span class="comment"># - key: &quot;node-role.kubernetes.io/worker&quot;</span></span><br><span class="line">  <span class="comment">#   operator: &quot;Exists&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure environment variables that will be present when the registration command runs</span></span><br><span class="line"><span class="comment">## This provides further control over the registration process and the config.toml file</span></span><br><span class="line"><span class="comment">## ref: `gitlab-runner register --help`</span></span><br><span class="line"><span class="comment">## ref: https://docs.gitlab.com/runner/configuration/advanced-configuration.html</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># envVars:</span></span><br><span class="line"><span class="comment">#   - name: RUNNER_EXECUTOR</span></span><br><span class="line"><span class="comment">#     value: kubernetes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## list of hosts and IPs that will be injected into the pod&#x27;s hosts file</span></span><br><span class="line"><span class="attr">hostAliases:</span> []</span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># - ip: &quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="comment">#   hostnames:</span></span><br><span class="line">  <span class="comment">#   - &quot;foo.local&quot;</span></span><br><span class="line">  <span class="comment">#   - &quot;bar.local&quot;</span></span><br><span class="line">  <span class="comment"># - ip: &quot;10.1.2.3&quot;</span></span><br><span class="line">  <span class="comment">#   hostnames:</span></span><br><span class="line">  <span class="comment">#   - &quot;foo.remote&quot;</span></span><br><span class="line">  <span class="comment">#   - &quot;bar.remote&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Annotations to be added to manager pod</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">podAnnotations:</span> &#123;&#125;</span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># iam.amazonaws.com/role: &lt;my_role_arn&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Labels to be added to manager pod</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">podLabels:</span> &#123;&#125;</span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># owner.team: &lt;my_cool_team&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## HPA support for custom metrics:</span></span><br><span class="line"><span class="comment">## This section enables runners to autoscale based on defined custom metrics.</span></span><br><span class="line"><span class="comment">## In order to use this functionality, Need to enable a custom metrics API server by</span></span><br><span class="line"><span class="comment">## implementing &quot;custom.metrics.k8s.io&quot; using supported third party adapter</span></span><br><span class="line"><span class="comment">## Example: https://github.com/directxman12/k8s-prometheus-adapter</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">#hpa: &#123;&#125;</span></span><br><span class="line">  <span class="comment"># minReplicas: 1</span></span><br><span class="line">  <span class="comment"># maxReplicas: 10</span></span><br><span class="line">  <span class="comment"># metrics:</span></span><br><span class="line">  <span class="comment"># - type: Pods</span></span><br><span class="line">  <span class="comment">#   pods:</span></span><br><span class="line">  <span class="comment">#     metricName: gitlab_runner_jobs</span></span><br><span class="line">  <span class="comment">#     targetAverageValue: 400m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Configure priorityClassName for manager pod. See k8s docs for more info on how pod priority works:</span></span><br><span class="line"><span class="comment">##  https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/</span></span><br><span class="line"><span class="attr">priorityClassName:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Secrets to be additionally mounted to the containers.</span></span><br><span class="line"><span class="comment">## All secrets are mounted through init-runner-secrets volume</span></span><br><span class="line"><span class="comment">## and placed as readonly at /init-secrets in the init container</span></span><br><span class="line"><span class="comment">## and finally copied to an in-memory volume runner-secrets that is</span></span><br><span class="line"><span class="comment">## mounted at /secrets.</span></span><br><span class="line"><span class="attr">secrets:</span> []</span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># - name: my-secret</span></span><br><span class="line">  <span class="comment"># - name: myOtherSecret</span></span><br><span class="line">  <span class="comment">#   items:</span></span><br><span class="line">  <span class="comment">#     - key: key_one</span></span><br><span class="line">  <span class="comment">#       path: path_one</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Additional config files to mount in the containers in `/configmaps`.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## Please note that a number of keys are reserved by the runner.</span></span><br><span class="line"><span class="comment">## See https://gitlab.com/gitlab-org/charts/gitlab-runner/-/blob/main/templates/configmap.yaml</span></span><br><span class="line"><span class="comment">## for a current list.</span></span><br><span class="line"><span class="attr">configMaps:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## Additional volumeMounts to add to the runner container</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">volumeMounts:</span> []</span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># - name: my-volume</span></span><br><span class="line">  <span class="comment">#   mountPath: /mount/path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Additional volumes to add to the runner deployment</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">volumes:</span> []</span><br><span class="line">  <span class="comment"># Example:</span></span><br><span class="line">  <span class="comment"># - name: my-volume</span></span><br><span class="line">  <span class="comment">#   persistentVolumeClaim:</span></span><br><span class="line">  <span class="comment">#     claimName: my-pvc</span></span><br></pre></td></tr></table></figure></div></details><h1 id="1-安裝ArgoCD">1 安裝ArgoCD</h1><p>Argo CD是一個持續交付工具可以自動化部署應用程式到Kubernetes集群中。它遵循GitOps模式，當發現Git Repo 中所監控的資料夾有變更時，Argo CD會自動部署應用程式到Kubernetes集群中。因為CD透過拉取的方式，所以我們又稱之為Pull Based。</p><h2 id="1-1-基本設定">1.1 基本設定</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Getting Start </span></span><br><span class="line">kubectl create namespace argocd</span><br><span class="line">kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定nodeport 根據argo clusterIP的service調整成 nodePort，因為我們要讓外部可以連線到argo</span></span><br><span class="line">kubectl get svc -n argocd argocd-server -o yaml &gt; argocd-nodeport.yaml </span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以這樣 去更新service的type：NodePort</span></span><br><span class="line">kubectl patch svc argocd-server -n argocd</span><br><span class="line">-p <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;NodePort&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><em><code>argocd-nodeport.yaml</code> 轉寫Nodeport的yaml 這樣才可以從外面取得</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/component:</span> <span class="string">server</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">argocd-server</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">argocd</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">argocd-server-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">argocd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30090</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30091</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">argocd-server</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f argocd-nodeport.yaml</span><br></pre></td></tr></table></figure><h2 id="1-2-取得初始化密碼">1.2 取得初始化密碼</h2><ul><li>ref: <a href="https://argo-cd.readthedocs.io/en/stable/getting_started/#4-login-using-the-cli">https://argo-cd.readthedocs.io/en/stable/getting_started/#4-login-using-the-cli</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=<span class="string">&quot;&#123;.data.password&#125;&quot;</span> | <span class="built_in">base64</span> -d; <span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">&lt;output&gt; </span><br><span class="line">5BX3ZVroqjsR1J05</span><br><span class="line"><span class="comment"># using username </span></span><br><span class="line">username: admin</span><br><span class="line">password: &lt;output&gt; </span><br></pre></td></tr></table></figure><h1 id="2-Gitlab-Manifest架構">2 Gitlab Manifest架構</h1><ul><li>這邊所使用的helm chart來進行config manager</li><li>可以參考如下圖的架構:<ul><li><code>templates</code>: 裡面放所有deployment所需使用的yaml檔案</li><li><code>values</code>: 當你templates裡面的yaml檔案有挖空的部分會根據values.yaml來填上</li><li><code>kioxia-helm.yaml</code>: 下一步step3要執行的CRD Application yaml</li><li><code>Chart.yaml</code>: 定義Chart的yaml檔案</li><li><code>values.yaml</code>: 如果找不到相對應的values.yaml就會使用的初始值</li></ul></li></ul><p><img src="https://i.imgur.com/X1DxhGC.png" alt=""></p><h2 id="2-1-templates-建立k8s部署用yaml">2.1 templates - 建立k8s部署用yaml</h2><ul><li>那我們先從templates開始，基本上這裡就是放所有的deployment, service那些在k8s部屬用的yaml檔案</li><li>你可以發現很多被挖空的地方，這些地方會由<code>values.yaml</code>所填補上</li></ul><p><img src="https://i.imgur.com/ABGVXoG.png" alt=""></p><blockquote><p>deployment.yaml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.metadata.name</span> &#125;&#125; </span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.namespace.name</span> &#125;&#125; </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">kioxia.share.station/server:</span> &#123;&#123; <span class="string">.Values.metadata.name</span> &#125;&#125; </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">kioxia.share.station/server:</span> &#123;&#123; <span class="string">.Values.metadata.name</span> &#125;&#125; </span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> &#123;&#123;<span class="string">.Values.image.repository</span>&#125;&#125;<span class="string">:&#123;&#123;.Values.image.tag&#125;&#125;</span></span><br><span class="line">          <span class="attr">lifecycle:</span></span><br><span class="line">            <span class="attr">preStop:</span></span><br><span class="line">              <span class="attr">exec:</span></span><br><span class="line">                <span class="attr">command:</span> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 10&quot;</span> ]</span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.metadata.name</span> &#125;&#125; </span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> &#123;&#123; <span class="string">.Values.service.port</span> &#125;&#125; </span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-values-yaml-建立部署用所填入的值">2.2 values.yaml - 建立部署用所填入的值</h2><ul><li>因為我們這裡使用微服務架構，因此我希望可以一次性透過helm來產所有的app的template</li><li>我們有3個values.yaml和一個資料夾customize-template<ul><li><code>customize-template</code>: 之後gitlab cd的部分會把env變數塞進去然後來覆蓋掉外面的values-app.yaml來達到觸發argo cd</li><li><code>values-file/idp/pdp.yaml</code>: 給特定server使用的yaml檔案，但是要怎麼知道argo要部屬哪一個values呢? 下一步2.3會告訴你<br><img src="https://i.imgur.com/Z2iK4M6.png" alt=""></li></ul></li></ul><blockquote><p><code>values-file.yaml</code></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # values.yaml - default input configuration file for the chart. If no other values file is supplied, the parameters in this file will be used.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-name</span> <span class="comment"># 對應到 &#123;&#123;Values.metadata.name&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">namespace:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">logging</span> <span class="comment"># 對應到 &#123;&#123;Values.namespace.name&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">&lt;harbor-url/image-name&gt;</span>   <span class="comment"># harbor 的 image repo</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">1a015d32</span> <span class="comment"># 這裡之後會被customizie-template所替換掉，我們每次commit到特定branch會觸發ci，ci會幫我建立image使用這個commit tag當作image tag，而我這個目的在於要拉這個image tag來部屬於k8s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8086</span>        <span class="comment"># pod 中服務的 port </span></span><br><span class="line">  <span class="attr">nodePort:</span> <span class="number">30086</span>   <span class="comment"># 對外開放的port</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>customize-template/vlaues-file.yaml</code></p></blockquote><ul><li>放在<code>cutomize-template</code>裡面的yaml檔案有點像是template的存在供customize工具來將env變數塞進去然後產生一個新的<code>values-file.yaml</code>放在<code>values/</code>底下ArgoCD會使用的檔案</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # values.yaml - default input configuration file for the chart. If no other values file is supplied, the parameters in this file will be used.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-name</span></span><br><span class="line"></span><br><span class="line"><span class="attr">namespace:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">logging</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">&lt;harbor-url/image-name&gt;</span></span><br><span class="line">  <span class="attr">tag:</span> <span class="string">$&#123;IMAGE_TAG&#125;</span> <span class="comment"># gitlab cd裡面會貼上 環境變數 </span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">  <span class="attr">nodePort:</span> <span class="number">30086</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-crd-yaml-建立argocd-CRD">2.3 crd.yaml - 建立argocd CRD</h2><ul><li>當我們準備好<ul><li><code>template</code>: 在k8s部屬用的<code>yaml</code>檔案</li><li><code>values.yaml</code>: 部屬用的value，會根據<code>value-ooo.yaml</code>來填補到<code>template</code>裡面</li></ul></li><li>接下來就是要執行在k8s環境用來監視gitlab的manifest是否有變動的application crd，所謂的CRD（Custom Resource Definition） 是 Kubernetes 提供的功能，允許你擴展 Kubernetes API，定義你自己的資源類型。通過 CRD，你可以將自定義的配置對象整合到 Kubernetes 中，像管理原生資源（如 Pods、Services）一樣管理這些自定義資源。</li></ul><p>Argo CD 的核心理念是 GitOps，它通過監視 Git 存儲庫的配置，將 Kubernetes 集群中的應用程序狀態與 Git 中的定義保持一致。Application CRD 讓 Argo CD 能夠了解應用程序的來源、目標和配置。</p><blockquote><p><code>argocd-crd.yaml</code></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Application</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-argocd</span> <span class="comment"># &lt;== 自己取名 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">argocd</span> <span class="comment"># &lt;== 一定要跟argo在同一個namespace</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># which cluster our resource should be deployed基本上不用改動</span></span><br><span class="line">  <span class="attr">destination:</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://kubernetes.default.svc</span></span><br><span class="line">  <span class="attr">project:</span> <span class="string">default</span></span><br><span class="line">  <span class="comment"># reference our manifest</span></span><br><span class="line">  <span class="attr">source:</span></span><br><span class="line">    <span class="attr">helm:</span></span><br><span class="line">      <span class="attr">valueFiles:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">values/values-file.yaml</span> <span class="comment"># &lt;== 指定你要使用的values.yaml</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">manifests</span> <span class="comment"># &lt;== 指定gitlab要監控的manifests，通常就是git repo裡面有個名為manifests的資料夾，這個資料夾裡面任何內容如果有變動argocd就會知道</span></span><br><span class="line">    <span class="attr">repoURL:</span> <span class="string">https://&lt;gitlab-url&gt;/&lt;app&gt;.git</span> <span class="comment"># &lt;== 指定gitlab repo</span></span><br><span class="line">    <span class="attr">targetRevision:</span> <span class="string">master</span> <span class="comment"># &lt;== 指定要監控哪一個branch</span></span><br><span class="line">  <span class="comment"># empty mean we manually sync the app</span></span><br><span class="line">  <span class="attr">syncPolicy:</span> &#123;&#125; <span class="comment"># &lt;== 可以設定要手動還是自動同步 </span></span><br></pre></td></tr></table></figure><blockquote><p>執行</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 啟動 看一下你執行的application是否有執行</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">argocd-crd.yaml</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">application</span> <span class="string">-n</span> <span class="string">argocd</span> </span><br></pre></td></tr></table></figure><h2 id="2-4-argo-先登入gitlab">2.4 argo 先登入gitlab</h2><ul><li><p>Ref: <a href="https://ppfocus.com/0/di2b6fdf4.html">https://ppfocus.com/0/di2b6fdf4.html</a></p></li><li><p>你可能會好奇argo要怎麼知道gitlab的帳號密碼?</p></li><li><p>由於我們這裡的代碼倉庫是私有的 GitLab，所以我們還需要配置對應的倉庫地址，在頁面上 Settings → Repositories，點擊 Connect Repo using HTTPS 按鈕：</p><ul><li>需要注意的是這裡默認使用的是 HTTPS，所以我們需要勾選下方的 <code>Skip server verification</code></li><li>然後點擊上方的 <code>CONNECT</code> 按鈕添加即可。然後重新同步上面的兩個 Application，就可以看到正常的狀態了。</li></ul></li></ul><h1 id="3-Gitlab-CICD-設定撰寫">3 Gitlab CICD 設定撰寫</h1><h2 id="3-1-基本參數設定">3.1 基本參數設定</h2><ul><li>我們要先於gitlab ci variable設定以下參數:</li><li>目的是為了push image到harbor<ul><li><code>CI_REGISTER_IMAGE_&lt;NAME&gt;</code>: image名稱，這裡的例子如果使用private repo則是可以填寫<code>/dev/kioxia-file</code></li><li><code>CI_REGISTER</code>: harbor位置，如果是使用private repo可以填寫<code>192.168.0.100:30004</code></li><li><code>CI_REGISTER_USER</code>: harbor robot account，所以要記得去Harbor建立robot的token和username，可以參考<a href="https://goharbor.io/docs/1.10/working-with-projects/project-configuration/create-robot-accounts/">官網</a>。</li><li><code>CI_REGISTER_PASSWORD</code>: harbor robot token</li></ul></li><li>目的是為了在cd pipeline做commit的動作，可以參考<a href="https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html">官網</a>:<ul><li><code>CI_USERNAME_GIT</code>: project access token’s account</li><li><code>CI_PASSWORD_GIT</code>: project access token</li></ul></li></ul><p><img src="https://i.imgur.com/E6qjNzN.png" alt=""><br><img src="https://i.imgur.com/3cNCEEe.png" alt=""></p><h2 id="3-2-設定gitlab-runner的適用對象">3.2 設定gitlab runner的適用對象</h2><ul><li>gitlab runner有設定可以使用的對象是誰，如果要使用gitlab runner的服務就要使用root權限去設定</li><li>使用root@password帳號登入進入runners</li><li>編輯runner設定</li><li>把想要使用cicd的project加入<br><img src="https://i.imgur.com/eQh8CY6.png" alt=""></li></ul><p><img src="https://i.imgur.com/FVjZLfQ.png" alt=""></p><h2 id="3-3-撰寫-gitlab-ci-yml">3.3 撰寫.gitlab-ci.yml</h2><p>:::warning<br>請注意，<code>.gitlab-ci.yml</code>不要寫成<code>.gitlab-ci.yaml</code>否則無法觸發<br>:::</p><ul><li><strong>原生vairable</strong><ul><li>我們有一些原生的varialbe，像是:</li><li><code>CI_COMMIT_SHORT_SHA</code></li><li><code>CI_PROJECT_DIR</code></li><li>更多參考: <a href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html">https://docs.gitlab.com/ee/ci/variables/predefined_variables.html</a></li></ul></li><li><strong>ci pipeline</strong><ul><li>我們就是先透過gitlab variables設定好要push images的路徑</li><li>透過kaniko做build的動作</li><li>詳細原因可以參考: <a href="https://docs.gitlab.com/ee/ci/docker/using_kaniko.html">https://docs.gitlab.com/ee/ci/docker/using_kaniko.html</a></li></ul></li><li><strong>cd pipeline</strong><ul><li>原本有兩種方式kustomzie來修改deployment的image tag但是argo裡面好像無法使用helm chart的同時又使用kustomize，我猜App of Apps之類的問題</li><li>我測試過如果拿掉helm就可以正常使用kustomize，想要玩玩看可以參考</li><li>在 Argo CD 中，如果你在使用 App of Apps 模式時，嘗試在同一個應用程序中同時使用 Helm 和 Kustomize，可能會遇到以下問題：</li></ul></li></ul><p>工具衝突：Argo CD 可能無法正確解析來自 Kustomize 和 Helm 的配置，因為這兩者有不同的處理邏輯和數據格式。<br>配置管理困難：在同一個應用程序中混合使用這兩種工具可能會導致配置管理變得複雜，增加了維護的難度。</p><ul><li>中文: <a href="https://www.qikqiak.com/post/gitlab-ci-argo-cd-gitops/">https://www.qikqiak.com/post/gitlab-ci-argo-cd-gitops/</a></li><li>原文: <a href="https://medium.com/@andrew.kaczynski/gitops-in-kubernetes-argo-cd-and-gitlab-ci-cd-5828c8eb34d6">https://medium.com/@andrew.kaczynski/gitops-in-kubernetes-argo-cd-and-gitlab-ci-cd-5828c8eb34d6</a></li><li>github: <a href="https://github.com/cnych/gitops-webapp-demo">https://github.com/cnych/gitops-webapp-demo</a></li><li>這裡的做法是參考另一種作法使用<code>envsubst</code>來複寫整個<code>values.yaml</code>檔案，envsubst是linux原生的指令</li></ul><blockquote><p><code>.gitlab-ci.yml</code></p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 我想要先組成 push 用的 harbor-url/&lt;image-name&gt;:&lt;sha&gt;</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">IMAGE_TAG:</span> <span class="string">$CI_COMMIT_SHORT_SHA</span>   <span class="comment"># commit sha 作為 image tag\</span></span><br><span class="line">  <span class="attr">CI_IMAGE_FILE:</span> <span class="string">$CI_REGISTRY$CI_REGISTRY_IMAGE_FILE:$CI_COMMIT_SHORT_SHA</span>   <span class="comment"># 目標是組成 push image 用的路徑 harbor-url/&lt;image-name&gt;:&lt;sha&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build-file</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 這邊我使用kaniko進行build image and push image動作</span></span><br><span class="line"><span class="comment"># Every job we done, GitLab Runner will delete the container. So we need to push the image into registry</span></span><br><span class="line"><span class="attr">build-file:</span> <span class="comment"># &lt;= can change the name you want </span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build-file</span> <span class="comment">#&lt;= should as same as stages below </span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gcr.io/kaniko-project/executor:v1.9.0-debug</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/kaniko/.docker</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;&#123;\&quot;auths\&quot;:&#123;\&quot;$CI_REGISTRY\&quot;:&#123;\&quot;username\&quot;:\&quot;$CI_REGISTER_USER\&quot;,\&quot;password\&quot;:\&quot;$CI_REGISTER_PASSWORD\&quot;&#125;&#125;&#125;&quot;</span> <span class="string">&gt;</span> <span class="string">/kaniko/.docker/config.json</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/kaniko/executor</span></span><br><span class="line">      <span class="string">--context</span> <span class="string">&quot;$&#123;CI_PROJECT_DIR&#125;&quot;</span></span><br><span class="line">      <span class="string">--dockerfile</span> <span class="string">&quot;$&#123;CI_PROJECT_DIR&#125;/File-Server/Dockerfile&quot;</span></span><br><span class="line">      <span class="string">--destination</span> <span class="string">&quot;$&#123;CI_IMAGE_FILE&#125;&quot;</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">daniyalj/alpine-envsub:v1</span> <span class="comment"># cnych/kustomize:v1.0 (if using kustomize)</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">origin</span> <span class="string">https://$&#123;CI_USERNAME_GIT&#125;:$&#123;CI_PASSWORD_GIT&#125;@git.prlab.io/kioxia/kioxia-project.git</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;gitlab-ci@git.k8s.local&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;GitLab CI/CD&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">http.sslVerify</span> <span class="literal">false</span> </span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="comment"># Works: use envsub change the values files. </span></span><br><span class="line">    <span class="comment">## work1: logging-helm, edit kustomize file </span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">-B</span> <span class="string">master</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$&#123;CI_PROJECT_DIR&#125;/manifests</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">export</span> <span class="string">IMAGE_TAG=$IMAGE_TAG</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">envsubst</span> <span class="string">&lt;</span> <span class="string">./customize-template/deployment.yaml</span> <span class="string">&gt;</span> <span class="string">./deployment.yaml</span></span><br><span class="line">    <span class="comment">## work2: logging-helm, edit kustomize file </span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$&#123;CI_PROJECT_DIR&#125;/manifests</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">envsubst</span> <span class="string">&lt;</span> <span class="string">./values/customize-template/values-file.yaml</span> <span class="string">&gt;</span> <span class="string">./values/values-file.yaml</span></span><br><span class="line">  <span class="comment"># If your commit message contains [ci skip] or [skip ci], using any capitalization, </span></span><br><span class="line">  <span class="comment"># the commit will be created but the pipeline will be skipped.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-am</span> <span class="string">&#x27;[skip ci] K8s Deploy CICD Done&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="補充-ArgoCD-CLI-操作">補充 ArgoCD CLI 操作</h1><p><a href="https://argo-cd.readthedocs.io/en/release-1.8/cli_installation/#linux">https://argo-cd.readthedocs.io/en/release-1.8/cli_installation/#linux</a></p><blockquote><p>安裝CLI</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linus </span></span><br><span class="line">VERSION=$(curl --silent <span class="string">&quot;https://api.github.com/repos/argoproj/argo-cd/releases/latest&quot;</span> | grep <span class="string">&#x27;&quot;tag_name&quot;&#x27;</span> | sed -E <span class="string">&#x27;s/.*&quot;([^&quot;]+)&quot;.*/\1/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/<span class="variable">$VERSION</span>/argocd-linux-amd64</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/argocd</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>登入</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find pod</span></span><br><span class="line">kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | <span class="built_in">cut</span> -d<span class="string">&#x27;/&#x27;</span> -f 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># login 要使用ip位置登入 192.168.0.100:30090</span></span><br><span class="line">argocd login &lt;ARGOCD_SERVER_IP&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="補充-ArgoCD-Auto-Sync">補充 ArgoCD Auto Sync</h1><p><a href="https://argo-cd.readthedocs.io/en/release-1.8/user-guide/auto_sync/">https://argo-cd.readthedocs.io/en/release-1.8/user-guide/auto_sync/</a></p><h2 id="Automated-Sync">Automated Sync</h2><ul><li>目前git manifest有更新的話並不會自動做更新動作</li><li>因此如果希望manifest有所改變的時候就自動部屬可以有以下設定</li><li>An automated sync will only be performed if the application is <code>OutOfSync</code>.</li><li>Applications in a <code>Synced</code> or <code>error</code> state will not attempt automated sync.</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">syncPolicy:</span></span><br><span class="line">    <span class="attr">automated:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Automatic-Pruning">Automatic Pruning</h2><ul><li>當argo cd 檢測到資源已經不再git中的定義時，並不會自動刪除原本資源</li><li>如果沒有額外設定，要自己去手動刪除原本的資源</li><li>但是可以通過以下命令，啟用prun作為自動同步的一部分自動發生</li></ul><blockquote><p>CRD Application設定</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">syncPolicy:</span></span><br><span class="line">    <span class="attr">automated:</span> </span><br><span class="line">  <span class="attr">prune:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Automatic-Self-Healing">Automatic Self-Healing</h2><h1 id="補充-ArgoCD-一些best-practice">補充 ArgoCD 一些best practice</h1><p><a href="https://argo-cd.readthedocs.io/en/release-1.8/user-guide/best_practices/">https://argo-cd.readthedocs.io/en/release-1.8/user-guide/best_practices/</a></p><ol><li>argo manifest config code最好和source code分開<ul><li>通常為服務是built 來自不同的Git repo因此應該要單獨deploy不要把所有微服務們的config放在一起</li><li>因為有時候微服務應用有很多不同版本組成</li><li>因為有時候commit會導致無限trigger部屬工作在這種情況可以透過分開的repo來放config changes避免這種事情發生</li></ul></li><li>為指令留空間<ul><li>如果想要讓<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">HPA</a>留有設定空間就不要設定relicas in Git</li></ul></li></ol><h1 id="補充-ArgoCD-重新設定密碼">補充 ArgoCD 重新設定密碼</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 先登入然後輸入使用者名稱與密碼</span><br><span class="line">$ argocd login 192.168.0.100:30090</span><br><span class="line"># 然後就可以執行重新設定密碼的指令</span><br><span class="line">$ argocd account update-password</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> ArgoCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes - 關於 Service 的介紹</title>
      <link href="/posts/k8s-service/"/>
      <url>/posts/k8s-service/</url>
      
        <content type="html"><![CDATA[<h1 id="介紹">介紹</h1><p>Kubernetes 中的 Service 是一種資源，說他是資源是因為它是一種 Kubernetes 提供的 API 物件，通過描述和管理網路訪問來控制 Pods 的互動和連接方式。而Service用於<em>將一組執行相同工作的容器 (Pods) 暴露為一個網路服務</em>。</p><p><strong>其存在的主要目的是提供一個穩定的網路介面</strong></p><p>讓應用程序或其他 Pods 能夠方便地相互通訊，即使 Pod 隨著時間可能會發生變化（例如重新啟動、擴展或縮減）。更具體一點，Service可以達到以下功能：</p><ol><li><strong>提供固定的訪問入口</strong>：Pods 是動態的，IP 可能會變動，但 Service 會提供一個固定的 IP 和 DNS 名稱，讓其他服務或應用可以持續連接，不受 Pods IP 變化的影響。</li><li><strong>負載平衡</strong>：當多個 Pods 提供相同的功能時，Service 會自動分配流量給這些 Pods，確保請求被平均分配，避免單個 Pod 承受過多壓力。</li><li><strong>解耦</strong>：Service 將應用程序的<code>網路流量</code>相關設定 與 Pod 的<code>具體運行</code>位置分離。簡單來說，你設定好Service之後，不管你擴展、縮減或是重新部署Pods，Service 都會自動根據你的設定去連接到正確的Pods，不需要再去修改Service的任何設定。</li></ol><p>有不同類型的 Service，例如：</p><ul><li><strong>ClusterIP</strong>：只在 Kubernetes 集群內部可訪問，用於內部服務間的通訊，這是默認的 Service 類型。<ul><li>使用時間：當你的應用程序只需要在<code>集群內部</code>訪問時。</li></ul></li><li><strong>NodePort</strong>：在每個 Node（節點）上開放一個特定的端口，讓外部流量可以進入。<ul><li>使用時機：當你的應用程序需要從<code>集群外部</code>訪問時。</li></ul></li><li><strong>LoadBalancer</strong>：當你使用 LoadBalancer 類型的 Service 時，它會利用雲服務提供商（例如 AWS、GCP、Azure 等）的外部負載平衡器，將外部請求分配到 Kubernetes 集群中的多個節點（Nodes）上。每個節點上的 Kube-proxy 再將流量分發到與該 Service 關聯的 Pods，這樣可以實現外部請求的負載均衡，確保高可用性和分擔流量壓力。<ul><li>使用時機：客戶端發出多個請求，雲提供商的負載平衡器會根據流量狀況，將請求分配到集群中的不同 Nodes。</li></ul></li><li><strong>ExternalName</strong>：他的作用是將Kubernetes集群內部的請求根據Service的名稱轉發到外部的DNS名稱。當你創建一個 ExternalName 類型的 Service 時，Kubernetes 會在內部建立一個 DNS 記錄，將該 Service 名稱映射到你指定的外部 DNS 名稱。當集群中的 Pods 或其他服務嘗試訪問這個 Service 時，請求會被自動轉發到指定的外部域名。<ul><li>使用時機：假設你創建了一個名為 <code>my-service</code> 的 ExternalName Service，並將它指向 <code>api.external-service.com</code>，那麼在集群內的任何 Pod 或服務訪問 <code>my-service</code> 時，實際上會連接到 <code>api.external-service.com</code>。</li></ul></li></ul><h1 id="建立-Service">建立 Service</h1><h2 id="透過YAML">透過YAML</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim svc.yaml</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 指定這個 Service 要適用到哪些 Pod，依據label: app=MyApp來選取</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 要作port-forward的設定，指定Pod的Port對應到的Node的Port</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f svc.yaml</span><br></pre></td></tr></table></figure><h2 id="透過Expose">透過Expose</h2><p>這種方法是將Pod expose給外部使用者，相當於創建一個Service。創建的Service會自動將該Pod的label填入selector欄位，<code>name</code>欄位則輸入Service的名稱，<code>type</code>是Service的類別。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl expose po &lt;pod-name&gt; --name=&lt;svc-name&gt; --<span class="built_in">type</span>=&lt;type-of-svc&gt;</span><br></pre></td></tr></table></figure><h1 id="Service-的差異">Service 的差異</h1><p>Service依照不同功能及使用場景，主要有三種Service：NodePort, ClusterIP及LoadBlancer</p><h2 id="NodePort">NodePort</h2><div class="note info flat"><p><strong>NodePort的目標是將Pod expose給外部使用者</strong></p></div><p><img src="https://i.imgur.com/O93Gx0T.png" alt=""><br><img src="https://i.imgur.com/aPpMFXs.png" alt=""></p><p>根據上圖可以看到</p><ol><li>在Node上開放一個特定的Port，讓外部流量可以進入</li><li>再透過Service將流量分發到Pods上</li></ol><blockquote><p>NodePort 的 YAML 設定如下</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ vim NP-Svc.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodeport-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targetPort:</span> <span class="number">80</span>    <span class="comment"># Pod的port</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>          <span class="comment"># cluster IP 的 port</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30008</span> <span class="comment"># 指定node對外的port</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br></pre></td></tr></table></figure><ul><li><code>targetPort</code>: 指定Pod上允許外部資源存取的Port Number，Service 會將請求導向到Pod的這個Port，如果在YAML裡面沒有指定<code>targetPort</code>，則預設會使用<code>port</code>的值。</li><li><code>port</code>: 這個端口定義了<em>集群內部如何訪問該服務</em>，當 Pod 或其他服務嘗試通過該服務的名字來訪問時，這就是它們使用的端口號。如果設置 port: 80，那麼集群內的其他應用可以通過服務名和 port 80 來訪問該服務。</li><li><code>nodePort</code>: 指定節點(Node)要開放哪一個Port，NodePort範圍是30000 ~ 32767，若NodePort欄位沒有給定，K8s會自動assign一個範圍內的Port為NodePort。當你<em>訪問 Kubernetes 節點的這個端口時，Kubernetes 會自動將流量轉發到該服務的後端 Pod 上</em>。nodePort 允許你從集群外部通過節點的 IP 和該端口來訪問服務。</li></ul><h2 id="ClusterIP">ClusterIP</h2><div class="note info flat"><p><strong>ClusterIP的目標是將Pod expose給集群內部使用者</strong></p></div><p><img src="https://i.imgur.com/kE39LrU.png" alt=""><br><img src="https://i.imgur.com/JwqGi09.png" alt=""></p><p>ClusterIP是 default的Service Type，它只提供集群內部的服務，集群內的Pod都可以透過它互相訪問，集群外部則無法訪問它。ClusterIP的應用場景通常是<em>保護某些資料不被外部存取</em>，例如一個Web Application有back-end和front-end，我只想將front-end Pod expose出去，但又想back-end和front-end可以溝通，這時就可以用到ClusterIP Service。</p><p>但是如果你使用的是前後端分離的話，<em>前端應用（通常是一個獨立的 Web 應用）和後端 API 是獨立部署和運行的</em>。因此，瀏覽器在這種情況下直接與後端 API 進行通訊，而不經過 Kubernetes 集群內的前端 Pods。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ vim CIP-Svc.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">clusterip-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="comment"># nodePort: 30008 # 就沒有node port</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br></pre></td></tr></table></figure><h2 id="LoadBalancer">LoadBalancer</h2><div class="note info flat"><p><strong>LoadBalancer的目標是讓流量分配到多個節點上多個Pods上</strong></p></div><p><img src="https://i.imgur.com/3dGxLE7.png" alt=""></p><p>在 Kubernetes 中，LoadBalancer 用於自動創建一個雲提供商的外部負載均衡器（如 AWS ELB、GCP LB）來將外部流量導向服務的後端 Pod。它可以幫助你<em>將外部請求分配到 Kubernetes 集群中的多個節點和 Pod 上，實現高可用性和負載均衡</em>。儘管 LoadBalancer 可以幫助實現自動的外部流量負載均衡，但在很多情況下，團隊會選擇不使用它，原因包括以下幾點：</p><p><strong>成本高</strong><br>公有雲負載均衡器（如 AWS ELB 或 GCP Load Balancer）通常會按小時或流量計費。對於每個應用使用一個 LoadBalancer 類型的服務，隨著服務數量增多，成本會非常高，特別是在生產環境中部署大量微服務時。</p><p><strong>受限於雲供應商的配置</strong><br>且通常只支持 L4 層（TCP/UDP）(應用程式端口級別)的負載均衡。它不能像自定義的反向代理（如 NGINX 或 Traefik）一樣靈活配置 HTTP 層的負載均衡、路由規則或其他更細緻的流量控制策略。</p><ul><li>L4 層負載均衡（傳輸層）: L4 負載均衡基於 TCP（傳輸控制協議）或 UDP（用戶數據報協議）協議來進行流量的分配，它只在網絡層的 IP 地址和端口號的基礎上進行決策，並不理解應用層的數據。</li><li>與 L4 不同，L7 層負載均衡可以處理應用層的數據，並基於這些數據進行更細緻的路由和控制。例如，L7 負載均衡器能夠解析 HTTP/HTTPS 流量，並根據具體的應用層信息（如 URL 路徑、HTTP headers、Cookies）進行決策。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #86 Partition List - 刷題之旅</title>
      <link href="/posts/leetcode-86-Partition-List/"/>
      <url>/posts/leetcode-86-Partition-List/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/5w4CjnL.png" alt=""></p><p>有一個linked list，要求將linked list中小於x的node放在前面，大於等於x的node放在後面。</p><h1 id="2-解法">2 解法</h1><p>這題不難，可以直接使用兩個linked list，一個是小於x的linked list，一個是大於等於x的linked list，最後再將兩個linked list合併即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], x: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 建立兩個虛擬頭節點，分別用於小於x的節點和大於等於x的節點</span></span><br><span class="line">        small_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        large_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 當前指針指向小鏈表和大鏈表的頭節點</span></span><br><span class="line">        small = small_head</span><br><span class="line">        large = large_head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍歷原鏈表</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val &lt; x:</span><br><span class="line">                <span class="comment"># 添加節點到小於x的鏈表</span></span><br><span class="line">                small.<span class="built_in">next</span> = cur</span><br><span class="line">                small = small.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 添加節點到大於等於x的鏈表</span></span><br><span class="line">                large.<span class="built_in">next</span> = cur</span><br><span class="line">                large = large.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 將大鏈表的最後一個節點的 next 設置為 None，避免循環鏈表</span></span><br><span class="line">        large.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 將小於x的鏈表的尾部連接到大於等於x的鏈表的頭部</span></span><br><span class="line">        small.<span class="built_in">next</span> = large_head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> small_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>一開始我傻傻的，沒有think out of the box，我是遍歷一個個節點，發現要換位置的時候進行處理，沒想到讓整個串接過程變得非常複雜，結果沒想到使用兩個linked-list就可以處理了，但是相對的這個空間複雜度是O(n)，如果題目限制空間複雜度是O(1)的話，那麼這個解法就不適用了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #61 Rotate List - 刷題之旅</title>
      <link href="/posts/leetcode-61-Rotate-List/"/>
      <url>/posts/leetcode-61-Rotate-List/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/iWIcvBe.png" alt=""><br><img src="https://i.imgur.com/c8EPzv2.png" alt=""></p><p>給定一個鍊錶，將鍊錶向右旋轉 k 步，其中 k 是非負數。</p><h1 id="2-解法">2 解法</h1><p>看到這個題目的時候，有想到如果今天k很大，這個linked list多少步驟會回到原本的樣子？基本上是當 k 是 鍊錶長度的倍數時，鍊錶會回到原本的樣子，因此我們可以先計算出鍊錶的長度，然後取餘數，這樣就可以得到我們要旋轉的步數。</p><p><em>當<code>last.next</code>是空的時候，表示觸底</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先計算長度</span></span><br><span class="line">last, count = head, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (last.<span class="built_in">next</span>): </span><br><span class="line">    count += <span class="number">1</span> </span><br><span class="line">    last = last.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新計算k取餘數</span></span><br><span class="line">k = k % count</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/xOdnlt7.png" alt=""><br>接下來如果k是2，代表最後面的兩個node會被擠到最前面，因此我們主要有兩個步驟：</p><ol><li>找到last，把last跟head連接起來</li><li>找到新的head，把新head的前一個node的next設為None</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到last，把last跟head連接起來</span></span><br><span class="line">last.<span class="built_in">next</span> = head</span><br><span class="line"><span class="comment"># 找到新head的前一個node （從上圖例子為4)</span></span><br><span class="line">tmp = head</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count - k - <span class="number">1</span>):</span><br><span class="line">    tmp = tmp.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把新head的前一個node的next設為None</span></span><br><span class="line">new_head = tmp.<span class="built_in">next</span></span><br><span class="line">tmp.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>完整程式碼為</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Time: O(n)</span></span><br><span class="line"><span class="string">    Space: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">0</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 先計算長度</span></span><br><span class="line">        last, count = head, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (last.<span class="built_in">next</span>): </span><br><span class="line">            count += <span class="number">1</span> </span><br><span class="line">            last = last.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 重新計算 k</span></span><br><span class="line">        k = k % count </span><br><span class="line">        <span class="comment"># 因為 tmp 會更動到 head 所以先處理 last.next </span></span><br><span class="line">        last.<span class="built_in">next</span> = head </span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="comment"># tmp 是要切斷當 head 的節點</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count - k - <span class="number">1</span>):</span><br><span class="line">            tmp = tmp.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重新串起來</span></span><br><span class="line">        ans = tmp.<span class="built_in">next</span></span><br><span class="line">        tmp.<span class="built_in">next</span> = <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題我想了一個小時，我沒有發現 len - k - 1 的方便邏輯，原始方法是透過兩個指標slow, fast去找倒數第k個。這題的重點是要先計算長度，然後取餘數，最後再重新串起來。這題的時間複雜度是 O(n)，空間複雜度是 O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #36 Valid Sudoku - 刷題之旅</title>
      <link href="/posts/leetcode-36-Valid-Sudoku/"/>
      <url>/posts/leetcode-36-Valid-Sudoku/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/XLJzQlX.png" alt=""><br><img src="https://i.imgur.com/BMzY8da.png" alt=""><br><img src="https://i.imgur.com/aTJ341i.png" alt=""></p><p>檢查一個數獨是否合法，合法的數獨滿足以下條件：</p><ol><li>每一行的數字都是1-9，且不重複</li><li>每一列的數字都是1-9，且不重複</li><li>每一個3x3的小格子裡的數字都是1-9，且不重複</li></ol><p><code>注意：不用檢查數獨是否有解，只需要檢查數獨是否合法。</code></p><h1 id="2-解法">2 解法</h1><p>其實思路很簡單，我們看到需要滿足的三個條件，就可以分別實現這三個條件的檢查函數，然後分別檢查即可。</p><p>但是在這之前你會發現這三個條件都有個共通點就是數字不重複，所以我們可以針對此設計一個不重複的檢查函數。<br><em>不重複</em></p><ul><li>透過set的特定把重複的移除，然後比較移除&quot;.&quot;後的長度是否相等即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_unique</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 移除&#x27;.&#x27;的數組</span></span><br><span class="line">    nums = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num != <span class="string">&#x27;.&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) == <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p><em>檢查row</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_row</span>(<span class="params">board</span>):</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> board:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_unique(row):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><em>檢查column</em></p><ul><li>檢查column比較特殊，有使用到zip的技巧</li><li>使用*board它會將可迭代對象中的元素一一傳入函數<ul><li>例如，<code>f(*[row1, row2, row3])</code> 等同於 <code>f(row1, row2, row3)</code>。</li></ul></li><li>簡單來說我們需要取麼個row的第i個元素，因為zip可以把多個list的第i個元素取出來，組合成一個元素<ul><li><code>zip(row1, row2, row3)</code> 就會變成 <code>[(row1[0], row2[0], row3[0]), (row1[1], row2[1], row3[1]), ...]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip 的使用，把多個list的第i個元素取出來，組合成一個元素</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line">zipped = <span class="built_in">zip</span>(list1, list2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(zipped))</span><br><span class="line"><span class="comment"># 輸出：[(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;)]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_column</span>(<span class="params">board</span>):</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">zip</span>(*board):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> check_unique(col):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><em>檢查3x3</em></p><ul><li>你會發現他有個規律，row裡面的資料會是<code>[0:3], [3:6], [6:9]</code>的檢查順序，然後以3個row為一個單位檢查，所以row的index也會是<code>[0, 3, 6]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_square</span>(<span class="params">board</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>):</span><br><span class="line">            square = [board[row][col] <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(i, i+<span class="number">3</span>) <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(j, j+<span class="number">3</span>)]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check_unique(square):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><em>最後就可以合併</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.is_row_valid(board) <span class="keyword">and</span> self.is_col_valid(board) <span class="keyword">and</span> self.is_square_valid(board)</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題目難，沒有高深技巧，但是我認為最難的是:</p><ul><li>column 該怎麼取得？<code>zip(*baord)</code>很重要</li><li>square 該怎麼取得？使用雙層for取得<code>[board[row][col] for row in range(i, i+3) for col in range(j, j+3)]</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Matrix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #30 Substring with Concatenation of All Words - 刷題之旅</title>
      <link href="/posts/leetcode-30-Substring-with-Concatenation-of-All-Words/"/>
      <url>/posts/leetcode-30-Substring-with-Concatenation-of-All-Words/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/mpd2Vqt.png" alt=""><br><img src="https://i.imgur.com/RoBhdsJ.png" alt=""></p><p>會提供words跟s，要求找出s中所有words的連續子串的起始索引。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-一個個慢慢找">2.1 一個個慢慢找</h2><p><img src="https://i.imgur.com/UDWR03T.png" alt=""></p><ul><li>我們從i=0開始檢查，取<code>s[i:i+word_len]</code>叫做word（圖片橘色部分）</li><li>有一個<code>word_dic</code>負責紀錄要求，也就是words中的word的數量</li><li>有一個<code>seen</code>負責紀錄已經看過且是<code>word_dic</code>的word，可以用來與<code>word_dic</code>比較判斷當前的window是否滿足狀況</li></ul><p><em>擴展window的條件</em>：<br><img src="https://i.imgur.com/HmGnG6k.png" alt=""></p><ul><li>基本上擴展window的時機點是透過<code>count</code>的移動來移動window，但是何時要移動<code>count</code>呢？</li><li>當前的word是合法的條件？<ol><li>當前的<code>word</code>是<code>word_dic</code>中的word</li><li>當前的<code>seen[word]</code>小於<code>word_dic[word]</code></li></ol></li><li>word 合法之後要做哪些工作？<ol><li><code>count</code>要+1，count用來計算<code>start</code>的位置以及判斷是否滿足<code>word_dic</code>的數量要求</li></ol></li></ul><p><em>紀錄i的時機</em><br><img src="https://i.imgur.com/GpaWdlF.png" alt=""></p><ul><li>當我們發現滿足<code>count</code>等於<code>len(words)</code>時，代表我們找到了一個合法的window，這時候要紀錄<code>i</code>的位置<ul><li>因為<code>count</code>只會在word合法的時候+1，所以當<code>count</code>等於<code>len(words)</code>時，代表我們找到了一個合法的window，這時候要紀錄<code>start</code>的位置</li></ul></li></ul><p><em>停止當前window的條件是</em>：<br><img src="https://i.imgur.com/43ezuCB.png" alt=""></p><ul><li>何時檢查要停下來？<ol><li>如果<code>word</code>不在<code>word_dic</code>中，或者<code>seen[word]</code>大於<code>word_dic[word]</code>，就要停下來，換下一個<code>i</code>開始檢查<ul><li>舉例來說<code>foofoobar</code>可以組成<code>seen=&#123;foo:2, bar:1&#125;</code>，但是我們要的是<code>word_dic=&#123;foo:1, bar:1&#125;</code></li><li><code>foo</code>的數量已經超過了，所以當前的window不合法，也就是<code>i</code>是不合法的，我們要往下一個開始檢查。</li></ul></li></ol></li><li>停下來後要做哪些事情？<ol><li><code>count</code>要歸零，<code>seen</code>要清空，重新來過</li><li><code>i</code>要+1，開始下一個window的檢查</li></ol></li><li><code>i</code>要檢查到哪裡？<ul><li><code>i</code>要檢查到<code>s</code>的長度減去<code>word_len * words_count</code></li><li>因為如果<code>i</code>到<code>len(s)-word_len * words_count</code>這裡都沒有找到合法的window，那麼後面的window也不可能找到合法的window，因為後面的長度已經不夠湊出<code>words</code>的長度了</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time: O(n*k)</span></span><br><span class="line"><span class="string">- n is the length of s</span></span><br><span class="line"><span class="string">- k is the counts of words, len(words)</span></span><br><span class="line"><span class="string">Space: O(n)</span></span><br><span class="line"><span class="string">- n for seen</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        word_dic = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        word_len, words_count = <span class="built_in">len</span>(words[<span class="number">0</span>]), <span class="built_in">len</span>(words)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 紀錄words中的word數量</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_dic[word] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 一個個判斷當前的i是否可以湊出words</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - word_len * wor)</span><br><span class="line">            <span class="comment"># 換下一個i開始檢查，count要歸零，seen要清空</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            seen = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="comment"># 如果 count (當前滿足的數量) 仍然小於 words_count (words的數量) 那就繼續做直到 非法跳出 或是 count數量湊足了</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; words_count:</span><br><span class="line">                word = s[i+count*word_len:i+(count+<span class="number">1</span>)*word_len]</span><br><span class="line">                seen[word] += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 合法：如果數量小於等於word_dict[word]，就可以繼續</span></span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> word_dict <span class="keyword">and</span> seen[word] &lt;= word_dict[word]: </span><br><span class="line">                    count += <span class="number">1</span>        </span><br><span class="line">                <span class="comment"># 不合法：如果數量超過也不合法</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 如果count等於words_count，代表我們找到了一個合法的window</span></span><br><span class="line">            <span class="keyword">if</span> count == words_count:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-跳躍式尋找">2.2 跳躍式尋找</h2><p><img src="https://i.imgur.com/oVMd00s.png" alt=""><br>我們發現每次檢查的時候都是以<code>word_len</code>為單位去尋找，如果<code>word_len=3</code>我們是不是就可以歸類出以上情況。</p><p><em>以i=0為單位去檢查</em><br><img src="https://i.imgur.com/iABq5iT.png" alt=""></p><ul><li>從上圖可以發現，以三個三個為單位，如果發現滿足，就透過j移動到下一個word</li><li>如果發現當前的word不在<code>word_dic</code>裡面，表示這個<code>start</code>肯定不合格<ul><li>所以我們要移動<code>start</code>到下一個word的位置</li><li>清空<code>seen</code>, <code>count</code>重新開始</li></ul></li></ul><p><img src="https://i.imgur.com/Ls4Gf18.png" alt=""></p><ul><li>如果發現相同word的數量太多時，我們可以透過縮window移除重複的word<ul><li>因為移除window的word，所以移動<code>start</code>到下一個位置</li><li>減少<code>count</code>的數量</li><li>減少<code>seen[first_word_in_window]</code>的數量</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time: O(n*k)</span></span><br><span class="line"><span class="string">- n is the length of s (儘管是跳躍式檢查，基本上每個char都會被檢查一次)</span></span><br><span class="line"><span class="string">- k is the counts of words, len(words) (因為有while迴圈，最壞的狀況是 [b,b,b,b,a,a] 假設 a 只要 1 個，就要先把前面所有的b都移除，所以這個while會執行len(words)次)</span></span><br><span class="line"><span class="string">Space: O(n)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        word_dic = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        word_len, words_count = <span class="built_in">len</span>(words[<span class="number">0</span>]), <span class="built_in">len</span>(words)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 紀錄words中的word數量</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_dic[word] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 以word_len為單位去檢查</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">            count = <span class="number">0</span> </span><br><span class="line">            seen = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            <span class="comment"># 因為我們 i 不像之前從 0~n-word_len*words_count，所以我們需要一個start來協助我們記住起點</span></span><br><span class="line">            start = i</span><br><span class="line">            <span class="comment"># 從 i 開始每次跳 word_len 去檢查</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s) - word_len + <span class="number">1</span>, word_len):</span><br><span class="line">                word = s[j:j+word_len]</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">in</span> word_dic:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    seen[word] += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果加了當前的word導致數量超過了，移動當前的window，把第一個word移除</span></span><br><span class="line">                    <span class="keyword">while</span> seen[word] &gt; word_dic[word]:</span><br><span class="line">                        first_word = s[start:start+word_len]</span><br><span class="line">                        seen[first_word] -= <span class="number">1</span></span><br><span class="line">                        left += word_len</span><br><span class="line">                        count -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 如果count等於words_count，代表我們找到了一個合法的window</span></span><br><span class="line">                    <span class="keyword">if</span> count == words_count: </span><br><span class="line">                        res.append(start)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    seen = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">                    count = <span class="number">0</span></span><br><span class="line">                    start = j + word_len</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題我真的想了很久…真的有Hard的程度，最一開始能想到的是從i開始慢慢往下移動去檢查的，但是會TLE，後來看了解答才知道可以跳躍式的去檢查，這樣就可以避免TLE了。</p><h1 id="參考資料">參考資料</h1><ul><li><a href="https://youtu.be/If4cSYO7z4U?si=9NWPsue3aj9ujlPW">Youtube</a></li><li><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/4277667/simple-sliding-window-solution-beats-99-for-time">LeetCode Solution</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Two Pointer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Hard </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #209 Minimum Size Subarray Sum - 刷題之旅</title>
      <link href="/posts/leetcode-209-Minimum-Size-Subarray-Sum/"/>
      <url>/posts/leetcode-209-Minimum-Size-Subarray-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/jJIujhd.png" alt=""><br>找到一個subarray的和大於等於target，並且這個subarray的長度是最小的。</p><div class="note info flat"><p>subarray是指連續非空的元素。<br>題目要求時間複雜度為O(N)。</p></div><h1 id="2-解法">2 解法</h1><p>因為要找出最小長度，基本上就是找到一組window大小為最小，但是同時滿足&gt;=target的條件。因為<code>nums</code>是無序的，所以一定是要遍歷一次，因此時間複雜度是O(N)。<br>老樣子，Sliding Window 就是需要定義出以下狀況：</p><ol><li>何時停止擴展？<ul><li>我們希望當前的window &gt;= target時，停止擴展</li><li>在還沒超過target之前，我們會一直擴展window</li><li>right 指針會一直往右移動</li></ul></li><li>處理當前window的時機？<ul><li>因為接下來我們要開始收縮window找找看有沒有更小的window</li><li>計算當前window的總和數，以及當前window的長度是否有小於最小長度</li></ul></li><li>何時收縮window？<ul><li>如果發現當前window的總和數 &gt;= target，就開始收縮window</li><li>移動left指針，並且更新當前window的總和數</li><li>當當前window的總和數 &lt; target，就停止收縮window</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(N)</span></span><br><span class="line"><span class="string">    space: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen2</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, min_len = <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        tot = <span class="number">0</span></span><br><span class="line">        <span class="comment"># right 指針會一直往右移動 擴展window</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            tot += nums[r]</span><br><span class="line">            <span class="comment"># 一但發現&gt;=target，就開始收縮window尋找最佳解</span></span><br><span class="line">            <span class="keyword">while</span> tot &gt;= target:</span><br><span class="line">                <span class="comment"># 更新最小長度</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, r - l + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 縮小長度，扣掉不在windows內的數字</span></span><br><span class="line">                tot -= nums[l]</span><br><span class="line">                <span class="comment"># 移動左指針</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_len <span class="keyword">if</span> min_len != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">0</span>        </span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題不難，但是我卡在如何要擴展window的時機，因為當初使用while來寫，但是這題不應該使用while，因為他不是two pointer從頭跟尾來縮window，他是two pointer從左到右來擴展跟收縮window。要檢查到right pointer觸底為止，所以不需要while。你也不用思考何時要right+1，因為for會處理掉這件事情。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Two Pointer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo - Butterfly 版本的日曆嵌入教學</title>
      <link href="/posts/hexo-calendar/"/>
      <url>/posts/hexo-calendar/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>之前一直想用，但中途都會失敗，今天終於成功了！這篇文章主要是記錄如何在Hexo的文章中嵌入日曆。</p><h1 id="步驟">步驟</h1><h2 id="1-安裝插件">1. 安裝插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save git://github.com/howiefh/hexo-generator-calendar.git</span><br></pre></td></tr></table></figure><h2 id="2-下載並修改js檔案">2. 下載並修改js檔案</h2><p>下載以下兩個檔案</p><ul><li><a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/calendar.js">calendar.j</a></li><li><a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/languages.js">languages.js</a></li></ul><p>我自己是保存到<code>source\self\</code>目錄底下：<br><img src="https://i.imgur.com/NtgyuXU.png" alt=""></p><p><em>接下來修改js檔案添加以下內容在最後底部的部分</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">$(<span class="string">&quot;#calendar&quot;</span>).<span class="title function_">aCalendar</span>(<span class="string">&quot;zh-TW&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/jncQLwa.png" alt=""></p><div class="note warning flat"><p>注意如果你有兩個版本的切換，是按照這篇文章<a href="%5Cposts%5Chexo-butterfly-lang-switch">Hexo - Butterfly 版本的語言切換功能設置</a>。<br>js檔案要存放在<code>source-en\self</code>底下，並且我們要修改兩個地方：<br><img src="https://i.imgur.com/hNth5yK.png" alt=""></p></div><h2 id="3-設定-config-yml">3. 設定_config.yml</h2><p>前往<code>config-butterfly.yml</code>，按照順序添加以下內容：<br><em>一定要下載jquery，不然日曆會無法顯示：</em></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/calendar.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/languages.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Nat11xE.png" alt=""></p><div class="note warning flat"><p>注意如果使雙語切換版本請修改以下內容要添加<code>en</code>：<br><img src="https://i.imgur.com/z2Jott5.png" alt=""></p></div><p>然後添加以下內容如下圖，這用來控制是否顯示日曆：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">card_calendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/MRp0QgO.png" alt=""></p><h2 id="4-寫入css樣式">4. 寫入css樣式</h2><p>新建<code>calendar.styl</code>文件，保存到<code>themes\butterfly\source\css_layout</code>目錄底下，可以複製以下代碼：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#calendar</span></span><br><span class="line">  <span class="selector-tag">a</span></span><br><span class="line">    <span class="attribute">text-decoration</span> none</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-head</span></span><br><span class="line">  <span class="attribute">position</span> relative</span><br><span class="line">  <span class="attribute">height</span> <span class="number">20px</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">8px</span> <span class="number">6px</span> <span class="number">2px</span> <span class="number">6px</span></span><br><span class="line">  <span class="attribute">margin-bottom</span> <span class="number">15px</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-prev</span>,<span class="selector-class">.cal-next</span></span><br><span class="line">  <span class="attribute">position</span> absolute</span><br><span class="line">  <span class="attribute">top</span> <span class="number">9px</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">9px</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">10px</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">3px</span> <span class="number">4px</span></span><br><span class="line">  <span class="attribute">border</span> <span class="number">1px</span> solid transparent</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#333</span></span><br><span class="line">  <span class="attribute">outline</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-prev</span></span><br><span class="line">  <span class="attribute">left</span> <span class="number">8px</span></span><br><span class="line">  <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="attribute">border-right</span> <span class="number">9px</span> solid <span class="number">#333</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-next</span></span><br><span class="line">  <span class="attribute">right</span> <span class="number">8px</span></span><br><span class="line">  <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="attribute">border-left</span> <span class="number">9px</span> solid <span class="number">#333</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-prev</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.cal-next</span><span class="selector-pseudo">:before</span></span><br><span class="line">  <span class="attribute">content</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attribute">display</span> block</span><br><span class="line">  <span class="attribute">width</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">height</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">border-top</span> <span class="number">5px</span> solid transparent</span><br><span class="line">  <span class="attribute">border-bottom</span> <span class="number">5px</span> solid transparent</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-title</span></span><br><span class="line">  <span class="attribute">width</span> <span class="number">120px</span></span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span> auto</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#333</span></span><br><span class="line">  <span class="attribute">font</span> bold <span class="number">14px</span>/<span class="number">18px</span> Arial</span><br><span class="line">  <span class="attribute">text-align</span> center</span><br><span class="line">  <span class="selector-tag">a</span></span><br><span class="line">    <span class="attribute">border</span> <span class="number">1px</span> solid transparent</span><br><span class="line">    <span class="attribute">color</span> <span class="number">#f76b61</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">td</span></span><br><span class="line">  <span class="attribute">border</span> none</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span></span><br><span class="line">  <span class="attribute">border-collapse</span> collapse</span><br><span class="line">  <span class="attribute">border-spacing</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">table-layout</span> fixed</span><br><span class="line">  <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">  <span class="attribute">margin</span> <span class="number">0</span></span><br><span class="line">  <span class="selector-tag">th</span></span><br><span class="line">    <span class="attribute">background</span> white</span><br><span class="line">    <span class="attribute">color</span> black</span><br><span class="line">    <span class="attribute">font-weight</span> <span class="number">900</span> <span class="meta">!important</span></span><br><span class="line">  <span class="selector-tag">tbody</span></span><br><span class="line">    <span class="selector-tag">a</span></span><br><span class="line">      <span class="attribute">background-color</span> <span class="number">#f76b61</span></span><br><span class="line">      <span class="attribute">color</span> white</span><br><span class="line">      <span class="attribute">display</span> block</span><br><span class="line">      <span class="attribute">font-weight</span> <span class="number">700</span></span><br><span class="line">      <span class="attribute">border</span> <span class="number">1px</span> solid white</span><br><span class="line">    <span class="selector-class">.cal-today</span></span><br><span class="line">      <span class="attribute">background-color</span> <span class="number">#ffdfdd</span></span><br><span class="line">      <span class="attribute">color</span> <span class="number">#f76b61</span></span><br><span class="line">  <span class="selector-class">.cal-gray</span></span><br><span class="line">    <span class="attribute">color</span> <span class="number">#ddd</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">td</span></span><br><span class="line">  <span class="attribute">font-weight</span> normal</span><br><span class="line">  <span class="attribute">line-height</span> <span class="number">2.5625</span></span><br><span class="line">  <span class="attribute">padding</span> <span class="number">0</span></span><br><span class="line">  <span class="attribute">text-align</span> center</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal-title</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.cal-prev</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.cal-next</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-class">.cal-foot</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-class">.cal-foot</span><span class="selector-pseudo">:focus</span></span><br><span class="line">  <span class="attribute">cursor</span> pointer</span><br><span class="line">  <span class="attribute">background-color</span> transparent</span><br><span class="line">  <span class="attribute">cursor</span> pointer</span><br><span class="line">  <span class="attribute">color</span> <span class="number">#42d3d8</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">tbody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-class">.cal</span> <span class="selector-tag">tbody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span></span><br><span class="line">  <span class="attribute">background-color</span> <span class="number">#ffdfdd</span></span><br><span class="line">  <span class="attribute">color</span> <span class="number">#fff</span></span><br><span class="line">  <span class="attribute">cursor</span> pointer</span><br></pre></td></tr></table></figure><h2 id="5-建立pug文件">5. 建立pug文件</h2><p>新建<code>card_calendar.pug</code>文件，保存到<code>themes/butterfly/layout/includes/widget/card_calendar.pug</code>目錄底下，可以複製以下代碼：<br>第一行是判斷是否顯示日曆，第二行是日曆的標題，第三行是日曆的內容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_calendar.enable </span><br><span class="line">  .card-widget.card-calendar</span><br><span class="line">    .card-content</span><br><span class="line">      .item-headline</span><br><span class="line">        i.far.fa-calendar-alt(aria-hidden=&quot;true&quot;)</span><br><span class="line">        span= _p(&#x27;aside.card_calendar&#x27;)</span><br><span class="line">      div.widget-wrap</span><br><span class="line">      div#calendar.widget</span><br></pre></td></tr></table></figure><p>然後我們要塞入我們製作的pug文件到<code>themes/butterfly/layout/includes/widget/index.pug</code>，塞入的順序會決定日曆的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!=partial(&#x27;includes/widget/card_calendar&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/pBQ8Gy1.png" alt=""></p><h2 id="6-新增日歷語言">6. 新增日歷語言</h2><p>打開<code>themes/butterfly/languages/zh-CN.yml</code>，添加以下內容（如果你使用雙語，也要記得在<code>en.yml</code>添加英文的版本）：<br><img src="https://i.imgur.com/2z0Ilxm.png" alt=""></p><h1 id="完成">完成</h1><p>這樣就完成拉！可以看到每一天你有po文的紀錄<br><img src="https://i.imgur.com/sbWarLh.png" alt=""></p><h1 id="參考資料">參考資料</h1><ul><li><a href="https://www.nightb.cn/archives/tian-jia-ri-li----hexomei-hua">添加日历——hexo美化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #392 Is Subsequence - 刷題之旅</title>
      <link href="/posts/leetcode-392-Is-Subsequence/"/>
      <url>/posts/leetcode-392-Is-Subsequence/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/oEHkhiv.png" alt=""></p><p>這題很easy，就是要找出<code>s</code>是否為<code>t</code>的subsequence。</p><h1 id="2-解法">2 解法</h1><p>我的想法一開始很簡單，two pointer從同一個起點0出發，如果相同，兩個pointer都往下走一步，如果不同，只有<code>t</code>的pointer往下走一步。如果<code>s</code>的pointer走到底，表示是subsequence，否則不是。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i == <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure><p>有另一個寫法也很特別，我以s為主，for迴圈iterate每個char在s裡面的。然後去判斷char是否在t裡面，如果有，就找出該char在t的位置<code>idx</code>，然後t變成<code>t[idx+1:]</code>，因為<code>t[:idx]</code>之前已經不需要了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> t:</span><br><span class="line">            idx = t.find(char)</span><br><span class="line">            t = t[idx+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題目難，很快就想出來了，只差在怎麼把程式碼寫得漂亮些。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Two Pointer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Two Pointer </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #15 3Sum - 刷題之旅</title>
      <link href="/posts/leetcode-15-3Sum/"/>
      <url>/posts/leetcode-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/fwnuAJm.png" alt=""></p><p>找到所有可以使三個數字的和為零的不重複組合。</p><h1 id="2-解法">2 解法</h1><p>看到不重複，腦子第一個冒出來是set。應該要把所有的組合都放進去，然後再轉成list。</p><p>而這題是two pointer卻要找3個數字的和為0，而two pointer使用的前提最好是==排序==過的數組。我們可以透過固定一個數字，然後使用two pointer的方式找到另外兩個數字。</p><h2 id="2-1-Hash-Set">2.1 Hash Set</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">==== Step <span class="number">1</span> ====</span><br><span class="line"><span class="comment"># nums 排序過</span></span><br><span class="line"><span class="comment"># i 是固定的數值</span></span><br><span class="line"><span class="comment"># l, r 分別是 left pointer 和 right pointer</span></span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  i  l        r</span><br><span class="line"><span class="comment"># 因為還太小，我們透過移動l來使總合變大</span></span><br><span class="line">nums[i] + nums[l] + nums[r] = -<span class="number">3</span></span><br><span class="line"></span><br><span class="line">==== Step <span class="number">2</span> ====</span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  i     l     r</span><br><span class="line"><span class="comment"># 因為還太小，我們透過移動l來使總合變大</span></span><br><span class="line">nums[i] + nums[l] + nums[r] = -<span class="number">3</span></span><br><span class="line"></span><br><span class="line">==== Step <span class="number">3</span> ====</span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  i       l   r</span><br><span class="line"><span class="comment"># 因為還太小，我們透過移動l來使總合變大</span></span><br><span class="line">nums[i] + nums[l] + nums[r] = -<span class="number">2</span></span><br><span class="line"></span><br><span class="line">==== Step <span class="number">4</span> ====</span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  i         l r</span><br><span class="line"><span class="comment"># 因為還太小，我們透過移動l來使總合變大</span></span><br><span class="line">nums[i] + nums[l] + nums[r] = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">==== Step <span class="number">5</span> ====</span><br><span class="line"><span class="comment"># 觸底了...都還沒找到，表示當前的i無法找到解</span></span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  i           r</span><br><span class="line">              l</span><br><span class="line"></span><br><span class="line">nums[i] + nums[l] + nums[r] = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>基本上從上面的程式碼就可以寫出以下程式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = <span class="built_in">set</span>() <span class="comment"># 存放所有的組合 避免重複</span></span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        target = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 固定i </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r: </span><br><span class="line">                tot = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> tot == target:</span><br><span class="line">                    ans.add((nums[i], nums[l], nums[r]))</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> tot &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans) <span class="comment"># 轉成list</span></span><br></pre></td></tr></table></figure><h2 id="2-2-List">2.2 List</h2><p>如果我們今天不想使用set，我們就要避免重複的組合，通常重複的組合怎麼出現的？如果我們今天的數組是<code>[-4,-1,-1,-1,1,2]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">==== Step <span class="number">1</span> ====</span><br><span class="line"><span class="comment"># 今天換下一個i</span></span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">     i  l     r</span><br><span class="line">nums[i] + nums[l] + nums[r] = <span class="number">0</span> <span class="comment"># [-1, -1, 2] 找到</span></span><br><span class="line"></span><br><span class="line">==== N Step ====</span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">       i  l    r</span><br><span class="line"><span class="comment"># 當我們發現l與上一個l是一樣的時候，我們就要跳過</span></span><br><span class="line">nums[i] + nums[l] + nums[r] = <span class="number">0</span> <span class="comment"># [-1, -1, 2] 找到</span></span><br><span class="line"></span><br><span class="line">==== N+<span class="number">1</span> Step ====</span><br><span class="line">[-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">       i     l r</span><br><span class="line"><span class="comment"># l 應該從與上一個不同時開始</span></span><br><span class="line">nums[i] + nums[l] + nums[r] = <span class="number">2</span></span><br></pre></td></tr></table></figure><p><em>基本上從上面的程式碼就可以寫出以下程式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># i 也是相同的意思，如果與上一個相同就跳過避免重複</span></span><br><span class="line">        <span class="keyword">if</span> idx &gt; <span class="number">0</span> <span class="keyword">and</span> nums[idx] == nums[idx-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        left, right = idx + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            total = nums[idx] + nums[left] + nums[right]</span><br><span class="line">            <span class="keyword">if</span> total &gt; <span class="number">0</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> total &lt; <span class="number">0</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[idx], nums[left], nums[right]])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 使用list不重複的關鍵在，如果left下一個與上一個相同要繼續往下走否則會重複</span></span><br><span class="line">                <span class="keyword">while</span> nums[left] == nums[left-<span class="number">1</span>] <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題我當初卡的點有兩個</p><ul><li>怎麼把set換成list，沒想到<code>list(set)</code>就可以了</li><li>怎麼避免重複的組合，我沒想到要檢查i跟l是否與上一個相同，如果相同要一直往下走。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Two Pointer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #11 Container With Most Water - 刷題之旅</title>
      <link href="/posts/leetcode-11-Container-With-Most-Water/"/>
      <url>/posts/leetcode-11-Container-With-Most-Water/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/qGkovKU.png" alt=""><br><img src="https://i.imgur.com/ELebxY6.png" alt=""></p><p>給定一個非負整數的數組<code>height</code>，每個元素代表一個垂直線，並且每個線的寬度都是1。找出兩條線，使得他們和x軸組成的容器可以容納最多的水。<br>（注意不可以傾斜容器）</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-暴力解法">2.1 暴力解法</h2><p>這題的暴力破解是O(N)基本上就是遍歷所有的組合，找出最大的容器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(height[i], height[j]) * (j-i))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="2-2-Speed-O-N">2.2 Speed O(N)</h2><p>從知道這是<em>two pointer的時候就要有個認知，那就是某種程度上他是有序的</em>，這個案例有兩個變數，在計算<code>面積 = 距離(指標距離) * 高度(min指標值)</code>，我們知道，<code>距離</code>最大的狀況下是頭跟尾，但是<em>window縮小的時候<code>距離</code>只會越來越小，他是有序的</em>。</p><p>然而這題比較困難的點是，我們要<em>如何確保windows之外已經算過不可能有比目前最佳解還要好的前提下來縮window</em>，因為<code>距離</code>是有跡可循，window縮小的時候只會更小，因此找到最大面積的關鍵是<code>高度(min指標值)</code>，他是一個不確定的因素，有可能window縮小時獲得更大的面積只是因為容器夠高，那我們要怎麼或得最大容器面積呢？</p><p><strong>有三個重要概念</strong></p><ol><li>如果發現比<code>max_area</code>大的面積，就更新<code>max_area</code></li><li>因為window縮小的時候，距離一定是縮短的，所以我們不避顧慮<code>距離(指標位置)</code>在windows之外有沒有可能有最佳解，因為我們最先計算的就是最大的距離<code>left=0</code>和<code>right=len(height)-1</code>。windows之外都是已經算過了，我們也把當前windows外的最佳解存在<code>max_area</code>。</li><li>在縮window時真正會影響有沒有最佳解的是<code>高度(指標值)</code>，決定是否要移動pointer時，只要考慮<code>高度</code>即可。<ol><li>如果 <code>height[left] &lt; height[right]</code>，那麼我們就移動<code>left</code>，因為<code>height[left]</code>是最小的，所以我們要找更大的<code>height</code>。</li><li>如果 <code>height[left] &gt; height[right]</code>，那麼我們就移動<code>right</code>，因為<code>height[right]</code>是最小的，所以我們要找更大的<code>height</code>。</li><li>如果 <code>height[left] == height[right]</code>，那麼我們就移動<code>left</code>或<code>right</code>都可以，因為他們都是最小的，所以我們要找更大的<code>height</code>。</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始狀態</span></span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> (= index)</span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line"> L               R</span><br><span class="line"></span><br><span class="line">Left pointer starts <span class="keyword">from</span> index <span class="number">0</span></span><br><span class="line">Right pointer starts <span class="keyword">from</span> the last index</span><br><span class="line">width = right - left = <span class="number">8</span> - <span class="number">0</span> = <span class="number">8</span></span><br><span class="line">height = <span class="built_in">min</span>(height[left], height[right]) = <span class="built_in">min</span>(<span class="number">1</span>, <span class="number">7</span>) = <span class="number">1</span></span><br><span class="line">area = <span class="number">8</span> * <span class="number">1</span> = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在這個狀況下 left vs right = 1 vs 7</span></span><br><span class="line"><span class="comment"># 1 &lt; 7 所以我們移動left pointer</span></span><br><span class="line"> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> (= index)</span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">   L             R</span><br><span class="line"></span><br><span class="line">Left pointer moves to <span class="built_in">next</span></span><br><span class="line">Right pointer stays the same</span><br><span class="line">current_area = <span class="number">7</span> * <span class="number">7</span> = <span class="number">49</span></span><br><span class="line">max_area = <span class="built_in">max</span>(<span class="number">8</span>, <span class="number">49</span>) = <span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在這個狀況下 left vs right = 8 vs 7</span></span><br><span class="line"><span class="comment"># 8 &gt; 7 所以我們移動right pointer</span></span><br><span class="line"> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> (= index)</span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">   L           R</span><br><span class="line"></span><br><span class="line">Left pointer stays the same</span><br><span class="line">Right pointer moves to <span class="built_in">next</span></span><br><span class="line">current_area = <span class="number">6</span> * <span class="number">3</span> = <span class="number">18</span></span><br><span class="line">max_area = <span class="built_in">max</span>(<span class="number">49</span>, <span class="number">18</span>) = <span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在這個狀況下 left vs right = 8 vs 3</span></span><br><span class="line"><span class="comment"># 8 &gt; 3 所以我們移動right pointer</span></span><br><span class="line"> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> (= index)</span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">   L         R</span><br><span class="line"></span><br><span class="line">Left pointer stays the same</span><br><span class="line">Right pointer moves to <span class="built_in">next</span></span><br><span class="line">current_area = <span class="number">5</span> * <span class="number">8</span> = <span class="number">40</span></span><br><span class="line">max_area = <span class="built_in">max</span>(<span class="number">49</span>, <span class="number">40</span>) = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在這個狀況下 left vs right = 8 vs 8</span></span><br><span class="line"><span class="comment"># 8 == 8 所以我們可以選擇移動left或是right pointer，這裡我們移動right pointer</span></span><br><span class="line"> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> (= index)</span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">     L       R</span><br><span class="line"></span><br><span class="line">Left pointer moves to <span class="built_in">next</span></span><br><span class="line">Right pointer stays the same</span><br><span class="line">current_area = <span class="number">4</span> * <span class="number">6</span> = <span class="number">24</span></span><br><span class="line">max_area = <span class="built_in">max</span>(<span class="number">49</span>, <span class="number">24</span>) = <span class="number">49</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><em>完整程式碼可以寫成</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time: O(N)</span></span><br><span class="line"><span class="string">Space: O(1)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">        max_area = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            cur = (r-l) * <span class="built_in">min</span>(height[l], height[r])</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, cur)</span><br><span class="line">            <span class="keyword">if</span> height[l] &gt; height[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><h1 id="3-結語">3 結語</h1><p>這題我最大的困難仍是不習慣一個觀點：如果有多個要素（以這個例子是<code>長度</code>跟<code>高度</code>）在<strong>移動指標時我該怎麼考量確保 windows 之外已經算過不可能有比目前最佳解還要好的前提下來縮 window</strong>？</p><ul><li>所以我們只要考量<code>高度</code>即可，因為<code>高度</code>是不確定的，所以我們要找最大的<code>高度</code>來縮window。</li><li>只有在確定windows之外確定不可能有沒算過的最佳解，我才會選擇縮windows來尋找可能的最佳解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Two Pointer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #167 Two Sum II - Input array is sorted - 刷題之旅</title>
      <link href="/posts/leetcode-167-Two-Sum-II-Input-Array-Is-Sorted/"/>
      <url>/posts/leetcode-167-Two-Sum-II-Input-Array-Is-Sorted/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/Y0qrFAW.png" alt=""></p><p>從numbers裡面找出兩個數字，使得他們的和等於target，並且返回這兩個數字的索引，且索引是從1開始。</p><div class="note warning flat"><p>這個題目要求空間複雜度為O(1)，因此我們不能使用hashmap。</p></div><h1 id="2-解法">2 解法</h1><h2 id="2-1-暴力解法">2.1 暴力解法</h2><p>最純的暴力破解法，就是O(N^2)遍歷所有的組合，找出符合條件的組合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(numbers)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> numbers[i] + numbers[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i+<span class="number">1</span>, j+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="2-2-Speed-O-N">2.2 Speed O(N)</h2><p>這題的關鍵是，<strong>我們該如何避免檢查那些不可能的組合</strong>？</p><p><img src="https://i.imgur.com/uc4AFsE.png" alt=""><br><img src="https://i.imgur.com/d6cQUFG.png" alt=""><br>我一開始沒有立刻領悟出 <code>numbers[right] + numbers[left]</code> 與 <code>target</code> 之間的關係，因為<code>numbers</code>是排序過的，所以我們可以利用這個特性，來找出答案。<br>舉例來說：</p><ul><li>left pointer 指向最小的數字</li><li>right pointer 指向最大的數字</li><li>如果<code>numbers[right] + numbers[left]</code> 導致超過 <code>target</code> 這意味著什麼？<ul><li>這意味著我們需要更小的數字，因此我們將right pointer往左移動，讓數字變小。</li></ul></li><li>如果<code>numbers[right] + numbers[left]</code> 導致遠低於 <code>target</code> 這意味著什麼？<ul><li>這意味著我們需要更大的數字，因此我們將left pointer往右移動，讓數字變大。</li></ul></li><li>你會發現，<em>兩個pointer往中間移動</em>，每個pointer都會遍歷一次，這樣的時間複雜度是O(N)。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            tot = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> tot == target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> tot &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="3-結語">3 結語</h1><p>這題的精華在於，你能不能發現<em>有序的numbers</em>，可以幫助你避免檢查不必要的組合。然後我最大的困難在於，我要怎麼確保window移動的時候，縮圈的方式不會錯過最佳解？以這個例子來說，既然要縮windows，我們是真的當前的window之外的組合都不可能是答案，才要縮圈。這也是為什麼這題的numbers必須排序過，才可以使用這個技巧。</p><p><img src="https://i.imgur.com/uLLydF7.png" alt=""><br><em>為什麼，tot太大時，我們除了將right pointer往左移動使其變小，為什麼不需要重新將left pointer往左移動來檢查呢？</em></p><ul><li>這是因為，我們今天right在當前的位置，是因為我們已經檢查過right+1的所有組合，然後left移動到與right相加時超過target的位置</li><li>因為移動過後的left與right+1相加的結果是太大，所以我們將right往左移動，讓數字變小，得到目前的right和left</li><li>現在我們因為right與left的組合太大，除了right pointer往左移動外，我們還去碰left pointer，這是多餘的。</li><li>因為 right + (left-1) 一定會小於 (right+1) + (left-1)，這是已經比較過的組合，也因為當時太小，才會把left pointer往右移動得到left</li><li>然後你現在又說移動left-1，就不合理，因為一定會因為太小，又把left pointer往右移動，這樣就是重複的動作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Two Pointer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Two Pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Two Pointer 和 Sliding Window 捕捉使用時機</title>
      <link href="/posts/lecture-two-pointer-and-sliding-window/"/>
      <url>/posts/lecture-two-pointer-and-sliding-window/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>今天想要深度的去了解Two pointer與sliding window 的使用，這也是面試常見的技巧。主要整理出『如何辨識要使用這些技巧』。</p><h1 id="Two-Pointer">Two Pointer</h1><p>那我們先從two pointer開始，因為sliding window其實是two pointer的一種特例，或是進階應用。</p><p>那麼什麼是two pinter呢？pinter 俗稱指標，指標用來儲存另一個物件的記憶體位置，通常在leetcode中，指標只是一個整數，用來指向陣列的某個物件索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pointer = <span class="number">0</span></span><br><span class="line">arr = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">100</span>]</span><br><span class="line">       ^</span><br><span class="line">arr[pointer] = arr[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">pointer = <span class="number">3</span></span><br><span class="line">arr = [<span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">100</span>]</span><br><span class="line">                    ^</span><br><span class="line">arr[pointer] = arr[<span class="number">3</span>] = <span class="number">70</span></span><br></pre></td></tr></table></figure><p>Two pointer就是指向陣列的兩個指標，通常是指向陣列的頭尾，然後向中間移動，或是指向陣列的兩個不同位置，然後向中間移動。雙指標允許我們同時查看兩個不同的值，然後我們根據這兩個值的關係來決定下一步的操作。</p><h2 id="Example-Valid-Palidorme">Example: Valid Palidorme</h2><p>Palidorme 就是一個經典的 two pointer 例子，Palidorme 又稱作『回文』，向前讀和向後讀是一樣的，例如：<code>&quot;racecar&quot;</code>(倒過來也長一樣)。為了開始檢查，我們在兩端初始化一個指標，left和right，分別指向字串的開頭和結尾。然後我們每次檢查兩個指標指向的字元是否相同，如果不同，就返回False，如果相同，就繼續檢查下一個字元，直到兩個指標相遇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">&#x27;racecar&#x27;</span></span><br><span class="line">          l     r</span><br><span class="line">left = <span class="number">0</span>     </span><br><span class="line">right = <span class="number">6</span>     </span><br><span class="line">string[left] = <span class="string">&#x27;r&#x27;</span></span><br><span class="line">string[right] = <span class="string">&#x27;r&#x27;</span></span><br><span class="line"><span class="string">&#x27;r&#x27;</span> == <span class="string">&#x27;r&#x27;</span></span><br><span class="line"><span class="comment"># The letters are equal, decision -&gt; bring left and right closer.</span></span><br><span class="line">string = <span class="string">&#x27;racecar&#x27;</span></span><br><span class="line">           l   r</span><br><span class="line">left = <span class="number">1</span>    </span><br><span class="line">right = <span class="number">5</span></span><br><span class="line">string[left] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">string[right] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> == <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment"># The letters are equal, decision -&gt; bring left and right closer.</span></span><br><span class="line">string = <span class="string">&#x27;racecar&#x27;</span></span><br><span class="line">            l r</span><br><span class="line">left = <span class="number">2</span>   </span><br><span class="line">right = <span class="number">4</span></span><br><span class="line">string[left] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">string[right] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="string">&#x27;c&#x27;</span> == <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="comment"># The letters are equal, decision -&gt; bring left and right closer.</span></span><br><span class="line">string = <span class="string">&#x27;racecar&#x27;</span></span><br><span class="line">             l </span><br><span class="line">             r</span><br><span class="line">left = <span class="number">3</span></span><br><span class="line">right = <span class="number">3</span></span><br><span class="line">string[left] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">string[right] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="string">&#x27;c&#x27;</span> == <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p><em>以下是python代碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_palindrome</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="comment"># Initialize pointers</span></span><br><span class="line">    left = <span class="number">0</span> </span><br><span class="line">    right = <span class="built_in">len</span>(string) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># Check all letters in the string </span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># If letters are not equal</span></span><br><span class="line">        <span class="comment"># Decision -&gt; Return False</span></span><br><span class="line">        <span class="keyword">if</span> string[left] != string[right]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">        <span class="comment"># Else, the letters are equal</span></span><br><span class="line">        <span class="comment"># Decision -&gt; Bring left and right closer and compare again</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span>        </span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>   </span><br></pre></td></tr></table></figure><h2 id="Other-Scenarios">Other Scenarios</h2><p>two pinter通常不像是上面的例子這麼簡單，有時候需要發揮想像力。以下是常見使用two pointer的情境：</p><ol><li>Binary Search 二元搜尋</li><li>Slow and Fast Pointer to detect a cycle</li><li>One pointer as a boundary and one another to search</li><li>Pointer at the beginning of two sorted arrays</li><li>Sliding Window (Advanced)</li></ol><p>Leetcode 題目：</p><p><em>難度較低</em></p><ul><li><a href="https://leetcode.com/problems/valid-palindrome/">Valid Palindrome</a></li><li><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Two Sum Sorted</a></li><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array</a></li><li><a href="https://leetcode.com/problems/merge-sorted-array/">Merged Two Sorted Arrays</a></li><li><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">Intersection of Two Arrays II</a></li><li><a href="https://leetcode.com/problems/binary-search/">Binary Search</a></li><li><a href="https://leetcode.com/problems/reverse-string/">Reverse a String</a></li></ul><p><em>難度較高</em></p><ul><li><a href="https://leetcode.com/problems/sort-colors/">Sorted Colors</a></li><li><a href="https://leetcode.com/problems/container-with-most-water/">Container with Most Water</a></li><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Sliding Window</a></li><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Binary Search Rotated Array</a></li></ul><h2 id="How-to-Recognize-it">How to Recognize it</h2><p>我們可以通過幾種方式來辨識two pointer的使用時機：</p><ol><li><strong>O(N^2)降低成O(N)</strong>：把雙層for迴圈的循環減少到單層迴圈</li><li><strong>Input是有序的</strong>：如果input已經排序或是有順序</li><li><strong>兩個索引的比較</strong>：如果我們要將一個索引值跟另一個索引值進行比較</li><li><strong>兩個索引的交換</strong>：我們需要在索引之間交換</li><li><strong>陣列的分區</strong>：如果我們需要將陣列分區，然後在分區中進行操作</li></ol><h1 id="Sliding-Window">Sliding Window</h1><p>Sliding window 是雙指標的擴展，透過left和right兩個指標來建立window（窗口），通常問題是要我們反回<em>滿足特定條件的最大或最小子範圍</em>。因此我們透過滑動（收縮和擴展）『window』來找到最佳範圍。在這裡我們會使用<a href="https://leetcode.com/problems/max-consecutive-ones-iii/">Max Consecutive Ones III</a>來舉例。</p><h2 id="Key-Steps">Key Steps</h2><p>但是在開始之前，我們要先知道Sliding Window的三個關鍵步驟：</p><ol><li>Expand out Window 擴展窗口</li><li>Meet the condition and process the window 滿足條件並處理窗口</li><li>Shrink the window 收縮窗口</li></ol><p><em>以下是代碼中3個關鍵步驟的呈現方式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># Iterate over elements in our input</span></span><br><span class="line">        <span class="comment"># Expand the window</span></span><br><span class="line">        <span class="comment"># Meet the condition to stop expansion</span></span><br><span class="line">            <span class="comment"># Process the current window   </span></span><br><span class="line">            <span class="comment"># Contract the window</span></span><br></pre></td></tr></table></figure><h2 id="Other-Scenarios-2">Other Scenarios</h2><p>Leetcode 常見的Sliding Window題目：</p><ul><li><a href="https://leetcode.com/problems/max-consecutive-ones-i/">Max Consecutive Ones I</a></li><li><a href="https://leetcode.com/problems/max-consecutive-ones-ii/">Max Consecutive Ones II</a></li><li><a href="https://leetcode.com/problems/max-consecutive-ones-iii/">Max Consecutive Ones III</a></li><li><a href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/">Longest Substring with At Most K Distinct Characters</a></li><li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a></li><li><a href="https://leetcode.com/problems/minimum-window-substring/">Minimum Window Substring</a></li></ul><h2 id="Example-Max-Consecutive-Ones-III">Example: Max Consecutive Ones III</h2><p>問題如下，我們可以替換1次0，找到最大的連續1的數量。但其實題目可以換句話說：<em>我們要找到最大的window，裡面最多只有1個0</em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAX CONSECUTIVE ONES II </span><br><span class="line">Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.</span><br><span class="line">Input: [1,0,1,1,0]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>那麼，促使我們<strong>停止擴大window的條件是什麼呢？</strong><br>就是當我們的window中0的數量超過1個時，我們就要停止擴大window。因為 0 太多拉！再擴大下去，會遠遠的超過偏差。換句話說我們需要<em>擴展window，直到我們的window中0的數量超過1個</em>，要停下腳步思考一下。</p><p>我們可以使用一個變數<code>count</code>來記錄0的數量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CONDITION TO STOP EXPANSION</span></span><br><span class="line">count == <span class="number">2</span>:</span><br></pre></td></tr></table></figure><p><em>那我們重新把這個停止擴大的條件放入我們的sliding window結構</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">nums</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span>          <span class="comment"># Intialize our window&#x27;s bound</span></span><br><span class="line">    count = <span class="number">0</span>                   <span class="comment"># Track how many 0’s are in the window</span></span><br><span class="line">    <span class="comment"># Iterate over elements in our input</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="comment"># Expand the window</span></span><br><span class="line">        <span class="comment"># Meet the condition to stop expansion</span></span><br><span class="line">        <span class="keyword">while</span> count &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Process the current window   </span></span><br><span class="line">            <span class="comment"># Contract the window</span></span><br><span class="line">        right += <span class="number">1</span>  </span><br></pre></td></tr></table></figure><p>因此，我們透過向右擴展window，直到我們的window中0的數量超過1個，我們就要停止擴展window。但是等等！我們怎麼知道count什麼時候會被增加呢？我們需要在擴展window的時候，檢查我們的window中是否有0，如果有，我們就要增加count。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向右擴展window時要檢查是否有0</span></span><br><span class="line"><span class="keyword">if</span> nums[right] == <span class="number">0</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>那我們再把它加進去代碼中</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">nums</span>):</span><br><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span>          <span class="comment"># Intialize our window&#x27;s bound</span></span><br><span class="line">count = <span class="number">0</span>                   <span class="comment"># Track how many 0’s are in the window</span></span><br><span class="line"><span class="comment"># Iterate over elements in our input</span></span><br><span class="line"><span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="comment"># Expand the window </span></span><br><span class="line">    <span class="keyword">if</span> nums[right] == <span class="number">0</span>:        </span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># Meet the condition to stop expansion</span></span><br><span class="line">    <span class="keyword">while</span> count &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Process the current window</span></span><br><span class="line">        <span class="comment"># Contract the window</span></span><br><span class="line">    right += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>很好！現在我們已經擴展了視窗，直到滿足條件為止。那我們接下來要做什麼呢？就是開始尋找我們的最佳解，在這個題目就是找到最大長度的連續1，我們可以透過<code>global_max</code>來記錄最大的連續1的長度。一但發現更好的解，我們就要更新<code>global_max</code>。在最後作為結果返回。當我們已經檢查過當前的window是否最長後，我們透過增加left來縮小window，直到我們的window中0的數量小於等於1個。</p><p>但是要注意的是，當我們增加left之前，也要檢查left是否會讓我們0的數量遞減，因為已經不再window中了，我們要減少count。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">nums</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span>          <span class="comment"># Our window bounds</span></span><br><span class="line">    count = <span class="number">0</span>                   <span class="comment"># Track how many 0’s are in the window</span></span><br><span class="line">    global_max = <span class="number">0</span>              <span class="comment"># Track the maximum, overall</span></span><br><span class="line">    <span class="comment"># Iterate over elements in our input</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="comment"># Expand the window </span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span>:        </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Meet the condition to stop expansion</span></span><br><span class="line">        <span class="keyword">while</span> count &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Process the current window</span></span><br><span class="line">            global_max = <span class="built_in">max</span>(global_max, right - left)</span><br><span class="line">            <span class="comment"># Contract the window</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == <span class="number">0</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure><p>作為最後步驟，我們需要處理邊緣情況，就是最大陣列其實是陣列的尾端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 0, 0, 1, 1, 1, 1, 1]</span><br><span class="line">       l                 r</span><br><span class="line">We never process the current window above because count_of_zeroes never has a chance to equal 2. </span><br><span class="line">So do this check at the end:</span><br><span class="line">if count_of_zeroes &lt; 2:</span><br><span class="line">    global_max = max(global_max, right-left)</span><br></pre></td></tr></table></figure><p>那我們把邊緣狀況加入我們的代碼中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sliding_window</span>(<span class="params">nums</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="number">0</span>        <span class="comment"># Our window bounds</span></span><br><span class="line">    count = <span class="number">0</span>                 <span class="comment"># Track how many 0’s are in the window</span></span><br><span class="line">    global_max = <span class="number">0</span>            <span class="comment"># Track the maximum, overall</span></span><br><span class="line">    <span class="comment"># Iterate over elements in our input</span></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="comment"># Expand the window </span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span>:        </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Meet the condition to stop expansion</span></span><br><span class="line">        <span class="keyword">while</span> count &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Process the current window</span></span><br><span class="line">            global_max = <span class="built_in">max</span>(global_max, right - left)</span><br><span class="line">        <span class="comment"># Contract the window</span></span><br><span class="line">            <span class="keyword">if</span> nums[left] == <span class="number">0</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &lt; <span class="number">2</span>:</span><br><span class="line">        global_max = <span class="built_in">max</span>(global_max, right-left)</span><br><span class="line">    <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure><h2 id="How-to-Recognize-it-2">How to Recognize it</h2><p>總結來說 Sliding Window 就是需要定義出以下狀況：</p><ol><li>何時停止擴展？</li><li>處理當前window的時機？</li><li>何時收縮window？</li></ol><p>因此我們需要3個變數</p><ol><li>window bounds: 通常是 left, right 來表示window的邊界</li><li>Track condition: 通常是一個變數來追蹤滿足條件，這個例子裡面我們使用count</li><li>Return value: 通常是一個變數來記錄最終結果，這個例子裡面我們使用global_max</li></ol><p>我們的思考邏輯是這樣的：</p><ol><li>定義條件以停止擴展</li><li>展開視窗直到滿足條件，但是在展開視窗前，要在right處檢查或處理元素</li><li>如果滿足停止擴展的條件，則處理當前視窗</li><li>縮小視窗，直到滿足條件，但是在縮小視窗前，要在left處檢查或處理元素</li><li>最後，處理邊緣情況</li></ol><h1 id="參考">參考</h1><ul><li><a href="https://medium.com/@timpark0807/leetcode-is-easy-two-pointers-90b9b0f2eb43">Medium | Leetcode is Easy! The Two Pointer Pattern.</a></li><li><a href="https://medium.com/@timpark0807/leetcode-is-easy-sliding-window-c44c11cc33e1">Medium | Leetcode is Easy! The Sliding Window Pattern.</a></li><li><a href="https://medium.com/leetcode-patterns/leetcode-pattern-2-sliding-windows-for-strings-e19af105316b">Medium | Leetcode Pattern 2 | Sliding Windows for Strings</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> Two Pointer </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #123 124 Best Time to Buy and Sell Stock - 刷題之旅</title>
      <link href="/posts/leetcode-123-124-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/posts/leetcode-123-124-Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/GVHmyW8.png" alt=""></p><p>給定一個數組，其中第i個元素是第i天的股票價格。你最多可以完成兩筆交易。請計算你可以獲得的最大利潤。<br>注意的是，你的股票是在賣掉之前，不可以再買入。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-Recursion">2.1 Recursion</h2><p>一次遍歷每個股票價格，然後選擇買入或賣出，然後遞歸下去。這樣的時間複雜度是O(2^N)。</p><ul><li>沒股票：如果目前沒有股票，那麼可以選擇買入或不買入。</li><li>有股票：如果目前已經有股票，那麼可以選擇賣出或不賣出。</li></ul><p>而目前題目說，可以進行2次的transaction，基本上1次transaction就是買入和賣出，也就是2次的action，因此2次的transaction就是4次action。</p><p>從上面看到，基本上會有四種可能</p><ol><li>買入</li><li>不買入</li><li>賣出</li><li>不賣出</li></ol><p>我們需要幾個變數</p><ul><li>idx: 當前的股票價格</li><li>have_stack: 是否有股票，來決定是買入還是賣出</li><li>count: 剩餘的交易次數</li></ul><p><em>如果沒股票</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> have_stack:</span><br><span class="line">    <span class="comment"># 這次買入(-cost)，下次就只能選則賣出</span></span><br><span class="line">    do_action = -prices[idx] + helper(idx+<span class="number">1</span>, <span class="keyword">not</span> have_stack, count)</span><br><span class="line">    <span class="comment"># 這次不買入，目前仍然沒有股票</span></span><br><span class="line">    not_do_action = helper(idx+<span class="number">1</span>, have_stack, count)</span><br></pre></td></tr></table></figure><p><em>如果有股票</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> have_stack:</span><br><span class="line">    <span class="comment"># 這次賣出(+sell)，下次就只能選則買入</span></span><br><span class="line">    do_action = prices[idx] + helper(idx+<span class="number">1</span>, <span class="keyword">not</span> have_stack, count-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 這次不賣出，目前仍然有股票</span></span><br><span class="line">    not_do_action = helper(idx+<span class="number">1</span>, have_stack, count)</span><br></pre></td></tr></table></figure><p><em>上述兩個情況的整合</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sell = prices[idx]</span><br><span class="line">buy = -prices[idx]</span><br><span class="line">do_action = (sell <span class="keyword">if</span> have_stack <span class="keyword">else</span> buy) + helper(idx+<span class="number">1</span>, <span class="keyword">not</span> have_stack, count)</span><br><span class="line">not_do_action = helper(idx+<span class="number">1</span>, have_stack, count)</span><br></pre></td></tr></table></figure><p><em>完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">時間複雜度: O(n * 2^C)（如果 count 是變量，最壞情況下為 O(n * 2^C)，其中 n 是價格列表的長度，C 是最大交易次數）</span></span><br><span class="line"><span class="string">空間複雜度: O(n)（主要取決於遞歸深度）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">or</span> idx == <span class="built_in">len</span>(prices):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        buy = -prices[idx]</span><br><span class="line">        sell = prices[idx]</span><br><span class="line">        do_action = (sell <span class="keyword">if</span> have_stack <span class="keyword">else</span> buy) + helper(idx+<span class="number">1</span>, <span class="keyword">not</span> have_stack, count)</span><br><span class="line">        not_do_action = helper(idx+<span class="number">1</span>, have_stack, count)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(do_action, not_do_action)</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="literal">False</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-Recursion-with-Memoization">2.2 Recursion with Memoization</h2><p>加入dp table，來記錄已經計算過的結果，這樣可以避免重複計算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">時間複雜度: O(2^n) 每個price可以選擇買或不買</span></span><br><span class="line"><span class="string">空間複雜度: O(n)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;transaction count = 4&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">idx: <span class="built_in">int</span>, have_stack: <span class="built_in">bool</span>, count: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span> <span class="keyword">or</span> idx == <span class="built_in">len</span>(prices):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (idx, have_stack, count) <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">return</span> dp[(idx, have_stack, count)]</span><br><span class="line"></span><br><span class="line">            buy = -prices[idx]</span><br><span class="line">            sell = prices[idx]</span><br><span class="line"></span><br><span class="line">            do_action = (sell <span class="keyword">if</span> have_stack <span class="keyword">else</span> buy) + helper(idx+<span class="number">1</span>, <span class="keyword">not</span> have_stack, count)</span><br><span class="line">            not_do_action = helper(idx+<span class="number">1</span>, have_stack, count)</span><br><span class="line">            dp[(idx, have_stack, count)] = <span class="built_in">max</span>(do_action, not_do_action)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dp[(idx, have_stack, count)]</span><br><span class="line"></span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="literal">False</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-Iterative">2.3 Iterative</h2><p>也可以使用迭代的方式來解這個問題，這樣的時間複雜度是O(N)。<br>假設cost1是第一次transation買入的價格，profit1是第一次transation賣出的所獲得的利潤。<br>那我們會拿profit1的利潤考量進去，在買入第二次的價格，也就是cost2時，可以把profit1扣掉，這樣就可以得到第二次的所付出的成本。<br>然後計算profit2時，把profit2扣掉cost2，就可以得到第二次的利潤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">時間複雜度: O(n)</span></span><br><span class="line"><span class="string">空間複雜度: O(1)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit2</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cost1, cost2 = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        profit1, profit2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">            cost1 = <span class="built_in">min</span>(cost1, p)</span><br><span class="line">            profit1 = <span class="built_in">max</span>(profit1, p - cost1)</span><br><span class="line">            cost2 = <span class="built_in">min</span>(cost2, p - profit1)</span><br><span class="line">            profit2 = <span class="built_in">max</span>(profit2, p - cost2)</span><br><span class="line">        <span class="keyword">return</span> sell1</span><br></pre></td></tr></table></figure><h1 id="k次交易">k次交易</h1><p><img src="https://i.imgur.com/I50RpKl.png" alt=""><br>如果今天是k次交易，該怎麼做呢？基本上就是要做k次的cost跟profit的更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cost1 = <span class="built_in">min</span>(cost1, p)</span><br><span class="line">profit1 = <span class="built_in">max</span>(profit1, p - cost1)</span><br><span class="line">cost2 = <span class="built_in">min</span>(cost2, p - profit1)</span><br><span class="line">profit2 = <span class="built_in">max</span>(profit2, p - cost2)</span><br><span class="line">cost3 = ...</span><br><span class="line">profit3 = ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果我們使用dp去存cost跟profit，<code>dp[i][0]</code>表示第i次的cost，<code>dp[i][1]</code>表示第i次的profit。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">時間複雜度: O(n * k)</span></span><br><span class="line"><span class="string">空間複雜度: O(k)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit3</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][<span class="number">0</span>], p - dp[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i][<span class="number">1</span>], p - dp[i-<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> dp[k][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>其實一開始看到題目就是take與not take的問題，但是他難在多考慮一個變數，也就是要幾次交易，這導致同時考量兩種變數，才變得比較複雜。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #221 Maximal Square - 刷題之旅</title>
      <link href="/posts/leetcode-221-Maximal-Square/"/>
      <url>/posts/leetcode-221-Maximal-Square/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/YrnnYJg.png" alt=""><br><img src="https://i.imgur.com/EAUvfqX.png" alt=""></p><p>給定一個二維矩陣<code>matrix</code>，找到只包含<code>1</code>的最大正方形，並返回其面積。</p><h1 id="2-解法">2 解法</h1><p>其實看到這種2D的DP題目，老樣子可以先把圖片畫出來，然後開始找規律，我們可以先定義如下：<br><code>dp[i][j]</code> 代表以<code>matrix[i][j]</code>為右下角的最大正方形邊長，這樣的話我們就可以推導出以下公式：</p><ul><li>如果<code>matrix[i][j] == 1</code><ul><li>那麼<code>dp[i][j]</code>就是<code>min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</code>，這裡的<code>+1</code>是因為<code>matrix[i][j]</code>是<code>1</code>，所以可以構成一個正方形</li></ul></li><li>如果<code>matrix[i][j] == 0</code><ul><li>那麼<code>dp[i][j]</code>就是<code>0</code>，因為無法構成正方形</li></ul></li></ul><p>比較特別的是思考的方式：但是必須考慮<code>dp[i][j]</code>的時候，周遭的cell必須都是計算過的，才可以透過解決小問題來解決大問題</p><ol><li>可以從<code>最左下角</code>開始思考，那我們就要看<code>dp[i][j]</code>的左邊、下面、下斜角的cell</li><li>或是從<code>最右上角</code>開始思考，但是必須考慮<code>dp[i][j]</code>的右邊、上面、上斜角的cell</li></ol><p><em>Solution1: 左下角開始</em><br><img src="https://i.imgur.com/Mr3uzK2.png" alt=""></p><p><em>Solution2: 右上角開始</em><br><img src="https://i.imgur.com/KaF2A1I.png" alt=""></p><h2 id="2-1-Recursion-Memoization">2.1 Recursion + Memoization</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time: O(m*n)</span></span><br><span class="line"><span class="string">Space: O(m*n)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">r: <span class="built_in">int</span>, c: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> r &gt;= rows <span class="keyword">or</span> c &gt;= columns:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> matrix[r][c] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (r, c) <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">return</span> dp[(r, c)]</span><br><span class="line">            down = helper(r+<span class="number">1</span>, c)</span><br><span class="line">            right = helper(r, c+<span class="number">1</span>)</span><br><span class="line">            down_right = helper(r+<span class="number">1</span>, c+<span class="number">1</span>)</span><br><span class="line">            dp[(r, c)] = <span class="built_in">min</span>(down, right, down_right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> dp[(r, c)]</span><br><span class="line">        </span><br><span class="line">        helper(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp.values()) ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="2-1-Iterative">2.1 Iterative</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time: O(m*n)</span></span><br><span class="line"><span class="string">Space: O(m*n)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(columns)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        max_side = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columns):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">if</span> dp[i][j] &gt; biggest:</span><br><span class="line">                        biggest = dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> biggest ** <span class="number">2</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.2 Iterative with Space Optimization</span></span><br><span class="line">```python</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time: O(m*n)</span></span><br><span class="line"><span class="string">Space: O(n)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalSquare</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(columns)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        max_side = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(columns):</span><br><span class="line">                <span class="comment"># 只有cell是1的時候才需要計算</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    dp[<span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 不是邊緣的狀況</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[<span class="number">1</span>][j] = <span class="number">1</span> + <span class="built_in">min</span>(dp[<span class="number">0</span>][j], dp[<span class="number">0</span>][j-<span class="number">1</span>], dp[<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">                    <span class="comment"># 更新最大邊長</span></span><br><span class="line">                    <span class="keyword">if</span> dp[<span class="number">1</span>][j] &gt; biggest:</span><br><span class="line">                        biggest = dp[<span class="number">1</span>][j]</span><br><span class="line">            <span class="comment"># 更新dp把new row更新到old row</span></span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 初始化動作才不會因為記憶體指向導致出錯</span></span><br><span class="line">            dp[<span class="number">1</span>] = [<span class="number">0</span>] * columns</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> biggest ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題不難，但是我沒想到<em>dp儲存的竟然是邊長，而不是面積，這點要注意一下</em>。這題的解法也是比較直觀，就是從左下角或是右上角開始思考，然後找出規律，這樣就可以寫出解法了。但是最需要注意的是，當我們<em>使用iterative並且挑選要從左下角或是右上角開始時，要記得選擇周邊的cell必須是已經計算過的</em>，這樣才能透過小問題解決大問題。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #72 Edit Distance - 刷題之旅</title>
      <link href="/posts/leetcode-72-Edit-Distance/"/>
      <url>/posts/leetcode-72-Edit-Distance/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/iF0AMje.png" alt=""><br><img src="https://i.imgur.com/8j3ynNK.png" alt=""></p><p>給定兩個單詞<code>word1</code>和<code>word2</code>，找到將<code>word1</code>轉換為<code>word2</code>所需的最小操作數。</p><ul><li>操作包括插入一個字符、刪除一個字符、替換一個字符</li><li>美的操作的成本是1</li></ul><h1 id="2-解法">2 解法</h1><p><img src="https://i.imgur.com/wcC1E1A.png" alt=""><br>我會建議先畫出一個dp圖，這個dp代表，<code>word1</code>的前<code>i</code>個字元與<code>word2</code>的前<code>j</code>個字元的最小操作數，這樣就可以從<code>dp[i-1][j-1]</code>推導出<code>dp[i][j]</code>。<br>你會發現，第一列或是第一排，也就是<code>word1</code>或<code>word2</code>為空的時候，最小操作數就是當前字元的長度，可以透過這個特性來初始化<code>dp</code>。</p><p>如上圖所示，可以寫出以下程式碼進行初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, w1: <span class="built_in">str</span>, w2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(w2)</span><br><span class="line">        n = <span class="built_in">len</span>(w1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果某一方為空，但是雙方長度不一樣，就回傳最長的那個</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>) <span class="keyword">and</span> n != m:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(m, n)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化dp</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化第一行與第一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/X33d9C0.png" alt=""><br>接下來，我們先來使用一個比較簡單的例子來說明一下會有哪些狀況：</p><ol><li>當<code>word1[i] == word2[j]</code>時，不需要進行任何操作，繼續往下一個字元比較即可<ul><li><code>(i+1,j+1)</code> 這會對應到 <code>dp[i][j] = dp[i-1][j-1]</code></li></ul></li><li>當<code>word1[i] != word2[j]</code>時，有三種操作方式：<ul><li>插入：<code>(i,j+1)</code> 這會對應到 <code>dp[i][j-1] + 1</code></li><li>刪除：<code>(i+1,j)</code> 這會對應到 <code>dp[i-1][j] + 1</code></li><li>替換：<code>(i+1,j+1)</code> 這會對應到 <code>dp[i-1][j-1] + 1</code></li></ul></li></ol><p>我來說明為什麼會這樣對應：<br><em>情境1:當比較的字元相同時</em><br><img src="https://i.imgur.com/HxkNoud.png" alt=""><br>從上圖你會發現，如果我們求<code>dp[3][5]</code>時，因為<code>word1[3-1] == word2[5-1] == &quot;s&quot;</code>，所以我們看能有三種操作方式，但是上面的操作方式中，只有從斜方向來的成本最小，因為當下比較的字元是相同的，所以我們不需要進行任何操作，可以直接取<code>dp[2][4]</code>的值。如果我們硬要取上面或是左邊的值，那就會多一次操作。</p><p><em>情境2:當比較的字元不同時</em><br><img src="https://i.imgur.com/rkbNCUC.png" alt=""><br>從上圖如果我們求<code>dp[3][4]</code>時，因為<code>word1[3-1] != word2[4-1]</code>，所以我們看能有三種操作方式，上面三種操作方式中我們要取最小的。從這個例子裡面，斜角或是左邊的值是最小的。</p><p><em>共通點</em><br>然後你會發現這三個操作的公式如下：</p><ul><li>上面（插入）：<code>dp[i][j-1] + 1</code></li><li>左邊（刪除）：<code>dp[i-1][j] + 1</code></li><li>斜角（替換）：<code>dp[i-1][j-1] + 1</code>（當前字元不同）或 <code>dp[i-1][j-1]</code>（當前字元相同）</li></ul><p>這樣我們就可以寫出以下程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, w1: <span class="built_in">str</span>, w2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(w2)</span><br><span class="line">        n = <span class="built_in">len</span>(w1)</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>) <span class="keyword">and</span> n != m:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(m, n)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 開始填表，因為第一行與第一列已經初始化了，所以從1開始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 計算top(插入)、left(刪除)、dia(替換)的成本</span></span><br><span class="line">                top = dp[i-<span class="number">1</span>][j]</span><br><span class="line">                dia = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                left = dp[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 如果當前字元不同，就取最小的並且+1操作</span></span><br><span class="line">                <span class="keyword">if</span> w2[i-<span class="number">1</span>] != w1[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(top, dia, left)</span><br><span class="line">                <span class="comment"># 如果當前字元相同，就取斜角的值（因為不需要操作成本）</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dia</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回傳最後一個值</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題花蠻多時間時考的，下次碰到類似的題目一率建議先把dp表畫出來，這樣會比較好理解。慢慢推倒就可以抓到公式了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #5 Longest Palindromic Substring - 刷題之旅</title>
      <link href="/posts/leetcode-5-Longest-Palindromic-Substring/"/>
      <url>/posts/leetcode-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/LUZsTW7.png" alt=""></p><p>找到最長的字串，該字串是回文的，也就是說，從左到右和從右到左是一樣的。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-暴力破解">2.1 暴力破解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">s: <span class="built_in">str</span>, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    best = <span class="string">&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; <span class="built_in">len</span>(best) <span class="keyword">and</span> isPalindrome(s, i, j):</span><br><span class="line">                best = s[i:j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> best </span><br></pre></td></tr></table></figure><h2 id="2-2-由中心向外過展">2.2 由中心向外過展</h2><p><img src="https://i.imgur.com/zFVrhF0.png" alt=""></p><p>從2.1的暴力破解法中有很多redundant computation。</p><ul><li>如果 <code>s[i:j]</code> 是回文，那麼 <code>s[i+1:j-1]</code> 往內的組合是回文</li><li>如果 <code>s[i:j]</code> 不是回文，那麼 <code>s[i-1:j+1]</code>往外擴展時，也不會是回文</li></ul><p>也因此，你會發現，如果我們鎖定一個中心點，然後往外擴展，當發現不是回文時，就立刻換下一個中心點。這樣的時間複雜度是O(n^2)。</p><ul><li>O(N) 遍歷每個字元當作中心點</li><li>O(N) 每個中心點擴展，最大擴展長度是O(N)</li></ul><p><em>Time complexity: O(N^2)</em></p><ul><li>最佳解法是O(N)當發現整個s不是回文時，立刻換下一個中心點。</li><li>最壞的狀況是O(N^2)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    resLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># odd length </span></span><br><span class="line">        l, r = i, i </span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> &gt; resLen:</span><br><span class="line">                res = s[l:r+<span class="number">1</span>]</span><br><span class="line">                resLen = r - l + <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="comment"># even length</span></span><br><span class="line">        l, r = i, i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> &gt; resLen:</span><br><span class="line">                res = s[l:r+<span class="number">1</span>]</span><br><span class="line">                resLen = r - l + <span class="number">1</span></span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>如果不想要太多重複的程式碼，也可以參考下面的寫法，只是有幾個注意的點：</p><ol><li>在 getLen 的時候，要注意 -1 因為會多擴展一次後才發現不滿足</li><li>要注意 <code>start = i - (cur - 1) // 2</code> 是因為我們要找到回文的起始點，cur要先-1才可以同時滿足odd, even的情況<ul><li>例如 <code>abba</code> 的時候，<code>i=1</code>的時候<code>cur=4</code>，所以<code>start = 1 - (4-1)//2 = 1 - 1 = 0</code>，這樣才可以取到<code>abba</code></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getLen</span>(<span class="params">l: <span class="built_in">int</span>, r: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r - l - <span class="number">1</span>    <span class="comment"># 要注意 -1 因為會多擴展一次後才發現不滿足</span></span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    ansLen = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        cur = <span class="built_in">max</span>(getLen(i, i), getLen(i, i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> cur &gt; ansLen:</span><br><span class="line">            ansLen = cur</span><br><span class="line">            start = i - (cur - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> s[start: start+ansLen]</span><br></pre></td></tr></table></figure><h2 id="2-3-O-n-Manacher’s-Algorithm">2.3 O(n) Manacher’s Algorithm</h2><p>我覺得這個算法非常複雜…我也不太懂，但是有興趣可以餐看這個影片<a href="https://youtu.be/nbTSfrEfo6M?si=FL3t15gfR7qUYDaA">Youtube |EP292Longest Palindromic Substring O(N) Manacher’s Algorithm</a></p><h1 id="3-總結">3 總結</h1><p>這題沒有太多dp的影子在裡面，這題的關鍵在當你意識到回文的時候，從中間往外去擴展，這可以讓你從O(N^3)縮短成O(N^2)。這題的時間複雜度是O(N^2)，空間複雜度是O(1)。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #63 Unique Paths II - 刷題之旅</title>
      <link href="/posts/leetcode-63-Unique-Paths-II/"/>
      <url>/posts/leetcode-63-Unique-Paths-II/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/pfMIkrO.png" alt=""><br><img src="https://i.imgur.com/58eKd9S.png" alt=""></p><p>給定一個m x n的矩陣，找到一條從左上角到右下角的最小路徑和。每次只能向右或是向下移動，但是他中間有障礙物，所以要避開障礙物。</p><h1 id="2-解法">2 解法</h1><p>這題與<a href="/posts/lecture-dp">LeetCode 課前預習 - 掌握 Dynamic Programming 的思維指南</a>的題目類似，如果你會做<a href="https://leetcode.com/problems/unique-paths/">Leetcode-62-Unique Paths</a>，這題也是一樣的概念，只是這題有障礙物，因此碰到障礙物就要記得把路徑設定為0。</p><h2 id="2-1-Iterative">2.1 Iterative</h2><p>因為已經做過類似的題目，所以直接從Iterative下手，我的想法是這樣的：</p><ul><li>今天邊緣也有可能有障礙物，所以要從邊緣開始處理</li><li>如果碰到障礙物，就把路徑設定為0</li><li>其他的就是從上面或是左邊來的路徑和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    rows = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    columns = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>] * columns <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">    <span class="comment"># 終點是1</span></span><br><span class="line">    dp[rows-<span class="number">1</span>][columns-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 從終點到起點處理</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(columns - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果是障礙物，就設定為0</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[row][column] == <span class="number">1</span>:</span><br><span class="line">                dp[row][column] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 其他狀況，不處理終點的狀況下</span></span><br><span class="line">            <span class="keyword">elif</span> dp[row][column] == <span class="number">0</span>:</span><br><span class="line">                down, left = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                <span class="comment"># 如果不是邊緣，就取下面的值，否則為0</span></span><br><span class="line">                <span class="keyword">if</span> row &lt; rows-<span class="number">1</span> <span class="keyword">and</span> dp[row+<span class="number">1</span>][column] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    down = dp[row+<span class="number">1</span>][column]</span><br><span class="line">                <span class="comment"># 如果不是邊緣，就取左邊的值，否則為0</span></span><br><span class="line">                <span class="keyword">if</span> column &lt; columns-<span class="number">1</span> <span class="keyword">and</span> dp[row][column+<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    left = dp[row][column+<span class="number">1</span>]</span><br><span class="line">                dp[row][column] = down + left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><em>這題也有一樣的思路，可以dp只用兩個row就好</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles2</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    rows = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    columns = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># row 只有兩個</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * columns <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][columns-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(columns - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[row][column] == <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][column] = <span class="number">0</span> <span class="comment"># 會因為沒有使用deecopy影響到dp[1][column]</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span>(row == rows-<span class="number">1</span> <span class="keyword">and</span> column == columns-<span class="number">1</span>):</span><br><span class="line">                down, left = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> row &lt; rows - <span class="number">1</span> <span class="keyword">and</span> dp[<span class="number">1</span>][column] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    down = dp[<span class="number">1</span>][column]</span><br><span class="line">                <span class="keyword">if</span> column &lt; columns - <span class="number">1</span> <span class="keyword">and</span> dp[<span class="number">0</span>][column + <span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    left = dp[<span class="number">0</span>][column + <span class="number">1</span>]</span><br><span class="line">                dp[<span class="number">0</span>][column] = down + left</span><br><span class="line">        <span class="comment"># 使用deepcopy才不會在修改dp[0]時影響到dp[1]</span></span><br><span class="line">        dp[<span class="number">1</span>] = copy.deepcopy(dp[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]     </span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題不難，也是很快就寫出來了，只是在處理邊緣的時候要注意不要超過邊界，以及要處理障礙物的情況。這題的時間複雜度是O(n * m)，空間複雜度是O(n * m)。如果你想要優化空間複雜度，可以參考上面的解法，只用兩個row的空間就好。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #64 Minimum Path Sum - 刷題之旅</title>
      <link href="/posts/leetcode-64-Minimum-Path-Sum/"/>
      <url>/posts/leetcode-64-Minimum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/OttZsVo.png" alt=""><br><img src="https://i.imgur.com/pIeNEmY.png" alt=""></p><p>給定一個m x n的矩陣，找到一條從左上角到右下角的最小路徑和。每次只能向右或是向下移動。</p><h1 id="2-解法">2 解法</h1><p>這題與<a href="/posts/lecture-dp">LeetCode 課前預習 - 掌握 Dynamic Programming 的思維指南</a>的題目類似，如果你會做<a href="https://leetcode.com/problems/unique-paths/">Leetcode-62-Unique Paths</a>，這題也是一樣的概念，只是這題是找最小路徑和。</p><h2 id="2-1-Recursive">2.1 Recursive</h2><p>首先我們很清楚，我們只能往右或是往下走，假設i是row，j是column，</p><p><em>所以我們可以寫出以下的關係式</em></p><ul><li>往右：<code>helper(i, j+1)</code> column + 1</li><li>往下：<code>helper(i+1, j)</code> row + 1</li><li>然後關係式：<code>min(往右, 往下) + 當前</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(helper(i, j+<span class="number">1</span>), helper(i+<span class="number">1</span>, j)) + grid[i][j]</span><br></pre></td></tr></table></figure><p>接下來我們來解決最小問題的狀況：</p><ul><li>如果只有一行或是一列，直接回傳總和，因為只有一條路可以走</li><li>何時知道走到底，當<code>i==rows-1</code>和<code>j==cols-1</code>時，就是走到底了，直接回傳<code>grid[i][j]</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i == rows-<span class="number">1</span> <span class="keyword">and</span> j == cols-<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> grid[i][j]</span><br></pre></td></tr></table></figure><p><em>我們就可以開始寫程式了</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果只有一行或是一列</span></span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">1</span> <span class="keyword">or</span> column == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(grid)</span><br><span class="line">        <span class="comment"># 走到底（終點）</span></span><br><span class="line">        <span class="keyword">if</span> i == row - <span class="number">1</span> <span class="keyword">and</span> j == column - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> grid[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 往右和往下選個最小的</span></span><br><span class="line">        right, down = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> j &lt; column - <span class="number">1</span>:</span><br><span class="line">            right = helper(i, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> i &lt; row - <span class="number">1</span>:</span><br><span class="line">            down = helper(i + <span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(right, down) + grid[i][j]</span><br><span class="line"></span><br><span class="line">    row = <span class="built_in">len</span>(grid)</span><br><span class="line">    column = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-Recursive-Memoization">2.2 Recursive + Memoization</h2><p>接下來下一步是為了減少重複運算，我們加入Memoization，這樣就不用一直重複計算了。這裡我們可以用一個<code>dp</code>的list來記錄已經計算過的值，我們可以先建立一個與<code>grid</code>一樣大小的list，然後每次計算過的值就存進去，下次再遇到就直接回傳。</p><p><em>建立與matrix相同大小的dp，該dp紀錄起點走到<code>dp[i][j]</code>的最佳解</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">row = <span class="built_in">len</span>(grid)</span><br><span class="line">column = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">dp = [[<span class="number">0</span>]*column <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br></pre></td></tr></table></figure><p><em>然後設計斷點</em></p><ul><li>如果走到底了，直接回傳<code>grid[i][j]</code></li><li>如果只有一行或是一列，直接回傳總和</li><li>如果dp不是0，直接回傳dp已經算過的內容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> row == <span class="number">1</span> <span class="keyword">or</span> column == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(grid)</span><br><span class="line"><span class="keyword">if</span> dp[i][j] != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> dp[i][j]</span><br><span class="line"><span class="keyword">if</span> i == row - <span class="number">1</span> <span class="keyword">and</span> j == column - <span class="number">1</span>:</span><br><span class="line">    dp[i][j] = grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure><p><em>那我們就可以開始寫完整的程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum2</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最小問題</span></span><br><span class="line">        <span class="comment">## 如果只有一行或是一列</span></span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">1</span> <span class="keyword">or</span> column == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(grid)</span><br><span class="line">        <span class="comment">## 已經算過</span></span><br><span class="line">        <span class="keyword">elif</span> dp[i][j] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        <span class="comment">## 走到底（終點）</span></span><br><span class="line">        <span class="keyword">elif</span> i == row - <span class="number">1</span> <span class="keyword">and</span> j == column - <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = grid[i][j]</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line"></span><br><span class="line">        right, down = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> j &lt; column - <span class="number">1</span>:</span><br><span class="line">            right = helper(i, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> i &lt; row - <span class="number">1</span>:</span><br><span class="line">            down = helper(i + <span class="number">1</span>, j)</span><br><span class="line">        dp[i][j] = <span class="built_in">min</span>(right, down) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br><span class="line"></span><br><span class="line">    row = <span class="built_in">len</span>(grid)</span><br><span class="line">    column = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [[-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(column)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line">    helper(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="2-3-Iterative-Tabulation">2.3 Iterative + Tabulation</h2><p>接下來我們使用Iterative就不會因為stack size超過導致出錯。這裡我們可以從終點走到起點，一步步計算出所有cell的最佳解，最終走到起點，回傳<code>dp[0][0]</code>就是答案。</p><p><em>建立一個<code>dp</code>的list，裡面的值是當前的最佳解</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">row = <span class="built_in">len</span>(grid)</span><br><span class="line">column = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">dp = [[<span class="number">0</span> * column] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br></pre></td></tr></table></figure><p><em>然後我們從終點慢慢往起點計算</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 最小問題：走到終點</span></span><br><span class="line">        <span class="keyword">if</span> i == row-<span class="number">1</span> <span class="keyword">and</span> j == column - <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = grid[i][j]</span><br><span class="line">        <span class="comment"># 如果在最下排</span></span><br><span class="line">        <span class="keyword">elif</span> i == row - <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = grid[i][j] + dp[i][j+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 如果在最右排 </span></span><br><span class="line">        <span class="keyword">elif</span> j == column - <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = grid[i][j] + dp[i+<span class="number">1</span>][j]</span><br><span class="line">        <span class="comment"># 其他狀況，因為我們要走回起點，所以不是往上i+1就是往左j+1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br></pre></td></tr></table></figure><p><em>最後完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum3</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    row = <span class="built_in">len</span>(grid)</span><br><span class="line">    column = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> * column] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line">    <span class="comment"># 開始找</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == row-<span class="number">1</span> <span class="keyword">and</span> j == column - <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = grid[i][j]</span><br><span class="line">            <span class="keyword">elif</span> i == row - <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == column - <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i+<span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br><span class="line">    <span class="comment"># 回傳</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>他還有另一個變化，如果不想要寫這麼多<code>if else</code>可以把<code>dp</code>都塞<code>flout('inf')</code>，並且在第一次塞<code>dp</code>也就是塞終點的時候，在比較<code>min</code>的時候，確保第一次比較的值是<code>0</code>即可。大概要做以下工作：</p><ul><li>多擴展一層，這樣for loop的時候<code>i+1</code>跟<code>j+1</code>不會超過邊界</li><li>然後塞終點到<code>dp</code>時，要確保第一個比較的值是0也就是<code>dp[row-1][column] = 0</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row, column = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 多擴展一層，就不需要做這麼多判斷了</span></span><br><span class="line">dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (column + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row + <span class="number">1</span>)]</span><br><span class="line">dp[row-<span class="number">1</span>][column] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p><em>for loop從終點開始往起點塞dp</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 塞 dp[終點] 時可以確保 grid[i][j] + min(0, inf) = grid[i][j]</span></span><br><span class="line">        dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br></pre></td></tr></table></figure><p><em>完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum3_2</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    row, column = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 多擴展一層，就不需要做這麼多判斷了</span></span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (column + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row + <span class="number">1</span>)]</span><br><span class="line">    dp[row-<span class="number">1</span>][column] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 開始找</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j])</span><br><span class="line">    <span class="comment"># 回傳</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="2-4-Iterative-with-Constant-Space">2.4 Iterative with Constant Space</h2><p>最後老樣子，我們能不能讓<code>dp</code>的空間更省，其實當我們計算完一排row時，我們只會用到上一排計算完row的值，上上次的就不會用到了，因此<code>dp</code>的row其實只要兩排就好了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">row, column = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (column+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]   <span class="comment"># 只需要兩排</span></span><br><span class="line">dp[<span class="number">0</span>][column] = <span class="number">0</span>   <span class="comment"># 只有第一次為了紀錄終點到dp 會需要寫成0</span></span><br></pre></td></tr></table></figure><p>但是要注意的是，我們每次走完一排，就要把算完的<code>dp[0]</code>更新到<code>dp[1]</code>並且，<code>dp[0][column]</code>要設定為<code>flout('inf')</code>，這樣下一次才能正確的更新<code>dp[0][j]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = grid[i][j] + <span class="built_in">min</span>(dp[<span class="number">0</span>][j + <span class="number">1</span>], dp[<span class="number">1</span>][j])</span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">0</span>]</span><br><span class="line">    dp[<span class="number">0</span>][column] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 其他狀況，要記得使用inf，才可以抓到替換到下一排的資料</span></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><em>完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minPathSum4</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    row, column = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (column+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][column] = <span class="number">0</span>   <span class="comment"># 只有第一次為了紀錄終點到dp 會需要寫成0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 開始找</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(column - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = grid[i][j] + <span class="built_in">min</span>(dp[<span class="number">0</span>][j + <span class="number">1</span>], dp[<span class="number">1</span>][j])</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">0</span>][column] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 其他狀況，要記得使用inf，才可以抓到替換到下一排的資料</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>看到這種matrix要找到最佳路徑有幾個準則：</p><ul><li>Recursive: <code>min(左邊, 下面)+當前</code> 就可以找到最佳解</li><li>Interative: 從終點開始往起點找到最佳解</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #120 Triangle - 刷題之旅</title>
      <link href="/posts/leetcode-120-Triangle/"/>
      <url>/posts/leetcode-120-Triangle/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/DVg3yvc.png" alt=""><br><img src="https://i.imgur.com/UONjAwx.png" alt=""></p><p>給定一個三角形，找到從頂部到底部的最小路徑和。每一步只能移動到下一行的相鄰元素上。</p><h1 id="2-解法">2 解法</h1><p>其實這題與<a href="leetcode-300-Longest-Increasing-Subsequence">leetcode #300 Longest Increasing Subsequence</a>有點類似，如果我們嘗試用樹狀圖，把所有可能寫出來，如果今天題目是<code>[[1], [2,3], [4,5,6], [7,8,9,10]]</code>大概會長以下這樣：<br><img src="https://i.imgur.com/j52Y1LN.png" alt=""></p><p>特徵如下：</p><ul><li>從底部慢慢往上走，算出每層由下往上的最佳解</li><li>dp 的值是由下往上的最佳解</li></ul><h2 id="2-1-Recursion">2.1 Recursion</h2><p>但我們先慢慢來吧，先寫出Recursion的寫法。他的問題也是經典的拿與不拿問題。題目可以看到，如果我這一層layer取i，那我下一層layer只能取i或是i+1，這兩個選最小的。</p><p><em>其實Recursive的關係式</em><br>(helper是recursive的function)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(helper(layer+<span class="number">1</span>, i), helper(layer+<span class="number">1</span>, i+<span class="number">1</span>)) + triangle[layer][i]</span><br></pre></td></tr></table></figure><p>那最小問題基本上就是當已經走到底了，直接回傳<code>triangle[layer][i]</code>，因為這時候就是最底層了，不用再往下走了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index 從 0 開始記得 -1 </span></span><br><span class="line"><span class="keyword">if</span> layer == <span class="built_in">len</span>(triangle) - <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> triangle[layer][i]</span><br></pre></td></tr></table></figure><p><em>完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minimumTotal</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">layer: <span class="built_in">int</span>, idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最小問題</span></span><br><span class="line">        <span class="keyword">if</span> layer == <span class="built_in">len</span>(triangle)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[layer][idx]</span><br><span class="line">        <span class="comment"># 關係式</span></span><br><span class="line">        <span class="keyword">return</span> triangle[layer][idx] + <span class="built_in">min</span>(helper(layer+<span class="number">1</span>, idx), helper(layer+<span class="number">1</span>, idx+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最後回傳從底部累加到頂部的最小值</span></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-Recursion-Memoization">2.2 Recursion + Memoization</h2><p>接下來我們就是要加上Memoization，這樣就不用一直重複計算了。這裡我們可以用一個<code>dp</code>的list來記錄已經計算過的值，我們可以先建立一個與<code>triangle</code>一樣大小的list，然後每次計算過的值就存進去，下次再遇到就直接回傳。</p><p><em>建立一個<code>dp[layer][idx]</code>是當前的從底部走上去的最佳解</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle))]</span><br></pre></td></tr></table></figure><p><em>當發現dp不是0時，直接回傳</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> dp[layer][idx] != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> dp[layer][idx]</span><br></pre></td></tr></table></figure><p><em>完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~<span class="keyword">def</span> <span class="title function_">minimumTotal2</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">layer: <span class="built_in">int</span>, idx: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 如果已經計算過，直接回傳</span></span><br><span class="line">        <span class="keyword">if</span> dp[layer][idx] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[layer][idx]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最小問題</span></span><br><span class="line">        <span class="keyword">if</span> layer == <span class="built_in">len</span>(triangle)-<span class="number">1</span>:</span><br><span class="line">            dp[layer][idx] = triangle[layer][idx]</span><br><span class="line">            <span class="keyword">return</span> dp[layer][idx]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 關係式</span></span><br><span class="line">        dp[layer][idx] = triangle[layer][idx] + <span class="built_in">min</span>(helper(layer+<span class="number">1</span>, idx), helper(layer+<span class="number">1</span>, idx+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[layer][idx]</span><br><span class="line"></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle))]</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-Iterative-Tabulation">2.3 Iterative + Tabulation</h2><p>既然從底部走上去，我們可以從底部開始往上走，這樣就不用一直遞迴了。我們可以從倒數第二層開始，然後往上走，每一層都是取最小的值加上自己，這樣就可以得到最後的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minimumTotal3</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[i]))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle))]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 從底部往上走</span></span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每一層的每一個值</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[layer])):</span><br><span class="line">            <span class="comment"># 最小問題 先把底部的值存進去 dp </span></span><br><span class="line">            <span class="keyword">if</span> layer == <span class="built_in">len</span>(triangle)-<span class="number">1</span>:</span><br><span class="line">                dp[layer][idx] = triangle[layer][idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[layer][idx] = triangle[layer][idx] + <span class="built_in">min</span>(dp[layer+<span class="number">1</span>][idx], dp[layer+<span class="number">1</span>][idx+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="2-4-Iterative-Tabulation-Space-Optimized">2.4 Iterative + Tabulation (Space Optimized)</h2><p>其實我們可以發現，我們每次只會用到下一層的值，所以我們可以只用一個list來存下一層的值，這樣就可以省下空間。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minimumTotal4</span>(<span class="params">self, triangle: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># dp 只建立最長的那一層數量</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[-<span class="number">1</span>]))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(triangle[layer])):</span><br><span class="line">            <span class="keyword">if</span> layer == <span class="built_in">len</span>(triangle)-<span class="number">1</span>:</span><br><span class="line">                dp[idx] = triangle[layer][idx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[idx] = triangle[layer][idx] + <span class="built_in">min</span>(dp[idx], dp[idx+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>其實還有更扯的，不需要建立<code>dp</code>，直接用<code>triangle</code>就可以了，因為我們每次都會更新<code>triangle</code>的值，所以不用另外建立一個list。<br>雖然他會改動到原本的<code>triangle</code>，但是到最後整個<code>triangle</code>的值就是從底部走上去的最佳解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minimumTotal5</span>(<span class="params">self, dp: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(dp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp[i])):</span><br><span class="line">            dp[i][j] += <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題我很有成就感，自己大概15分鐘就可以寫出Recursion + Memoization的解法，然後再花了10分鐘寫出Iterative + Tabulation的解法，這樣就可以了。這題其實很簡單，只要從底部往上走，每一層都取最小的值加上自己，這樣就可以得到最後的答案。</p><p>只要是take與不take的問題，我發現我已經慢慢可以習慣了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>機器學習 - 如何提高分類器的準確度</title>
      <link href="/posts/ml-improving/"/>
      <url>/posts/ml-improving/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><ul><li><a href="https://wenku.csdn.net/answer/0da02e355b07448c849b7258d528b049?ydreferer=aHR0cHM6Ly93d3cuYmluZy5jb20v">CSND | 提高SVM分類器的準確率</a></li></ul><p>目前，因為論文的主要題目是做法律文件的機器學習分類，但是因為資料量少，碰到一點瓶頸。所以整理了一些提高分類器準確度的方法，但是注意的是本篇內容主要針對傳統的機器學習像是SVM, RF, NB等，並非Deep Learning。主要有以下：</p><ol><li>特徵工程：選擇更好的特徵</li><li>調整超參數：可以透過找到最佳的超參數組合，來提高分類器的準確率</li><li>數據清洗與預處理：數據清洗是機器學習中非常重要的一個環節，數據清洗的好壞直接影響到模型的準確率</li><li>使用核函數：有些模型像是SVM可以使用不同的核函數，來提高分類器的準確率，例如線性核函數、多項式核函數、高斯核函數等</li><li>集成學習：使用集成學習如Bagging、Boosting等方法，來提高分類器的準確率</li><li>增加訓練數據：增加訓練數據，可以提高分類器的準確率，特別是針對複雜的問題</li></ol><h1 id="調整超參數">調整超參數</h1><p>你是否曾經覺得模型有太多的超參數而感到厭煩嗎？要從某一個演算法得到好的解必須要調整超參數，所謂的超參數就是控制訓練模型的一組神秘數字，例如學習速率就是一種超參數。你永遠都不知道 0~1 之間哪一個數字是最適合的，唯一的方法就是試錯 (trial and error)。那萬一模型有多個超參數可以控制，豈不是就有成千上萬種組合要慢慢嘗試嗎？</p><h2 id="GridSearchCV">GridSearchCV</h2><ul><li><a href="https://ntudac.medium.com/python-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-%E4%BA%A4%E5%8F%89%E9%A9%97%E8%AD%89%E8%88%87%E8%B6%85%E5%8F%83%E6%95%B8%E8%AA%BF%E6%95%B4-69a752cb6f65">Medium | 【Python】機器學習 — 交叉驗證與超參數調整</a></li></ul><p>超參數可以使用GridSearchCV來找到最佳的超參數組合，這樣可以提高分類器的準確率。例如SVM的超參數有C、kernel、gamma等，可以使用GridSearchCV來找到最佳的超參數組合。這樣的好處是不需要動手寫for循環，可以自動找到最佳的超參數組合。</p><p>關於<a href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html#gridsearchcv">GridSearchCV</a>的使用，可以參考以下的代碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## In many applications, we don&#x27;t abuse test set like that</span></span><br><span class="line"><span class="comment">## we use cross validation to replace multiple evaluations on test set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## To do CV, there is no need to write multiple loops all by myself</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line">parameters_to_search = &#123;<span class="string">&#x27;learning_rate&#x27;</span>: learning_rates, </span><br><span class="line">              <span class="string">&#x27;min_samples_leaf&#x27;</span>: min_samples_leafs&#125;</span><br><span class="line"></span><br><span class="line">gb_model = GradientBoostingRegressor(n_estimators = <span class="number">300</span>, </span><br><span class="line">                                     subsample = <span class="number">0.7</span>,</span><br><span class="line">                                    n_iter_no_change = <span class="number">10</span>,</span><br><span class="line">                                     random_state = randomState)</span><br><span class="line"></span><br><span class="line">gb_model_CV = GridSearchCV(gb_model, parameters_to_search, cv=<span class="number">5</span>)</span><br><span class="line">gb_model_CV.fit(X_train.fillna(-<span class="number">1</span>), y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## the gridcv module run the models and save the results for us</span></span><br><span class="line">gb_model_CV.cv_results_</span><br><span class="line"></span><br><span class="line"><span class="comment">## the mean of 5-folds test(not true test) R2</span></span><br><span class="line">gb_model_CV.cv_results_[<span class="string">&quot;mean_test_score&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## the best one is learning_rate=0.18999999999999997, min_samples_leaf=5</span></span><br><span class="line">gb_model_CV.best_estimator_</span><br></pre></td></tr></table></figure><h2 id="Optuna">Optuna</h2><ul><li><a href="https://ithelp.ithome.com.tw/articles/10276835">iThelp | [Day 21] 調整模型超參數利器 - Optuna</a></li></ul><p>你可能聽過 Sklearn 的 GridSearchCV 同樣也是暴力的找出最佳參數，或是使用 RandomizedSearchCV 指定超參數的範圍並隨機的抽取參數進⾏訓練，其它們的<em>共同缺點是非常耗時與佔用機器資源</em>。這裡我們要來介紹 Optuna 這個自動找超參數的方便工具，並且可以和多個常用的機器學習演算法整合。<br>Optuna 是一個專為機器學習設計的自動超參數優化的框架，有以下優點：</p><ol><li>支援大多數ML或DL框架：Optuna 支援大多數的機器學習或深度學習框架，包括 Scikit-learn、PyTorch、TensorFlow、XGBoost、LightGBM 等。</li><li>對搜尋結果提供可解釋性(XAI)</li><li>儲存歷史最佳參數實現平行優化</li><li>可以決定並終止不滿足條件的試驗</li></ol><p>我參考了上面的連結，整理一下Optuna的使用方法</p><ul><li><code>trial</code> 設定我們的目標，以下面為例就是找到Accuracy的最大值<code>maximize</code></li><li><code>objective</code> 定義要針對什麼模型進行處理，最後回傳accuracy，讓Optuna檢查目前的準確度是否是最小值了</li><li><code>study</code> 進行50次試驗，找到最佳的超參數，可以使用<code>study.best_params</code>來獲取最佳的超參數</li></ul><p><em>相關的參數可以參考<a href="https://xgboost.readthedocs.io/en/latest/parameter.html">XGBoost官方</a></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 引入相關套件 pip install optuna </span></span><br><span class="line"><span class="keyword">import</span> optuna</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objective</span>(<span class="params">trial</span>):</span><br><span class="line">    <span class="comment"># 2. 想要控制哪些參數 &quot;參數名稱&quot;, &quot;參數範圍&quot;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;eta&#x27;</span>: trial.suggest_float(<span class="string">&quot;eta&quot;</span>, <span class="number">1e-8</span>, <span class="number">1.0</span>, log=<span class="literal">True</span>),</span><br><span class="line">        <span class="string">&#x27;alpha&#x27;</span>: trial.suggest_float(<span class="string">&#x27;alpha&#x27;</span>, <span class="number">1e-8</span>, <span class="number">1.0</span>, log=<span class="literal">True</span>),</span><br><span class="line">        <span class="string">&#x27;lambda&#x27;</span>: trial.suggest_float(<span class="string">&#x27;lambda&#x27;</span>, <span class="number">1e-8</span>, <span class="number">1.0</span>, log=<span class="literal">True</span>),</span><br><span class="line">        <span class="string">&#x27;grow_policy&#x27;</span>: trial.suggest_categorical(<span class="string">&quot;grow_policy&quot;</span>, [<span class="string">&quot;depthwise&quot;</span>, <span class="string">&quot;lossguide&quot;</span>]),</span><br><span class="line">        <span class="string">&#x27;n_estimators&#x27;</span>: trial.suggest_int(<span class="string">&#x27;n_estimators&#x27;</span>, <span class="number">50</span>, <span class="number">500</span>),</span><br><span class="line">        <span class="string">&#x27;max_depth&#x27;</span>: trial.suggest_int(<span class="string">&#x27;max_depth&#x27;</span>, <span class="number">3</span>, <span class="number">10</span>),</span><br><span class="line">        <span class="string">&#x27;learning_rate&#x27;</span>: trial.suggest_float(<span class="string">&#x27;learning_rate&#x27;</span>, <span class="number">0.01</span>, <span class="number">0.3</span>),</span><br><span class="line">        <span class="string">&#x27;subsample&#x27;</span>: trial.suggest_float(<span class="string">&#x27;subsample&#x27;</span>, <span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;colsample_bytree&#x27;</span>: trial.suggest_float(<span class="string">&#x27;colsample_bytree&#x27;</span>, <span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        <span class="string">&#x27;gamma&#x27;</span>: trial.suggest_float(<span class="string">&#x27;gamma&#x27;</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">        <span class="string">&#x27;min_child_weight&#x27;</span>: trial.suggest_int(<span class="string">&#x27;min_child_weight&#x27;</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 初始化並訓練XGBoost模型</span></span><br><span class="line">    xgb_model = XGBClassifier(</span><br><span class="line">        **params,</span><br><span class="line">        use_label_encoder=<span class="literal">False</span>, </span><br><span class="line">        eval_metric=<span class="string">&#x27;mlogloss&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    xgb_model.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 預測並計算精確度作為目標</span></span><br><span class="line">    y_pred_xgboost = xgb_model.predict(X_test)</span><br><span class="line">    accuracy = accuracy_score(y_test, y_pred_xgboost)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 使用optuna進行超參數調整</span></span><br><span class="line">study = optuna.create_study(direction=<span class="string">&#x27;maximize&#x27;</span>)  <span class="comment"># 我們想要最大化精確度</span></span><br><span class="line">study.optimize(objective, n_trials=<span class="number">50</span>)  <span class="comment"># 進行50次試驗</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 獲取最佳超參數</span></span><br><span class="line">best_params = study.best_params</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best hyperparameters: &quot;</span>, best_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 使用最佳超參數訓練最終模型</span></span><br><span class="line">xgb_model = XGBClassifier(</span><br><span class="line">    **best_params,</span><br><span class="line">    use_label_encoder=<span class="literal">False</span>, </span><br><span class="line">    eval_metric=<span class="string">&#x27;mlogloss&#x27;</span></span><br><span class="line">)</span><br><span class="line">xgb_model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 測試最終模型</span></span><br><span class="line">y_pred_xgboost = xgb_model.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9. 評估最終模型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Accuracy (XGBoost):&quot;</span>, accuracy_score(y_test, y_pred_xgboost))</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred_xgboost, target_names=label_encoder.classes_))</span><br></pre></td></tr></table></figure><p>我們還可以使用<code>optuna.visualization</code>來視覺化最佳參數的分布，例如：</p><ul><li>plot_optimization_history (視覺化優化的過程)</li><li>plot_intermediate_values (視覺化學習的曲線)</li><li>plot_parallel_coordinate (視覺化高維度中參數間的彼此關係)</li><li>plot_contour (視覺化參數間的彼此關係)</li><li>plot_slice (視覺化個別參數)</li><li>plot_param_importances (參數對模型的重要程度)</li><li>plot_edf (視覺化驗分佈函數)</li></ul><p>這裡我們使用 <code>plot_param_importances</code> 以及 <code>plot_optimization_history</code>來作為例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> optuna.visualization <span class="keyword">import</span> plot_param_importances, plot_optimization_history</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10. Optuna 視覺化：參數重要性</span></span><br><span class="line">fig = plot_param_importances(study)</span><br><span class="line">plotly_config = &#123;<span class="string">&quot;staticPlot&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">fig.show(config=plotly_config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 11. Optuna 視覺化：優化歷史</span></span><br><span class="line">fig = plot_optimization_history(study)</span><br><span class="line">fig.show(config=plotly_config)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/wFpoYWb.png" alt=""><br>我們可以從下圖看到大概第25次的時候就已經找到最大的精準度了，並且<code>min_child_weight</code>是影響性最大的參數。</p><h1 id="特徵工程">特徵工程</h1><h1 id="關於集成學習">關於集成學習</h1><h1 id="參考資料">參考資料</h1>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Biweekly Contest #Find the Power of K-Size Subarrays - 打怪開始</title>
      <link href="/posts/contest-137-Q1-Find-the-Power-of-K-Size-Subarrays/"/>
      <url>/posts/contest-137-Q1-Find-the-Power-of-K-Size-Subarrays/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/IgWuwKn.png" alt=""></p><p>這是我的第一次參加 LeetCode Contest，這次的題目是一道簡單的滑動窗口問題，給定一個數組<code>nums</code>和一個整數<code>k</code>，你需要針對大小為 k 的所有子陣列計算它們的 “power”：</p><ol><li>如果子陣列的所有元素是連續且按升序排列，則該子陣列的 power 是其最大元素。</li><li>如果子陣列的元素不符合條件，則返回 -1。</li></ol><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>我一開始的想法很簡單，我需要有一個function負責檢查是否為連續且按升序排列，如果是就返回最後一個數值，如果不是就返回-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">sub_nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">        <span class="keyword">if</span> sub_nums[j - <span class="number">1</span>] + <span class="number">1</span> != sub_nums[j]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sub_nums[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>接下來我們只要根據 k 的長度，把數組分成大小為 k 的子陣列，然後檢查每個子陣列是否符合條件，如果符合就找出最大值，如果不符合就返回-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resultsArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    N = len(nums)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    time: O(N*K)</span></span><br><span class="line"><span class="string">    space: O(N-k+1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">sub_nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">            <span class="keyword">if</span> sub_nums[j - <span class="number">1</span>] + <span class="number">1</span> != sub_nums[j]:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sub_nums[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> i + k &lt;= <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(helper(nums[i:i + k]))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>但是以上的時間複雜度是 O(N*K)，<strong>有沒有辦法可以得到時間複雜度是 O(N) 呢？</strong></p><h2 id="2-2-進階解法">2.2 進階解法</h2><p>他有個很重要的概念，什麼樣的狀況可以是可以紀錄當前的值，而非 -1 呢？<br><em>所謂的合格是，兩個值，要連續且按升序排列</em></p><ol><li>當前的值，與前一個值相差 1（合格）</li><li>並且，過去從<code>i - k</code>開始，往後的數值到 <code>i</code> 為止，都是連續且按升序排列</li></ol><p>當時我看到有個人的解法是，他用了一個變數<code>bad</code>來記錄，從上面的條件來看，如果<em>當前的值不是連續升序時，這個影響必須後面連續 k 個值</em>，只有在被影響的要素慢慢消除時，才可以反回當前的值（也就是最大值），從這裡可以看到就有點像是一個累積毒素的感覺。</p><ol><li>當檢查到當下的值不符合條件時，我們就要把<code>bad</code>的值<code>+1</code>，這就身體沈澱的毒素。</li><li>那我們什麼時候變得健康呢？那就是當我們的毒素都清理乾淨後<code>bad==0</code>。<ul><li>我們要確保前面從 <code>i - k</code> 開始到<code>i</code>的都沒有毒素，如果遇到毒素</li><li>其實只要<code>bad</code>不要增加持續一段時間即可，也就是說當遇到毒素時，<code>bad+=1</code>當遇到健康的時候<code>bad-=1</code></li></ul></li><li><code>bad</code>可能會有2種狀態<ul><li><code>bad &gt; 0</code>：代表我們有毒素，因此我們要回傳<code>-1</code></li><li><code>bad == 0</code>：代表我們健康，我們要紀錄當前的值<code>nums[i]</code></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resultsArray3</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 如果 k == 1，直接返回 nums 即為答案</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    bad = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 從 1 開始，因為我們要從第二個數字開始往後比較</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 健康當前是健康的</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] - <span class="number">1</span> == nums[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 但是身體有毒素 bad &gt; 0，因爲當下是健康的，所以毒素-1</span></span><br><span class="line">            <span class="keyword">if</span> bad &gt; <span class="number">0</span>:</span><br><span class="line">                bad -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不健康！如果當前的值不是連續升序，我們就要增加毒素</span></span><br><span class="line">            bad += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 從 k - 1 開始記錄 </span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 如果毒素為 0，代表我們健康，記錄當前的值否則返回 -1</span></span><br><span class="line">            res.append(nums[i] <span class="keyword">if</span> bad == <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上面的邏輯可能會通過題目的三個測試，但是如果我們碰到<code>[5, 5, 5, 5, 5, 1, 2, 3, 4]</code> 就是前面簡直就是垃圾人生，吃一堆毒素…，導致後面儘管很健康，但是也清理不掉毒素，可是這不是我們要的結果！我們希望，只要確保前<code>k</code>個值沒有毒素就好。</p><p><img src="https://i.imgur.com/8V7Frf9.png" alt=""></p><p>從上圖來看，我們希望<code>i=7</code>時，<code>bad</code>是歸零的狀態因為<code>[1, 2, 3]</code>是合法的，當<code>bad==0</code>時我們才可以把<code>nums[7]</code>塞到<code>res</code>裡面。這意味著，為了確保遍歷到<code>i=7</code>時<code>bad</code>是歸零的，也就是說我們上面的程式碼要對<code>bad+=1</code>的時機做調整。</p><p><img src="https://i.imgur.com/zhT58mY.png" alt=""></p><p>你會看到上圖中，我們共畫了5個箭頭，我們要知道只要確保前<code>k</code>個值沒有毒素就好，也就是說<em>如果毒素離<code>i</code>太遠，就會自動代謝掉，就是要毒素自動<code>-1</code></em>。</p><ul><li>從<code>i=3</code>時<code>bad</code>已經累積了3<code>(1+1+1)</code>個毒素<ul><li>我們往前看距離<code>k</code>的位置<code>i=1</code>時，發現當時毒素有<code>+1</code></li><li>但是其實<code>i=1</code>已經距離<code>i=4</code>太遠了！這個毒素的影響性應該要代謝掉</li><li>我們只關心前<code>k</code>個值是否有毒素，所以我們這時候應該 <code>-1</code>把這個太過於遙遠的毒素代謝掉</li><li>最後<code>bad</code>變成<code>(1+1+1)-1=2</code></li></ul></li><li>從<code>i=4</code>時<code>bad</code>此時是3<code>(2+1)</code><ul><li>因為上一個殘留的毒素是2，加上當前<code>i=4</code>是不健康的所以<code>+1</code></li><li>我們往前看距離<code>k</code>的位置<code>i=2</code>時，發現當時毒素有<code>+1</code></li><li>但是其實<code>i=2</code>已經距離<code>i=5</code>太遠了！這個毒素的影響性應該要被代謝掉了</li><li>我們只關心前<code>k</code>個值是否有毒素，所以我們這時候應該 <code>-1</code>，把這個太過於遙遠的毒素代謝掉</li><li>最後<code>bad</code>變成<code>(2+1)-1=2</code></li></ul></li><li>從<code>i=5</code>時<code>bad</code>此時仍是3<code>(2+1)</code><ul><li>因為上一個殘留的毒素是2，加上當前<code>i=5</code>是不健康的所以<code>+1</code></li><li>我們往前看距離<code>k</code>的位置<code>i=3</code>時，發現當時毒素有<code>+1</code>，但是其實<code>i=3</code>已經距離<code>i=6</code>太遠了！這個毒素的影響性應該要代謝掉</li><li>我們只關心前<code>k</code>個值是否有毒素，所以我們這時候應該 <code>-1</code>，把這個太過於遙遠的毒素代謝掉</li><li>最後<code>bad</code>變成<code>(2+1)-1=2</code></li></ul></li><li>從<code>i=6</code>時<code>bad</code>此時是2<code>(2+0)</code><ul><li>因為上一個殘留的毒素是2，加上當前<code>i=6</code>是健康的所以<code>+0</code></li><li>我們往前看距離<code>k</code>的位置<code>i=4</code>時，發現當時毒素有<code>+1</code>，但是其實<code>i=4</code>已經距離<code>i=6</code>太遠了！這個毒素的影響性應該要代謝掉</li><li>我們只關心前<code>k</code>個值是否有毒素，所以我們這時候應該 <code>-1</code>，把這個太過於遙遠的毒素代謝掉</li><li>最後<code>bad</code>變成<code>(2)-1=1</code></li></ul></li><li>從<code>i=7</code>時<code>bad</code>此時是1<code>(1+0)</code><ul><li>因為上一個殘留的毒素是1，加上當前<code>i=7</code>是健康的所以<code>+0</code></li><li>我們往前看距離<code>k</code>的位置<code>i=5</code>時，發現當時毒素有<code>+1</code>，但是其實<code>i=5</code>已經距離<code>i=7</code>太遠了！這個毒素的影響性應該要代謝掉</li><li>我們只關心前<code>k</code>個值是否有毒素，所以我們這時候應該 <code>-1</code>，把這個太過於遙遠的毒素代謝掉變成<code>(1)-1=0</code></li><li>這時候我們<code>bad==0</code>就可以把<code>nums[i]</code>塞到<code>res</code>裡面。</li></ul></li></ul><div class="note info flat"><p>你會發現一個點，<code>bad+=1</code>的時機是：<br><strong>往回看<code>nums[i-k+1]</code>這個值，是否為不健康，但是因為已經過太久了，應該被代謝掉</strong><br><strong>怎麼知道不健康？也就是說<code>nums[i-k+1]</code>與<code>nums[i-k]</code>在比較時否為連續升序？</strong></p></div><p><em>bad+=1的時機可以寫成這樣(要注意範圍不要變成負的 <code>i&gt;=k</code>)</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># i-k+1 看最久遠的病毒，如果是不健康，但是已經過太久，應該代謝掉(-1)</span></span><br><span class="line"><span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> nums[i-k+<span class="number">1</span>] - <span class="number">1</span> != nums[i-k]:</span><br><span class="line">    bad -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>那我們重新調整一下程式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resultsArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    bad = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 從 1 開始，因為我們要從第二個數字開始往後比較</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># &quot;增加毒素&quot;的時機：如果當前的值 - 1 不等於前一個值，但表不健康</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] - <span class="number">1</span> != nums[i - <span class="number">1</span>]:</span><br><span class="line">            bad += <span class="number">1</span></span><br><span class="line">        <span class="comment"># &quot;減少毒素&quot;的時機：往回看 nums[i-k+1] 這個值，是否為不健康</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> nums[i-k+<span class="number">1</span>] - <span class="number">1</span> != nums[i-k]:</span><br><span class="line">            bad -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            res.append(nums[i] <span class="keyword">if</span> bad == <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>還可以更精簡喔，下面是世界選手最簡潔的程式碼：</p><p><em>我們是否可以利用False的特性，直接加在bad上，這樣就不用判斷了！</em></p><ul><li>True: 代表 0</li><li>False: 代表 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resultsArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    bad = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 我們透過 False 來判斷是否要增加毒素 +1 </span></span><br><span class="line">        bad += nums[i] - <span class="number">1</span> != nums[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">            <span class="comment"># 我們透過 False 來判斷是否要減少毒素 -1</span></span><br><span class="line">            bad -= nums[i-k+<span class="number">1</span>] - <span class="number">1</span> != nums[i-k]</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            res.append(nums[i] <span class="keyword">if</span> bad == <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3-結語">3 結語</h1><p>這個題目的解法是我看到別人排名很前面的人寫出來的，因為我還沒刷過sliding window的題目，所以當時完全沒想到這個解法，這次的比賽讓我學到了很多，希望下次可以更好。</p><h1 id="4-參考">4 參考</h1><ul><li><a href="https://leetcode.com/contest/biweekly-contest-137/ranking/">Biweekly Contest 137 - Ranking</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 周賽 </category>
          
          <category> Sliding Window </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Sliding Window </tag>
            
            <tag> Leetcode Contest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #300 Longest Increasing Subsequence - 刷題之旅</title>
      <link href="/posts/leetcode-300-Longest-Increasing-Subsequence/"/>
      <url>/posts/leetcode-300-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/AkvECnS.png" alt=""></p><p>給定一個整數數組<code>nums</code>，找到一個最長的遞增子序列的長度。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-Recursion">2.1 Recursion</h2><p>這題是DP問題，假設我們有一組數字<code>[1, 2, 3, 7, 4, 5, 6]</code> 我們需要比較<code>當前的值 nums[i]</code>是否比<code>上一個值 last</code>還要大，當滿足條件的時候，我們就要思考一個問題到底是**要把當前的值考量進去，還是跳過當前的？**這就會牽涉到兩個公式，類似背包問題，偷與不偷，那這裡就是塞與不塞：</p><ul><li>塞： <code>1塞(當前值) + 未來的最佳解</code></li><li>不塞： <code>不塞 + 未來的最佳解</code></li></ul><p>以上述的例子來說，如果我們走到 <code>7</code> 的時候，我們可以選擇塞或不塞</p><ul><li>如果塞的話，未來的最佳解都是 0，因為沒有比<code>7</code>大的值了</li><li>如果不塞的話，後面還有<code>4, 5, 6</code>可以選擇</li></ul><p>這樣的話我們可以得出一個公式，假設i是當前的值：</p><ul><li>塞： <code>1 + helper(nums[i+1:])</code></li><li>不塞： <code>helper(nums[i+1:])</code></li></ul><p>但是還有一個問題需要考慮，就是我們在往後比較的時候，需要知道被比較的對象是誰，舉例來說一樣從<code>7</code>開始</p><ul><li>塞：那後續與<code>4, 5, 6</code>比較的就是<code>7</code></li><li>不塞：那後續與<code>4</code>比較的就是<code>3</code>，與<code>5</code>比較的就是<code>4</code>以此類推，會隨著<code>i</code>的變化而變化<br>而上面這個被後續比較的對象就是<code>last</code>，所以我們的公式就變成：</li><li>塞： <code>1 + helper(nums[i], nums[i+1:])</code></li><li>不塞： <code>helper(last, nums[i+1:])</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">last, i</span>):</span><br><span class="line">        <span class="comment"># 終止條件 走到底了</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 當前值 e.g. 7 </span></span><br><span class="line">        cur = nums[i]</span><br><span class="line">        take = <span class="number">0</span></span><br><span class="line">        <span class="comment"># last=3, cur=7 如果發現可以塞的話，我們就要比較塞與不塞的最大值</span></span><br><span class="line">        <span class="keyword">if</span> cur &gt; last:</span><br><span class="line">            <span class="comment"># 塞：(計數+1) + 後續的最佳解(此時last變成cur, 與下一個(i+1)比較</span></span><br><span class="line">            take = <span class="number">1</span> + helper(cur, i+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 不塞：不計數 + 後續的最佳解(此時last不變繼續傳下去比較, 與下一個(i+1)比較)</span></span><br><span class="line">        not_take = helper(last, i+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 取最大值：塞與不塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(take, not_take)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="2-1-Recursion-with-Memoization">2.1 Recursion with Memoization</h2><p>上面的解法是遞迴，但是遞迴的問題就是會有很多重複的計算，所以我們可以用memoization來解決這個問題，這樣就不用重複計算了。我們從上面可以發現<code>i</code>是慢慢增長的，所以我們如果可以儲存不同長度且不同last時的最佳解，那就可以避免重複計算。</p><p>我們儲存<code>dp[(last, i)]=max(take, not_take)</code>，這樣就可以知道在不同長度的狀況下，最佳解是多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    dp = &#123;&#125;  <span class="comment"># 使用字典來進行記憶化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">last, i</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果這個子問題已經計算過，則直接返回結果</span></span><br><span class="line">        <span class="keyword">if</span> (last, i) <span class="keyword">in</span> dp:</span><br><span class="line">            <span class="keyword">return</span> dp[(last, i)]</span><br><span class="line">        cur = nums[i]</span><br><span class="line">        <span class="keyword">if</span> cur &gt; last:</span><br><span class="line">            add = <span class="number">1</span> + helper(cur, i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            add = <span class="number">0</span></span><br><span class="line">        not_add = helper(last, i + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 記錄結果</span></span><br><span class="line">        dp[(last, i)] = <span class="built_in">max</span>(add, not_add)</span><br><span class="line">        <span class="keyword">return</span> dp[(last, i)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> helper(<span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-Iterative-Tabulation">2.2 Iterative + Tabulation</h2><p>接下來我們需要使用迭代的方式來解決這個問題。這題我是參考<a href="https://youtu.be/cjWnW0hdF1Y?si=xlgyyOycrkcA5uu8">Youtube | Neetcode</a>介紹得非常詳細。首先，他是一個拿與不拿的問題，因此我們使用比較簡單的例子<code>[1,2,4,3]</code>先畫個樹狀圖來看一下有哪些狀況，不用全部畫出來，我們就先繪製出第一個到底的狀況就好如下圖：</p><p><img src="https://i.imgur.com/OXPaleO.png" alt=""><br>首先你會發現:</p><ul><li><code>LTS[3]</code>因為<code>i=3</code>已經是最底了，基本上從<code>3</code>往後看只會有自己一個長度，因此 <code>LTS[3]=1</code>是無庸置疑的。</li><li><code>LTS[2]</code>因為<code>i=2</code>，所以有兩種可能<code>max(1, 1+LTS[3])</code>但是<code>1+LTS[3]</code>只有在<code>nums[2]&gt;nums[3]</code>的情況下才會成立，所以仍然是<code>LTS[2]=1</code></li><li><code>LST[1]</code>因為<code>i=1</code>後面有三種可能<code>max(1, 1+LTS[2], 1+LTS[3])</code>就有點像是<code>max(自己, 自己+id2, 自己+id3)</code>，而<code>i=2</code>因為比後面的數字都還要小，所以<code>自己+id2</code>或<code>自己+id3</code>都成立。因此我們會得到<code>max(1, 1+1, 1+1)=2</code></li><li><code>LST[0]</code>因為<code>i=0</code>後面有四種狀況<code>max(1, 1+LTS[1], 1+LTS[2], 1+LTS[3])</code>，而<code>i=1</code>因為比後面的數字都還要小，所以<code>自己+id1</code>或<code>自己+id2</code>或<code>自己+id3</code>都成立。因此我們會得到<code>max(1, 1+2, 1+1, 1+1)=3</code></li></ul><p>如果你繼續嘗試把其他可能都畫出來，你會發現都已經是重複的狀況：<br><img src="https://i.imgur.com/EAkQJtb.png" alt=""></p><p>從前述講的順序中，我們會發現可以從後面往前面推，然後使用雙層for迴圈，並且時間複雜度是O(n^2)。<br>最外層i是從<code>n-1</code>到<code>0</code>，內層j是從<code>i+1</code>到<code>n</code>，這樣就可以得到所有的狀況，並且可以得到最佳解。<br><img src="https://i.imgur.com/zRa6bUW.png" alt=""></p><p>最後程式碼如下，就解出來了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp = [<span class="number">1</span>]*<span class="built_in">len</span>(nums) <span class="comment"># 至少可以包含自己，一定會有最小值1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 只有在nums[i] &lt; nums[j]的情況下才會更新否則都是自己</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j]:</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], <span class="number">1</span>+dp[j])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><div class="note info flat"><p>時間複雜度：O(n^2)<br>空間複雜度：O(n)</p></div><h2 id="2-3-O-NlogN-Patience-Sort">2.3 O(NlogN) Patience Sort</h2><ul><li><a href="https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/LongestIncreasingSubsequence.pdf">Patience Sort 簡報</a></li><li><a href="https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)">Leetcode Solution</a></li></ul><p>接下來題目要求試試看<code>O(NlogN)</code>其實就要使用Binary Search，但是在使用Binary Search之前，我們需要先了解一下一個超級神奇的演算法！叫做<a href="https://en.wikipedia.org/wiki/Patience_sorting">Patience Sort</a>，他是一個卡牌遊戲，可以幫助我們找到最長的遞增子序列。我們先來介紹卡牌遊戲的規則：</p><p>首先，我們有一組卡牌，規則是：</p><ul><li>如果當前的卡牌比piles的最後一張卡牌還要大，那就直接放到最後一張卡牌的後面</li><li>如果當前的卡牌比piles的最後一張卡牌還要小，那就要找到一張比當前卡牌還要大的卡牌，然後放在上面，如果找不到的話，就要開一個新的pile<br><img src="https://i.imgur.com/s3XxiPt.png" alt=""><br><img src="https://i.imgur.com/XOMxkAH.png" alt=""></li></ul><p><em>最後你會發現，每個piles最上面的卡牌由左到右是遞增的</em><br><img src="https://i.imgur.com/2mmUOnD.png" alt=""></p><p><em>更神奇的事情發生了，這個piles的數量就是最長的遞增子序列的長度！因為每個piles一定可以找到一張牌可以排出遞減的牌組</em><br><img src="https://i.imgur.com/JQB7ylO.png" alt=""><br><img src="https://i.imgur.com/hMyA7m7.png" alt=""></p><p>所以我們用這個卡牌的遊戲規則其實跟我們的地目很像</p><ol><li>有一個無序的卡牌</li><li>然後我們想要知道最長的遞增子序列</li></ol><p>如果我們改一下題目的規則：</p><ol><li>如果當前的卡牌比piles的最後一張卡牌還要小，就要覆蓋該piles的最後一張卡牌</li><li>如果當前的卡牌比piles的最後一張還要大，就建立新的piles</li></ol><p>來重新看一下題目，這樣我們到時候堆疊出來的piles就會長這樣：<br><img src="https://i.imgur.com/79Ugbqh.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">nums = [10,9,2,5,3,7,101,18]</span><br><span class="line"></span><br><span class="line">dp 就像是紀錄每個 pile 的 top，如果發現新的牌比 top 還要大，就直接放在後面（建立新的pile）</span><br><span class="line">一開始我們就直接把10放進去吧，此時pile的數量是1，而該pile的top是10</span><br><span class="line">len   1</span><br><span class="line">dp = [10]</span><br><span class="line"></span><br><span class="line">2----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">    ^  </span><br><span class="line">現在換考慮 9, 9 比pile的top10還要小 更新pile top為9</span><br><span class="line">len   1</span><br><span class="line">dp = [9]    </span><br><span class="line"></span><br><span class="line">3----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">       ^  </span><br><span class="line">現在換考慮 2, 2 比pile的top10還要小 更新pile top為2</span><br><span class="line">len   1</span><br><span class="line">dp = [2]    </span><br><span class="line"></span><br><span class="line">4----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">          ^  </span><br><span class="line">現在換考慮 5, 因為比pile的top2還要大，所以建立新的pile</span><br><span class="line">len   1  2</span><br><span class="line">dp = [2  5]   </span><br><span class="line"></span><br><span class="line">5----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">             ^  </span><br><span class="line">現在換考慮 3, 因為比pile[2]的top5還要小，更新pile[2]的top為3</span><br><span class="line">len   1  2</span><br><span class="line">dp = [2  3]   </span><br><span class="line"></span><br><span class="line">6----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">                ^  </span><br><span class="line">現在換考慮 7, 因為比任何pile的top還要大，所以建立新的pile</span><br><span class="line">len   1  2  3</span><br><span class="line">dp = [2  3  7]  </span><br><span class="line"></span><br><span class="line">7----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">                    ^  </span><br><span class="line">現在換考慮 101, 因為比任何pile的top還要大，所以建立新的pile</span><br><span class="line">len   1  2  3   4</span><br><span class="line">dp = [2  3  7  101]  </span><br><span class="line"></span><br><span class="line">8----------------------------</span><br><span class="line">10  9  2  5  3  7  101  18</span><br><span class="line">                        ^  </span><br><span class="line">現在換考慮 18, 只有pile[4]的top比18還要大，所以更新pile[4]的top為18</span><br><span class="line">len   1  2  3   4</span><br><span class="line">dp = [2  3  7   18] </span><br><span class="line"></span><br><span class="line">最後dp的長度就是最長的遞增子序列</span><br></pre></td></tr></table></figure><p><em>用python來實現如下</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Speed: O(n*n)</span></span><br><span class="line"><span class="string">Space: O(n)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    dp = [nums[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> x &gt; dp[-<span class="number">1</span>]:</span><br><span class="line">            dp.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">                <span class="keyword">if</span> dp[i] &gt;= x:</span><br><span class="line">                    dp[i] = x</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br></pre></td></tr></table></figure><p>但是這樣還是<code>O(N^2)</code>因此我們可以用二分查找來解決這個問題，這樣就可以達到O(NlogN)的時間複雜度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    dp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dp <span class="keyword">or</span> x &gt; dp[-<span class="number">1</span>]:</span><br><span class="line">            dp.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 二分搜尋的演算法 l=left, r=right, mid=middle</span></span><br><span class="line">            l, r = <span class="number">0</span>, <span class="built_in">len</span>(dp)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                mid = l + (r-l)//<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> dp[mid] &lt; x:</span><br><span class="line">                    <span class="comment"># 如果 x 比 dp[mid] 還要小，l 會一直往右移動（變成mid+1）為了不跟 r 重疊，因為r可能是之前的mid</span></span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果 x 比 dp[mid] 還要大，r 會一直往左移動（變成mid）</span></span><br><span class="line">                    r = mid</span><br><span class="line">            dp[l] = x</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br></pre></td></tr></table></figure><p>或是直接使用套件<code>bisect</code>來解決這個問題</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect <span class="keyword">from</span> bisect_left</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    dp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        i = bisect_left(dp, x)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(dp):</span><br><span class="line">            dp.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = bisect_left(dp, x) <span class="comment"># 找到第一個比x大的位置</span></span><br><span class="line">            dp[i] = x  <span class="comment"># 更新</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題真的是我花了2天慢慢想，完全沒想過Patience Sort這種方式來解題目，太神奇拉！！！超愛這題！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #322 Coin Change - 刷題之旅</title>
      <link href="/posts/leetcode-322-Coin-Change/"/>
      <url>/posts/leetcode-322-Coin-Change/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/iRg3o3m.png" alt=""></p><p>給定不同面額的硬幣<code>coin</code>和一個總金額<code>amount</code>，寫一個函數來計算可以製造出總金額的最少硬幣數量。如果無法製造出總金額，則返回<code>-1</code>。</p><h1 id="2-解法">2 解法</h1><p>其實dp的題目中有個共通點，都像是書包題目，為什麼是 dp 問題是因為可以拆分成小問題，而 amount 的小問題基本上就是 <code>range(1, amount+1)</code> 這些範圍如果都能夠找到最佳解ㄝ那自然<code>amount</code>也能找到最佳解。所以我們腦子有個思路，就是我們可以先從<code>1</code>開始。而最小值就是<code>0</code>，因為<code>0</code>元不需要硬幣。</p><p><em>小問題開始</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 dp 碰到 0 的 amount 就是 0</span></span><br><span class="line">dp = &#123;<span class="number">0</span>: <span class="number">0</span>&#125; </span><br><span class="line"><span class="comment"># 因為 range 是不包含最後一個數字，所以要 +1 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>): </span><br><span class="line">    <span class="comment"># 初始化 dp[i] 為無限大</span></span><br><span class="line">    dp[i] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br></pre></td></tr></table></figure><p>接下來，我們假設: <code>amount=11</code> 且 <code>coins=[3, 5]</code>，我們可以看到<code>dp</code>的變化如下：</p><ul><li><code>dp[0] = 0</code></li><li><code>dp[1] = inf</code> 沒有對應的 coin</li><li><code>dp[2] = inf</code> 沒有對應的 coin</li><li><code>dp[3] = 1</code>  因為有 coin 3 可以組成</li><li><code>dp[4] = inf</code> 沒有對應的 coin</li><li><code>dp[5] = 1</code>  因為有 coin 5 可以組成</li><li><code>dp[6] = 2</code>  當 <code>i&gt;coin</code>時基本上有2種可能取最小<ul><li><code>dp[6-3] + dp[3] = 1+1 = 2</code></li><li><code>dp[6-5] + dp[5] = inf+1 = inf</code></li></ul></li><li><code>dp[7] = 2</code>  當 <code>i&gt;coin</code>時基本上有2種可能取最小<ul><li><code>dp[7-3] + dp[3] = 1+1 = 2</code></li><li><code>dp[7-5] + dp[5] = inf+1 = inf</code></li></ul></li><li><code>dp[8] = 2</code>  當 <code>i&gt;coin</code>時基本上有2種可能取最小<ul><li><code>dp[8-3] + dp[3] = 1+1 = 2</code></li><li><code>dp[8-5] + dp[5] = 1+1 = 2</code></li></ul></li></ul><p><img src="https://i.imgur.com/uViugzO.png" alt=""><br>有沒有發現上面有個規律</p><ul><li>當<code>i &gt; coin</code>時，我們可以看到<code>dp[i]</code>的值是<code>dp[i-coin] + dp[coin]</code></li><li>當<code>i &lt; coin</code>時，<code>dp[i]</code>的值是<code>float('inf')</code>，因為無法組成</li><li>當<code>i == coin</code>時，<code>dp[i]</code>的值是<code>1</code>，因為只有一個硬幣就可以組成，但其實他也可以寫成<code>dp[i] = dp[i-coin]+dp[coin]</code>因為會得到<code>dp[0]+dp[coin]</code></li></ul><p>然後所有的<code>dp[coin]</code>都是<code>1</code>，最後回傳值就是<code>dp[amount]</code>，如果<code>dp[amount]</code>是<code>inf</code>就回傳<code>-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp = &#123;<span class="number">0</span>: <span class="number">0</span>&#125; </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">    dp[i] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="keyword">if</span> i == coin:</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &gt; coin:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>) <span class="comment"># dp[i-coin] + dp[coin] = dp[i-coin] + 1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-2-反過來">2.2 反過來</h2><p>如果我們<code>for loop</code>外層先從<code>coin</code>開始，內層再<code>for loop i</code>的好處是不用比較<code>i</code>和<code>coin</code>的大小，因為<code>i</code>一定大於等於<code>coin</code>。<br>可以讓程式碼更簡潔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dp = [<span class="number">0</span>] + [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * amount</span><br><span class="line"><span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>時間複雜度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p><ul><li>n 是 amount</li><li>m 是 coins<br>空間複雜度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li><li>n 是 amount</li></ul><h1 id="3-總結">3 總結</h1><p>所有碰到dp的題目，這種類似的背包問題都有個共通性…<br>那就是如果使用<code>for loop</code>的時候，要從包背最小空間開始找到最佳解，也就是題目的<code>for i in range(i, amount+1)</code>作為最外層開始。然後裡面的物品<code>coin</code>就是內層的<code>for coin in coins</code>，最後找到每個<code>dp[i]</code>的最佳解。並且找到<code>dp[i]</code>與上一個可行的最佳解。舉例來說：</p><ul><li>目前i是<code>6</code>，coin是<code>3</code></li><li>那就是<code>dp[6]</code>的最佳解是上一個最佳解<code>dp[6-3]</code>是否要加上<code>dp[3]</code>？</li></ul><p>這感覺有點像是，我目前碰到<code>3</code>的物品，要不要偷當前的<code>3</code>來達成書包的最大化。</p><ul><li>偷：<code>dp[6-3] + dp[3]</code> = <code>至少空出3的書包空間</code> + <code>3</code></li><li>不偷：<code>dp[6]</code> = <code>目前塞滿的狀態</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #139 Word Break - 刷題之旅</title>
      <link href="/posts/leetcode-139-Word-Break/"/>
      <url>/posts/leetcode-139-Word-Break/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/pmrcgaG.png" alt=""></p><p>這題簡單來說就是給定一個字串<code>s</code>和一個字典<code>wordDict</code>，判斷<code>s</code>是否可以被空格分割成一個或多個在字典中出現的單詞。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的作法">2.1 我的作法</h2><p>但是這個為什麼說他是一個dp問題，是因為他就像背包問題一樣，s是背包，wordDict是物品，我們要看看s能不能裝下wordDict裡面的物品。如果裝錯物品可能導致裝不下。<br>我的想法一開始是一個用切割的方式切成兩塊，然後把所有可能的組合都存到字典裡面，最後找到可以把目前切割結果組合成s的組合。</p><p><em>切割成兩塊</em></p><ul><li>例如：<code>applepenapple</code></li></ul><ol><li><code>a</code> + <code>pplepenapple</code></li><li><code>ap</code> + <code>plepenapple</code></li><li><code>app</code> + <code>lepenapple</code></li><li>…</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    check_w = word[<span class="number">0</span>:i]</span><br><span class="line">    rest_w = word[i:n]</span><br></pre></td></tr></table></figure><p><em>如果找到一組，切成兩塊的結果都是True就找到了</em></p><ul><li>假設<code>helper</code>是一個可以判斷是否可以切割成wordDict的函數</li><li>關係式：<code>helper(word[0:i])</code> and <code>helper(word[i:n])</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    check_w = helper(word[<span class="number">0</span>:i])</span><br><span class="line">    rest_w = helper(word[i:n])</span><br><span class="line">    <span class="keyword">if</span> check_w <span class="keyword">and</span> rest_w:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><em>終止條件</em></p><ul><li>我們需要一個字典來存放已經切割過的結果，避免重複計算</li><li>如果是空字串，就是True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是空字串或是在wordDict裡面，就是True</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&quot;</span> <span class="keyword">or</span> s <span class="keyword">in</span> wordDict:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已經計算過，就直接返回</span></span><br><span class="line"><span class="keyword">if</span> s <span class="keyword">in</span> dp:</span><br><span class="line">    <span class="keyword">return</span> dp[s]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">    check_w = helper(word[<span class="number">0</span>:i])</span><br><span class="line">    rest_w = helper(word[i:n])</span><br><span class="line">    <span class="keyword">if</span> check_w <span class="keyword">and</span> rest_w:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><em>最後</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n^2)</span></span><br><span class="line"><span class="string">    - T(n)=T(n-1)+T(n-2)+...+T(1)，這是一個等比數列，總和為 O(n^2)。</span></span><br><span class="line"><span class="string">    space: O(n)</span></span><br><span class="line"><span class="string">    - 使用了一個長度為 n 的字典來存儲已經計算過的結果。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordBreak</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">if</span> word == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           <span class="keyword">if</span> word <span class="keyword">in</span> dp:</span><br><span class="line">                <span class="keyword">return</span> dp[word]</span><br><span class="line"></span><br><span class="line">            n = <span class="built_in">len</span>(word)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                check_w = word[<span class="number">0</span>:i]</span><br><span class="line">                rest_w = word[i:n]</span><br><span class="line"></span><br><span class="line">                dp[check_w] = helper(check_w)</span><br><span class="line">                dp[rest_w] = helper(rest_w)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[check_w] <span class="keyword">and</span> dp[rest_w]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dp = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">return</span> helper(s)</span><br></pre></td></tr></table></figure><p>可見這個solution的時間複雜度是O(n^2)，空間複雜度是O(n)。不太好．．．</p><h2 id="2-2-優化">2.2 優化</h2><p>我們想一下，如果今天有個共同重要的是，我們需要從index=0開始找s的每一種長度的字串，是否滿足在wordDict裡面，舉例來說，我們希望dp紀錄的是，不同狀態的s是否可以被wordDict裡面的字串組合而成。</p><ul><li><code>dp[apple] = True</code> 我們可以用長度來代表不同的狀態，例如可以寫成這樣<code>dp[5] = True</code>，這樣就可以<code>s</code>的前面<code>5</code>個字元是否可以被wordDict裡面的字串組合而成。</li><li><code>dp[applepen] = True</code> = <code>dp[9] = True</code></li><li>其他狀態就是False，除了<code>dp[0] = True</code>，因為空字串是True</li></ul><p><em>初始化 + 終止條件</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    check_w = s[i]</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">        <span class="keyword">if</span> check_w == w:</span><br><span class="line">            dp[i] = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>但是我們會發現一個問題，就是當找到<code>apple</code>的時候，我們要繼續往後比較<code>penapple</code>該怎麼做？如果我們知道<code>i</code>的位置是True，我們繼續往後比較時，我們可以直接從<code>i</code>的位置開始比較，這樣就可以省下很多時間。</p><p>然後我們的<code>dictWord=['apple', 'pena','pen']</code>這三組好了，我很喜歡用這個例子，因為如果你先選了<code>pena</code>，那麼可能會因為邏輯錯誤無法回傳True(apple, pen)的組。</p><ol><li>我們目前已經確定<code>apple</code>前五個字<code>dp[5]=True</code></li><li>然後我們會需要走到<code>s[i:len(w)]</code>開始看從<code>apple</code>之後的文字數加上<code>len(w)</code>是否等於<code>w</code><ol><li>就像是目前<code>w</code>是<code>pena</code></li><li><code>i</code> 是 <code>5</code></li><li><code>s[i:i+len(w)]</code> 是 <code>pena</code></li></ol></li><li>然後我們檢查<code>s[i:i+len(w)]</code>是否等於<code>w</code>，如果是的話，我們就可以把<code>dp[i+len(w)]</code>設為True，也就是目前的長度<code>applepena</code> 是滿足的，寫成 <code>dp[9] = True</code></li><li>但是在<code>i+len(w)</code>的時候要注意不要超過<code>len(s)</code>的長度喔，否則會發生index out of range的問題。</li><li>最後回傳<code>dp[-1]</code>就是我們的答案，也就是長度最長的那個字串是否滿足。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * (<span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">        <span class="comment"># note1: 只有當dp[i]是True的時候，我們才需要繼續比較，也就是說`apple`（i=0:4）之前都不用比較，因為已經找到最佳解</span></span><br><span class="line">        <span class="keyword">if</span> dp[i]: </span><br><span class="line">            <span class="keyword">if</span> i+<span class="built_in">len</span>(w) &lt;= <span class="built_in">len</span>(s):      <span class="comment"># note4: 注意不要超過s的長度</span></span><br><span class="line">                check_w = s[i:i+<span class="built_in">len</span>(w)] <span class="comment"># note2: 從最佳解之後的字串開始比較，只取出跟wordDict一樣長度的字串</span></span><br><span class="line">                <span class="keyword">if</span> check_w == w:</span><br><span class="line">                    dp[i+<span class="built_in">len</span>(w)] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[-<span class="number">1</span>]   <span class="comment"># note5: 最後一個就是最佳解</span></span><br></pre></td></tr></table></figure><p><em>寫乾淨一點</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">time: O(n*m)</span></span><br><span class="line"><span class="string">- 從 i 到 len(s) 的時間複雜度是 O(n)</span></span><br><span class="line"><span class="string">- wordDict裡面有m個字串，所以時間複雜度是 O(n*m)</span></span><br><span class="line"><span class="string">space: O(n)</span></span><br><span class="line"><span class="string">- 使用了一個長度為 n 的字典來存儲已經計算過的結果。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wordBreak3</span>(<span class="params">self, s: <span class="built_in">str</span>, wordDict: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> dp[i]:</span><br><span class="line">                <span class="keyword">if</span> i + <span class="built_in">len</span>(w) &lt;= <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i:i+<span class="built_in">len</span>(w)] == w:</span><br><span class="line">                    dp[i+<span class="built_in">len</span>(w)] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題我真的想了很久，一整天都在慢慢沈澱這個問題…dp真不簡單，真的很難想到怎麼用for loop的方式實現。這種類似背包問題，就是要想辦法找到<em>前一步的最佳解</em>，例如，在<code>applepenapple</code>中，如果比較到<code>i=5</code>時，我們要知道以當前的狀態最佳解是<code>i=4</code>時，所以應該考量的是<code>i=4</code> + 當前的字串，是否可以更新目前得最佳解？舉例來說：</p><ul><li>比較<code>apple</code>的時候，更新最佳解<code>dp[5]=True</code></li><li>比較<code>applep</code>的時候<ul><li>因為最佳解是<code>dp[5]=True</code></li><li>所以我們可以從<code>i=4</code>開始往後到目前的<code>i=5</code>考慮是否能夠更新最佳解</li><li>因為<code>s[4:5]=p</code>不滿足任何wordDict的字串，所以<code>dp[6]=False</code></li></ul></li><li>比較<code>applepe</code>的時候<ul><li>因為最佳解是<code>dp[5]=True</code></li><li>所以我們可以從<code>i=4</code>開始往後到目前的<code>i=6</code>考慮是否能夠更新最佳解</li><li>因為<code>s[4:6]=pe</code>不滿足任何wordDict的字串，所以<code>dp[7]=False</code></li></ul></li><li>比較<code>applepen</code>的時候<ul><li>因為最佳解是<code>dp[5]=True</code></li><li>所以我們可以從<code>i=4</code>開始往後到目前的<code>i=8</code>考慮是否能夠更新最佳解</li><li>因為<code>s[4:8]=pen</code>是滿足wordDict的字串，所以<code>dp[8]=True</code></li></ul></li><li>比較<code>applepena</code>的時候<ul><li>因為最佳解是<code>dp[8]=True</code></li><li>所以我們可以從<code>i=7</code>開始往後到目前的<code>i=9</code>考慮是否能夠更新最佳解</li><li>因為<code>s[7:9]=a</code>不滿足任何wordDict的字串，所以<code>dp[9]=False</code></li></ul></li><li>比較<code>applepenap</code>的時候<ul><li>因為最佳解是<code>dp[8]=True</code></li><li>所以我們可以從<code>i=7</code>開始往後到目前的<code>i=10</code>考慮是否能夠更新最佳解</li><li>因為<code>s[7:10]=ap</code>不滿足任何wordDict的字串，所以<code>dp[10]=False</code></li></ul></li><li>比較<code>applepenapp</code>…以此類推</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #198 House Robber - 刷題之旅</title>
      <link href="/posts/leetcode-198-House-Robber/"/>
      <url>/posts/leetcode-198-House-Robber/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/gJcLzLy.png" alt=""></p><p>有一排房子，每個房子裡面有一定的錢，但是不能連續偷兩個房子，否則會報警，在不觸發報警的狀況下求最多可以偷到多少錢。</p><h1 id="2-解法">2 解法</h1><p>按照之前的介紹<a href="/posts/lecture-dp">LeetCode 課前預習 - 掌握 Dynamic Programming 的思維指南</a>，我很推薦把每一種步驟都嘗試寫出來看看，分別是：</p><ol><li>Step1: Recursive</li><li>Step2: Recursive with Memoization</li><li>Step3: Iterative + Tabulation</li><li>Step4: Iterative with Constant Space</li></ol><h2 id="Step1-Recursive">Step1: Recursive</h2><p>一道很典型的通過子問題去解決原問題的題目，所以可以透過遞歸以及動態規劃解決。<br><strong>假設</strong>：知道了<code>前 n - 1 家店</code>最多能偷的錢數，<code>前 n - 2 家店</code>最多能偷的錢數。<br><strong>關係式</strong>：如果我們想要知道<code>前 n 家商店</code>最多能偷多少錢，我們可以選擇偷</p><ul><li>偷：偷<code>第 n 家商店</code> + <code>前 n - 2 家商店</code>最多能偷的錢數。</li><li>不偷：不偷<code>第 n 家商店</code> + <code>前 n - 1 家商店</code>最多能偷的錢數。</li></ul><p><strong>最小問題</strong>：如果今天 <code>n = 0</code>，那麼就是<code>0</code>，如果<code>n = 1</code>，那麼就是<code>nums[0]</code>。</p><ul><li><code>n = 0</code>：表示沒有店家可以偷</li><li><code>n = 1</code>：表示只有一家店可以偷，那也只能偷了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(2^n) </span></span><br><span class="line"><span class="string">    - 對於長度為 n 的數組，時間複雜度為 O(2^n)。</span></span><br><span class="line"><span class="string">    - 因為每次遞歸函數都會將問題分成兩個子問題，並且繼續遞歸處理，這種情況會產生一個大小為 2^n 的遞歸樹。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    space: O(n) 遞迴的深度</span></span><br><span class="line"><span class="string">    - 由於遞歸呼叫使用了函數呼叫棧，空間複雜度等於遞歸的深度。</span></span><br><span class="line"><span class="string">    - 每次遞歸呼叫時，棧的深度會增加 1。最壞情況下，遞歸深度為 O(n)，因此空間複雜度為 O(n)。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 最小問題</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 偷與不偷</span></span><br><span class="line">    steal = self.rob(nums[:-<span class="number">2</span>]) + nums[-<span class="number">1</span>]  <span class="comment"># 偷：前 n - 2 家店最多能偷的錢數 + 第 n 家店</span></span><br><span class="line">    not_steal = self.rob(nums[:-<span class="number">1</span>])         <span class="comment"># 不偷：前 n - 1 家店最多能偷的錢數</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回最大值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(steal, not_steal)</span><br></pre></td></tr></table></figure><h2 id="Step2-Recursive-with-Memoization">Step2: Recursive with Memoization</h2><p>那我們就思考，是不是某些已經算過的子問題，我們可以直接拿來用，這樣就不用重複計算了。<br>因此我們需要一個dict來記錄已經算過的子問題。使用dict的好處是可以使用O(1)的時間複雜度來查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob2</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n) 每個子問題只會被計算一次，並且儲存在 dp 字典中</span></span><br><span class="line"><span class="string">    space: O(n)</span></span><br><span class="line"><span class="string">    - call stack space O(n): 最壞情況下，遞歸深度為 O(n)，即 n 次遞歸呼叫會佔用 O(n) 的堆疊空間。</span></span><br><span class="line"><span class="string">    - dp dict O(n): dp 字典中儲存了 n+1 個子問題的結果，因此需要 O(n) 的額外空間。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 檢查是否已經計算過</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> dp:</span><br><span class="line">            <span class="keyword">return</span> dp[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 偷與不偷</span></span><br><span class="line">            steal = helper(nums[:-<span class="number">2</span>]) + nums[-<span class="number">1</span>]    <span class="comment"># 前n-2店家能偷的最佳解 + 第n家店（-1是因爲python的index是從0開始）</span></span><br><span class="line">            not_steal = helper(nums[:-<span class="number">1</span>])           <span class="comment"># 前n-1店家能偷的最佳解</span></span><br><span class="line">            dp[n] = <span class="built_in">max</span>(steal, not_steal)</span><br><span class="line">            <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立一個 dict 來儲存已經計算過的子問題 也把最小問題放進去</span></span><br><span class="line">    dp = &#123;<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: nums[<span class="number">0</span>]&#125;</span><br><span class="line">    <span class="keyword">return</span> helper(nums)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Step3-Iterative-Tabulation">Step3: Iterative + Tabulation</h2><p>接下來，因為Recursive的缺點是有call stack size的限制，所以我們可以使用Iterative，來避免這個問題</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob3</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n) 每個子問題只會被計算一次，並且儲存在 dp 字典中</span></span><br><span class="line"><span class="string">    space: O(n) 只需要一個dp list</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [<span class="number">0</span>, nums[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>: <span class="keyword">return</span> dp[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">        steal = dp[i-<span class="number">2</span>] + nums[i-<span class="number">1</span>] <span class="comment"># 偷到前兩個的最佳解 + 偷當前的因為從0開始所以要-1</span></span><br><span class="line">        not_steal = dp[i-<span class="number">1</span>]         <span class="comment"># 只偷到前一個的最佳解</span></span><br><span class="line">        dp.append(<span class="built_in">max</span>(steal, not_steal))</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="Step4-Iterative-with-Constant-Space">Step4: Iterative with Constant Space</h2><p>最後，我們再思考一下，目前時間複雜度已經到極限了，但是空間複雜度是不是可以再省一點？因為我們只需要前面兩個步驟的結果就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rob4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n) 每個子問題只會被計算一次，並且儲存在 dp 字典中</span></span><br><span class="line"><span class="string">    space: O(1) 只需要constant個變數</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    prev2, prev1 = <span class="number">0</span>, nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>):</span><br><span class="line">        best = <span class="built_in">max</span>(prev2 + nums[i-<span class="number">1</span>], prev1)    <span class="comment"># 偷（偷到前兩個+目前） 與 不偷（偷到前一個）</span></span><br><span class="line">        prev2 = prev1                       <span class="comment"># 更新pre變成prev2</span></span><br><span class="line">        prev1 = best                        <span class="comment"># 目前的best是prev1繼續算下一個</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題不難，我覺得所有的dp題目最有挑戰性的就是要先知道他的recursive formula，只要能夠實作出來，其他的優化都是小case。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #70 Climbing Stairs - 刷題之旅</title>
      <link href="/posts/leetcode-70-Climbing-Stairs/"/>
      <url>/posts/leetcode-70-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/h0bwqls.png" alt=""></p><p>爬樓梯，每次可以爬一階或是兩階，求爬到第n階有幾種方法。</p><h1 id="2-解法">2 解法</h1><p>按照之前的介紹<a href="/posts/lecture-dp">LeetCode 課前預習 - 掌握 Dynamic Programming 的思維指南</a>，我很推薦把每一種步驟都嘗試寫出來看看，分別是：</p><ol><li>Step1: Recursive</li><li>Step2: Recursive with Memoization</li><li>Step3: Iterative + Tabulation</li><li>Step4: Iterative with Constant Space</li></ol><h2 id="Step1-Recursive">Step1: Recursive</h2><p>最基本也是最蠢的就是我們要先發現，基本上走樓梯的方法數量是<code>f(n) = f(n-1) + f(n-2)</code>，這樣的遞迴式，我們可以直接寫出來。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="Step2-Recursive-with-Memoization">Step2: Recursive with Memoization</h2><p>那我們就思考，是不是某些已經算過的子問題，我們可以直接拿來用，這樣就不用重複計算了。<br>因此我們需要一個dict來記錄已經算過的子問題。使用dict的好處是可以使用O(1)的時間複雜度來查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs_step2</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n) 因為每個數字都會被計算一次</span></span><br><span class="line"><span class="string">    space: O(n) 需要存儲從 1 到 n 的每個狀態</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> dp:</span><br><span class="line">            <span class="keyword">return</span> dp[i]</span><br><span class="line"></span><br><span class="line">        dp[i] = self.climbStairs_step2(i - <span class="number">1</span>) + self.climbStairs_step2(i - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i]</span><br><span class="line"></span><br><span class="line">    dp = &#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">2</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> helper(n)</span><br></pre></td></tr></table></figure><h2 id="Step3-Iterative-Tabulation">Step3: Iterative + Tabulation</h2><p>接下來，因為Recursive的缺點是有call stack size的限制，所以我們可以使用Iterative，來避免這個問題</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs_step3</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n)</span></span><br><span class="line"><span class="string">    space: O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="Step4-Iterative-with-Constant-Space">Step4: Iterative with Constant Space</h2><p>最後，我們再思考一下，目前時間複雜度已經到極限了，但是空間複雜度是不是可以再省一點？因為我們只需要前面兩個步驟的結果就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">climbStairs_step4</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    time: O(n)  因為我們只需要計算n次</span></span><br><span class="line"><span class="string">    space: O(1) 只需要3個變數</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    pre_1 = <span class="number">1</span></span><br><span class="line">    pre_2 = <span class="number">2</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        sumPrev = pre_1 + pre_2</span><br><span class="line">        pre_1 = pre_2</span><br><span class="line">        pre_2 = sumPrev</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pre_2</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題是Easy，所有的dynamic最基本的就是要先想到Recursive的解法，才可以進去DP的大門。否則一切都是空談。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Dynamic Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Dynamic Programming 的思維指南</title>
      <link href="/posts/lecture-dp/"/>
      <url>/posts/lecture-dp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>我希望可以熟悉DP的思維，剛好看到這篇<a href="https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b">Medium | Ultimate Guide to Dynamic Programming</a>獲得蠻多的讚，所以打算這篇為基礎做筆記。</p><p>在解決Dynamic Programming重要的前提是：</p><ul><li>耐心: DP問題通常需要花時間來思考，不要急著寫程式</li><li>熟悉遞迴: DP問題通常可以用遞迴的方式來解決，因此熟悉遞迴是很重要的</li></ul><h1 id="Recursion遞迴跟DP的不同">Recursion遞迴跟DP的不同</h1><p>遞歸和動態規劃的主要關聯在於：</p><ul><li><code>重疊子問題</code>：如果一個遞歸算法在計算過程中重複解決相同的子問題，可以使用動態規劃來優化。這時，遞歸算法可以轉化為帶備忘錄的遞歸（自頂向下的動態規劃）。</li><li><code>最優子結構</code>：如果一個問題的最優解可以由其子問題的最優解構成，那麼可以使用動態規劃來解決這個問題。</li></ul><p>有一個很簡單的例子，使用Fibonacci數列來說明這兩個概念。</p><details class="toggle" ><summary class="toggle-button" style="">Fibonacci數列的遞歸解法</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">Fibonacci數列的dp解法</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n, memo</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">return</span> n </span><br><span class="line">    memo[n] = fib(n-<span class="number">1</span>, memo) + fib(n-<span class="number">2</span>, memo)</span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br></pre></td></tr></table></figure></div></details><div class="note info flat"><p><strong>Dynamic Programming是一個可以讓你的Recursive Code更加有效率的工具</strong></p></div><h1 id="DP-是什麼">DP 是什麼</h1><p>再深入討論DP之前，作者有提到<em>不應該立即把任何問題視為&quot;DP問題&quot;</em></p><ol><li>應該要先潈清楚問題是否有需要使用Recursion來解決</li><li>然後從Recursion的計算中，承認可能有一些Redundancy，再來考慮是否需要使用DP進行改進與優化。</li></ol><p>那我們以<a href="https://leetcode.com/problems/unique-paths/">Leetcode-62-Unique Paths</a>來看一個DP的例子。<br><img src="https://i.imgur.com/9aZo6q4.png" alt=""><br>機器人位於一個mxn的網格左上角，機器人只能在向下或向右移動，機器人要到達網格的右下角，有多少種不同的方式？</p><h2 id="Step-1-Recursion">Step 1 Recursion</h2><div class="note info flat"><p><strong>No dynamic Programming, no memoization, no other fancy letter terminology</strong></p></div><p>最一開始，建議從概述你最純粹、最簡單的遞迴解法開始，這樣可以幫助你更好地理解問題。然而第一步驟通常也是最難的，尤其是當題目最終要求要使用dp進一步優化時。在這個過程至終，需要透過確定問題的本質來制訂作戰計畫。但我知道這聽起來很vague(模糊)，每個問題都是獨一無二的只要做得越多，越能夠學習到如何優雅的解決他們。</p><p><img src="https://i.imgur.com/ToGZZYa.png" alt=""></p><p>可以從上圖看到，要先知道，如果今天<code>n=1</code>或是<code>m=1</code>的情況，也就是上圖灰色地帶，你只能盲目的往右或往下走，這樣你就只有一種走法。當你想走到<code>dp[2,2]</code>時，在只能向右或向下移動的情況下，有兩種方式可以到達<code>dp[2][2]</code>。也就是要麼：</p><ol><li>先走到<code>dp[1,2]</code>，然後再走到<code>dp[2,2]</code>，也就是當你走到<code>dp[1,2]</code>的路徑時，基本上要到<code>dp[2,2]</code>的路徑數量也不會改遍了，你就只能往下走</li><li>先走到<code>dp[2,1]</code>，然後再走到<code>dp[2,2]</code>，也就是當你走到<code>dp[2,1]</code>的路徑時，基本上要到<code>dp[2,2]</code>的路徑數量也不會改遍了，你就只能往右走</li></ol><p>然後神奇的事情發生了，<em>在求任何給定步驟<code>(m, n)</code>的唯一路徑數量時，我們可以通過<code>(m,n)</code>的上一格<code>(m-1,n)</code>和左一格<code>(m,n-1)</code>相加來得到</em>。</p><div class="note info flat"><p>在唯一路徑的問題中，我們可以透過遞迴關係（一開始可能不明顯）來理解:<br><strong>任何給定步驟(m, n)的唯一路徑數量是 (m-1, n) 和 (m, n-1)的唯一路徑數量之和</strong>。</p></div><p>這個概念可以用以下程式來實作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">TIME: Exponential</span></span><br><span class="line"><span class="string">SPACE: O(max(m, n))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">m, n</span>):</span><br><span class="line">            <span class="comment"># 當 m 或 n 為 1 時，只有一種走法（往右或往下走到底）要麽已經在最下面只要往右走，要麽已經在最右邊只要往下走</span></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">            <span class="comment"># (m,n) 的路徑是 (m-1,n) 和 (m,n-1) 的路徑數量之和</span></span><br><span class="line">            <span class="keyword">return</span> helper(m-<span class="number">1</span>, n) + helper(m, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>儘管到目前為止我們的解決方案效率低下，但是關鍵收穫是我們已經確定遞迴關係，可以理解如何通過適當地引用隔壁的格子來計算當前格子的路徑數量。</p><p>這正是我們在<strong>解決DP問題時的第一步想要到達的位置 – 最蠢的Recursive</strong>。</p><h2 id="Step-2-Recursion-Memoization">Step 2 Recursion + Memoization</h2><p>現在我們需要弄七寵如何利用之前低效的解決方案，把它變成更容易消化的東西，這也是真正開始使用DP的地方，再深入討論之前，我們需要<em>先具體定義一下在哪些條件下我們可以真正開始考慮一個問題是否值得使用DP來解決</em>。</p><div class="note info flat"><p>存在以下狀況時，可以且應該使用DP:</p><ol><li><strong>overlapping subproblems 重疊的子問題</strong>：當一個問題可以被分解為多個子問題，且這些子問題之間存在重疊時，簡單來說就是你要<em>多次解決同一個子問題</em>。</li><li><strong>optimal substructure 最優子結構</strong>：當一個問題的最優解可以通過其子問題的最優解構成時。也就是說，如果你找到一個<em>子問題的最優解</em>，那或多或少就可以免費地得到<em>原問題的最優解</em>。</li></ol></div><p>建議當面試的時候，大聲地陳述這兩個條件，如果他們都滿足時我們可以使用DP來解決問題。</p><p>首先來看第一個狀況，那就是 overlapping subproblems，這個概念在我們的問題中是很明顯的，<em>因為我們在遞迴過程中多次計算相同的子問題。這就是我們可以使用memoization的地方</em>，我們可以在遞迴過程中保存計算過的子問題的結果，這樣我們就不需要再次計算它們了。這個過程叫做 <code>memoization</code>。</p><p>通常情況我們會透過將結果存在數據結構中來實現這一點，然後這個數據結構可以讓我們在未來的O(1)的時間內找到結果(e.g. hash table, dictionary, set)。很幸運的是，從Step1 Recursion到Step 2 +Memoization只需要一點點的改動，我們只需要添加兩個項目：</p><ol><li><code>儲存結果</code>：一個代碼可以儲存所有recursive call的結果</li><li><code>檢查是否為重複子問題</code>: 一個邏輯來檢查這個問題是否已經被解決過了，如果是我們將檢索並使用它，而不是重新計算他</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">TIME: O(m * n)</span></span><br><span class="line"><span class="string">SPACE: O(m * n) [but limited to max call stack size and susceptible to overflow]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m, n</span>):</span><br><span class="line">        <span class="comment"># 建立一個資料結構儲存結果</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">m, n</span>):</span><br><span class="line">            <span class="comment"># 檢查是否為重複子問題</span></span><br><span class="line">            <span class="keyword">if</span> dp[m][n] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[m][n]</span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 儲存結果</span></span><br><span class="line">            dp[m][n] = helper(m-<span class="number">1</span>, n) + helper(m, n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(m, n)</span><br></pre></td></tr></table></figure><p>說明：</p><ul><li>上面的程式中，在一開始陣列初始化的地方我們建立了一個mxn的網格，這裡我們使用m+1與n+1是為了避免出現out of bound error</li><li>添加了中止條件：<ul><li>檢查如果可以在dp中找到結果，就直接返回結果，這樣就不需要再次計算它們了。</li><li>保留原有的，如果m或n是1，那麼就回傳1只有一種走法。</li></ul></li><li>如果沒有到達任何一個終止，我們就將遞迴的結果更新到dp裡面</li></ul><p>走到這裡，下次<strong>在調用 m 和 n 的時候，已經不用在重複計算了</strong>！</p><p>在這裡你可能會注意到我們在解決方法中引入了額外的空間，你是對的！我們需要承認，需要<em>犧牲一點空間來改善時間</em>，在導致DP解決方案的時候，這種權衡是不費吹灰之力的，而這種方式通常只會<strong>按linearly或constant的增加空間複雜度，但是會exponentially的提高時間複雜度</strong>！這是你可以強調的。</p><h2 id="Step-3-Iteration-Tabulation">Step 3 Iteration + Tabulation</h2><p>當你在面試走到這裡時，通常已經相當不錯了，但是仍然可能存在近一步的優化，這就是我們要討論的地方。如果你完全想不到Step2之後還有哪裡可以改進，然後面試官也已經很開心並滿意你的Step2，那你可以收工了。否則，請繫好安全帶！Because we’re shifting gears once again! XD</p><p>在這裡我們將使用Tabulation，而不是Memoization。從根本上來說這兩個方法的<strong>目標相同 – 儲存我們以前所做的計算，以便在未來的反覆運算中使用它</strong>。</p><p>但是，<em>Tabulation涉及將計算儲存在array (通常是2-dimensional array)，而Memoization通常儲存在set, object, dictionary</em>。也因此，Tabluation允許我們能夠在不依賴Recursive的狀況下Iteratively反覆遍歷陣列。</p><div class="note danger flat"><p>請注意，使用Iteration + Tabulation 不一定會帶來更好的效能（e.g. time and space），但是<em>好處在於你的程式能夠允許執行更大的inputs，不用在意 call stack size</em><br><strong>No longer limited to the maximum size of the call stack.</strong></p></div><p>那具體，怎麼使用Iteration + Tabulation呢？可以參考下圖：<br><img src="https://i.imgur.com/n5W92rE.png" alt=""></p><ol><li>我們一樣建立一個二維的空間（為了可以使用iterative），然後我們把所有的初始值都設定為1，因為這些cell中一定有至少1種走法，再慢慢更新就好</li><li>然後我們通過往回走（從終點到起點），我們可以計算出所有的cell</li><li>因此可以發現<code>dp(m,n)</code>是由右邊和下面的cell來計算的，所以我們可以用下面<code>dp[m+1][n]</code> 與 右邊<code>dp[m][n+1]</code>來計算當前cell的值</li><li>根據圖中的例子，我們需要遍歷 <code>m=1~0</code> 以及 <code>n=5~0</code> 也就是藍色cell的部分，來計算出所有的cell</li></ol><p>我們經常忘記call stack size的限制，例如我們使用python的遞迴函數，當我們的遞迴深度超過997時，就會出現RecursionError。這就是為什麼在這裡我們使用Tabulation，因為這樣我們就不需要擔心這個問題了。那我們來看以下程式吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">TIME: O(n * m)</span></span><br><span class="line"><span class="string">SPACE: O(n * m)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m, n</span>): </span><br><span class="line">        <span class="comment"># 我們把所有的初始值都設定為 1 因為這些 cell 中一定有至少1種走法</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="comment"># 通過往回走（從終點到起點），我們可以計算出所有的 cell</span></span><br><span class="line">        <span class="comment"># -2 是因為(1)從0開始算 (2)我們不需要計算最下排的cell</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>): </span><br><span class="line">            <span class="comment"># -2 是因為(1)從0開始算 (2)我們不需要計算最右排的cell</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp[r] - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">                <span class="comment"># 裡用下方 和 右邊的 cell 來計算當前 cell 的值</span></span><br><span class="line">                dp[r][c] = dp[r+<span class="number">1</span>][c] + dp[r][c+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 因為是從終點到起點，所以最後返回起點的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/TJ0hnyj.png" alt=""><br>上面的流程大概會長這樣：</p><ul><li>首先，最下排也就是m=2的所有cell，以及n=6的所有cell都是1，不需要計算</li><li>我們需要從<code>m=1, n=5</code>的cell開始計算，然後慢慢往左走，直到<code>m=1, n=0</code>的cell (也就是圖片黃色部份)</li><li>然後再從<code>m=0, n=5</code>的cell開始計算，然後慢慢往左走，直到<code>m=0, n=0</code>的cell (也就是圖片綠色部份)</li><li>最後得到的<code>dp[0][0]</code>就是我們的答案</li></ul><p>請注意，Step2, Step3 的<em>時間複雜度與空間複雜度是相同的，只是說Step3可以擺脫call stack size的限制</em>。讓你品嘗到自由的滋味。</p><h2 id="Step-4-Iteration-Tabulation-Optimized">Step 4 Iteration + Tabulation <code>Optimized</code></h2><p>如果你已經在面試中很好的完成前三個步驟，你已經做得很漂亮了，如果要再進一步，就是錦上添花，但是不用因為你無法每次都到達這裡而惱羞成怒。</p><p>我們來探討一下我們前幾步驟的解決方案中，可能存在一個機會減少這種空間複雜性（但這點上，時間複雜性已經是最優的了）。這就是我們要討論的地方。如果你發現，<em>我們每次在建立recursive的時候，僅僅會需要下面一格跟右邊一格的cell，那我們是不是我們根本不用建立整個mxn的空間</em>，只需要2個空間就足夠了！這肯定會提高我們的空間複雜度。</p><p>具體的感覺如下圖：<br><img src="https://i.imgur.com/UsDJHjH.png" alt=""></p><ul><li>原本來說上圖的左邊，在我們計算完 m=1 這整排的時候，m=2 這排就沒屁用了。那我們是不是可以利用 m=2 這沒屁用的空間？當然可以！</li><li>所以我們創建新的dp二維空間表（上圖的右圖），然後m只用2排（<code>m=0~1</code>），每算完一排，就整排往下移動(<code>dp[1]=dp[0]</code>)，就可以用新的一排繼續算(<code>dp[0]</code>)</li><li><em>你會發現我們永遠都在計算m=0這排</em>，因為只要把<code>dp[0]</code>更新到<code>dp[1]</code>就好，有種山不轉水轉的感覺</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">TIME: O(n * m)</span></span><br><span class="line"><span class="string">SPACE: O(n)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m, n</span>): </span><br><span class="line">        <span class="comment"># 只需要建立一個包含2row的table而不是之前的m</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>): </span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp[r] - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>)):</span><br><span class="line">                dp[<span class="number">0</span>][c] = dp[<span class="number">1</span>][c] + dp[<span class="number">0</span>][c+<span class="number">1</span>]    <span class="comment"># 只計算dp[0]這排</span></span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">0</span>]                           <span class="comment"># 山不轉水轉，把計算完的dp[0]更新到dp[1]</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="Ref">Ref</h1><p><a href="https://medium.com/@al.eks/the-ultimate-guide-to-dynamic-programming-65865ef7ec5b">Medium | Ultimate Guide to Dynamic Programming</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #98 Validate Binary Search Tree - 刷題之旅</title>
      <link href="/posts/leetcode-98-Validate-Binary-Search-Tree/"/>
      <url>/posts/leetcode-98-Validate-Binary-Search-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/AGe0J0H.png" alt=""><br><img src="https://i.imgur.com/Jcwxj38.png" alt=""></p><h1 id="2-解法">2 解法</h1><p>我的問題是在，我一開始以為，只要把上一個節點，傳下去，跟下一層的節點進行比較就好了。但是我錯了！</p><blockquote><p>我一開始腦子想著<br><img src="https://i.imgur.com/GrZc7FT.png" alt=""></p></blockquote><p>你會發現上圖根本不是正確的二元搜尋樹，因為節點3比root小，不應該出現在右子樹中…所以我就卡住了。</p><h2 id="2-2-使用Recursion">2.2 使用Recursion</h2><p>其實這題真的目的在於，<em>在 左子樹，只要一往右走，就要考慮到根節點的值，不能大於root.val</em>。而<em>在右子樹，只要一往右走，就要考慮到根節點的值，不能小於root.val</em>。我想了好久，都沒想到到底要怎麼樣知道走不同子樹的路線時（在左子樹還是在右子樹），還能知道當前到底走在哪個方向（一往右走，還是一往左走）…直到我試著畫出每個節點的上下限。</p><p><img src="https://i.imgur.com/Sy3pkuW.png" alt=""><br>你會發現，根本不需要顧慮左還是右子樹，你會發現：</p><ul><li>只要是往左走，<code>max</code>一定會更新成<code>parent.val</code>，而<code>min</code>則是繼承自上一層的<code>min</code>。</li><li>只要是往右走，<code>min</code>一定會更新成<code>parent.val</code>，而<code>max</code>則是繼承自上一層的<code>max</code>。</li></ul><p>然後神奇的事情發生了:</p><ul><li>因為在左子樹往右走時，<code>max</code>會一路繼承上一層的<code>max</code>，追溯到源頭就是<code>root</code>! 也就是說，我們在左子樹往右走時，<code>max</code>一定會是<code>root</code>的值。</li><li>因為在右子樹往左走時，<code>min</code>會一路繼承上一層的<code>min</code>，追溯到源頭就是<code>root</code>! 也就是說，我們在右子樹往左走時，<code>min</code>一定會是<code>root</code>的值。</li></ul><p>寫成python其實就是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, node: <span class="type">Optional</span>[TreeNode], min_val=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;-inf&#x27;</span></span>), max_val=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;inf&#x27;</span></span>)</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 往左走 min繼承上一層的min，max更新成parent.val也就是node</span></span><br><span class="line">    self.isValidBST(node.left, min_val, node.val)</span><br><span class="line">    <span class="comment"># 往右走 max繼承上一層的max，min更新成parent.val也就是node</span></span><br><span class="line">    self.isValidBST(node.right, node.val, max_val)</span><br></pre></td></tr></table></figure><p>那我們接下來考慮一下我們的終止條件：</p><ul><li>確保當前節點的值在上下限之間</li><li>如果挖到底，就回傳True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, node: <span class="type">Optional</span>[TreeNode], min_val=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;-inf&#x27;</span></span>), max_val=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;inf&#x27;</span></span>)</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 如果挖到底，就回傳True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 確保當前節點的值在上下限之間，否則回傳False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (min_val &lt; node.val &lt; max_val):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 如果當前節點的值在上下限之間，就繼續往下挖</span></span><br><span class="line">    left = self.isValidBST(node.left, min_val, node.val)</span><br><span class="line">    right = self.isValidBST(node.right, node.val, max_val)</span><br><span class="line">    <span class="comment"># 確保左右子樹都是合法的二元搜尋樹</span></span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure><h2 id="2-3-使用Stack">2.3 使用Stack</h2><p>我們也可以考慮使用inorder來解這題，因為inorder是一個遞增的序列，（左 - 中 - 右）我們可以透過 inorder 搭配 stack，把所有節點都走過一遍，並且確保是遞增的序列。每次在pop()出來的時候，我們就可以確保右邊的節點比當前節點大。如果不是就回傳False。</p><p><em>首先，一步步把左邊塞入stack</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    stack = [] </span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> stack: </span><br><span class="line">        <span class="comment"># 一步步把左邊塞入stack</span></span><br><span class="line">        <span class="keyword">while</span> root: </span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left </span><br></pre></td></tr></table></figure><p><em>到最底後，pop()出來，開始確保right比node大</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    stack = [] </span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> stack: </span><br><span class="line">        <span class="keyword">while</span> root: </span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left </span><br><span class="line">        <span class="comment"># 到最底後，pop()出來</span></span><br><span class="line">        root = stack.pop()</span><br><span class="line">        <span class="comment"># 然後跟前一個節點比較，按照inorder，pre &lt; root，如果發生 pre &gt; root 就回傳False</span></span><br><span class="line">        <span class="keyword">if</span> pre <span class="keyword">and</span> pre.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 更新pre</span></span><br><span class="line">        pre = root</span><br><span class="line">        <span class="comment"># 繼續往右走</span></span><br><span class="line">        root = root.right</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題我沒有想出來，缺乏考慮到在二元搜尋樹在左子樹往右走時，還要考慮到root，而在右子樹往左走時，也要考慮到root。而最難的問題是，怎麼在適當的時幾，考慮到root?要怎麼把root一層層傳下去是關鍵。透過上下限的方式來看到共通性很重要。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #230 Kth Smallest Element in a BST - 刷題之旅</title>
      <link href="/posts/leetcode-230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/posts/leetcode-230-Kth-Smallest-Element-in-a-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/SvtTaou.png" alt=""><br><img src="https://i.imgur.com/9NSH0pD.png" alt=""></p><p>在二元搜尋樹中，找到第 <code>k</code> 小的節點值。</p><h1 id="2-解法">2 解法</h1><p>看到二元搜尋樹就要知道，中序遍歷的結果就是一個排序好的陣列。因此我們可以透過中序遍歷的方式，來找到第 <code>k</code> 小的節點值。也就是先 left - root - right 的方式遍歷，當我們遍歷到第 <code>k</code> 個節點時，就可以回傳。大概可以這樣思考：</p><ol><li>我們先走到底，也就是一直往左走，直到走到最左邊的節點。</li><li>當觸底的時候，我們開始計數，每次遍歷到一個節點，就把 <code>count</code>+1。</li><li>當 <code>count</code> 與 <code>k</code> 相等時，就回傳當前節點的值。</li><li>否則，遍歷右邊的節點。<br>那我們開始來一步步拆解這個問題吧！</li></ol><p><em>Step 1 我們先走到底</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># 如果沒有節點了，就停止</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 先走到底</span></span><br><span class="line">    inorder(root.left)</span><br></pre></td></tr></table></figure><p><em>Step 2 當觸底的時候，我們開始計數</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder(root.left)</span><br><span class="line">    <span class="comment"># 這時候的root就是最左邊的節點</span></span><br><span class="line">    <span class="comment"># 開始計數</span></span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><em>Step 3 當 <code>count</code> 與 <code>k</code> 相等時，找到第<code>k</code>的最小值。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder(root.left)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果count等於k，就回傳當前節點的值</span></span><br><span class="line">    <span class="keyword">if</span> count == k:</span><br><span class="line">        ans = root.val</span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>到這裡幾乎就完成一大半了，但是上面的<em>程式碼只有遍歷到最左邊的節點，我們還需要遍歷右邊的節點</em>。因此我們可以透過遞歸的方式，來遍歷右邊的節點。<br><em>Step 4 遍歷右邊節點</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inorder(root.left)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == k:</span><br><span class="line">        ans = root.val</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 遍歷右邊的節點</span></span><br><span class="line">    inorder(root.right)</span><br></pre></td></tr></table></figure><p>這樣就完成了！！完整的程式碼如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left, k)</span><br><span class="line">            self.num = self.num + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.num == k:</span><br><span class="line">                self.ans = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.right, k)</span><br><span class="line"></span><br><span class="line">        inorderTraversal(root, k)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h2 id="2-2-使用迭代的方式">2.2 使用迭代的方式</h2><p>這裡我們可以使用迭代的方式來解這個問題，也就是使用stack來模擬遞歸的方式。而概念也是一樣</p><ol><li>先走到底最左邊</li><li>開始計數</li><li>當 <code>count</code> 與 <code>k</code> 相等時，就回傳當前節點的值</li><li>否則，遍歷右邊的節點</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="comment"># 1 先走到底最左邊</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 2 從最左邊開始計數</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 3 如果count等於k，就回傳當前節點的值</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            <span class="comment"># 遍歷右邊的節點，也會被塞入stack中</span></span><br><span class="line">            cur = node.right</span><br></pre></td></tr></table></figure><h1 id="3-結語">3 結語</h1><p>這題不難，但是我也是笨笨的思路沒有想清楚，腦子第一個反應應該是要出現我要先走到最底層，然後開始計數的程式邏輯不夠清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mostLeft</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mostLeft(root.left)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mostLeft</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">while</span> root.left:</span><br><span class="line">        root = root.left</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
            <tag> BST </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #103 Binary Tree Zigzag Level Order Traversal - 刷題之旅</title>
      <link href="/posts/leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
      <url>/posts/leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/MvVz5Uv.png" alt=""><br><img src="https://i.imgur.com/XenNvxk.png" alt=""></p><p>給定一個二元樹，返回其節點值的<em>之字形層序遍歷</em>。換句話說，從左到右，逐層遍歷所有節點，然後每一層的節點值交替方向。<br>第 1 層從左到右，第 2 層從右到左，第 3 層從左到右，第 4 層從右到左，交替進行。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>仔細看會發現一個規律，就是當我們在做層序遍歷的時候，我們可以透過<code>BFS</code>的方式，在不同的層，當發現是偶數層時，要從左到右，我們可以stack先塞right再left。而在奇數層時，要從右到左，我們可以stack先塞left再right。<br><img src="https://i.imgur.com/P8TWjjF.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過pop的方式取出最晚進去的節點</span></span><br><span class="line">node = nodes.pop()</span><br><span class="line"><span class="comment"># 紀錄當前的層</span></span><br><span class="line">cur_level.append(node.val)</span><br><span class="line"><span class="comment"># 如果是偶數層 Left到Right，因此我們先塞Right再Left，按照後進先出的方式達到 Left -&gt; Right </span></span><br><span class="line"><span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> node.right: next_level.append(node.right)</span><br><span class="line">    <span class="keyword">if</span> node.left: next_level.append(node.left)</span><br><span class="line"><span class="comment"># 如果是奇數層 Right到Left，因此我們先塞Left再Right，按照後進先出的方式達到 Right -&gt; Left</span></span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    <span class="keyword">if</span> node.left: next_level.append(node.left)</span><br><span class="line">    <span class="keyword">if</span> node.right: next_level.append(node.right)</span><br></pre></td></tr></table></figure><p>基本上我們就完成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">nodes, lvl</span>):</span><br><span class="line">            cur_lvl = []</span><br><span class="line">            next_lvl = []</span><br><span class="line">            <span class="comment"># 如果沒有節點了，就停止</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 如果 nodes 存在</span></span><br><span class="line">            <span class="keyword">while</span> nodes:</span><br><span class="line">                node = nodes.pop()</span><br><span class="line">                cur_lvl.append(node.val)</span><br><span class="line">                <span class="comment"># 如果是偶數層 Left到Right，因此我們先塞Right再Left，按照後進先出的方式達到 Left -&gt; Right</span></span><br><span class="line">                <span class="keyword">if</span> lvl % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> node.left: next_lvl.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.right: next_lvl.append(node.right)</span><br><span class="line">                <span class="comment"># 如果是奇數層 Right到Left，因此我們先塞Left再Right，按照後進先出的方式達到 Right -&gt; Left</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> node.right: next_lvl.append(node.right)</span><br><span class="line">                    <span class="keyword">if</span> node.left: next_lvl.append(node.left)</span><br><span class="line">            <span class="comment"># 將當前層的節點值存放在答案中</span></span><br><span class="line">            ans.append(cur_lvl)</span><br><span class="line">            <span class="comment"># 遞迴下一層</span></span><br><span class="line">            helper(next_lvl, lvl+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            helper([root], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="2-2-使用迭代的方式">2.2 使用迭代的方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            next_level, values = [], []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> stack:</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="comment"># 每一層從左到右</span></span><br><span class="line">                <span class="keyword">if</span> node.left: next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: next_level.append(node.right)</span><br><span class="line">            <span class="comment"># 如果是奇數層，就反轉</span></span><br><span class="line">            <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                values = values[::-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 然後直接塞入答案</span></span><br><span class="line">            result.append(values)</span><br><span class="line">            stack = next_level</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題也是自己寫出來的，大概有知道一些想法，寫出來所花費的時間大概是30分鐘。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #199 Binary Tree Right Side View - 刷題之旅</title>
      <link href="/posts/leetcode-199-Binary-Tree-Right-Side-View/"/>
      <url>/posts/leetcode-199-Binary-Tree-Right-Side-View/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/YpOQfHv.png" alt=""><br><img src="https://i.imgur.com/VcwVcNu.png" alt=""></p><p>假如你站在樹的右邊，看著樹，你會看到樹的右邊的節點。紀錄下來這些節點。</p><h1 id="2-解法">2 解法</h1><p>一開始我看到這題的時候，腦子浮現的是，我就是努力的往右邊走，如果右邊沒辦法走了，就往左邊走，這樣就可以記錄下來右邊的節點了。但是我的想法無法解決以下這個情境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure><p>以下的程式碼是錯誤的，他只會記錄到right subtree的最右邊，但是left subtree也就是 2 跟 5 節點不會被尋訪。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root: </span><br><span class="line">            self.res.append(root.val)</span><br><span class="line">        <span class="comment"># 如果右邊有節點，就往右邊走</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.rightSideView(root.right)</span><br><span class="line">        <span class="comment"># 如果右邊沒有節點，但左邊有，就往左邊走</span></span><br><span class="line">        <span class="keyword">elif</span> root.left: </span><br><span class="line">            self.rightSideView(root.left)</span><br><span class="line">        <span class="keyword">return</span> self.res </span><br></pre></td></tr></table></figure><p>因此我們希望，當發現右邊已經走到底時，但是左邊的高度比較高時，我們還是要繼續往left subtree走，這樣才能記錄到左邊的節點。他的關鍵在，<em>回傳的答案會與樹的高度有關</em>。我們需要有兩個思維：</p><ul><li>如果右邊可以走，<em>優先走右邊，並且把最右邊的節點記錄</em>下來。</li><li>如果發現右邊已經觸底了，那就換左樹走，但是左樹也不是每個最右邊的節點都要記錄，<em>只有當高度比右樹高時，才要記錄</em>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">node, depth</span>): </span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="comment"># 只有如果目前的高度與答案的長度相等時，才要記錄</span></span><br><span class="line">            <span class="keyword">if</span> depth == <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            <span class="comment"># 右邊繼續往下走，depth + 1</span></span><br><span class="line">            helper(node.right, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 左邊繼續往下走，depth + 1</span></span><br><span class="line">            helper(node.left, depth + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ans = []</span><br><span class="line">    helper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>也可以用BFS的方式來解這題，我們可以用queue來記錄每一層的節點，並且每次只記錄每一層的最右邊的節點。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> i == size - <span class="number">1</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題很快就可以解出來，只是在於有沒有意識到，<em>當右邊長度比左邊短時，要怎麼遍歷左子樹，並且在適當的時機（最新高度的最右邊）塞入左子樹的節點</em>，關鍵在要紀錄depth。當達到新的高度時，但是這個高度還沒有紀錄任何節點時，就要記錄下來。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #236 Lowest Common Ancestor of a Binary Tree - 刷題之旅</title>
      <link href="/posts/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/posts/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/uOjMZRy.png" alt=""><br><img src="https://i.imgur.com/tYD4R1G.png" alt=""></p><p>給一個二元樹，找到兩個節點的最低共同祖先。（祖先可以是自己）</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>看到這題的時候我腦子裡面出現兩種情況：</p><ol><li>如果兩個節點在同一個子樹下（p是q的子節點或是q是p的子節點），那祖先會是p或是q。</li><li>如果兩個節點在不同的子樹下（p和q分別在左右子樹下），那祖先會是把他們倆分開時的root。</li></ol><blockquote><p>情境1: p 是 q 的祖先 或是 q 是 p 的祖先<br><img src="https://i.imgur.com/EyQsSZB.png" alt=""></p></blockquote><blockquote><p>情境2: p 和 q 在不同的子樹下<br><img src="https://i.imgur.com/Sygutbi.png" alt=""></p></blockquote><p>因此我們可以針對這兩種情況來寫遞歸。</p><p><em>情境1</em><br>我們可以建立一個function檢查兩個點是否在同一個子樹下，如果是的話，回傳p或是q。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_same_subtree</span>(<span class="params">parent, child</span>):</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> parent == child:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> check_same_subtree(parent.left, child) <span class="keyword">or</span> check_same_subtree(parent.right, child)</span><br></pre></td></tr></table></figure><p>所以主程式可以這樣寫：</p><ul><li>先檢查 p 是否為 q 的祖先（在同一個樹下），如果是就回傳 p</li><li>再檢查 q 是否為 p 的祖先（在同一個樹下），如果是就回傳 q</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">    <span class="keyword">if</span> check_same_subtree(p, q):</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">if</span> check_same_subtree(q, p):</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><p><em>情境2</em><br>接下來我們開始處理情境2，也就是 p 和 q 在不同的子樹下。他的特點是在，我們一但同時在當前的root的left subtree與right subtree找到p 或是 q，就回傳當前的root。否則若只有一邊有，但是另一邊的subtree還沒有，那就代表還不夠高，繼續往上找。<br><img src="https://i.imgur.com/JmvSTow.png" alt=""><br>從上圖可以看到，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> check_same_subtree(p, q):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">elif</span> check_same_subtree(q, p):</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_parent</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        left = find_parent(root.left)</span><br><span class="line">        right = find_parent(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果左右子樹都有找到，代表當前的root就是答案</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: </span><br><span class="line">            self.ans = root </span><br><span class="line">        <span class="comment"># 如果左右子樹有一個找到，代表還不夠高，繼續往上找</span></span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">or</span> right: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果左右子樹都沒有找到，回傳False</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check_same_subtree</span>(<span class="params">parent, child</span>):</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> parent == child:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> check_same_subtree(parent.left, child) <span class="keyword">or</span> check_same_subtree(parent.right, child)</span><br></pre></td></tr></table></figure><p>最後結果就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    ans = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> check_same_subtree(p, q):</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        <span class="keyword">elif</span> check_same_subtree(q, p):</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            self.find_parent(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_parent</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        left = find_parent(root.left)</span><br><span class="line">        right = find_parent(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果左右子樹都有找到，代表當前的root就是答案</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: </span><br><span class="line">            self.ans = root </span><br><span class="line">        <span class="comment"># 如果左右子樹有一個找到，代表還不夠高，繼續往上找</span></span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">or</span> right: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果左右子樹都沒有找到，回傳False</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></table></figure><h2 id="2-2-更好的解法">2.2 更好的解法</h2><p>在上面你會發現一個精神：</p><ul><li>我們會檢查當前root的left subtree和right subtree是否有找到p或是q，如果有找到，就回傳當前的root。</li><li>如果只有一邊有找到，另一邊沒有，但還是回傳True</li><li>如果兩邊都沒找到，回傳False</li></ul><p>那我們是否可以改變一下觀念，把Ture, False的概念換成回傳 True =  p 或是 q 以及 False = None，這樣我們就可以把情境1和情境2合併在一起了。<br><img src="https://i.imgur.com/otrdABF.png" alt=""><br>具體來說是怎麼把情境1和2合併在一起呢？</p><ul><li>情境1: 如果發現一邊是None，那我們就回傳另一邊<ul><li>如果另一邊有值就會回傳最早碰到的節點（p或是q）那就是祖先。</li><li>如果另一邊沒有值，代表兩邊都沒有找到，就回傳None（但題目有說明p跟q一定會在樹裡面，所以這個情況不會發生）</li></ul></li><li>情境2: 如果發現兩邊都有值，就代表我們找到 p 跟 q 節點了，但是因為他們在不同的子樹下，所以當前的root就是祖先。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="comment"># 回傳 Ture 或是 False 概念 只是都是 root </span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 情境2 兩邊都有值，代表找到 p 跟 q，但是在不同的子樹下 回傳當前的root</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 情境1 一邊有值，另一邊沒有值，回傳有值的那一邊</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">or</span> right: </span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">or</span> right</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題的關鍵思想在於 找left subtree 跟 right subtree 是否存在 p 與 q</p><ul><li>如果只有一邊存在，那代表 p 與 q 一定是父子關係，所以回傳最早找到的那個節點（父節點）</li><li>如果兩邊subtree各自找到 p 與 q，那代表 p 與 q 在不同的子樹下，所以回傳當前的root</li></ul><p>這題我有自己想出來，可惜的是花了兩個小時，後來看到更好的解法，才發現自己的解法太複雜了，但是核心思想是一樣的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #102 Binary Tree Level Order Traversal - 刷題之旅</title>
      <link href="/posts/leetcode-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/posts/leetcode-102-Binary-Tree-Level-Order-Traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/wlANRzM.png" alt=""><br><img src="https://i.imgur.com/6McfWmL.png" alt=""></p><p>給定一個二元樹，返回其節點值的<em>層序遍歷</em>。換句話說，從左到右，逐層遍歷所有節點。</p><h1 id="2-解法">2 解法</h1><p>這題很明顯，我們可以使用<code>BFS</code>的方式來解，因為<code>BFS</code>是一種逐層遍歷的方式。</p><p>我們會需要</p><ul><li><code>next_level</code> 來存放下一層的節點，然後透過呼叫自己，放入<code>next_level</code>的節點。</li><li><code>nodes</code> 是當層的所有節點。</li><li><code>values</code> 是用來存放當層的節點值。</li><li><code>result</code> 就是結果。</li></ul><p><strong>Recursive</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs_helper</span>(<span class="params">nodes</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            next_level, values = [], []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_level.append(node.right)</span><br><span class="line">            result.append(values)</span><br><span class="line">            bfs_helper(next_level)</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>Iterator</strong><br>也可以把它寫成迭代的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        nodes = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> nodes:    <span class="comment"># 當nodes不為空</span></span><br><span class="line">            next_level = []</span><br><span class="line">            values = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    next_level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    next_level.append(node.right)</span><br><span class="line">            result.append(values)</span><br><span class="line">            nodes = next_level  <span class="comment"># 每次遍歷完當層的節點後，把next_level放入nodes，這樣下次迭代就會遍歷下一層的節點</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題是一個簡單的<code>BFS</code>問題，只要熟悉<code>BFS</code>的遍歷方式，就可以很快解出來。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #173 Binary Search Tree Iterator - 刷題之旅</title>
      <link href="/posts/leetcode-173-Binary-Search-Tree-Iterator/"/>
      <url>/posts/leetcode-173-Binary-Search-Tree-Iterator/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/Mdh9wrd.png" alt=""><br><img src="https://i.imgur.com/nXxvm20.png" alt=""><br><img src="https://i.imgur.com/QstIzHx.png" alt=""></p><p>簡單來說，這題是要實作一個Binary Search Tree的iterator，這個iterator可以讓你用<code>next()</code>的方式來取得<em>下一個最小的值</em>。然後使用 <code>hasNext()</code> 來判斷是否還有下一個最小值。</p><div class="note warning flat"><p><strong>注意</strong>：題目有要求，空間複雜度必須是<code>O(h)</code>，<code>h</code>是樹的高度。</p></div><h1 id="2-解法">2 解法</h1><p>當你看到 <code>next()</code> 目的是在取得『最小值』時。因為BST的特性是，<em>任意節點的左子樹不空，那左子樹上所有節點的值均小於他的根節點的值</em>。因此我們可以使用 <code>inorder traversal</code> 的方式來解這題，因為 <code>inorder traversal</code> 是一種由<em>小到大(左-中-右)的方式</em>遍歷BST。詳細關於inorder得實作可以參考<a href="/posts/lecture-bfs-dfs">這篇LeetCode 課前預習 - 掌握 BFS 與 DFS 指南</a>。</p><h2 id="2-1-解法1-Inorder-Traversal">2.1 解法1: Inorder Traversal</h2><p>這邊我們可以使用<code>stack</code>來幫助我們做<code>inorder traversal</code>，然後每次呼叫<code>next()</code>的時候，我們就可以取得最小的值，在 <code>hasNext()</code> 的時候，我們只要判斷<code>stack</code>是否為空就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self._inorder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_inorder</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._inorder(node.right)   <span class="comment"># 因為 FILO，所以先放右邊（大的）比較晚出來</span></span><br><span class="line">        self.stack.append(node)</span><br><span class="line">        self._inorder(node.left)    <span class="comment"># 再放左邊（小的）比較早出來</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack.pop().val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>但是上面的解法，空間複雜度是<code>O(n)</code>，不符合題目要求，上面的程式問題在於 <code>_inorder</code> 的時候，把所有節點都放進<code>stack</code>裡面，這樣空間複雜度就是<code>O(n)</code>。</p></div><h2 id="2-2-解法2-Iterator-with-Stack">2.2 解法2: Iterator with Stack</h2><p><em>在解法1中，我們把所有的節點都保存起來了，但其實沒必要一次性保存所有節點，我們應該要控制stack塞入節點的時機</em>，這樣就可以達到<code>O(h)</code>的空間複雜度。具體該怎麼做，我們來釐清一下：</p><p><strong>第一種情境</strong><br><img src="https://i.imgur.com/wnssIm8.png" alt=""><br>當我們初始化<code>BSTIterator</code>的時候，在呼叫<code>next()</code>時，我們希望回傳最小值，而題目要求空間複雜度是<code>O(h)</code>，所以我們就<em>遍歷到底，直到取到最小值</em>，這個遍歷的過程中，我們可以把遍歷的節點都放進stack裡面，這樣就可以達到<code>O(h)</code>的空間複雜度。所以第一種狀況的程式碼大概是這樣：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cur:</span><br><span class="line">    stack.append(cur)</span><br><span class="line">    cur = cur.left</span><br></pre></td></tr></table></figure><p><strong>第二種情境</strong><br><img src="https://i.imgur.com/kD0eOL4.png" alt=""><br>接下來我們要考慮的是，當我們呼叫<code>next()</code>的時候，具體要考慮哪些事情，這裡分成兩個部分：</p><ol><li>當我們呼叫<code>next()</code>的時候，我們要回傳最小值，也就是stack的最上面的節點。</li><li>當我們取出最小值後，指標往上移動，因為<em>下次取<code>next()</code>時也是從stack中pop出來，但是我們的stack還沒有放任何右子樹的節點</em>，因此每次pop出來後，我們就要檢查，right是否有值，如果有也要將右子樹遍歷到最小值的所有節點壓到stack中，這樣下次呼叫<code>next()</code>的時候，就可以取得下一個最小值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res = stack.pop()</span><br><span class="line"><span class="comment"># 檢查是否有右子樹</span></span><br><span class="line"><span class="keyword">if</span> res.right:</span><br><span class="line">    <span class="comment"># 如果有，要把右子樹遍歷到最小值的所有節點壓到stack中，下次next()才會取得右子樹的最小值</span></span><br><span class="line">    cur = res.right</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        stack.append(cur)</span><br><span class="line">        cur = cur.left</span><br><span class="line"><span class="keyword">return</span> res.val</span><br></pre></td></tr></table></figure><p>那基本上我們就可以實作這個iterator了，我們把情境1的程式碼包裝成<code>_leftmost_inorder()</code>，最後程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: TreeNode</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self._leftmost_inorder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_leftmost_inorder</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            self.stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        topmost_node = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> topmost_node.right:</span><br><span class="line">            self._leftmost_inorder(topmost_node.right)</span><br><span class="line">        <span class="keyword">return</span> topmost_node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>其實這題不難，只是要先能夠想到 inorder 然後根據 inorder 的演算法做變體。這題的重點在於如何控制stack塞入的過程，這樣就可以達到<code>O(h)</code>的空間複雜度。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #106 Construct Binary Tree from Postorder and Inorder Traversal - 刷題之旅</title>
      <link href="/posts/leetcode-106-construct-binary-tree-from-postorder-and-inorder-traversal/"/>
      <url>/posts/leetcode-106-construct-binary-tree-from-postorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/jnQmebm.png" alt=""><br><img src="https://i.imgur.com/hoBcab1.png" alt=""></p><p>提供給你 postorder 與 inorder 的數列，請你建立一個二元樹。首先 讓我們先了解 postorder 與 inorder 的定義。<br><em>Inorder Traversal</em> -&gt; LEFT -&gt; ROOT -&gt; RIGHT<br><em>Postorder Traversal</em> -&gt; LEFT -&gt; RIGHT -&gt; ROOT</p><h1 id="2-解法">2 解法</h1><p>這題跟 <a href="/posts/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal">105 題</a>很像，只是順序不同，這題是 postorder 與 inorder，105 題是 preorder 與 inorder。這題的解法也是利用遞迴的方式來建立二元樹。</p><p>你會發現，postorder <em>最後一筆</em>會是 Root，<em>前面</em>會先遍歷left sub-tree整顆跑完，才會再遍歷right sub-tree。而 inorder 是先遍歷left sub-tree，再遍歷root，最後是right sub-tree。你會發現 preorder 跟 inorder 的優缺點如下：</p><ul><li><strong>postorder</strong>:<ul><li>好處：因為最後一個值是root，所以可以直接取得root的值</li><li>缺點：無法知道左右子樹的範圍</li></ul></li><li><strong>inorder</strong>:<ul><li>好處：可以知道左右子樹的範圍</li><li>缺點：無法知道root的值</li></ul></li></ul><p>因此我們要利用彼此雙方的好處，互補彼此的缺點。這時候我們就可以利用遞迴的方式來建立二元樹。<br><img src="https://i.imgur.com/AFlFEyn.png" alt=""></p><h2 id="2-1-取subtree的範圍">2.1 取subtree的範圍</h2><p><strong>Step1: 在postorder找到root + 在 inorder找到左右子樹長度</strong></p><ol><li>那就是如果我們先取得postorder的最後一個值，就可以知道root的值是什麼</li><li>然後再根據這個值去inorder中找到root的位置，這樣就可以知道左右子樹的範圍。<ol><li>左子樹起點=0 ~ 左子樹 root_index (不包含) 簡單來說就是 <code>inorder[0:root_index]</code></li><li>右子樹起點=root_index+1 ~ 右子樹結束點=len(inorder) (包含) 簡單來說就是 <code>inorder[root_index+1:]</code></li></ol></li></ol><p>大概是這種感覺：<br><img src="https://i.imgur.com/PJOP42Y.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>], </span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 1. 找到 inorder 的 root 位置以切出左右子樹</span></span><br><span class="line">    root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">    root = TreeNode(root_val)</span><br><span class="line">    root_index = inorder.index(root_val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 找到 inorder 的左右子樹</span></span><br><span class="line">    i_left = inorder[:root_index]</span><br><span class="line">    i_right = inorder[root_index + <span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p><strong>Step2: 根據左右子樹的長度，在postorder切割左右子樹</strong><br>因為我們用inorder知道了左右子樹的，我們就可以在 postorder 裡面開始切割左右子樹</p><ol><li>使用 <code>i_left</code> 的長度，在 <code>[1:]</code> 切割左子樹</li><li>[0+1:] 這個區間是由 左子樹 + 右子樹 所組成<ol><li>左子樹起點=0 ~ 左子樹結束點=1+left_len (不包含) 簡單來說就是 <code>postorder[0:left_len+1]</code></li><li>右子樹起點=1+left_len ~ 右子樹結束點=-1 (包含) 簡單來說就是 <code>postorder[left_len+1:-1]</code></li></ol></li><li>從 postorder 得到的左右子樹，取最後一個值，又可以得到 root</li><li>把postorder從[:-1] 切成兩半左右子樹後，我們又可以開始遞迴，找到這兩個子樹的 root</li></ol><p>大概是這種感覺：<br><img src="https://i.imgur.com/WM2sQ6n.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>], </span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># Step 1: The last element in postorder is the root</span></span><br><span class="line">    root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">    root = TreeNode(root_val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 2: Find the index of the root in inorder</span></span><br><span class="line">    root_index = inorder.index(root_val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 3: Split the inorder list into left and right subtrees</span></span><br><span class="line">    i_left = inorder[:root_index]</span><br><span class="line">    i_right = inorder[root_index + <span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 4: Split the postorder list into left and right subtrees</span></span><br><span class="line">    p_left = postorder[:<span class="built_in">len</span>(i_left)]</span><br><span class="line">    p_right = postorder[<span class="built_in">len</span>(i_left):-<span class="number">1</span>]  <span class="comment"># Exclude the last element which is the root</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 5: Recursively build the left and right subtrees</span></span><br><span class="line">    root.left = self.buildTree(i_left, p_left)</span><br><span class="line">    root.right = self.buildTree(i_right, p_right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>Step3: 當左右子樹為空時，回傳None</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>], </span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># Base case: if inorder or postorder is empty, return None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Step 1: The last element in postorder is the root</span></span><br><span class="line">    root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">    root = TreeNode(root_val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 2: Find the index of the root in inorder</span></span><br><span class="line">    root_index = inorder.index(root_val)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 3: Split the inorder list into left and right subtrees</span></span><br><span class="line">    i_left = inorder[:root_index]</span><br><span class="line">    i_right = inorder[root_index + <span class="number">1</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 4: Split the postorder list into left and right subtrees</span></span><br><span class="line">    p_left = postorder[:<span class="built_in">len</span>(i_left)]</span><br><span class="line">    p_right = postorder[<span class="built_in">len</span>(i_left):-<span class="number">1</span>]  <span class="comment"># Exclude the last element which is the root</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Step 5: Recursively build the left and right subtrees</span></span><br><span class="line">    root.left = self.buildTree(i_left, p_left)</span><br><span class="line">    root.right = self.buildTree(i_right, p_right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="精簡">精簡</h3><p>稍微整理以下就可以變成這樣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>], </span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(postorder[-<span class="number">1</span>])</span><br><span class="line">    root_index = inorder.index(root.val)</span><br><span class="line">    root.left = self.buildTree(inorder[:root_index], postorder[:root_index])</span><br><span class="line">    root.right = self.buildTree(inorder[root_index + <span class="number">1</span>:], postorder[root_index:-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>總結一下順序：</p><ol><li><strong>inorder切出左右子樹</strong>: 在 inorder 用 root 切出左右子樹的範圍</li><li><strong>inorder找出左右子樹長度</strong>:拿 inorder 左右子樹的長度，在 postorder 切出左右子樹的範圍</li><li><strong>postorder 切出左右子樹，以找出root</strong>: postorder 的左右子樹一出來，就可以知道左右子樹的 root 是什麼（因為 postorder 的第一個值是root）</li><li><strong>大小問題關係式</strong>: 然後把 root.left 與 root.right 填入</li></ol><h2 id="2-2-queue-的解法">2.2 queue 的解法</h2><p>跟 105 題一樣，可以使用queue去解這題，這樣就不用一直切割list，可以直接用index去取值，這樣會比較快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> inorder:</span><br><span class="line">        INDEX = inorder.index(postorder.pop(-<span class="number">1</span>))</span><br><span class="line">        root = TreeNode(inorder[INDEX])</span><br><span class="line">        root.left = self.buildTree(inorder[<span class="number">0</span>:INDEX], postorder[<span class="number">0</span>:INDEX])</span><br><span class="line">        root.right = self.buildTree(inorder[INDEX+<span class="number">1</span>:], postorder[INDEX:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>因為已經寫過了，所以大概30分鐘內就可以解決</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #112 Path Sum - 刷題之旅</title>
      <link href="/posts/leetcode-112-path-sum/"/>
      <url>/posts/leetcode-112-path-sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/Bbg6ac7.png" alt=""><br><img src="https://i.imgur.com/kAtWkeS.png" alt=""><br>給定一個sum，判斷是否存在一條從根節點到葉子節點的路徑，使得路徑上所有節點的值的和等於sum。</p><h1 id="2-解法">2 解法</h1><p>這題不難，我們只要在往下遍歷的時候，每次減去當前節點的值，然後判斷是否為0即可。這題可以用DFS的方式解。</p><p><em>如果Root是空的回傳False，否則剪掉當前的節點</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    targetSum -= root.val</span><br></pre></td></tr></table></figure><p><em>如果發現root.left且root.right都是None代表觸底，檢查targetSum是否為None</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">    <span class="keyword">return</span> targetSum == <span class="number">0</span></span><br></pre></td></tr></table></figure><p><em>只要root還不是最底層的leaf，就繼續往下，如果左右子樹其中一個有True就回傳True</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> self.hasPathSum(root.left, targetSum) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum)</span><br></pre></td></tr></table></figure><p><em>完整的程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        targetSum -= root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum)</span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題是一個簡單的DFS，只要在遍歷的時候，每次減去當前節點的值，然後判斷是否為0即可。這題可以用DFS的方式解。大概5-10分鐘寫完。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Easy </tag>
            
            <tag> binary-tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #129 Sum Root to Leaf Numbers - 刷題之旅</title>
      <link href="/posts/leetcode-129-sum-root-to-leaf-numbers/"/>
      <url>/posts/leetcode-129-sum-root-to-leaf-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/H2nAkZo.png" alt=""><br><img src="https://i.imgur.com/nLFcDZ7.png" alt=""></p><h1 id="2-解法">2 解法</h1><p>看到這題的時候，就想要用 DFS 來解，順序大概是 <code>root -&gt; left</code> 走過的節點都把他串起來，然後再 <code>root -&gt; right</code>。那什麼時候要相加呢？當走到葉子節點（走到底時）的時候，就把這條路徑的數字相加起來就可以了。因此也可以用Recursive來解。</p><p>大問題：把每條路徑的數字相加起來。<br>小問題：假設我們已經走到底了，已經把數字串起來<br>最小的問題：把已經串完的數字，跟tot做加總，最後返回tot。</p><p><em>首先需要有個可以把每個節點串起來的變數<code>path</code></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, path</span>):</span><br><span class="line">    path = path + <span class="built_in">str</span>(node.val) <span class="comment"># 把每個節點串起來</span></span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        dfs(node.left, path)        <span class="comment"># 左子樹走到底</span></span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        dfs(node.right, path)       <span class="comment"># 右子樹走到底</span></span><br></pre></td></tr></table></figure><p><em>當走到leaf節點時，要做加總</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, path</span>):</span><br><span class="line">    path = path + <span class="built_in">str</span>(node.val)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:  <span class="comment"># 串好後，發現已經走到底</span></span><br><span class="line">        tot += <span class="built_in">int</span>(path)                  <span class="comment"># 把數字相加</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            dfs(node.left, path)        </span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            dfs(node.right, path)       </span><br></pre></td></tr></table></figure><p><em>最後返回加總的數字，以下是完整程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    tot = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNumbers</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self._sum_numbers(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> self.tot</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sum_numbers</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], path</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        path += <span class="built_in">str</span>(root.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            self.tot += <span class="built_in">int</span>(path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self._sum_numbers(root.left, path)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self._sum_numbers(root.right, path)</span><br></pre></td></tr></table></figure><p>你可能會想，一定要使用外部的變數嗎？可以不用，可以直接返回數字，這樣就不用使用外部變數了。</p><ul><li>但是我們要往下挖的時候，也就是在遞迴的時候，我們要把目前的數字傳下去，所以我們需要一個變數來記錄目前的數字，那就是<code>cur_sum</code>。</li><li>到最底的時候，就要把當前目前的數字返回，把每次觸底返回的結果進行相加<code>ans</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNumbers</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">return</span> self._sum_numbers(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sum_numbers</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], cur_sum</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        cur_sum = cur_sum * <span class="number">10</span> + root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> cur_sum  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                ans += self._sum_numbers(root.left, cur_sum)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                ans += self._sum_numbers(root.right, cur_sum)</span><br><span class="line">            <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題不難，但是也是偷看了一下解答，才寫得出來。大概也是花了30分鐘左右，我有想到要使用DFS，但是卡在最小問題，也就是最後加總的時候不確定該怎麼處裡。後來看了解答，才發想有兩種方式，一種是設定class的變數，讓<em>在遞迴的過程中可以直接對變數進行操作</em>。另一個重要的觀念是，<em>該怎麼在每次遞迴的時候，保留之前走過的訊息</em>（也就是把走過的數字串起來或加總）這個需要在每次遞迴的時候，把串到一半的數字繼續往下傳，這樣才能保留之前的訊息，但是也不用擔心值會在不同遞迴的地方改變，每個遞迴有他自己的<code>cur_sum</code>。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #114 Flatten Binary Tree to Linked List - 刷題之旅</title>
      <link href="/posts/leetcode-114-flatten-binary-tree-to-linked-list/"/>
      <url>/posts/leetcode-114-flatten-binary-tree-to-linked-list/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/fR5GthN.png" alt=""><br><img src="https://i.imgur.com/7BpBiMH.png" alt=""></p><p>簡單來說就是要把一個二元樹轉換成一個只有右子樹的鏈表。變成linkedlist。並且題目特別要求，使用 <code>in-place</code> 的方式。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-DFS">2.1 DFS</h2><p>一開始你會發現基本上他就是DFS，依序走訪每個節點，然後把每個節點的左子樹接到右子樹，然後把左子樹設為空。<br>題目中，要求說是in-place，也就是說in-place 的意思可能更多說的是直接<em>在原來的節點上改變指向，空間複雜度並沒有要求</em>。所以這題也可以用遞迴解一下，這時候會讓我們想到DFS preorder的做法。詳細可以參考這篇<a href="/posts/lecture-bfs-dfs">LeetCode 課前預習 - 掌握 BFS 與 DFS 指南</a>。</p><p>但是你在推導的時候會發現：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br><span class="line">preorder: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 </span><br></pre></td></tr></table></figure><p>我們知道題目給定的遍歷順序其實就是preorder遍歷的順序，所以我們能不能利用preorder遍歷的程式碼，每遍歷一個節點，就將上一個節點的右邊指標更新為目前節點。<br>preorder遍歷的順序是1 2 3 4 5 6。</p><ul><li>遍歷到2，把1的右指針指向2。1 -&gt; 2 3 4 5 6。</li><li>遍歷到3，把2的右指針指向3。1 -&gt; 2 -&gt; 3 4 5 6。</li><li>…</li></ul><p>但是現實是殘酷的，如果我們把 1.right 指向 2，那原本的 1的右子樹就會消失，所以我們需要一個變數來記錄原本的右子樹。或是說，我們可以先從右子樹下手，先處理好最右邊的子樹，慢慢往左處理，那就不會有右子樹丟失的問題了？</p><p><strong>解決方法的話，我們可以逆過來進行</strong><br>我們依序遍歷6 5 4 3 2 1，然後每<code>遍歷一個節點就將目前節點的右指標更新為上一個節點</code>。</p><ul><li>遍歷到5，把5的右指針指向6。6 &lt;- 5 4 3 2 1。</li><li>遍歷到4，把4的右指針指向5。6 &lt;- 5 &lt;- 4 3 2 1。</li><li>…</li></ul><p>那這個逆過來的順序是 postorder，只是順序是 <code>右子樹-&gt;左子樹-&gt;根節點</code>，所以我們可以用遞迴的方式來解這題。<em>這樣就不會有丟失孩子的問題了，因為更新目前的右指標的時候，目前節點的右孩子已經訪問過了</em>。</p><p>而6 5 4 3 2 1的遍歷順序其實變形的後序遍歷，遍歷順序是右子樹-&gt;左子樹-&gt;根節點。</p><p><em>先回想一下變形的postorder遍歷的程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        postorder(node.right)</span><br><span class="line">        postorder(node.left)</span><br><span class="line">        <span class="built_in">print</span>(node.val)</span><br><span class="line">    </span><br><span class="line">    postorder(root)</span><br></pre></td></tr></table></figure><p><em>然後我們修改一下要把最底慢慢串上去</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        root.right = self.pre</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        self.pre = root</span><br></pre></td></tr></table></figure><h2 id="2-2-Morris-Traversal">2.2 Morris Traversal</h2><p>另一個作法是，<em>如果我們想要實現 O(1) 的空間複雜度，那我們可以使用Morris Traversa</em>l，簡單來說他就是不斷地</p><ol><li>把<code>右子樹</code>接到<code>左子樹</code>的<code>最右邊</code></li><li>然後把<code>左子樹</code>接到<code>右子樹</code></li><li>然後把<code>左子樹</code>設為<code>空</code>。</li></ol><p>這樣就可以達到題目的要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先找到cur.左子樹的最右邊節點 rightmost (4)</span></span><br><span class="line">    <span class="number">1</span> &lt;--- cur </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span>  &lt;--- cur.right </span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   (<span class="number">4</span>) <span class="number">6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 先找到cur.left 接到 rightmost.right (4)</span></span><br><span class="line">    <span class="number">1</span> &lt;--- cur </span><br><span class="line">   / </span><br><span class="line">  <span class="number">2</span> &lt;--- cur.left  </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">3</span>   (<span class="number">4</span>) &lt;--- rightmost </span><br><span class="line">      \</span><br><span class="line">       <span class="number">5</span> &lt;--- cur.right  </span><br><span class="line">        \</span><br><span class="line">         <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然後把 cur.left 接到 cur.right</span></span><br><span class="line"><span class="comment">// 設定 cur.left 為空 </span></span><br><span class="line">    <span class="number">1</span> &lt;--- cur </span><br><span class="line">   / \</span><br><span class="line"><span class="literal">null</span>  <span class="number">2</span>  &lt;--- cur.right = cur.left           </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>  (<span class="number">4</span>)  &lt;--- rightmost </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 cur 移動到 cur.right </span></span><br><span class="line"><span class="comment">// 重新找到 cur.left 的最右邊節點 rightmost (3)</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span> &lt;--- cur           </span><br><span class="line">     / \          </span><br><span class="line">   (<span class="number">3</span>)  <span class="number">4</span> &lt;--- cur.left </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先找到cur.left 接到 rightmost.right (4)</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span> &lt;--- cur           </span><br><span class="line">     / </span><br><span class="line">   (<span class="number">3</span>)</span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span>  &lt;--- cur.left </span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 cur.left 接到 cur.right</span></span><br><span class="line"><span class="comment">// cur.left 設為空</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>  &lt;--- cur         </span><br><span class="line">       \          </span><br><span class="line">       (<span class="number">3</span>) &lt;--- cur.left = cur.right      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>那我們來一步步開始實作吧！</p><details class="toggle" ><summary class="toggle-button" style="">Step1: 找到rightmost</summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先找到cur.左子樹的最右邊節點 rightmost (4)</span></span><br><span class="line">    <span class="number">1</span> &lt;--- cur </span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span>  &lt;--- cur.right </span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   (<span class="number">4</span>) <span class="number">6</span></span><br></pre></td></tr></table></figure><p><em>找到rightmost</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cur.left:</span><br><span class="line">    <span class="comment"># 要找到cur.left的最右邊節點</span></span><br><span class="line">    rightmost = cur.left </span><br><span class="line">    <span class="comment"># 開始往左子樹的最右邊走</span></span><br><span class="line">    <span class="keyword">while</span> rightmost.right:</span><br><span class="line">        rightmost = rightmost.right</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">Step2: 把cur.right 接到 rightmost + cur.left 接到 cur.right</summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先找到cur.left 接到 rightmost.right (4)</span></span><br><span class="line">    <span class="number">1</span> &lt;--- cur </span><br><span class="line">   / </span><br><span class="line">  <span class="number">2</span> &lt;--- cur.left  </span><br><span class="line"> / \  </span><br><span class="line"><span class="number">3</span>   (<span class="number">4</span>) &lt;--- rightmost </span><br><span class="line">      \</span><br><span class="line">       <span class="number">5</span> &lt;--- cur.right  </span><br><span class="line">        \</span><br><span class="line">         <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然後把 cur.left 接到 cur.right</span></span><br><span class="line"><span class="comment">// 設定 cur.left 為空 </span></span><br><span class="line">    <span class="number">1</span> &lt;--- cur </span><br><span class="line">   / \</span><br><span class="line"><span class="literal">null</span>  <span class="number">2</span>  &lt;--- cur.right = cur.left           </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>  (<span class="number">4</span>)  &lt;--- rightmost </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br></pre></td></tr></table></figure><p><em>把cur.right 接到 rightmost + cur.left 接到 cur.right</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rightmost.right = cur.left</span><br><span class="line">cur.right = cur.left </span><br><span class="line">cur.left = <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">Step3: 移動 cur 到 cur.right 然後回到 Step1</summary><div class="toggle-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 cur 移動到 cur.right </span></span><br><span class="line"><span class="comment">// 重新找到 cur.left 的最右邊節點 rightmost (3)</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span> &lt;--- cur           </span><br><span class="line">     / \          </span><br><span class="line">   (<span class="number">3</span>)  <span class="number">4</span> &lt;--- cur.left </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br></pre></td></tr></table></figure><p><em>移動cur到cur.right</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> cur: </span><br><span class="line">    step1(...)</span><br><span class="line">    step2(...) </span><br><span class="line">    cur = cur.right </span><br></pre></td></tr></table></figure></div></details><p><em>把上面三個步驟串起來，就是完整的程式碼</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                rightmost = cur.left </span><br><span class="line">                <span class="keyword">while</span> rightmost.right:</span><br><span class="line">                    rightmost = rightmost.right</span><br><span class="line">                rightmost.right = cur.right</span><br><span class="line">                cur.right = cur.left </span><br><span class="line">                cur.left = <span class="literal">None</span></span><br><span class="line">            cur = cur.right</span><br></pre></td></tr></table></figure><h1 id="3-結語">3 結語</h1><p>這題花真的很久的時間，第一次看到Morris Traversal的時候，真的覺得很神奇，直接看code看不懂，還是要搭配圖片來學習比較清楚。然後我本來想用DFS的方法，但是就會發生右子樹丟失的問題。這題真的很有趣，也很有挑戰性，希望自己在處理樹的方式更好。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #117 Populating Next Right Pointers in Each Node II - 刷題之旅</title>
      <link href="/posts/leetcode-117-populating-next-right-pointers-in-each-node-ii/"/>
      <url>/posts/leetcode-117-populating-next-right-pointers-in-each-node-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/poGeSwV.png" alt=""><br><img src="https://i.imgur.com/EVFgUFx.png" alt=""></p><p>給定一個二元樹，然後每個節點有一個 next 指針，將它指向它右邊的節點。如果沒有右邊的節點，則設為 None。</p><div class="note warning flat"><p>題目有特殊要求，不能使用額外的空間，也就是說不能使用 Queue 來解這題。</p></div><h1 id="2-解法">2 解法</h1><p>我們先走簡單路線，你會發現<em>基本上就是把同一層的節點串起來</em>，然後再串下一層的節點。因此我們可以使用BFS的方式來解這題。講到BFS的演算法，可以參考這篇<a href="/posts/lecture-bfs-dfs">LeetCode 課前預習 - 掌握 BFS 與 DFS 指南</a>。</p><h2 id="2-1-Queue">2.1 Queue</h2><p>我們可以知道在Iterative的方式下，先不考慮題目限制，我們可以使用Queue來解這題。</p><p><em>BFS的演算法</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">nodes</span>):</span><br><span class="line">        <span class="comment"># 如果沒有節點，就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        next_level = []     <span class="comment"># 裝下一層的每個節點</span></span><br><span class="line">        result = []         <span class="comment"># 裝目前這層的節點值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:  <span class="comment"># 循序這層的每個節點</span></span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:   </span><br><span class="line">                next_level.append(node.left)    <span class="comment"># 把目前這層的子節點，都放到下一層的next_level</span></span><br><span class="line">            <span class="keyword">if</span> node.right:  </span><br><span class="line">                next_level.append(node.right)   <span class="comment"># 把目前這層的子節點，都放到下一層的next_level</span></span><br><span class="line">        </span><br><span class="line">        bfs(next_level)     <span class="comment"># 繼續執行下一層的節點</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        bfs([root])</span><br><span class="line">    <span class="keyword">return</span> [node <span class="keyword">for</span> level <span class="keyword">in</span> result <span class="keyword">for</span> node <span class="keyword">in</span> level]</span><br></pre></td></tr></table></figure><p>從上面得到一個概念，那就是如果我們把 <code>next_level</code>也就是當前的 <code>nodes</code> 串起來，不就達到題目的要求了嗎？我們希望在執行 for loop 每個 <code>node</code> 的時候，可以把 <code>nodes</code>之間串起來。可以先建立一個 <code>dummyhead</code>，然後串 <code>node</code>，這樣進入 for loop 的時候，就可以 <code>dummyhead.next</code> 串起來，傳完後再重新把 <code>dummyhead</code> 斷開就好。<br>大概是這種感覺:<br><img src="https://i.imgur.com/fARUf3D.png" alt=""></p><p><em>把同level的nodes串起來</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dummy = Node(-<span class="number">1</span>)</span><br><span class="line">cur = dummy</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    cur.<span class="built_in">next</span> = node</span><br><span class="line">    cur = cur.<span class="built_in">next</span></span><br><span class="line">    ...</span><br><span class="line">dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>基本上我們就完成了，以下是完整的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: Node</span>) -&gt; Node:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">nodes</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        next_level = []</span><br><span class="line">        dummy = Node(-<span class="number">1</span>)</span><br><span class="line">        pre = dummy     <span class="comment"># dummy head in each level</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">            pre = node</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                next_level.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                next_level.append(node.right)</span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span>   <span class="comment"># reset dummy</span></span><br><span class="line">        bfs(next_level)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        bfs([root])</span><br></pre></td></tr></table></figure><h2 id="2-2-Space-O-1">2.2 Space O(1)</h2><p>但是這樣還不夠，因為題目有要求 O(1)的空間限制，因此我們不能使用 Queue 來解這題。我參考了這篇<a href="https://leetcode.wang/leetcode-117-Populating-Next-Right-Pointers-in-Each-NodeII.html">Leetcode wang</a>的文章，我覺得挺清楚的。<em>通常講到 O(1) 就要聯想到 pointer</em>，那我們需要兩個pointer：</p><ul><li>一個pointer紀錄上一層的level的node，我們稱作<code>pre</code>;</li><li>另一個pointer紀錄當前層level的node，我們稱作<code>cur</code></li></ul><p><code>pre</code>跟<code>cur</code>都要往右移動，也就是<code>cur</code>負責串當前層的節點，<code>pre</code>負責移動上一層的node，以方便<code>cur</code>繼續連下一個樹同層的節點。大概是這種感覺：</p><blockquote><p>處理<code>pre</code>的子節點時，<code>cur</code>要負責把小孩子都串起來<br><img src="https://i.imgur.com/OU73098.png" alt=""></p></blockquote><blockquote><p>當<code>cur</code>的小孩子串完後，<code>pre</code>要往右移動，<code>cur</code>才可以繼續串<br><img src="https://i.imgur.com/qKaGuTs.png" alt=""></p></blockquote><p>從以上規律可以發現：</p><ul><li><code>dummy</code> 負責串每層的第一個</li><li><code>pre</code> 會一直往右走直到觸底，就換下層的第一個，可以指向<code>dummy.next</code></li><li><code>cur</code> 負責把當前的層串起來</li></ul><p><img src="https://i.imgur.com/97ppiHL.png" alt=""></p><p><em>完整程式碼如下</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: Node</span>) -&gt; Node:</span><br><span class="line">    pre = root </span><br><span class="line">    <span class="keyword">while</span> pre: </span><br><span class="line">        dummy = Node(-<span class="number">1</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> pre:  <span class="comment"># pre 如果觸底了，pre 就換下層的第一個</span></span><br><span class="line">            <span class="keyword">if</span> pre.left:</span><br><span class="line">                cur.<span class="built_in">next</span> = pre.left</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> pre.right:</span><br><span class="line">                cur.<span class="built_in">next</span> = pre.right</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span>  <span class="comment"># pre 會一直往右走直到觸底</span></span><br><span class="line">        pre = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># reset dummy</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題花了大概30分鐘想出來，這是我第一次寫BFS的題目，因此還是有借住一點idea，搭配BFS的演算法，免強想出一個O(n)空間複雜度的解法。這題的重點在於，如何把同一層的節點串起來，然後再串下一層的節點。這樣的題目，我覺得還是要多練習，才能更加熟練。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 BFS 與 DFS 指南</title>
      <link href="/posts/lecture-bfs-dfs/"/>
      <url>/posts/lecture-bfs-dfs/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-vs-DFS">BFS vs DFS</h1><p>二元樹走訪或稱二元樹遍歷，簡單來說就是走訪樹中各節點，<em>轉化為線性關係</em>。</p><p><strong>主要分成兩種策略方式</strong></p><ul><li><code>深度優先搜尋（Depth-first Search，DFS）</code>:從根節點出發，選擇某一子樹並以<em>垂直方向由上到下</em>處理，將其子節點訪問完後，再選擇另一子樹走訪。</li><li><code>廣度優先搜尋（Breadth-first Search，BFS）</code>:從根節點出發，以<em>水平方向由左到右</em>走訪，將同階層的兄弟節點訪問完之後，再走訪下一階層的節點。</li></ul><h1 id="深度優先搜尋-DFS">深度優先搜尋 DFS</h1><p><img src="https://i.imgur.com/sXVzHvx.png" alt=""><br>假設根結點為N、左子樹為L、右子樹為R</p><ul><li>前序走訪(Pre-order Traversal): <code>NLR</code>, <code>根節點</code> → <code>左子樹</code> → <code>右子樹</code></li><li>中序走訪(In-order Traversal): <code>LNR</code>, <code>左子樹</code> → <code>根節點</code> → <code>右子樹</code></li><li>後序走訪(Post-order Traversal): <code>LRN</code>, <code>左子樹</code> → <code>右子樹</code> → <code>根節點</code></li></ul><p>簡單來說</p><ul><li>都是<em>先左子樹，再右子樹</em></li><li><code>preorder</code>: root 在前面</li><li><code>inorder</code>: root 在中間（裡面）</li><li><code>postorder</code>: root 在後面</li></ul><h2 id="preorder的實作">preorder的實作</h2><blockquote><p><code>前序走訪</code>： 順序是根節點、左子節點、右子節點。<br><img src="https://i.imgur.com/pqK2gdz.png" alt=""><br>Order: [1, 2, 4, 8, 9, 5, 3, 6, 10, 11, 7]</p></blockquote><p><code>recursive</code>: 先處理根節點 -&gt; 假設左右子樹已經處理好 ：（再印左）-&gt;（後印右）<br><code>iterative</code>: 使用 stack 把要先處理的節點晚點放入，先處理左子樹，再處理右子樹。那就先塞右子樹，再塞左子樹。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前序遍历 (NLR)</span></span><br><span class="line"><span class="string">    根节点 → 左子树 → 右子树</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        result.append(node.val)  <span class="comment"># 訪問root</span></span><br><span class="line">        dfs(node.left)           <span class="comment"># 遞迴訪問左子樹</span></span><br><span class="line">        dfs(node.right)          <span class="comment"># 遞迴訪問右子樹</span></span><br><span class="line">    </span><br><span class="line">    dfs(root) <span class="comment"># 起點：開始遞迴</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    前序遍历 (NLR)</span></span><br><span class="line"><span class="string">    根节点 → 左子树 → 右子树</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    stack, result = [root], []  <span class="comment"># stack用來存放要處理的節點 result 是解答</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()  <span class="comment"># 起點：從root開始</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            result.append(node.val)  <span class="comment"># root 先處理</span></span><br><span class="line">            stack.append(node.right) <span class="comment"># stack 後進先出：right後處理，先押入stack</span></span><br><span class="line">            stack.append(node.left)  <span class="comment"># stack 後進先出：left先處理，後押入stack</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="inorder的實作">inorder的實作</h2><blockquote><p><code>中序走訪</code>： 順序是左子節點、根節點、右子節點。<br><img src="https://i.imgur.com/xIllxaU.png" alt=""><br>Order: [8, 4, 9, 2, 5, 1, 10, 6, 11, 3, 7]</p></blockquote><p><code>recursive</code>:  假設左右子樹已經處理好 ：先印左子樹 -&gt; 印root -&gt;後印右子樹<br><code>iterative</code>:</p><ul><li>使用 stack 深入進去左子樹的底端</li><li>stack pop 出來處理(最底層的左子樹)</li><li>轉向右子樹</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历 (LNR)</span></span><br><span class="line"><span class="string">    左子树 → 根节点 → 右子树</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(node.left)           <span class="comment"># 先處理左子樹</span></span><br><span class="line">        result.append(node.val)  <span class="comment"># 再處理root</span></span><br><span class="line">        dfs(node.right)          <span class="comment"># 後處理右子樹</span></span><br><span class="line">    </span><br><span class="line">    dfs(root)   <span class="comment"># 起點：開始遞迴</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中序遍历 (LNR)</span></span><br><span class="line"><span class="string">    左子树 → 根节点 → 右子树</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    stack, result = [], []</span><br><span class="line">    current = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> current:</span><br><span class="line">        <span class="comment"># 要先把整個左邊處理完，因此要先一直塞left到底</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            stack.append(current)</span><br><span class="line">            current = current.left  <span class="comment"># 一直向左子樹走</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把stack中所有的左子樹節點進行處理</span></span><br><span class="line">        current = stack.pop()</span><br><span class="line">        result.append(current.val)  <span class="comment"># 處理 left -&gt; root </span></span><br><span class="line">        current = current.right     <span class="comment"># 最後，轉向當前左子樹最底的右節點</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="postorder的實作">postorder的實作</h2><blockquote><p><code>後序走訪</code>： 順序是左子節點、右子節點、根節點。<br><img src="https://i.imgur.com/dOKKFgn.png" alt=""><br>Order: [8, 9, 4, 5, 2, 10, 11, 6, 7, 3, 1]</p></blockquote><p><code>recursive</code>:  假設左右子樹已經處理好 ：先印左子樹 -&gt; 後印右子樹 -&gt; 印root<br><code>iterative</code>:</p><ul><li>很像preorder前序走訪，只是 順序是根節點、右子節點、左子節點。</li><li>因此我們可以使用preorder的方式，但是要先append右子樹，再append左子樹</li><li>最後再reverse整個結果列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历 (LRN)</span></span><br><span class="line"><span class="string">    左子树 → 右子树 → 根节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(node.left)           <span class="comment"># 遞迴訪問左子樹</span></span><br><span class="line">        dfs(node.right)          <span class="comment"># 遞迴訪問右子樹</span></span><br><span class="line">        result.append(node.val)  <span class="comment"># 訪問root</span></span><br><span class="line">    </span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder_traversal_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    后序遍历 (LRN)</span></span><br><span class="line"><span class="string">    左子树 → 右子树 → 根节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    stack, result = [root], []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            result.append(node.val)  <span class="comment"># 訪問root</span></span><br><span class="line">            stack.append(node.left)  <span class="comment"># 因為最後會reverse，所以先處理右子樹，因此先押入左子樹</span></span><br><span class="line">            stack.append(node.right) <span class="comment"># 因為最後會reverse，所以後處理左子樹，因此後押入右子樹</span></span><br><span class="line">    </span><br><span class="line">    result.reverse()  <span class="comment"># 最後反轉結果列表</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="Morris-Traversal">Morris Traversal</h2><p>很多時候題目會要求 O(1) 空間複雜度，這時候我們可以使用 Morris Traversal 來達成，但是<em>此方法直接修改原始樹，但可以保證空間複雜度為 O(1)</em>，因此使用的時候要注意是否可以改動到原始樹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 1 的 left sub-tree 插入 right sub-tree 的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>         <span class="number">5</span></span><br><span class="line">     / \         \</span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>         <span class="number">6</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 將原本的right sub-tree 接到 left sub-tree 的最右邊節點</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">     / \          </span><br><span class="line">    <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">         \</span><br><span class="line">          <span class="number">5</span></span><br><span class="line">           \</span><br><span class="line">            <span class="number">6</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 將 2 的 left sub-tree 插入 right sub-tree 的地方</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>       <span class="number">4</span>  </span><br><span class="line">                 \</span><br><span class="line">                  <span class="number">5</span></span><br><span class="line">                   \</span><br><span class="line">                    <span class="number">6</span>   </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 將原本的 right sub-tree 接到 left sub-tree 的最右邊節點</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">2</span>          </span><br><span class="line">       \          </span><br><span class="line">        <span class="number">3</span>      </span><br><span class="line">         \</span><br><span class="line">          <span class="number">4</span>  </span><br><span class="line">           \</span><br><span class="line">            <span class="number">5</span></span><br><span class="line">             \</span><br><span class="line">              <span class="number">6</span>         </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><em>程式碼 preorder-morris-traversal</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flatten2</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; TreeNode:</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            <span class="comment"># 1. 先找到左樹最右邊的node rightmost</span></span><br><span class="line">            rightmost = cur.left</span><br><span class="line">            <span class="keyword">while</span> rightmost.right:</span><br><span class="line">                rightmost = rightmost.right</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 把 cur 的右樹接到 rightmost.right, 然後再把 cur.right 接到 left</span></span><br><span class="line">            rightmost.right = cur.right</span><br><span class="line">            cur.right = cur.left</span><br><span class="line">            cur.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. cur 換成 cur.right</span></span><br><span class="line">        cur = cur.right</span><br></pre></td></tr></table></figure><h1 id="廣度優先搜尋-BFS">廣度優先搜尋 BFS</h1><blockquote><p><code>層序走訪</code>： 順序是由根節點一層一層往下，由左往右。<br><img src="https://i.imgur.com/HTHctVb.png" alt=""><br>Order: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</p></blockquote><p><code>recursive</code>:  next_level 是拿來存放下一層的節點，values 當前層的解答，最後把 values 加入 result 中。<br><code>iterative</code>: 跟recursive不會有太大的差異，反而比較好理解，就是把下一層要處理的節點放入 queue （先進先出） 中，然後處理當前節點，只要發現當前的節點仍有下一層，那就放到queue等等處理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_recursive</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    广度优先搜索 (递归实现)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs_level</span>(<span class="params">nodes</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodes:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        next_level, values = [], []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            values.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                next_level.append(node.left) </span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                next_level.append(node.right)  </span><br><span class="line">        result.append(values)</span><br><span class="line">        bfs_level(next_level)</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        bfs_level([root])</span><br><span class="line">    <span class="keyword">return</span> [val <span class="keyword">for</span> sublist <span class="keyword">in</span> result <span class="keyword">for</span> val <span class="keyword">in</span> sublist] <span class="comment"># flatten result </span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs_iterative</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    广度优先搜索 (迭代实现)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    queue = deque([root])</span><br><span class="line">    result = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        result.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><p><strong>DFS複雜：使用Stack先進後出</strong><br><em>使用<code>recursive</code>會比較容易</em></p><ul><li>大問題：要走訪整個樹</li><li>小問題：<ul><li>假設左右子樹已經走訪  recursive 左右子樹，最後結合root即可</li></ul></li></ul><p><em>使用<code>iterative</code>會比較複雜</em></p><ul><li><code>preorder</code> 因為需要先完整的走到底 (左子樹)，因此可以先印root，然後先放 right 再放 left，這樣 pop 就會處理 按後進先出原則，先處理left再處理right。</li><li><code>postorder</code> 比較特別，記住他是 preorder (但是先處理右子樹，再處理左子樹)的相反，因此可以使用跟 preorder 一樣的方式，只是stack先放left再放right，最後再reverse整個結果列表。</li><li><code>inorder</code> 比較特殊，因為 root 放在中間，這意味著要先把左子樹走完，為了先走到底，我們要用 while loop 一直往左子樹底部走直到觸底，然後再處理root，最後轉向右子樹。</li></ul><p><strong>BFS單純：使用Queue先進先出</strong><br><em>使用 <code>recursive</code> 或是 <code>iterative</code> 所需要的概念都相同</em></p><ul><li>那就是都是先把下一層要處理的節點放入 queue 中，然後處理當前節點，只要發現當前的節點仍有下一層，那就放到queue等等處理。</li></ul><h1 id="Ref">Ref</h1><ul><li><a href="https://ithelp.ithome.com.tw/articles/10271647">ithome | 【Day14】[資料結構]-二元樹走訪Binary Tree Traversal</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #226 Invert Binary Tree - 刷題之旅</title>
      <link href="/posts/leetcode-226-invert-binary-tree/"/>
      <url>/posts/leetcode-226-invert-binary-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/KMgY27F.png" alt=""><br><img src="https://i.imgur.com/YqGKUT4.png" alt=""></p><p>要把左右子樹對調，outside替換，inside也是替換。</p><h1 id="2-解法">2 解法</h1><ol><li>大問題：要把一個樹的左右子樹對調</li><li>小問題：讓我們相信遞歸並<strong>假設我們已經透過遞歸給出了根的左子樹和右子樹對調</strong>。</li><li>最小的問題：當 root 是 None 時，回傳 None。</li></ol><p>假設就是我們呼叫 <code>invertTree(root.left)</code> 與 <code>invertTree(root.right)</code> 會回傳對調後的左右子樹，我們只要把左右子樹對調就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>: </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>大概花了20分，這題不難，但是我用了很蠢的方式寫，後來得到提示，就是直接假設左右子樹已經對調好了，就可以直接設定 <code>root.left=已經對調好的右子樹</code> 和 <code>root.right=已經對調好的左子樹</code>，這樣就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Easy </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #100 Same Tree - 刷題之旅</title>
      <link href="/posts/leetcode-100-same-tree/"/>
      <url>/posts/leetcode-100-same-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/XDtcbGv.png" alt=""><br><img src="https://i.imgur.com/MkqLN3W.png" alt=""><br>檢查兩棵樹是否相同</p><h1 id="2-解法">2 解法</h1><p>這題跟<a href="/posts/leetcode-101-Symmetric-Tree/">101-Symmetric Tree</a>的解法很像，所以很簡單：<br>一樣套用 Recursion 的思維，我們先將大問題變成小問題</p><ol><li>大問題：知道兩個樹是否相同</li><li>小問題：讓我們相信遞歸並<strong>假設我們已經透過遞歸給出了根的左子樹和右子樹是對稱的</strong>。</li><li>大小關係式：<code>(p.val == q.val) and (p.left, q.left) and (p.right, q.left)</code><ol><li>當前的值相同 and 左子樹相同 and 右子樹相同</li></ol></li><li>最小的問題：當 p 和 q 都觸底的時候，是如果都是None就代表True，但是當其中一邊有值，另一邊沒有值，就不相同了。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題很簡單，跟檢查兩棵樹是否對稱有一樣的解法，所以四分鐘就解完通過了！果然武器還是要備好。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Easy </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #105 Construct Binary Tree from Preorder and Inorder Traversal - 刷題之旅</title>
      <link href="/posts/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/"/>
      <url>/posts/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/qHNIwNd.png" alt=""><br><img src="https://i.imgur.com/PTGYgK0.png" alt=""></p><p>提供給你 preorder 與 inorder 的數列，請你建立一個二元樹。首先 讓我們先了解 preorder 與 inorder 的定義。<br><em>Inorder Traversal</em> -&gt; LEFT -&gt; ROOT -&gt;RIGHT<br><em>PreOrder Traversal</em> -&gt; ROOT -&gt; LEFT -&gt; RIGHT</p><h1 id="2-解法">2 解法</h1><p>你會發現，preorder 第一筆會是 Root，後面會先遍歷left sub-tree整顆跑完，才會再遍歷right sub-tree。而 inorder 是先遍歷left sub-tree，再遍歷root，最後是right sub-tree。你會發現 preorder 跟 inorder 的優缺點如下：</p><ul><li><strong>preorder</strong>:<ul><li>好處：因為第一個值是root，所以可以直接取得root的值</li><li>缺點：無法知道左右子樹的範圍</li></ul></li><li><strong>inorder</strong>:<ul><li>好處：可以知道左右子樹的範圍</li><li>缺點：無法知道root的值</li></ul></li></ul><p>因此我們要利用彼此雙方的好處，互補彼此的缺點。這時候我們就可以利用遞迴的方式來建立二元樹。<br><img src="https://i.imgur.com/5dFxDmh.png" alt=""></p><h2 id="2-1-取subtree的範圍">2.1 取subtree的範圍</h2><p><strong>Step1: 在preorder找到root + 在 inorder找到左右子樹長度</strong></p><ol><li>那就是如果我們先取得preorder的第一個值，就可以知道root的值是什麼</li><li>然後再根據這個值去inorder中找到root的位置，這樣就可以知道左右子樹的範圍。<ol><li>左子樹起點=0 ~ 左子樹 root_index (不包含) 簡單來說就是 <code>inorder[0:root_index]</code></li><li>右子樹起點=root_index+1 ~ 右子樹結束點=len(inorder) (包含) 簡單來說就是 <code>inorder[root_index+1:]</code></li></ol></li></ol><p>大概是這種感覺：<br><img src="https://i.imgur.com/PJOP42Y.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 1. 找到 inorder 的 root 位置以切出左右子樹</span></span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>]) </span><br><span class="line">    root_index = inorder.index(root.val) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 找到 inorder 的左右子樹</span></span><br><span class="line">    i_left = inorder[<span class="number">0</span>:root_index]</span><br><span class="line">    i_right = inorder[root_index+<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><p><strong>Step2: 根據左右子樹的長度，在preorder切割左右子樹</strong><br>因為我們用inorder知道了左右子樹的，我們就可以在 preorder 裡面從 <code>preorder[0+1:]</code> (root的下一個node) 開始切割左右子樹</p><ol><li>使用 <code>i_left</code> 的長度，在 <code>[1:]</code> 切割左子樹</li><li>[0+1:] 這個區間是由 左子樹 + 右子樹 所組成<ol><li>左子樹起點=1 ~ 左子樹結束點=1+left_len (不包含) 簡單來說就是 <code>preorder[1:1+left_len]</code></li><li>右子樹起點=1+left_len ~ 右子樹結束點=len(preorder) (包含) 簡單來說就是 <code>preorder[1+left_len:]</code></li></ol></li><li>從 preorder 得到的左右子樹，取第一個值，又可以得到 root<ol><li>inorder</li></ol></li><li>把preorder從[1:] 切成兩半左右子樹後，我們又可以開始遞迴，找到這兩個子樹的 root</li></ol><p>大概是這種感覺：<br><img src="https://i.imgur.com/Qvo1Xq8.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 1. 找到 inorder 的 root 位置以切出左右子樹</span></span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>]) </span><br><span class="line">    root_index = inorder.index(root.val) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 找到 inorder 的左右子樹</span></span><br><span class="line">    i_left = inorder[<span class="number">0</span>:root_index]</span><br><span class="line">    i_right = inorder[root_index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 用 inorder 左右子樹的長度，找出 preorder 的左右子樹</span></span><br><span class="line">    left_len = <span class="built_in">len</span>(i_left)</span><br><span class="line">    p_left = preorder[<span class="number">1</span>:left_len+<span class="number">1</span>]</span><br><span class="line">    p_right = preorder[left_len+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 然後我們就可以利用 preorder 的左右子樹，找到左右子樹的 root</span></span><br><span class="line">    root.left = self.buildTree(p_left, i_left)</span><br><span class="line">    root.right = self.buildTree(p_right, i_right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>Step3: 當左右子樹為空時，回傳None</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 最小問題：當左右子樹為空時，回傳None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 找到 inorder 的 root 位置以切出左右子樹</span></span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>]) </span><br><span class="line">    root_index = inorder.index(root.val) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 找到 inorder 的左右子樹</span></span><br><span class="line">    i_left = inorder[<span class="number">0</span>:root_index]</span><br><span class="line">    i_right = inorder[root_index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 用 inorder 左右子樹的長度，找出 preorder 的左右子樹</span></span><br><span class="line">    left_len = <span class="built_in">len</span>(i_left)</span><br><span class="line">    p_left = preorder[<span class="number">1</span>:left_len+<span class="number">1</span>]</span><br><span class="line">    p_right = preorder[left_len+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 然後我們就可以利用 preorder 的左右子樹，找到左右子樹的 root</span></span><br><span class="line">    root.left = self.buildTree(p_left, i_left)</span><br><span class="line">    root.right = self.buildTree(p_right, i_right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="精簡">精簡</h3><p>我們稍微整理一下，這個遞迴的過程</p><ol><li>left_len 其實可以用 root_index 來取代，因為左子樹的長度就是 root_index</li><li>最後 就可以精簡成這樣</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>]) </span><br><span class="line">    root_index = inorder.index(root.val) </span><br><span class="line">    root.left = self.buildTree(preorder[<span class="number">1</span>:root_index+<span class="number">1</span>], inorder[<span class="number">0</span>:root_index])</span><br><span class="line">    root.right = self.buildTree(preorder[root_index+<span class="number">1</span>:], inorder[root_index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>總結一下順序：</p><ol><li><strong>inorder切出左右子樹</strong>: 在 inorder 用 root 切出左右子樹的範圍</li><li><strong>inorder找出左右子樹長度</strong>:拿 inorder 左右子樹的長度，在 preorder 切出左右子樹的範圍</li><li><strong>preorder 切出左右子樹，以找出root</strong>: preorder 的左右子樹一出來，就可以知道左右子樹的 root 是什麼（因為preorder的第一個值是root）</li><li><strong>大小問題關係式</strong>: 然後把 root.left 與 root.right 填入</li></ol><p>這題的大問題與小問題的關係是</p><ol><li>大問題：建立一個二元樹</li><li>小問題：建立左右子樹</li><li>大小問題的關聯式：假設知道 root.left 與 root.right 最後要回傳 root<ol><li>左子樹的範圍是 <code>preorder[1:root_index+1]</code> 與 <code>inorder[0:root_index]</code>，右子樹的範圍是 <code>preorder[root_index+1:]</code> 與 <code>inorder[root_index+1:]</code></li><li>我們要回傳 root，並且把左右子樹填入</li><li>root 一定是 preorder 的第一個 node，因此 root.left 跟 root.right 就是左右子樹中 preorder 的第一個 node</li></ol></li></ol><h2 id="2-2-queue-的解法">2.2 queue 的解法</h2><p><img src="https://i.imgur.com/TsVaXXO.png" alt=""></p><p>這題解法也很酷，你可以從上圖看到，preorder 儘管被切割成 left 與 right，但是我們真正會使用到 preorder 的地方就是 <code>root = TreeNode(preorder[0])</code> 我們只是想拿 preorder 的第一個值，如果我們每次取完root後，就 pop 掉，下一個數值就會是肯定是子樹的root。因此我們也不用大費周章的去切割preorder，只要每次取完root後，就 pop 掉，下一個數值就會是肯定也會是某個子樹的root。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="keyword">if</span> inorder:</span><br><span class="line">        INDEX = inorder.index(preorder.pop(<span class="number">0</span>))</span><br><span class="line">        root = TreeNode(inorder[INDEX])</span><br><span class="line">        root.left = self.buildTree(preorder, inorder[:INDEX]) <span class="comment"># 直接傳 preorder 進去(root已經被pop掉了)</span></span><br><span class="line">        root.right = self.buildTree(preorder, inorder[INDEX+<span class="number">1</span>:]) <span class="comment"># 直接傳 preorder 進去(root已經被pop掉了)</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題花了一個小時，概念是想出來了，但是還是寫不太出來Recursive…，後來看了一下解答，慢慢體會想法被實踐的感覺…呵呵。希望Recursion會慢慢進步。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Medium </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #101 Symmetric Tree - 刷題之旅</title>
      <link href="/posts/leetcode-101-Symmetric-Tree/"/>
      <url>/posts/leetcode-101-Symmetric-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/Hj7XjLr.png" alt=""></p><p>檢查是否對稱。<br>Follow up: Could you solve it both recursively and iteratively?</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-Recursioin">2.1 Recursioin</h2><p>一樣套用Recursion的思維，我們先將大問題變成小問題</p><ol><li>大問題：知道一個樹是否對稱</li><li>小問題：讓我們相信遞歸並<strong>假設我們已經透過遞歸給出了根的左子樹和右子樹是否對稱</strong>。</li><li>大小關係式：(left.val == right.val) and (left.left, right.right) and (left.right, right.left)<ul><li>當前的值 and 外面對稱 and 裡面對稱</li></ul></li><li>最小的問題：當 left 和 right 都觸底的時候，是對稱的，但是當其中一邊有值，另一邊沒有值，就不對稱了。</li></ol><p>我們可以定義一個遞歸函數，它將兩個節點作為輸入，一個來自左子樹，一個來自右子樹。如果兩個節點都為 null，或者它們的值相等且子樹對稱，則輔助函數傳回 true。</p><p>大概是這樣的感覺：<br><img src="https://i.imgur.com/NAhK7tT.png" alt=""><br><img src="https://i.imgur.com/kBNwpft.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._is_symmetric(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_symmetric</span>(<span class="params">self, left_root: TreeNode, right_root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> left_root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right_root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> left_root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right_root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        outside = self._is_symmetric(left_root.left, right_root.right)</span><br><span class="line">        inside = self._is_symmetric(left_root.right, right_root.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_root.val == right_root.val <span class="keyword">and</span> outside <span class="keyword">and</span> inside</span><br></pre></td></tr></table></figure><h2 id="2-2-Iteration">2.2 Iteration</h2><ol><li>初始化隊列：將根節點的左子樹和右子樹成對放入隊列中。</li><li>迭代檢查：<ol><li>每次從隊列中取出一對節點進行比較。</li><li>如果兩個節點都為 None，則繼續下一次迭代。</li><li>如果其中一個節點為 None 或兩個節點的值不相等，則樹不對稱，返回 False。</li><li>將節點的<strong>子節點成對放入隊列中</strong>，以便在下一次迭代中檢查：<ol><li>inside: 左節點的右子樹與右節點的左子樹成對。</li><li>outside: 左節點的左子樹與右節點的右子樹成對。</li></ol></li></ol></li><li>結束條件：當隊列為空時，表示已經檢查完所有成對的節點，且都對稱，返回 True。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="comment"># 初始化隊列 成對放入</span></span><br><span class="line">    queue = deque((root.left, root.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue: </span><br><span class="line">        left, right = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> left.val != right.val: </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        queue.append((left.left, right.right))</span><br><span class="line">        queue.append((left.right, right.left))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>就差一點點，我還是有偷看解答的前面兩段話獲得hint，差點寫除來，但是很接近了。最後我卡在 <code>left_root.val == right_root.val and outside and inside</code> 一開始我只有意識到 <code>outside and inside</code>，我是把 <code>left_root.val == right_root.val</code> 當作最小問題來處理，但他還不是最小。最小問題是雙方為None時。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Easy </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #104 Maximum Depth of Binary Tree - 刷題之旅</title>
      <link href="/posts/leetcode-104-maximum-depth-of-binary-tree/"/>
      <url>/posts/leetcode-104-maximum-depth-of-binary-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/rqtO8xf.png" alt=""><br>計算Binary Tree的最大深度。</p><h1 id="2-解法">2 解法</h1><p>我們先將大問題變成小問題</p><ol><li>大問題：知道一個樹的最大深度</li><li>小問題：讓我們相信遞歸並<strong>假設我們已經透過遞歸給出了根的左子樹和右子樹的最大深度</strong>。</li><li>大小問題的關係：因此，為了找到這個二元樹的最大深度，我們必須取出遞歸給我們的 2 個深度中的最大值，然後加 1 以將當前級別（即根的級別）考慮到我們的深度中。</li><li>最小的問題是，當 root 是 None 時，我們的深度為 0。</li></ol><div class="note info flat"><p>大小問題關係式：max(左子樹深度, 右子樹深度) + 1(root)</p></div><p>寫成python大概會長這樣</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>還有另一種思維，那就是最小的問題就是當 root 有值，但是就一個節點，沒有 right 與 left，這時候我們的深度就是 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>還不是很適應遞迴的思維，所以這個我還是直接偷看了一下解答，不看沒發現，一看不得了，幸好有先學Recursion的思維，不然這題真的會卡住。可以參考一下我的<a href="/posts/lecture-recursion">LeetCode 課前預習 - 掌握 Recursion 的思維指南</a>。思考的時候我們想三個方向</p><ol><li>他們的大問題跟小問題分別可以是什麼</li><li>大小問題的關聯式子怎麼寫</li><li>最小問題又是什麼</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Recursion </tag>
            
            <tag> Easy </tag>
            
            <tag> binary-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Recursion 的思維指南</title>
      <link href="/posts/lecture-recursion/"/>
      <url>/posts/lecture-recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>會想要寫這篇是因為在碰到binary tree的時候會大量的使用recursion，因此想先瞭解Recursion的核心思維，希望能讓自己將遞迴的概念內化，讓他從此不再高不可攀。那我們就開始吧！首先，來聊聊基礎遞迴常見的思維方式之一，</p><ol><li>先將一個大問題，拆解成幾個較小的問題</li><li>如果發現這些較小的問題當中，也能<strong>依照相同的方式拆解</strong>成更小的問題</li><li>每當小問題解決時，<strong>大問題也可以依靠小問題的結果來解決</strong></li><li>從大問題到小問題，<strong>每層</strong>的解決方法都是<strong>一樣</strong>的，除了<strong>最小問題</strong>以外</li><li>根據以上幾點，我可以不段套用相同的函數，讓他<strong>自己幫自己解決問題</strong></li></ol><p>以上就是遞迴的基本核心精神，如何分析看不懂沒關係，我們先來看個最基本的例子</p><h1 id="實戰範例">實戰範例</h1><h2 id="從-1-加到-n">從 1 加到 n</h2><p>如果使用迴圈的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">n</span>):</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        result += i</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>我們的思考方式如下：</p><ol><li>大問題：從1加到n</li><li>小一點的問題：從1加到n-1</li><li>那我們只要先處理好小問題，最後再把其答案加上n就好了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_1_to_n</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + sum_1_to_n(x-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>這個思維就是，如果我想算 sum(1~10)，我可以改成算 10 + sum(1~9)。那如何算 sum(1~9) 呢？當然就是 9 + sum(1~8) 依此類推下去。</p><p>但最後還有個小問題，如果我們要算 sum(1~1)，該怎麼做？如果寫成 1 + sum(1~0) 似乎有點不合理，所以這就是我們所謂的<strong>最小問題需要額外的處理</strong>，很幸運的是我們的最小問題非常容易，因為我們已經知道答案是 1。因此將上面的程式碼稍作修改後，最終答案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_1_to_n</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x + sum_1_to_n(x-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>到此為止，我們用兩種方法解決了相同的問題，而他們兩個思維本質上的差異在於：</p><ol><li>迴圈（Iteration）：當用迴圈（Iteration）思考時，你則總是得很明確的告訴電腦<em>每一個變數的值要如何改變</em>，所以得想清楚這些值的所有變化過程。</li><li>遞迴（Recursion）：當用遞迴（Recursion）思考時，我們並不直接思考如何解決問題，而是先思考<em>問題能否被拆小</em>，還有<em>大問題跟小問題間的關聯性</em>。</li></ol><p>迴圈應該對大多工程師來說都非常的直覺了，那我們為何還需要學遞迴的做法呢？以上述例子來說，<em>Recursion雖然讓程式碼簡潔了一點點，不過思考起來稍微難了點</em>，似乎有利有弊。但我們要把吃苦當吃補，這是因為這種思維的轉換，是遞迴最重要的地方，因為有些演算法，靠遞迴的思路來寫可能會非常容易，像是Binary Tree</p><p>重新用遞迴思維看一次上面的例子，當我們有了一個空殼的 function 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_1_to_n</span>(<span class="params">x</span>):</span><br><span class="line">    ???</span><br></pre></td></tr></table></figure><p>我們並不清楚該如何實作他，但我想的是假如這個 function 可以運作，那我如何利用他自己來幫自己解決問題。於是我們想的東西是<br><strong>從大到小問題</strong></p><ol><li>我發現一個轉移式 <code>sum_1_to_n(x) = x+ sum_1_to_n(x-1)</code></li><li>那依此類推，<code>sum_1_to_n(x-1) = (x-1) + sum_1_to_n(x-2)</code> … 這個等式可以繼續無限循環下去。</li><li>而我也知道最小問題 <code>sum_1_to_n(1)</code> 的答案是 1，所以在最小問題可以停下直接給答案。<br><strong>從小問題到大問題</strong></li><li>我知道 <code>sum_1_to_n(1)</code> 的答案是 1</li><li>那套用轉移式，我可以知道 <code>sum_1_to_n(2) = 2 + sum_1_to_n(1) = 2 + 1 = 3</code>，你會發現 x 就是 2 而 x-1 要放入 <code>sum_1_to_n</code> 函式裡面</li><li>繼續以上，我們可以知道 <code>sum_1_to_n(3) = 3 + sum_1_to_n(2) = 3 + 3 = 6</code> … 如此循環下去，我就能知道任意的 <code>sum_1_to_n(x)</code> 的值了</li></ol><h2 id="河內塔">河內塔</h2><p><img src="https://i.imgur.com/4WMk1Fa.png" alt=""><br>我們有三根柱子，並有 N 個圓盤套在最左邊柱子上面（上圖 N = 4），現在我們要把它們全部移動到最右邊的柱子上，請問我們最少需要移動幾次？<br>以下是移動的規則：</p><ol><li>每次只能移動一個最上方的圓盤到任意柱子上</li><li>大圓盤不能放在小圓盤上面</li></ol><p>遞迴思維：大問題沒頭緒的話，先想一下，如果能解決稍微小一點的問題，是不是就能靠他幫忙，來解決大問題了。</p><ol><li>大問題：移動 4 個圓盤總共需要幾步</li><li>小一點的問題：移動 3 個圓盤總共需要幾步（相同的問題，但範圍變小）</li></ol><p>假設我們知道小問題的答案（如何移動3個圓盤到特定柱子），我們可以把最後一步的步驟想成，假如移動3個盤子需要的步驟是K，那移動4個盤子就是</p><ol><li>先移動3個盤子到中間的柱子，這個步驟需要K步</li><li>先把最下面的盤子移動到最右邊，這個步驟需要1步</li><li>然後把剩下的3個盤子從中間移動到右邊的柱子，這個步驟需要K步</li></ol><p><img src="https://i.imgur.com/ypeMwOJ.png" alt=""></p><h3 id="1-找到關係式">1. 找到關係式</h3><div class="note warning flat"><p>因此我們得到了一個寶貴的關係式：<strong>（移動 X 個盤子的步驟數）= 2 * (移動 X - 1 個盤子的步驟數) + 1</strong></p></div><p>寫成程式碼的話就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi_tower_step</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * hanoi_tower_step(x-<span class="number">1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-最小問題的解答">2. 最小問題的解答</h3><p>當然，一樣不能忘記，我們都會有一個”最小問題”，他不能再繼續遞迴下去，在這邊我們的最小問題，當然就是<em>只有 1 個圓盤的時候該如何處理，而很顯然的，這個答案也是 1</em>。最終我們就會得到非常簡潔的答案如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hanoi_tower_step</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * hanoi_tower_step(x-<span class="number">1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>靠著遞迴的思維，我們<em>甚至根本就不知道移動盤子的最佳策略是什麼</em>，或說我們唯一需要知道的策略，只有如何移動 1 個盤子，也就是 1 步，或 0 個盤子也行，就是 0 步，<em>剩下的就只剩找到大小問題之間的關聯性就解決了</em>，是不是很強大。</p><p>其他常見的簡單經典例子還有：<a href="https://zh.wikipedia.org/wiki/%E9%9A%8E%E4%B9%98">階乘</a>、<a href="https://zh.wikipedia.org/zh-tw/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">費氏數列</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">輾轉相除法</a>、<a href="https://leetcode.com/problems/climbing-stairs/">爬梯子</a> 等等。</p><h2 id="費氏數列">費氏數列</h2><p>以費氏數列（Fibonacci）為例</p><ol><li>大問題：找到費氏數列中，第 X 個數的數值</li><li>小問題1：找到費氏數列中，第 X-1 個數的數值</li><li>小問題2：找到費氏數列中，第 X-2 個數的數值</li><li>大小問題的關聯式：fibonacci(x) = fibonacci(x-1) + fibonacci(x-2)</li><li>最小問題：第 1 個與第 2 個數的數值</li></ol><p>所以程式碼，照抄下來就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">or</span> x == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(x-<span class="number">1</span>) + fibonacci(x-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>遞迴還有另一個小缺點是<strong>深度限制</strong>。簡單來說，就是遞迴的過程中，由於每個 function 都還沒執行完就又 call 了自己，那你就會堆積一堆執行到半路的 function，電腦需要一定的記憶體去記錄這些狀態，所以當你深度太超過就會炸掉（Stack Overflow），有興趣更深入理解的讀者可以看這邊的解說，常見的處理方式叫做 <a href="https://tw.coderbridge.com/questions/b945143a4ed74799b06a96804bbc9e05">Tail Recursion</a>。若以刷 Leetcode 題來說，由於題目會設計好，你幾乎是不會遇到這問題的，但實務中則要小心注意。</p></div><h1 id="總結">總結</h1><p>思考的時候我們想三個方向</p><ol><li>他們的大問題跟小問題分別可以是什麼</li><li>大小問題的關聯式子怎麼寫</li><li>最小問題又是什麼</li></ol><h1 id="Ref">Ref</h1><ul><li><a href="https://medium.com/appworks-school/%E9%80%B2%E5%85%A5%E9%81%9E%E8%BF%B4-recursion-%E7%9A%84%E4%B8%96%E7%95%8C-%E4%B8%80-59fa4b394ef6">Medium | 一次看懂遞迴 (Recursion) 的思維模式（一</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手帶你實作 Hugging Face Transformers (入門篇)</title>
      <link href="/posts/transformers/"/>
      <url>/posts/transformers/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformers-相關的庫">Transformers 相關的庫</h1><ul><li>Transformers 核心庫: 模型加載 模型訓練</li><li>Tokenizer 分詞器: 對數據進行預處理，將文本轉換成模型可以理解的格式(Token序列)</li><li>Datasets 數據集庫: 下載公開的數據集，並且進行預處理</li><li>Evaluate 評估函示: 像是準確率 F1, BLEU, ROUGE 等等</li><li>PEFT 高校微調方法: 只訓練一小部分參數，而不是全部重新訓練，提供常用的微調方法</li><li>Accelerate 分布式訓練: 對訓練過程進行加速，提供了分布式訓練的方法</li><li>Optimum 優化加速庫: 提供了一些優化方法，比如混合精度訓練，對訓練過程進行加速</li><li>Gradio 可視化庫: 提供了一些可視化的方法，透過幾行程式達到快速外部交互的效果</li></ul><h1 id="前置環境">前置環境</h1><p>需要安裝以下套件：</p><ol><li>python</li><li>conda</li><li>pytorch</li></ol><ul><li>以我的狀況為例，我是cuda支援的版本是12.4，這代表小於12.4的版本都可以支援cuda，建議使用pip進行安裝</li><li>30xx 或是 40xx 顯卡要安裝 cu11 以上的版本</li></ul><p>最後測試是否安裝成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Name&gt;python</span><br><span class="line">&gt;&gt;&gt; import torch</span><br><span class="line">&gt;&gt;&gt; torch.cuda.is_available()</span><br><span class="line">True <span class="comment"># 如果是 True 代表安裝成功</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="確認cuda版本">確認cuda版本</h2><p><img src="https://i.imgur.com/Dpk1cKn.png" alt=""></p><ol><li>進入 nvdia 控制面板</li><li>點選系統信息</li><li>查看 cuda 版本</li></ol><h1 id="Transformers-安裝">Transformers 安裝</h1><p>執行以下指令安裝 transformers</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install transformers datasets evaluate peft accelerate gradio optimum sentencepiece</span><br><span class="line">pip install jupyterlab scikit-learn pandas matplotlib tensorboard nltk rouge</span><br></pre></td></tr></table></figure><h1 id="關於Pipeline">關於Pipeline</h1><p>這是一個簡單的工具，可以幫助我們快速的使用模型進行預測，包含三個階段：</p><ol><li>Tokenization 數據處理: 將文本轉換成模型可以理解的格式(Token序列)<ul><li>Raw Text (<code>&quot;This is apple&quot;</code>) -&gt; Tokenization -&gt; Token IDs (<code>[100, 101, 2708]</code>)</li></ul></li><li>Model 模型調用: 使用模型進行預測<ul><li><code>[-4.3630, 4.6859]</code></li></ul></li><li>Post-processing 結果後處理: 將模型的輸出轉換成我們需要的格式<ul><li><code>Pisitive: 99.89%, Negative: 0.11%</code></li></ul></li></ol><p>有很多不同 Pipeline 支援的任務，可以透過以下程式碼查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers.pipelines <span class="keyword">import</span> SUPPORTED_TASKS</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> SUPPORTED_TASKS.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v[<span class="string">&quot;type&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示出以下 這邊我們會以 text-classification 為例</span></span><br><span class="line">audio-classification  | audio</span><br><span class="line">automatic-speech-recognition  | multimodal</span><br><span class="line">text-to-audio  | text</span><br><span class="line">feature-extraction  | multimodal</span><br><span class="line">text-classification  | text</span><br><span class="line">token-classification  | text</span><br><span class="line">question-answering  | text</span><br><span class="line">table-question-answering  | text</span><br><span class="line">visual-question-answering  | multimodal</span><br><span class="line">document-question-answering  | multimodal</span><br><span class="line">fill-mask  | text</span><br><span class="line">summarization  | text</span><br><span class="line">translation  | text</span><br><span class="line">text2text-generation  | text</span><br><span class="line">text-generation  | text</span><br><span class="line">zero-shot-classification  | text</span><br><span class="line">zero-shot-image-classification  | multimodal</span><br><span class="line">zero-shot-audio-classification  | multimodal</span><br><span class="line">conversational  | text</span><br><span class="line">image-classification  | image</span><br><span class="line">image-feature-extraction  | image</span><br><span class="line">image-segmentation  | multimodal</span><br><span class="line">image-to-text  | multimodal</span><br><span class="line"><span class="built_in">object</span>-detection  | multimodal</span><br><span class="line">zero-shot-<span class="built_in">object</span>-detection  | multimodal</span><br><span class="line">depth-estimation  | image</span><br><span class="line">video-classification  | video</span><br><span class="line">mask-generation  | multimodal</span><br><span class="line">image-to-image  | image</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/cyb3H6I.png" alt=""></p><h2 id="快速上手">快速上手</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pipe = pipeline(<span class="string">&quot;text-classification&quot;</span>) <span class="comment"># 指定任務 </span></span><br><span class="line">pip(<span class="string">&quot;This is a good day&quot;</span>) <span class="comment"># 會印出 &#123;&#x27;label&#x27;: &#x27;POSITIVE&#x27;, &#x27;score&#x27;: 0.9998&#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用指定模型">使用指定模型</h2><p>可以前往 <a href="https://huggingface.co/models">https://huggingface.co/models</a> 找到模型名稱建立相對應的Pipeline。</p><p><strong>指定任務 -&gt; 再指定模型 -&gt; 創建基於指定模型的 Pipeline</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pipe = pipeline(<span class="string">&quot;text-classification&quot;</span>, model=<span class="string">&quot;uer/roberta-base-finetuned-dianping-chinese&quot;</span>)</span><br><span class="line">pipe(<span class="string">&quot;今天是好天氣&quot;</span>) <span class="comment"># 會印出 &#123;&#x27;label&#x27;: &#x27;POSITIVE&#x27;, &#x27;score&#x27;: 0.9998&#125;</span></span><br></pre></td></tr></table></figure><p><strong>預先加載模型，再創建Pipeline</strong></p><div class="note info flat"><p>一定要使用模型相對應的 Tokenizer，否則會出現錯誤</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">model = AutoModelForSequenceClassification.from_pretrained(<span class="string">&quot;uer/roberta-base-finetuned-dianping-chinese&quot;</span>)</span><br><span class="line">toeknizer = AutoTokenizer.from_pretrained(<span class="string">&quot;uer/roberta-base-finetuned-dianping-chinese&quot;</span>)</span><br><span class="line">pipe = pipeline(<span class="string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)</span><br><span class="line">pipe(<span class="string">&quot;今天是好天氣&quot;</span>) <span class="comment"># 會印出 &#123;&#x27;label&#x27;: &#x27;POSITIVE&#x27;, &#x27;score&#x27;: 0.9998&#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用GPU">使用GPU</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pipe = pipeline(<span class="string">&quot;text-classification&quot;</span>) <span class="comment"># 指定任務 </span></span><br><span class="line"><span class="built_in">print</span>(pipe.model.device) <span class="comment"># 會顯示 device(type=&#x27;cuda&#x27;, index=0)</span></span><br></pre></td></tr></table></figure><h1 id="關於Tokenizer">關於Tokenizer</h1><p>Tokenizer 是將文本轉換成模型可以理解的格式(Token序列)，這是模型的第一步，因為模型只能理解數字，而不能理解文本。因此 Tokenizer 是非常重要的一個環節。</p><p><strong>基本使用</strong></p><ul><li>加載保存<ul><li><code>from_pretrained</code>: 從預訓練模型中加載 Tokenizer</li><li><code>save_pretrained</code>: 將 Tokenizer 保存到本地</li></ul></li><li>句子分詞<ul><li><code>tokenize</code>: 句子分詞</li><li><code>encode</code>: 句子轉換成 ID</li></ul></li><li>查看字典<ul><li><code>vocab</code>: 顯示 Tokenizer 的詞彙表</li></ul></li><li>索引轉換<ul><li><code>convert_tokens_to_ids</code>: 將 Token 轉換成 ID</li><li><code>convert_ids_to_tokens</code>: 將 ID 轉換成 Token</li></ul></li><li>填充截斷<ul><li><code>padding</code>: 對文本進行填充</li><li><code>truncation</code>: 對文本進行截斷</li></ul></li></ul><h2 id="快速上手-2">快速上手</h2><ul><li>直接使用 tokenizer(sen, padding=“max_length”, max_length=10) 可以會傳以下資訊<ul><li><code>offset_mapping</code>: 會顯示每個 token 在原始文本中的位置，通常會合 word_ids 一起使用<ul><li>會長這樣 <code>[(0, 0), (0, 2), (2, 5), (5, 8), (8, 11), (0, 0)]</code></li></ul></li><li><code>word_ids</code>: 會顯示每個 token 對應的原始文本中的單詞<ul><li>會長這樣 <code>[None, 0, 1, 2, 3, None]</code></li></ul></li><li><code>input_ids</code>: 會顯示每個 token 對應的 ID<ul><li>會長這樣 <code>[101, 0, 1, 2, 3, 102]</code></li></ul></li><li><code>attention_mask</code>: 會顯示每個 token 對應的注意力遮罩，哪些部分是有效的哪些是填充的<ul><li>會長這樣 <code>[1, 1, 1, 1, 1, 1, 0, 0]</code></li></ul></li><li><code>token_type_ids</code>: 會顯示每個 token 對應的 token type<ul><li>會長這樣 <code>[0, 0, 0, 0, 0, 0, 0, 0]</code></li></ul></li></ul></li><li><code>add_special_tokens</code>: 是否加入特殊的 token，像是 [CLS], [SEP] 等等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 加載與保存</span></span><br><span class="line"><span class="comment">## 可以在 /users/.cache/huggingface/hub 下找到</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;user/tokenizer-name&quot;</span>)</span><br><span class="line">tokenizer.save_pretrained(<span class="string">&quot;tokenizer-name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 分詞</span></span><br><span class="line">tokenizer = toeknizer(<span class="string">&quot;今天是好天氣&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(tokenizer) <span class="comment"># 會印出 [&#x27;今天&#x27;, &#x27;是&#x27;, &#x27;好&#x27;, &#x27;天氣&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看辭典</span></span><br><span class="line"><span class="built_in">print</span>(tokenizer.vocab) <span class="comment"># 會印出 &#123;&#x27;今天&#x27;: 0, &#x27;是&#x27;: 1, &#x27;好&#x27;: 2, &#x27;天氣&#x27;: 3&#125;</span></span><br><span class="line"><span class="built_in">print</span>(tokenizer.vocab_size) <span class="comment"># 可以查看辭典的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 索引轉換</span></span><br><span class="line">ids = tokenizer.convert_tokens_to_ids(<span class="string">&quot;今天是好天氣&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ids) <span class="comment"># 會印出 [0, 1, 2, 3]</span></span><br><span class="line">str_sen = tokenizer.convert_ids_to_tokens([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(str_sen) <span class="comment"># 會印出 [&#x27;今天&#x27;, &#x27;是&#x27;, &#x27;好&#x27;, &#x27;天氣&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 更便捷的方法</span></span><br><span class="line"><span class="comment">### add_special_tokens - 是否加入特殊的 token，像是 [CLS], [SEP] 等等</span></span><br><span class="line">ids = tokenizer.encode(<span class="string">&quot;今天是好天氣&quot;</span>, add_special_tokens=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(ids) <span class="comment"># 會印出 [101, 0, 1, 2, 3, 102] </span></span><br><span class="line">str_sen = tokenizer.decode([<span class="number">101</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">102</span>])</span><br><span class="line"><span class="built_in">print</span>(str_sen) <span class="comment"># 會印出 &#x27;[CLS] 今天 是 好 天氣 [SEP]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 填充與截斷</span></span><br><span class="line"><span class="comment">## 太短的句子要 填充 </span></span><br><span class="line">ids = tokenizer.encode(<span class="string">&quot;今天是好天氣&quot;</span>, padding=<span class="string">&quot;max_length&quot;</span>, max_length=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(ids) <span class="comment"># [101, 0, 1, 2, 3, 102, 0, 0, 0, 0] </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## 過長的句子要 截斷(truncation) 你會發現 special token 必須包含在裡面</span></span><br><span class="line">ids = tokenizer.encode(<span class="string">&quot;今天是好天氣&quot;</span>, truncation=<span class="literal">True</span>, max_length=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(ids) <span class="comment"># [101, 0, 1, 102]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 最常用的方法</span></span><br><span class="line">inputs = tokenizer(<span class="string">&quot;今天是好天氣&quot;</span>, padding=<span class="string">&quot;max_length&quot;</span>, max_length=<span class="number">10</span>, return_offsets_mapping=<span class="literal">True</span>) </span><br><span class="line"><span class="built_in">print</span>(inputs) <span class="comment"># input_ids, attention_mask, token_type_ids, offset_mapping 都會印出來</span></span><br><span class="line">inputs.word_ids() <span class="comment"># 會印出 &#x27;word_ids&#x27;: [None, 0, 1, 2, 3, 3, None] 因為有可能一個單字拆成多個 token 你會看到 3, 3 表示這個單字被拆成兩個 token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 處理 batch </span></span><br><span class="line">sens = [<span class="string">&quot;今天是好天氣&quot;</span>, <span class="string">&quot;明天是好天氣&quot;</span>]</span><br><span class="line">inputs = tokenizer(sens, padding=<span class="string">&quot;max_length&quot;</span>, max_length=<span class="number">15</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="特殊Tokenizer的加載">特殊Tokenizer的加載</h2><p>huggingface 上有很多模型不是官方的，有可能我們下載的模型，他的 Tokenizer 不在官方的 Tokenizer 中，這時候我們可以使用 <code>trust_remote_code=True</code> 來加載 Tokenizer，表示我們相信這個 Tokenizer 是安全的。以 <a href="https://huggingface.co/THUDM/chatglm-6b/tree/main">https://huggingface.co/THUDM/chatglm-6b/tree/main</a> 為例，他所使用的 Tokenizer 是 <code>tokenization_chatglm.py</code> 他自己實現的。</p><p><img src="https://i.imgur.com/nEnq8QI.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;THUDM/chatglm-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 加載完後可以保存 </span></span><br><span class="line">tokenizer.save_pretrained(<span class="string">&quot;chatglm-6b&quot;</span>)</span><br><span class="line"><span class="comment"># 加載回來也要添加 trust_remote_code=True</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;chatglm-6b&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h1 id="關於-Model">關於 Model</h1><p><strong>模型的類型</strong></p><ol><li>只有 Encoder: 每個詞都能看到完整上下文<ul><li>常用預訓練模型: BERT, RoBERTa, ALBERT</li><li>適合任務：文本分類、命名實體識別、閱讀理解</li></ul></li><li>只有 Decoder: 每個詞能看到上文，但是不能看到下文<ul><li>常用預訓練模型: GPT, LLaMA</li><li>適合任務：文本生成</li></ul></li><li>Encoder+Decoder: 前面的token只能看後面的，但是到了後面的token就是純粹的解碼器模型了<ul><li>常用預訓練模型: MART, T5, GLM, Marian, mBART</li><li>適合任務：文本摘要, 翻譯<br><img src="https://i.imgur.com/i1BBL7n.png" alt=""></li></ul></li></ol><p><strong>Model Head</strong></p><ul><li>通常是連接在模型後的層，通常為1個或多個fully connected layer</li><li>他負責將模型的輸出轉換成我們需要的格式，以解決不同類型的任務</li><li>常見的像是 ForMaskedLMHead (遮住某個字來猜), ForSeq2SeqLMHead (翻譯), ForQuestionAnsweringHead (問答), ForSequenceClassification (分類)<br><img src="https://i.imgur.com/NkYv83t.png" alt=""></li></ul><h2 id="快速上手-3">快速上手</h2><p>這邊主要會介紹 Model 的基本使用方法</p><ul><li>在線加載: <code>AutoModel.from_pretrained</code></li><li>模型下載</li><li>離線加載</li><li>模型參數下載</li></ul><p>模型調用</p><ol><li>不帶 model head 的模型調用</li><li>帶 model head 的模型調用</li></ol><h3 id="下載模型-AutoModel">下載模型 AutoModel</h3><p><strong>方法1: 線上下載</strong><br>直接透過 AutoModel.from_pretrained()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoConfig, AutoModel, AutoTokenizer</span><br><span class="line"></span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;hf1/rbt3&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>方法2: 模型下載</strong><br>或是可以透過git的方式，甚至是去huggingface自己下載<code>.bin</code>檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!git <span class="built_in">clone</span> <span class="string">&quot;https://huggingface.co/hf1/rbt3&quot;</span></span><br><span class="line">!git lfs <span class="built_in">clone</span> <span class="string">&quot;https://huggingface.co/hf1/rbt3&quot;</span> --include=<span class="string">&quot;*.bin&quot;</span></span><br></pre></td></tr></table></figure><p>然後你就可以在本地加載了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoConfig, AutoModel, AutoTokenizer</span><br><span class="line"></span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;本地資料夾位置&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="模型參數加載-AutoConfig">模型參數加載 AutoConfig</h3><p>可以透過AutoConfig查看模型相關參數</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoConfig, AutoModel, AutoTokenizer</span><br><span class="line"></span><br><span class="line">config = AutoConfig.from_pretrained(<span class="string">&quot;rbt3&quot;</span>)</span><br><span class="line">config.[想看的參數] <span class="comment"># e.g config.output_attentions</span></span><br></pre></td></tr></table></figure><h3 id="模型調用-AutoTokenizer-AutoModel">模型調用 AutoTokenizer + AutoModel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoConfig, AutoModel, AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先進行tokenize</span></span><br><span class="line">sen = <span class="string">&quot;今天天氣很好今天天氣很好&quot;</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;rbt3&quot;</span>)</span><br><span class="line">inputs = tokenizer(sen, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs) <span class="comment"># 會列印出 input_ids, token_type_ids, attention_mask </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 調用model </span></span><br><span class="line">model = AutoModel.from_pretrained(<span class="string">&quot;rbt3&quot;</span>) <span class="comment"># 參數可以根據config.[想看的參數]來輸出 e.g. AutoModel.from_pretrained(&quot;rbt3&quot;, output_attentions = True)</span></span><br><span class="line">output = model(**inputs)</span><br><span class="line"><span class="built_in">print</span>(output) <span class="comment"># 就會輸出 last_hidden_state, pooler_output, ... 等 (看你model想輸出多少)</span></span><br><span class="line"><span class="built_in">print</span>(output.last_hidden_state) <span class="comment"># 可以印出特定想看的結果</span></span><br><span class="line"><span class="built_in">print</span>(output.last_hidden_state.size()) <span class="comment"># 可以印出維度 torch.size([1, 12, 768]) 1 batch size, 12 整個token長度, 768 結果size</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(inputs[<span class="string">&quot;input_ids&quot;</span>][<span class="number">0</span>])) <span class="comment"># 可以看inputs的長度發現是12</span></span><br></pre></td></tr></table></figure><h3 id="Model-Head的模型調用">Model Head的模型調用</h3><ul><li>ref: <a href="https://towardsdatascience.com/adding-custom-layers-on-top-of-a-hugging-face-model-f1ccdfc257bd">Medium | Adding Custom Layers on Top of a Hugging Face Model</a></li></ul><p>Model Head 有點像是模型的最後一層，他負責將模型的輸出轉換成我們需要的格式，以解決不同類型的任務。<br><img src="https://i.imgur.com/A4jRa1z.png" alt=""></p><p>我們用 AutoModelForSequenceClassification 文本分類為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForSequenceClassification </span><br><span class="line"></span><br><span class="line">clz_model = AutoModelForSequenceClassification.from_pretrained(<span class="string">&quot;rbts&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(clz_model.config.num_labels) <span class="comment"># 可以看到有幾個分類會印出 2 </span></span><br><span class="line"><span class="built_in">print</span>(clz_model(**inputs)) <span class="comment"># 兩個分類的機率就會印出來 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我們也可以設定成10個分類</span></span><br><span class="line">clz_model = AutoModelForSequenceClassification.from_pretrained(<span class="string">&quot;rbts&quot;</span>, num_labels=<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(clz_model.config.num_labels) <span class="comment"># 可以看到有幾個分類會印出 10</span></span><br><span class="line"><span class="built_in">print</span>(clz_model(**inputs)) <span class="comment"># 兩個分類的機率就會印出來 </span></span><br></pre></td></tr></table></figure><h2 id="模型微調範例">模型微調範例</h2><h3 id="step-1-加載數據">step 1 加載數據</h3><p>先去下載 <a href="https://github.com/SophonPlus/ChineseNlpCorpus/blob/master/datasets/ChnSentiCorp_htl_all/ChnSentiCorp_htl_all.csv"><code>ChnSentiCorp_ht1_all.csv</code></a> 預測資料存在本地</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoConfig, AutoModel, AutoTokenizer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line">data = pd.read_csv(<span class="string">&quot;./ChnSentiCorp_ht1_all.csv&quot;</span>).dropna() <span class="comment"># 把空移除</span></span><br></pre></td></tr></table></figure><h3 id="Step-2-創建-dataset">Step 2 創建 dataset</h3><p>後面Dataloader會根據整批的dataset</p><ol><li>進行 90:10 的訓練和測試資料分割</li><li>進行 tokenizer</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>: </span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.data = pd.read_csv(<span class="string">&quot;./ChnSentiCorp_ht1_all.csv&quot;</span>).dropna()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data.iloc[index][<span class="string">&quot;review&quot;</span>], self.data.iloc[index][<span class="string">&quot;label&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line">dataset = MyDataset()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(dataset[i]) <span class="comment"># 印出來應該會長(&#x27;sentence&#x27;, 1)</span></span><br></pre></td></tr></table></figure><h3 id="Step3-劃分數據集">Step3 劃分數據集</h3><p>接下來我們可以使用 <code>random_split</code> 劃分數據:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> random_split</span><br><span class="line"></span><br><span class="line">trainset, validset = random_split(dataset, lengths=[<span class="number">0.9</span>, <span class="number">0.1</span>]) <span class="comment"># 90:10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(trainset, <span class="built_in">len</span>(validset))) <span class="comment"># (6989, 776)</span></span><br></pre></td></tr></table></figure><h3 id="Step-4-創建Dataloader">Step 4 創建Dataloader</h3><p>開始處理 batch 資料，進行 batch 的 tokenizer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;rbt3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">collate_func</span>(<span class="params">batch</span>):</span><br><span class="line">    texts, labels = [], []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> batch:</span><br><span class="line">        texts.append(item[<span class="number">0</span>])</span><br><span class="line">        labels.append(item[<span class="number">1</span>])</span><br><span class="line">    inputs = tokenizer.batch_encode_plus(texts, max_length=<span class="number">512</span>, padding=<span class="string">&quot;max_length&quot;</span>, truncation=<span class="literal">True</span>, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    inputs[<span class="string">&quot;labels&quot;</span>] = torch.tensor(labels) <span class="comment"># 在裡面多添加一個key叫做labels, 這樣就有input_ids, labels, ...</span></span><br><span class="line">    <span class="keyword">return</span> inputs </span><br><span class="line"></span><br><span class="line">trainloader = DataLoader(trainset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>, collate_fn=collate_func) </span><br><span class="line">validloader = DataLoader(validset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>, collate_fn=collate_func)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(<span class="built_in">enumerate</span>(trainloader))[<span class="number">1</span>]) <span class="comment"># 可以印出來第一筆，&#123;&#x27;input&#x27;: [[101, 1, 2], [101, 2, 1], ...], &#x27;label&#x27;: tensor([1, 1, ...])&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Step-5-創建模型及優化器">Step 5 創建模型及優化器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> Adam </span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForSequenceClassification </span><br><span class="line"></span><br><span class="line">model = AutoModelForSequenceClassification.from_pretrained(<span class="string">&quot;./rbt3/&quot;</span>)</span><br><span class="line">optimizer = Adam(model.parameters(), lr=<span class="number">2e-5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 gpu </span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    model = model.cuda()</span><br></pre></td></tr></table></figure><h3 id="Step-6-訓練與驗證">Step 6 訓練與驗證</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>():</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    acc_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.inference_mode():</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> validloader:</span><br><span class="line">            <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                batch = &#123;k: v.cuda() <span class="keyword">for</span> k, v <span class="keyword">in</span> batch.items()&#125;</span><br><span class="line">            ouput = model(**batch)</span><br><span class="line">            pred = torch.argmax(ouput.logits, dim=-<span class="number">1</span>)</span><br><span class="line">            acc_num += (pred.long() == batch[<span class="string">&quot;labels&quot;</span>]).<span class="built_in">float</span>().<span class="built_in">sum</span>() <span class="comment"># 因為是batch，我們想知道這個batch ouput準確的共有多少</span></span><br><span class="line">    <span class="keyword">return</span> acc_num / <span class="built_in">len</span>(validset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch=<span class="number">3</span>, log_step=<span class="number">100</span></span>):</span><br><span class="line">    global_step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ep <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">        model.train()</span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> trainloader: </span><br><span class="line">            <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                batch = &#123;k: v.cuda() <span class="keyword">for</span> k, v <span class="keyword">in</span> batch.items()&#125;</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            output = model(**batch)</span><br><span class="line">            output.loss.backword() <span class="comment"># 進行backforward</span></span><br><span class="line">            optimizer.step() <span class="comment"># 更新模型</span></span><br><span class="line">            <span class="keyword">if</span> global_step % log_step == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;ep: <span class="subst">&#123;ep&#125;</span>, global_step: <span class="subst">&#123;global_step&#125;</span>, loss:<span class="subst">&#123;output.loss.item()&#125;</span>&quot;</span>)</span><br><span class="line">            global_step += <span class="number">1</span></span><br><span class="line">        acc = evaluate()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;ep: <span class="subst">&#123;ep&#125;</span>, acc: <span class="subst">&#123;acc&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 就可以開始訓練了</span></span><br><span class="line">train()  </span><br></pre></td></tr></table></figure><h3 id="Step-9-進行預測">Step 9 進行預測</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sen = <span class="string">&quot;我覺得這家酒店不錯 飯很好吃！&quot;</span></span><br><span class="line">id2_label = &#123;<span class="number">0</span>: <span class="string">&quot;差評&quot;</span>, <span class="number">1</span>:<span class="string">&quot;好評&quot;</span>&#125;</span><br><span class="line"><span class="keyword">with</span> torch.inference_mode():</span><br><span class="line">    inputs = tokenizer(sen, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    inputs = &#123;k: v.cuda() <span class="keyword">for</span> k, v <span class="keyword">in</span> inputs.items()&#125;</span><br><span class="line">    logits = model(**inputs).logits</span><br><span class="line">    pred = torch.argmax(logits, dim=-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;輸入: <span class="subst">&#123;sen&#125;</span> \n模型預測結果:<span class="subst">&#123;id2_label(pred.item())&#125;</span>&quot;</span>) <span class="comment"># 會顯示 輸入: 我覺得這家酒店不錯 飯很好吃！ \n模型預測結果:好評</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接使用 pipeline </span></span><br><span class="line"><span class="keyword">from</span> transformer <span class="keyword">import</span> pipeline </span><br><span class="line"></span><br><span class="line">pipe = pipeline(<span class="string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer, device=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(pipe(sen)) <span class="comment"># 會印出 -&gt; [&#123;&#x27;label&#x27;: &#x27;LABEL1&#x27;, &#x27;score&#x27;: 0.99&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我們希望幫我把結果進行轉換可以設定 model.config </span></span><br><span class="line">model.config.id2lable = id2_label</span><br><span class="line"><span class="built_in">print</span>(pipe(sen)) <span class="comment"># 會印出 -&gt; 好評</span></span><br></pre></td></tr></table></figure><h1 id="參考文獻">參考文獻</h1><ul><li><a href="https://youtu.be/ddCfxkCh-O8?si=pi9Ir_aWBF5gPjjt">Youtube | 【手把手带你实战HuggingFace Transformers-入门篇】基础知识与环境安装</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
            <tag> Transformers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Binary Search Tree 指南</title>
      <link href="/posts/lecture-binary-search-tree/"/>
      <url>/posts/lecture-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="簡介">簡介</h1><p>相信各位在準備面試的時候，Binary Search Tree 這個資料結構一定會被問到，他是 Tree 大本營中最先學到的一種演算法，在資料的搜尋、插入、刪除上都有很好的表現，在Balanace Tree的狀況下可以達到<code>O(logn)</code>，所謂的Balanace Tree就像是左邊跟右邊的枝葉數量差不多，不會出現左邊很多右邊很少的情況，這樣才能達到<code>O(logn)</code>的時間複雜度。</p><p><img src="https://i.imgur.com/3AnFANe.png" alt=""></p><h1 id="定義">定義</h1><p><img src="https://i.imgur.com/9ReAnnS.png" alt=""><br>那我們先來說說BST的四個特性：</p><ol><li>根(root)的左邊節點(left node)其子樹(sub-tree)中所有的節點值都小於根(root)的值。</li><li>根(root)的右邊節點(right node)其子樹(sub-tree)中所有的節點值都大於根(root)的值。</li><li>任意節點的左右子樹都符合BST。</li><li><strong>不存在任何key/value相等的節點。</strong></li></ol><div class="note warning flat"><p><strong>小提醒：我把第四點畫起來是因為很多人會不記得第四點，但遇過面試有問，但想一下就會知道如果有相等值的節點就會違反第一點或第二點。</strong></p><details class="toggle" ><summary class="toggle-button" style="">如果我還是想要塞入相同的值怎麼辦？ BST的變體</summary><div class="toggle-content"><p>如果硬要塞相同的值，有一些變體可以處理重複的值，這些變體包括</p><ul><li>左傾或右傾策略 (Left-Leaning or Right-Leaning Strategy):當插入重複的值時，可以選擇將重複的值插入左子樹或右子樹。例如，所有重複的值都放在右子樹。</li><li>計數器方法 (Counter Method): 在每個節點上添加一個計數器來記錄該值的出現次數。這樣，當插入重複的值時，只需要增加該節點的計數器，而不需要插入新的節點。</li></ul><p>使用第一種策略（所有重複值都插入右子樹）時，樹的結構如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  10</span><br><span class="line"> /  \</span><br><span class="line">5    15</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure><p>使用第二種策略（計數器方法）時，樹的結構如下，但節點 5 的計數器為 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  10</span><br><span class="line"> /  \</span><br><span class="line">5(2)  15</span><br></pre></td></tr></table></figure></div></details></div><h1 id="Balance-的重要性">Balance 的重要性</h1><p>Binary Search Tree (BST) 是基於 Binary Search Algorithm 的概念以 Tree 的資料結構所建立，也可以說他是為了搜尋而生的演算法，因為他的搜尋時間複雜度是<code>O(logn)</code>，當然這是在平衡樹的情況下，如果是一個不平衡的樹，那搜尋時間複雜度就會變成<code>O(n)</code>。關鍵就在<strong>平衡</strong>。那我們這邊就先來講 <strong>樹高</strong>。</p><p>以 3 個 node 的 BST 為例，會有三種排列的可能性分別是：<br><img src="https://i.imgur.com/borfFku.png" alt=""><br>好，那今天如果我們要搜尋 10 這個鍵值：</p><ul><li>第一種排列：只需要一次比較（從 root 進入，10 &lt; 20，往左走，找到了）</li><li>第二種排列：需要兩次比較（從 root 進入，10 &lt; 30，往左走，10 &lt; 20，繼續往左走，找到了）</li></ul><p>所以我們可以看到在一樣數量的 node 的情況之下，<em>不一樣的樹高對搜尋產生的影響是很關鍵的，如果有平衡就可以讓樹高在最理想的情況，使搜尋可以達到 O(log n)</em>。</p><div class="note info flat"><p><strong>如果平衡的話，假有共有 n 個節點，那麼樹高應該就是 ( log n ) + 1。</strong></p></div><h1 id="四種操作">四種操作</h1><p>接下來介紹搜尋、新增、改值、刪除四種操作</p><h2 id="新增節點">新增節點</h2><p>假設我們今天要把值為 15 的節點新增進去，要做以下事情：</p><ol><li>先建立 15 的節點</li><li>與 root 節點比大小，15 &lt; 20，所以往左走</li><li>與節點10 比大小，15 &gt; 10，所以往右走</li></ol><p><img src="https://i.imgur.com/WaxuiW0.png" alt=""></p><h2 id="搜尋節點">搜尋節點</h2><p>假設我們要搜尋 15 這個節點，其實<em>跟新增的步驟差不多</em>，先逐一比大小，差在要確認經過的節點的值是不是 15 即可。</p><ol><li>把要找的值 15 與 root 節點比大小，15 &lt; 20，所以往左走</li><li>把要找的值 15 與節點10 比大小，15 &gt; 10，所以往右走</li><li>與節點15比較發現 15 == 15，找到了</li></ol><p><img src="https://i.imgur.com/IUgMgt0.png" alt=""></p><h2 id="修改節點的值">修改節點的值</h2><p>根搜尋也差不多，只是找到節點後，把該節點的值改掉即可。或是直接把舊的節點刪除，插入更新值的節點。</p><h2 id="刪除節點">刪除節點</h2><p>刪除節點比較複雜一點，大概會有以下刪除的狀況：</p><ol><li>刪除的節點是葉子節點（沒有子節點）：該節點無子節點,直接刪除。</li><li>刪除的節點有一個子節點：該節點只有一個子節點,直接刪除,並把子節點接上去。</li><li>刪除的節點有兩個子節點：該節點有兩個子節點,找到左子樹中最大的節點或右子樹中最小的節點來替代被刪除的節點。</li></ol><p><img src="https://i.imgur.com/j20gAZ0.png" alt=""></p><p><strong>情況1 - 刪除孤兒：直接把該節點刪除即可</strong><br><img src="https://i.imgur.com/bBZfo8W.png" alt=""></p><p><strong>情況2 - 替代被刪除的節點</strong><br><img src="https://i.imgur.com/xJDrqvD.png" alt=""></p><p><strong>情況3 - 從左子樹(small nodes)找最大(max)去掌管左子樹，或是從右子樹(big smalls)找最小(min)去掌管右子樹</strong><br><img src="https://i.imgur.com/QUh0NyR.png" alt=""></p><h1 id="實作">實作</h1><p>先定義兩個class，把操作方法定義在 BST 裡面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: Node</span>):</span><br><span class="line">        self.root = root</span><br></pre></td></tr></table></figure><h2 id="新增節點-2">新增節點</h2><p>以 root 為起點開始比大小，直到發現空位就可插入，這邊是用 loop 的方法來寫，也可以用遞迴的方式來寫。</p><p>loop 的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: Node</span>):</span><br><span class="line">        self.root = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">        <span class="comment"># 從 root 開始走</span></span><br><span class="line">        current_node = self.root</span><br><span class="line">        <span class="comment"># 會一直往下走current_node=current_node.right/left，直到發生break</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">            <span class="comment"># 不允許重複的值</span></span><br><span class="line">            <span class="keyword">if</span> node.value == current_node.value:</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;Node already exists&quot;</span>)</span><br><span class="line">            <span class="comment"># node 比較小塞 cur.left </span></span><br><span class="line">            <span class="keyword">elif</span> node.value &lt; current_node.value: </span><br><span class="line">                <span class="comment"># 如果cur沒有left sub-tree，直接塞進去</span></span><br><span class="line">                <span class="keyword">if</span> current_node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    current_node = current_node.left</span><br><span class="line">                <span class="comment"># cur.left 是空的，且 node &lt; cur 因此 node 變成 cur.left </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current_node.left = node</span><br><span class="line">                    node.parent = current_node</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># node 比較大塞 cur.right</span></span><br><span class="line">            <span class="keyword">elif</span> node.value &gt; current_node.value:</span><br><span class="line">                <span class="comment"># 如果cur沒有right sub-tree，直接塞進去</span></span><br><span class="line">                <span class="keyword">if</span> current_node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    current_node = current_node.right</span><br><span class="line">                <span class="comment"># cur.right 是空的，且 node &gt; cur 因此 node 變成 cur.right </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    current_node.right = node</span><br><span class="line">                    node.parent = current_node</span><br><span class="line">                    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>使用 Recursion 的方法：簡單來說就是把 continue 的部分改成呼叫自己，這樣就可以一直往下走，直到找到空位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_node</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> self.root:</span><br><span class="line">           self.root = node</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           self._add_node_recursive(self.root, node)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">_add_node_recursive</span>(<span class="params">self, current_node: Node, new_node: Node</span>):</span><br><span class="line">       <span class="keyword">if</span> new_node.value == current_node.value:</span><br><span class="line">           <span class="keyword">raise</span> Exception(<span class="string">&quot;Node already exists&quot;</span>)</span><br><span class="line">       <span class="keyword">elif</span> new_node.value &lt; current_node.value:</span><br><span class="line">           <span class="keyword">if</span> current_node.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">               current_node.left = new_node</span><br><span class="line">               new_node.parent = current_node</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               self._add_node_recursive(current_node.left, new_node)</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">if</span> current_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">               current_node.right = new_node</span><br><span class="line">               new_node.parent = current_node</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               self._add_node_recursive(current_node.right, new_node)</span><br></pre></td></tr></table></figure><h2 id="搜尋節點-2">搜尋節點</h2><p>基本上跟新增一樣，也是去比大小，找到的話就回傳</p><p>loop 的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: Node</span>):</span><br><span class="line">        self.root = root</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node_by_value</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment"># 從 root 開始走</span></span><br><span class="line">        current_node = self.root</span><br><span class="line">        <span class="comment"># 會一直往下走current_node=current_node.right/left，直到發生break</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">            <span class="comment"># 找到了</span></span><br><span class="line">            <span class="keyword">if</span> value == current_node.value:</span><br><span class="line">                <span class="keyword">return</span> current_node</span><br><span class="line">            <span class="comment"># value 比較小在 cur.left </span></span><br><span class="line">            <span class="keyword">elif</span> value &lt; current_node.value: </span><br><span class="line">                <span class="comment"># 如果cur有left sub-tree，繼續往下走</span></span><br><span class="line">                <span class="keyword">if</span> current_node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    current_node = current_node.left</span><br><span class="line">                <span class="comment"># cur.left 是空的，但 value &lt; cur 正常應該要出現，但是沒有，表示不存在</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;node not found&#x27;</span>)</span><br><span class="line">            <span class="comment"># value 比較大在 cur.right</span></span><br><span class="line">            <span class="keyword">elif</span> value &gt; current_node.value:</span><br><span class="line">                <span class="comment"># 如果cur有right sub-tree，繼續往下走</span></span><br><span class="line">                <span class="keyword">if</span> current_node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    current_node = current_node.right</span><br><span class="line">                <span class="comment"># cur.right 是空的，且 value &gt; cur 正常應該要出現，但是沒有，表示不存在</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&#x27;node not found&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Recursion 的方法程式碼就少了很多，也比較清楚：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: Node</span>):</span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_node_by_value</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">return</span> self._get_node_by_value_recursive(self.root, value)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_node_by_value_recursive</span>(<span class="params">self, current_node: Node, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> current_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;node not found&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value == current_node.value:</span><br><span class="line">            <span class="keyword">return</span> current_node</span><br><span class="line">        <span class="comment"># valu 比 cur 小，繼續往 left (小)深入</span></span><br><span class="line">        <span class="keyword">elif</span> value &lt; current_node.value:</span><br><span class="line">            <span class="keyword">return</span> self._get_node_by_value_recursive(current_node.left, value)</span><br><span class="line">        <span class="comment"># value 比 cur 大，繼續往 right (大)深入</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._get_node_by_value_recursive(current_node.right, value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="刪除節點-2">刪除節點</h2><p>刪除就很麻煩了，直接使用遞迴會比較好寫：</p><ol><li>如果值小於當前節點的值，則遞歸地在左子樹中刪除節點。</li><li>如果值大於當前節點的值，則遞歸地在右子樹中刪除節點。</li><li><em>如果找到節點，分三種情況處理</em>：<ol><li>該節點<code>無子節點</code>，直接刪除。</li><li>該節點有<code>一個子節點</code>，讓該子節點接替被刪除節點的位置。</li><li>該節點有<code>兩個子節點</code>:<ol><li>找到欲刪除節點的右子樹中的最小值節點（或左子樹中的最大值節點）</li><li>將其值複製到當前節點</li><li>並遞歸地刪除最小值節點。</li></ol></li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BST</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root: Node</span>):</span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete_node_by_value</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span><br><span class="line">        self.root = self._delete_node_recursive(self.root, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_delete_node_recursive</span>(<span class="params">self, current: Node, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> current_node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;node not found&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># value 比 cur 小，繼續往 cur.left (小)深入</span></span><br><span class="line">        <span class="keyword">if</span> value &lt; current_node.value:</span><br><span class="line">            current_node.left = self._delete_node_recursive(current_node.left, value) <span class="comment"># 有一個子節點或 None，讓該節點接替被刪除節點的位置</span></span><br><span class="line">        <span class="comment"># value 比 cur 大，繼續往 cur.right (大)深入</span></span><br><span class="line">        <span class="keyword">elif</span> value &gt; current_node.value:</span><br><span class="line">            current_node.right = self._delete_node_recursive(current_node.right, value) <span class="comment"># 有一個子節點或 None，讓該節點接替被刪除節點的位置</span></span><br><span class="line">        <span class="comment"># 找到了！</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 情境1, 2: 只有一個子節點 或是 無節點，回到呼叫的地方 子節點會接替 current 是 被刪除的父節點，cur.left/right 串到那一個節點或是None</span></span><br><span class="line">            <span class="keyword">if</span> current_node.left <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">                <span class="keyword">return</span> current_node.right</span><br><span class="line">            <span class="keyword">elif</span> current_node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> current_node.left</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 情境3: 有兩個子節點，該節點有兩個子節點 </span></span><br><span class="line">            min_larger_node = self._get_min(current_node.right) <span class="comment"># (1)找到右子樹中的最小值節點（或左子樹中的最大值節點）</span></span><br><span class="line">            current_node.value = min_larger_node.value <span class="comment"># (2)將其值複製到當前節點</span></span><br><span class="line">            current_node.right = self._delete_node_recursive(current_node.right, min_larger_node.value) <span class="comment"># (3)並遞歸地刪除最小值節點。點</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> current_node <span class="comment"># 回傳要被刪除那個點的被替代的新節點</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_min</span>(<span class="params">self, node: Node</span>):</span><br><span class="line">        current = node </span><br><span class="line">        <span class="keyword">while</span> current.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            current = current.left</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="Ref">Ref</h1><ul><li><a href="https://medium.com/@Kadai/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%A4%A7%E4%BE%BF%E7%95%B6-binary-search-tree-3c40be3204e">Medium | 資料結構大便當 — binary search tree</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> BST </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #82 Remove Duplicates From Sorted List II - 刷題之旅</title>
      <link href="/posts/leetcode-82-remove-duplicates-from-sorted-list-ll/"/>
      <url>/posts/leetcode-82-remove-duplicates-from-sorted-list-ll/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/BzeimVg.png" alt=""></p><p>簡單來說，在<strong>有序的listNode中</strong>，移除鍊錶中重複的元素，<strong>只留下沒有重複的元素</strong>。</p><h1 id="2-解法">2 解法</h1><p>首先要注意的是，題目提到的是<strong>有序的鍊錶</strong>，這樣就可以<strong>很簡單的使用pointer解決這個問題</strong>。<br>一開始我的解法很蠢，我自己都不太想放上來了…我用三個指標，這導致我花了30分鐘才寫完，不僅僅很攏長可讀性還不高。後來我看到有人的解答是用雙指針，這樣就簡單多了。大概重新用雙指針思考一次題目，7分鐘就寫完了。</p><p>首先我們會需要兩個指針：</p><ul><li><code>pre</code> 用來記錄重複的前一個元素，這樣才可以把 <code>pre.next</code> 接到沒有重複的元素上</li><li><code>cur</code> 跟 <code>cur.next</code> 這兩個會不斷的比較，如果相鄰的兩個元素<code>val</code>相同<ul><li><code>pre</code> 保持原地不動</li><li>(while loop) <code>cur</code> 要一直往下走直到 <code>cur.val</code> 跟 <code>cur.next.val</code> 不相同</li></ul></li><li>如果發現 <code>pre.next</code> 與 <code>cur</code> 不同時，就要重新接到最新的 <code>cur</code> 上</li></ul><p>大概是這種感覺<br><img src="https://i.imgur.com/23Q1KNU.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    pre = dummy</span><br><span class="line">    cur = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> pre.<span class="built_in">next</span> != cur:</span><br><span class="line">            pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = cur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><details class="toggle" ><summary class="toggle-button" style="">爛死的三指針做法不要參考</summary><div class="toggle-content"><p>但是你會發現，很多神韻的雙指針也是這樣處理：</p><ul><li><code>fast</code> 就像 <code>cur.next</code></li><li><code>slow</code> 就是 <code>cur</code></li><li><code>pre</code> 就是 <code>pre</code></li><li><code>while fast and slow.val == fast.val</code> 就跟 雙指針的 <code>while cur.next and cur.val == cur.next.val</code> 一樣</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    pre = dummy</span><br><span class="line">    slow = pre.<span class="built_in">next</span></span><br><span class="line">    fast = slow.<span class="built_in">next</span> <span class="keyword">if</span> slow <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        <span class="keyword">if</span> pre.<span class="built_in">next</span> == slow <span class="keyword">and</span> slow.val != fast.val:</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = fast</span><br><span class="line">            fast = fast.<span class="built_in">next</span> <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> slow.val == fast.val:</span><br><span class="line">            <span class="keyword">while</span> fast <span class="keyword">and</span> slow.val == fast.val:</span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = fast</span><br><span class="line">            fast = fast.<span class="built_in">next</span> <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pre.<span class="built_in">next</span> != slow:</span><br><span class="line">            pre.<span class="built_in">next</span> = slow</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></div></details><div class="note info flat"><p>時間複雜度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 雖然while裡面有while，但是每個元素只會被訪問一次<br>空間複雜度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 因為使用了指針，不需要額外的空間</p></div><h1 id="3-總結">3 總結</h1><p>這題不難，一看到是有序的，就應該馬上想到使用pointer解決。只是我錯在使用三個指針，導致寫的很複雜，花了30分鐘才完成，後來看到別人的解法，才發現原來可以這樣簡單解決，因此再重新寫一次，6分鐘就寫完了。<br>這題的重點就是<strong>如果只是比較隔壁關係使用1個pointer比較鄰居就好，另一個pointer放previous的訊息</strong>，這樣就可以很快解決這個問題。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #19 Remove Nth Node From End of List - 刷題之旅</title>
      <link href="/posts/leetcode-19-remove-nth-node-from-end-of-list/"/>
      <url>/posts/leetcode-19-remove-nth-node-from-end-of-list/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/MgcYNQy.png" alt=""><br>簡單來說，就是給定一個 linked list 和一個數字 n，要求刪除<strong>倒數第 n 個節點</strong>，並返回新的 linked list。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>一開始想到的做法:</p><ol><li>把所<em>有位置的訊息存在一個 dict 裡面</em></li><li>然後因為已經遍歷過一次<em>知道整個長度</em>，直接尋找到要刪除的節點的前一個進行刪除。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    node_dict = &#123;&#125;</span><br><span class="line">    cur = head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        node_dict.__setitem__(index, cur)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    pre_idx = index - n</span><br><span class="line">    <span class="comment"># 有可能指定拿掉 head，就吐 head.next</span></span><br><span class="line">    <span class="keyword">if</span> node_dict.get(pre_idx+<span class="number">1</span>) == head:</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment"># 串起來</span></span><br><span class="line">    pre_node: ListNode = node_dict.get(pre_idx)</span><br><span class="line">    pre_node.<span class="built_in">next</span> = node_dict.get(pre_idx+<span class="number">2</span>) <span class="keyword">if</span> node_dict.get(pre_idx+<span class="number">2</span>) <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 斷掉鏈結</span></span><br><span class="line">    tar_node: ListNode = node_dict.get(pre_idx+<span class="number">1</span>)</span><br><span class="line">    tar_node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info flat"><p>空間複雜度為 O(n)。<br>時間複雜度為 O(n)。</p><p><strong>如果題目要求 O(1) 這個方法就不行了。</strong></p></div><h2 id="2-2-雙指針">2.2 雙指針</h2><p>這個方法挺神的，從來沒想過，但是這個方法的時間複雜度為 O(n)，空間複雜度為 O(1)。<br>這個方法的原理是，我們使用兩個指針，<em>一個是 <code>fast</code>，一個是 <code>slow</code>，<code>fast</code> 比 <code>slow</code> 快 n 個節點，當 <code>fast.next</code> 到達最後一個節點時，<code>slow</code> 就是倒數第 n 個節點的前一個節點</em>，這樣就可以直接刪除了。<br><strong>我們可以簡單地將兩個指標錯開 n 個節點，方法是在啟動第二個指標（慢速）之前先讓第一個指標（快）先行</strong></p><p>大概是這種感覺：<br><img src="https://i.imgur.com/rEO43Fq.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd2</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        slow, fast = head, head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先讓 fast 比 slow 快</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n): fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 如果發現是空的，那肯定要拿掉的是第一個node</span></span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一定是等到 fast node 觸底後停止, 當 fast.next == None 時 slow 在 target 的前一個</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>自己的做法真的很單純，每次看到只能O(n)第一個想到的都是HashMap，很好笑，但是如果今天要求空間複雜度必須為O(1)的話，這個就無法了，必須使用雙指針的方法，來找到倒數第n個節點。因此如果今天題目要求one pass + 空間複雜度O(1)的話，就必須要使用雙指針的方法。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #92 Reverse Linked List II - 刷題之旅</title>
      <link href="/posts/leetcode-92-reverse-linked-list-II/"/>
      <url>/posts/leetcode-92-reverse-linked-list-II/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/NJwSaUa.png" alt=""></p><p>簡單來說，就是在指定的位置 m 到 n 之間，將鍊錶進行反轉。</p><div class="note warning flat"><p>注意的是，<strong>題目要 one pass 是指只能遍歷一次鍊錶，不能多次遍歷。</strong></p></div><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>我的想法很簡單</p><ol><li>先建立一個字典，紀錄 key = index, value = node</li><li>你會發現 left 到 right 之間的反轉，從 left 開始，left 應該改成 right 的值，right 應該改成 left 的值，直到 left 跟 right 相遇。</li><li>何時該停呢？當 left &gt;= 原本的 right 時，就停止。</li></ol><p>大概是這種感覺<br><img src="https://i.imgur.com/nMkxxk2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            head: <span class="type">Optional</span>[ListNode],</span></span><br><span class="line"><span class="params">            left: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">            right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. build up dictionary</span></span><br><span class="line">        node_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node_dict.__setitem__(index, cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2 開始反轉把 left 的位置變成 right 的位置</span></span><br><span class="line">        org_right = right</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        cur = dummy</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> index == left - <span class="number">1</span> <span class="keyword">and</span> left &lt;= org_right:</span><br><span class="line">                cur.<span class="built_in">next</span> = node_dict.get(right) <span class="comment"># 關鍵在這裡，把 left 的位置變成 right 的位置</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                cur.<span class="built_in">next</span> = node_dict.get(index + <span class="number">1</span>) <span class="comment"># 一般情況下，就是把原本的鍊錶串起來</span></span><br><span class="line"></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        ans = dummy.<span class="built_in">next</span></span><br><span class="line">        dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="2-2-雙指針解法">2.2 雙指針解法</h2><p>這個做法真的是從來沒想過，但是很巧妙，而且只需要遍歷一次鍊錶，就可以完成反轉。超級厲害！<br>他的概念是這樣的:</p><ol><li><em>先找到 <code>pre</code> 這個節點</em><ul><li>怎麼找到<code>pre</code>? 這個節點是 left 的前一個節點，也就是 <code>left - 1</code>，之後就都固定 <code>pre</code> 不動。</li><li>為什麼需要？ 因為 <code>pre</code> 要負責更新 <code>pre.next</code> 為反轉後的第一個節點。</li></ul></li><li><em>再來就是 <code>cur</code> 這個節點</em>，<ul><li>怎麼找到 <code>cur</code>? 最一開始，<code>cur</code> 是 <code>pre.next</code>，之後就固定 <code>cur</code> 不動。</li><li>為什麼需要? 因為 <code>cur</code> 要負責更新 <code>cur.next</code> 為 <code>next.next</code> 這個節點，往前移動。</li></ul></li><li><em>最後是 <code>next</code> 這個節點</em><ul><li>怎麼找到 <code>next</code>? 最一開始，<code>next</code> 是 <code>cur.next</code>，之後就固定 <code>next</code> 不動。</li><li>為什麼需要? 因為 <code>next</code> 要負責更新 <code>next.next</code> 為 <code>cur</code> 這個節點，往前移動。</li></ul></li></ol><p>大概是這種感覺，<strong>你會發現 next 會被塞到 pre.next 這個位置，而 cur 就一直往前移動</strong><br><img src="https://i.imgur.com/JuCfp4E.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween2</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            head: <span class="type">Optional</span>[ListNode],</span></span><br><span class="line"><span class="params">            left: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">            right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre_n = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left-<span class="number">1</span>):</span><br><span class="line">            pre_n = pre_n.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur_n = pre_n.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            next_n = cur_n.<span class="built_in">next</span></span><br><span class="line">            cur_n.<span class="built_in">next</span> = next_n.<span class="built_in">next</span></span><br><span class="line">            next_n.<span class="built_in">next</span> = pre_n.<span class="built_in">next</span></span><br><span class="line">            pre_n.<span class="built_in">next</span> = next_n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題不難理解，凡是想要從 O(n^2) 變成 O(n) 可以使用 HashMap，所以我一開始就建立字典記錄所有的位置。但是後來看到雙指針解法，真的是很厲害，腦袋到底怎麼想到的啊！<br>如果今天要<strong>有順序的進行反轉或是整批的改變位置移動，雙指針會是一個Linked List的重點</strong>。想像有兩個指針，一個指針<code>cur</code>慢往前，另一個指針會是目標節點<code>target</code> (在這裡是<code>next</code>)，<code>target</code> 會串到想要放的目標 location(在這裡是<code>pre.next</code>)，<code>cur</code> 會一直往前移動(<code>cur.next</code> 變成 <code>pre.next</code>)，直到達到目標節點，這樣就可以完成操作。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #138 Copy List with Random Pointer - 刷題之旅</title>
      <link href="/posts/leetcode-138-copy-list-with-random-pointer/"/>
      <url>/posts/leetcode-138-copy-list-with-random-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/RVADJ1Y.png" alt=""><br><img src="https://i.imgur.com/lNMmLGY.png" alt=""><br><img src="https://i.imgur.com/pgeQAoy.png" alt=""></p><p>簡單來說，就是要你複製出一個一樣的ListNode結構，而這個ListNode有一個random的參數，這個random參數是指向ListNode中的任意一個節點，這個節點可以是自己，也可以是其他節點。</p><h1 id="2-解法">2 解法</h1><h2 id="2-0-創建鍊錶">2.0 創建鍊錶</h2><p>在開始前，我們總是得想辦法先做個測試資料吧…輸入是一個二維陣列，每個元素是一個list，第一個元素是值，第二個元素是random的index，如果是None就是None。</p><ul><li>input: <code>[[7, None], [13, 0], [11, 4], [10, 2], [1, 0]]</code></li><li>output: ListNode 鍊錶</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createLinkedList</span>(<span class="params">nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; ListNode:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    random_dict = &#123;&#125;  <span class="comment"># 存 node, random_index</span></span><br><span class="line">    node_dict = &#123;&#125;    <span class="comment"># 存 index, node</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化頭節點</span></span><br><span class="line">    head = ListNode(nums[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    current = head</span><br><span class="line">    node_dict[<span class="number">0</span>] = head</span><br><span class="line">    random_dict[head] = nums[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代列表中的其餘元素並創建鏈表</span></span><br><span class="line">    <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[<span class="number">1</span>:], start=<span class="number">1</span>):</span><br><span class="line">        current.<span class="built_in">next</span> = ListNode(num[<span class="number">0</span>])</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">        node_dict[index] = current</span><br><span class="line">        random_dict[current] = num[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 處理 random</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> node_dict.values():</span><br><span class="line">        random_index = random_dict[node]</span><br><span class="line">        node.random = node_dict.get(random_index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_node_list</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;(val: <span class="subst">&#123;node.val&#125;</span>, random.val: <span class="subst">&#123;node.random.val <span class="keyword">if</span> node.random <span class="keyword">else</span> <span class="literal">None</span>&#125;</span>) -&gt; &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        node = node.<span class="built_in">next</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;None&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    l1 = [[<span class="number">7</span>, <span class="literal">None</span>], [<span class="number">13</span>, <span class="number">0</span>], [<span class="number">11</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span> = createLinkedList(l1)</span><br><span class="line">    print_node_list(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure><p>會印出以下內容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(val:7, random.val:None) -&gt; </span><br><span class="line">(val:13, random.val:7) -&gt; </span><br><span class="line">(val:11, random.val:1) -&gt; </span><br><span class="line">(val:10, random.val:11) -&gt; </span><br><span class="line">(val:1, random.val:7) -&gt; </span><br><span class="line">None</span><br></pre></td></tr></table></figure><h2 id="2-1-我的解法">2.1 我的解法</h2><p>一開始我想到<em>因為要複製出一模一樣的 Node 後，並且有了所有的 Node，才可以開始處理 random 的問題</em>，所以步驟如下：</p><ol><li>做一個字典方便搜尋：先複製整個 node 並且存 new_node 進去 node_dict (key: index, value: node)</li><li>建立一個紀錄 random_index 的字典，會紀錄 new_node 的 index 對應到 random_node 的 index (key: node.index, value: random_node.index)</li><li>開始幫 new_node 塞 random based on <code>random_index_dict</code><ul><li>在 random_index_dict 找 new_node.index 的 random.index</li><li>在 node_dict 找 random.index 取出 value 也就是 random_node</li><li>塞 random_node 到 new_node.random 裡面</li></ul></li></ol><h3 id="1-O-n-建立-idx-random-idx-的字典">1. O(n) 建立 idx -&gt; random_idx 的字典</h3><p>首先我要知道每個 index 的 random index 是多少，所以我先做一個函數 <code>findRandomIndex</code> 來找出每個 node 的 random index，並且存進字典裡面。<br>結果大概會類似這樣 <code>&#123;0: None, 1: 0, 2: 4, 3: 2, 4: 0&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findRandomIndex</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">int</span>, ListNode]:</span><br><span class="line">    node_index_dict = &#123;&#125;    <span class="comment"># key: node, value: node.index</span></span><br><span class="line">    random_index_dict = &#123;&#125;  <span class="comment"># key: node.index, value: random.index</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先塞好所有node的資料字典</span></span><br><span class="line">    current = head</span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        node_index_dict.__setitem__(current, index)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 開始整理 每個 node 的 random_index (key: node, value: random.index)</span></span><br><span class="line">    current = head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        random_node = current.random</span><br><span class="line">        random_index = node_index_dict.get(random_node) <span class="keyword">if</span> node_index_dict.get(random_node) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        random_index_dict.__setitem__(index, random_index)</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random_index_dict    <span class="comment"># 回傳每個node 他的random所在的index (key:node, value:random.index) &#123;0: None, 1: 0, 2: 4, 3: 2, 4: 0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-複製整個-node-O-n-塞-random-node-O-n">2. 複製整個 node O(n) &amp; 塞 random node O(n)</h3><p>接下來我會先處理整個 new_node 的建立，並且建立另一個字典 <code>node_idct</code> 可以記錄 <code>key=index, value=new_node</code>，這樣我就可以</p><ol><li>使用 <code>random_index_dict</code> 找到當前 index 的 random index</li><li>然後根據 <code>random_index</code> 從 <code>node_dict</code> 中找到 node</li><li>就可以串起來了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyRandomList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line"></span><br><span class="line">    random_index_dict = self.findRandomIndex(head)</span><br><span class="line">    node_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.  先做好所有node的dict (key: index, value: node)</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    current = dummy</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        current.<span class="built_in">next</span> = ListNode(head.val)</span><br><span class="line">        node_dict.__setitem__(index, current.<span class="built_in">next</span>)</span><br><span class="line">        <span class="comment"># 換下一個階段</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    new_head = dummy.<span class="built_in">next</span></span><br><span class="line">    dummy.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.  開始幫 new_head 塞 random based on `random_index_dict`</span></span><br><span class="line">    current = new_head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        random_index_of_cur_index = random_index_dict.get(index)</span><br><span class="line">        random_node = node_dict.get(random_index_of_cur_index)</span><br><span class="line">        current.random = random_node</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><h2 id="2-2-使用-HashTable">2.2 使用 HashTable</h2><p>這個做法也是建立 HashTable 但是沒有像我這麼笨，他是直接把 <code>old_node</code> 當作 key，<code>new_node</code> 當作 value。簡直天才！因為這樣不管是串 next 還是串 random 都只要拿 old_node 去找，就可以找到 new_node，然後開始串。</p><p>大概是這種感覺：<br><img src="https://i.imgur.com/IH8tA4R.png" alt=""></p><p>看看下面才幾行…就解決了這個問題！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyRandomList2</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    old_to_new = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 做好 新舊對應的 dict</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        old_to_new[cur] = ListNode(cur.val)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="comment"># 2. 因為已經有一個全部的dict 所以可以容易地將 next 跟 random 串起來</span></span><br><span class="line">        old_to_new[cur].<span class="built_in">next</span> = old_to_new.get(cur.<span class="built_in">next</span>)</span><br><span class="line">        old_to_new[cur].random = old_to_new.get(cur.random)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_to_new[head]</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題我是有想出來的，並且通過測試。我也想到要使用HashTable，但是我卻沒想到要使用 old_node 來當作 key，new_node 來當作 value，這樣就可以在找 random 的時候，直接找到 new_node 就可以了。這個解法真的很巧妙，超級厲害！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #21 Merge Two Sorted Lists - 刷題之旅</title>
      <link href="/posts/leetcode-21-merge-two-sorted-lists/"/>
      <url>/posts/leetcode-21-merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/QRGvMq9.png" alt=""></p><p>合併兩個有序的鍊錶，並且返回一個新的鍊錶。新的鍊錶是由兩個鍊錶的節點組成的。</p><h1 id="2-解法">2 解法</h1><p>跟 <a href="https://shannonhung.github.io/posts/leetcode-2-add-two-numbers">leetcode-2-add-two-numbers</a> 很類似，因為它涉及到多個 listNode 的操作，並且將操作結果合併為一個，因此我們可以使用 dummy_head 來幫助我們串接結果。因為他是排序，所以要比較兩個數字的大小，但是我們最怕的是在取listNode的值時發現他是None而導致錯誤，因為題目說數字範圍是[0, 50] 因此我們取 100 當作最大值，<em>因此我們可以使用 <code>digit1 = list1.val if list1 else 100</code> 的方式</em>，儘管遇到 none 仍然可以繼續執行迴圈，直到兩個 list1 跟 list2 都觸底，以避免 None 的問題。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">        cur = dummy_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> list2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 檢查是否為 None，如果是 None 就取 100 以繼續迴圈</span></span><br><span class="line">            digit1 = list1.val <span class="keyword">if</span> list1 <span class="keyword">else</span> <span class="number">100</span></span><br><span class="line">            digit2 = list2.val <span class="keyword">if</span> list2 <span class="keyword">else</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 操作：比較大小，取最小值，並且移動指標</span></span><br><span class="line">            <span class="keyword">if</span> digit1 &lt;= digit2:</span><br><span class="line">                min_val = digit1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                min_val = digit2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(min_val)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 把 dummy_head 移除</span></span><br><span class="line">        result = dummy_head.<span class="built_in">next</span></span><br><span class="line">        dummy_head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題很簡單，如果有處理過 Medium 等級的 <a href="https://shannonhung.github.io/posts/leetcode-2-add-two-numbers">leetcode-2-add-two-numbers</a>會覺得這個簡單很多！這題五分鐘左右就寫出來了！會運用到的概念就是 dummy_head 以及 取 value 的使用。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Easy </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #2 Add Two Numbers - 刷題之旅</title>
      <link href="/posts/leetcode-2-add-two-numbers/"/>
      <url>/posts/leetcode-2-add-two-numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/f2vClUm.png" alt=""><br><img src="https://i.imgur.com/LPCMrnR.png" alt=""></p><p>這題就是兩個鍊錶表示的數相加，這樣就可以實現兩個很大的數相加了，<em>關鍵要能無需考慮數值 int ，float 的限制了</em>。但是如果你把 ListNode 直接串啟程字串並且轉換成數字，這你就大錯特錯了！因為這樣就失去了這題的意義了。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>我一開始沒意識到，這題的 ListNode 是倒序的，所以我一開始的想法是把兩個 ListNode 轉換成數字，然後相加，再轉換成 ListNode。但是這樣就失去了這題的意義了。因為有一個test case是超級長的<code>[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]</code>直接突破了int的限制。</p><div class="note warning flat"><p><strong>所以我的解法無法通過這個 test case。建議參考下一個方法</strong></p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1. 先串起來成字串 [2, 3, 4] =&gt; 432, [5, 6, 4] =&gt; 465</span></span><br><span class="line"><span class="string">        2. 字串轉換成數字後相加 int(432) + int(465) = 807</span></span><br><span class="line"><span class="string">        3. 807 mode 10 一個個串入 7 -&gt; 0 -&gt; 8</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l1_str = <span class="string">&quot;&quot;</span></span><br><span class="line">        l2_str = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            l1_str = <span class="built_in">str</span>(l1.val) + l1_str</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            l2_str = <span class="built_in">str</span>(l2.val) + l2_str</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        tot = <span class="built_in">int</span>(l1_str) + <span class="built_in">int</span>(l2_str)</span><br><span class="line">        val = tot % <span class="number">10</span></span><br><span class="line">        head = ListNode(val)</span><br><span class="line"></span><br><span class="line">        current = head</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            tot = <span class="built_in">int</span>(tot / <span class="number">10</span>)</span><br><span class="line">            val = tot % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> tot == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            new_node = ListNode(val)</span><br><span class="line">            current.<span class="built_in">next</span> = new_node</span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="2-2-最佳解法">2.2 最佳解法</h2><p>這題的精髓在於有以下兩個特點：</p><ol><li><strong>從個位數往前一個個相加</strong>：為了實現兩個很大的數值相加，不被 int 的限制，我們在相加的時候可以從倒序 listnode 開始相加，也就是 123 + 456 的時候，我們從 3+6 開始。因此 123 需要先變成 321，456 需要先變成 654。這樣才可以從個位數（3與6）開始相加。</li><li><strong>處理商數</strong>：再來第二點是，我們要處理商數，也就是進位的問題。因此我們需要一個變數 <code>carry</code> 來處理進位的問題。如果個位數相加的時候，發現有進位的需求，我們就把進位的數字加到下一個數字相加的時候。</li><li><strong>dummy_head</strong>：如果我們要處理第一個 ListNode 就是兩個 ListNode 的第一個值相加的話，這可能會導致整個程式碼很攏長，要先檢查是否None，然後取出第二個數值，再相加。確保好第一個ListNode才可以進入while迴圈，但是檢查的事項又要重新做第二次，因此還不如直接先造出一個假的 ListNode，然後最後再返回 <code>dummy_head.next</code> 就好。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addTwoNumbers2</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    dummy_head = ListNode(<span class="number">0</span>) <span class="comment"># 原來還可以隨便塞一個，最後 return dummy_head.next 就好 （記得把 dummy_head.next 清空）</span></span><br><span class="line">    cur = dummy_head</span><br><span class="line">    carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> carry != <span class="number">0</span>:</span><br><span class="line">        digit1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        digit2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = digit1 + digit2 + carry</span><br><span class="line">        digit = <span class="built_in">sum</span> % <span class="number">10</span></span><br><span class="line">        carry = <span class="built_in">sum</span> // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(digit)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    result = dummy_head.<span class="built_in">next</span></span><br><span class="line">    dummy_head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題我也沒有在時間內解出來，直接去看答案了，雖然我的想法跟答案有點像，但是我還是傻傻的先把ListNode轉換成數字的字串，再用這個字串從第一個字串開始處理，太蠢了！！！可以直接拿ListNode開始處理，人家都幫你倒敘排好了…簡單來說，根本不用這樣做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: <span class="type">Optional</span>[ListNode], l2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    l1_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    l2_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> l1:</span><br><span class="line">        l1_str = <span class="built_in">str</span>(l1.val) + l1_str</span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> l2:</span><br><span class="line">        l2_str = <span class="built_in">str</span>(l2.val) + l2_str</span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> linked-list </tag>
            
            <tag> Review-Needed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #141 Linked List Cycle - 刷題之旅</title>
      <link href="/posts/leetcode-141-linked-list-cycle/"/>
      <url>/posts/leetcode-141-linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/ZQmiCGT.png" alt=""><br><img src="https://i.imgur.com/C7UpI5P.png" alt=""><br><img src="https://i.imgur.com/bf1O1pO.png" alt=""></p><p>判斷一個 linked list 是否有 cycle，如果有就返回 True，沒有就返回 False。</p><div class="note warning flat"><p><strong>特殊要求空間複雜度為 O(1)。</strong></p></div><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>一開始我的想法很簡單，但是空間複雜度為 O(n)。就是把每個節點都放進一個 set 裡面，如果有重複的節點就返回 True，否則返回 False。但是這個不滿足要求空間複雜度為 O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        check_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            check_dict.__setitem__(head, head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> check_dict.get(head):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="2-2-龜兔演算法">2.2 龜兔演算法</h2><p>這個方法很巧妙，因為只能適用空間複雜度為 O(1)。通常可以存固定數量的變數，一個變數肯定不夠，那如果兩個變數呢？ 但是兩個變數怎麼確認是否有 cycle 呢？這時候就要用到龜兔演算法了。</p><p>原理也很好理解，想像一下在一個圓形的跑道上，兩個人跑步，一個人跑的快一點，一個人跑的慢一點，如果有 cycle，那麼不管兩個人從哪個位置出發，跑的過程中兩人一定會相遇。所以這裡我們使用兩個指針，fast和slow，fast每次走兩步，slow每次走一步，如果有 cycle，那麼fast和slow一定會相遇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle3</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># Floyd&#x27;s Tortoise and Hare Algorithm</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:  <span class="comment"># while not null</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># there is a cycle</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># There is no cycle</span></span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這是一個Easy的題目，但是我完全忘記了龜兔演算法，這是一個很好的提醒。這個方法的時間複雜度為 O(n)，空間複雜度為 O(1)。如果<em>要求空間複雜度為<code>O(1)</code>的時候，在一個有cycle的linked list上，可以用兩個pointer來檢查是否有cycle。</em></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Easy </tag>
            
            <tag> linked-list </tag>
            
            <tag> Review-Needed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Linked List 的核心</title>
      <link href="/posts/lecture-linked-list/"/>
      <url>/posts/lecture-linked-list/</url>
      
        <content type="html"><![CDATA[<h1 id="介紹">介紹</h1><p>Linked List 鏈結串列是一種常見且基礎的資料結構，我們可以<em>基於 Linked List 去建立 Queue、Stack 等資料結構</em>。關於Stack與Queue可以參考這篇文章<a href="/posts/lecture-stack-and-queue/">LeetCode 課前預習 - 掌握 Stack 和 Queue 大全</a>。</p><p><strong>Linked List 的種類</strong></p><ul><li>single linked list: 只能訪問<code>下一個</code>節點</li><li>double linked list: 可以訪問<code>上一個</code>和<code>下一個</code>節點</li><li>circular linked list: 最後一個節點指向第一個節點</li></ul><p>linked list 一個很重要的概念是這個 list 的* Node.next 是儲存下一個 Node 在實際記憶體中的位置*，而不是儲存下一個 Node 的值。<br><img src="https://i.imgur.com/di647gG.png" alt=""></p><h1 id="結構">結構</h1><h2 id="節點">節點</h2><p>一個linked list主要由節點Node組成，每個節點包含兩個部分：</p><ol><li>data: 用來存放節點的數據</li><li>next: 用來指向下一個節點，是一個指標 pointer，pointer 會指向下一個節點，而最後一個節點的 pointer 則是指向 Null。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>這時我們可以透過 new 來建立節點:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node1 = Node(<span class="number">1</span>)</span><br><span class="line">node2 = Node(<span class="number">2</span>)</span><br><span class="line">node3 = Node(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="串起來">串起來</h2><p>那麼，我們該如何將這些節點連接起來呢?先透過改變物件的 next 屬性試試，結果變成巢狀物件了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node1.<span class="built_in">next</span> = node2</span><br><span class="line">node2.<span class="built_in">next</span> = node3</span><br></pre></td></tr></table></figure><h2 id="遍歷">遍歷</h2><p>雖然變成巢狀的物件，但確實每個節點的next都為下一個節點物件，我們可以寫一個函式去模擬 linked list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_linked_list</span>(<span class="params">head</span>):</span><br><span class="line">    current = head</span><br><span class="line">    result = <span class="string">&quot;root -&gt; &quot;</span> </span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        result += <span class="built_in">str</span>(current.data) + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">        current = current.<span class="built_in">next</span> <span class="comment"># 這裡會是重點，每個節點的 next 儲存下一個節點的實際記憶體位置</span></span><br><span class="line">    result += <span class="string">&quot;None&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最後，就可以印出類似 linked list 的字串</span></span><br><span class="line"><span class="comment"># root -&gt; 2 -&gt; 4 -&gt; 6 -&gt; None</span></span><br></pre></td></tr></table></figure><h1 id="操作">操作</h1><p><strong>如何存取第一個節點？</strong></p><ul><li>知道第一個節點的位置很重要，因為我們可以從第一個節點開始<em>遍歷整個linked list</em>。</li><li>通常我們會使用一個<code>head</code>指標來指向第一個節點，這樣我們就可以從<code>head</code>開始遍歷整個linked list。</li></ul><p><img src="https://i.imgur.com/oS6abzl.png" alt=""></p><p><strong>主要操作</strong><br>接著要介紹的是針對 linked list 進行一些操作的一些方法，起初我們先建立兩個建構子，一個用於創造節點物件，一個創造linked list並先寫好幾個方法的名字在裡面。這些方法裡面包涵：</p><ul><li><code>length</code>: 回傳 linked list 的長度</li><li><code>is_empty</code>: 判斷 linked list 是否為空</li><li><code>get</code>: 取得特定 index 的節點</li><li><code>remove</code>: 移除特定 index 的節點</li><li><code>add_at_index</code>: 在特定 index 新增節點</li><li><code>__str__</code>: 用來印出 linked list 的字串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_at_index</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        current = self.head</span><br><span class="line">        result = <span class="string">&quot;root -&gt; &quot;</span> </span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            result += <span class="built_in">str</span>(current.data) + <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        result += <span class="string">&quot;None&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="length-O-n">length O(n)</h2><p>主要邏輯就是碰到一個節點就 count+1，移動到下一個節點再 count+1，直到遇到 null 為止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">    current = self.head</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="is-empty-O-1">is_empty O(1)</h2><p>如果 head 為 None，那麼 linked list 就是空的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.head <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="get-by-index">get by index</h2><p>這個方法主要是取得特定 index 的節點，我們可以透過<em>迴圈去找到特定 index 的節點</em>，如果找到就回傳該節點，否則回傳 None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, index</span>):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.length():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;Index out of bounds&quot;</span>)</span><br><span class="line">    current = self.head </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index):</span><br><span class="line">        current = current.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> current </span><br></pre></td></tr></table></figure><h2 id="remove-by-index-O-n">remove by index O(n)</h2><p>這個方法主要是移除特定 index 的節點，我們可以透過<em>迴圈找到特定 index 的節點</em>，然後將該節點的 next 指向下下個節點，這樣就可以移除該節點。<br>但是需要注意的是如果<em>移除 index 為 0 的節點，我們需要將 head 指向下一個節點</em>，這樣就可以移除第一個節點。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, index</span>):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= self.length():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;Index out of bounds&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">        self.head = self.head.<span class="built_in">next</span> <span class="comment"># 若是要移除第一個節點，需要將 head 指向下一個節點</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="comment"># 開始透過迴圈找到特定 index 的節點</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>):</span><br><span class="line">            current = current.<span class="built_in">next</span> <span class="comment"># 找到最後 current.next 就是要移除的節點</span></span><br><span class="line">        current.<span class="built_in">next</span> = current.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 把 current.next 指向下下個節點</span></span><br></pre></td></tr></table></figure><h2 id="add-by-index-O-n">add by index O(n)</h2><p>主要是新增一個新的節點到特定的 index，也是要注意是否新增的 index 是 0，如果是 0 的話，我們需要將 head 指向新的節點。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_at_index</span>(<span class="params">self, index, data</span>):</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; self.length():</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">&quot;Index out of bounds&quot;</span>)</span><br><span class="line">    <span class="comment"># 建立新 node </span></span><br><span class="line">    new_node = Node(data)</span><br><span class="line">    <span class="comment"># 塞在第一個位置</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">        new_node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = new_node</span><br><span class="line">    <span class="comment"># 塞在其他位置</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = self.head</span><br><span class="line">        <span class="comment"># 開始透過迴圈找到特定 index 的節點</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(index - <span class="number">1</span>): <span class="comment"># index - 1 就是要塞的前一個位置</span></span><br><span class="line">            current = current.<span class="built_in">next</span></span><br><span class="line">        new_node.<span class="built_in">next</span> = current.<span class="built_in">next</span></span><br><span class="line">        current.<span class="built_in">next</span> = new_node</span><br></pre></td></tr></table></figure><h2 id="總結">總結</h2><p>使用 Linked List 的主要重點是：</p><ol><li><em>用For loop遍歷</em>：你會發現，<code>add</code>, <code>get</code>, <code>length</code>, <code>remove</code> 這些方法都是<em>透過迴圈</em>去找到特定 index 的節點，然後進行操作。</li><li><em>Index 合理性</em>：跟 index 有關的，都要先檢查 index 的合理性 <code>if index &lt; 0 or index &gt;= self.length():</code></li><li><em>Head 的考量</em>：在 remove, add 的時候，要考量到是否會更動到第一個節點。</li><li><em>判斷index是否超過長度</em>：需要特別注意的是 add 因為可能要塞在最後 所以 index 可以等於 length，但是 remove 和 get 不行，因為 remove 是要移除節點，所以 index 不能等於 length。</li><li>for loop 的 range 到底要不要 -1：這邊你可以想像，像是add或是remove時，我們都需要目標index的前一個節點才能進行操作，所以在這邊要-1。<ol><li>get: 你要找到的是 index 的節點，所以不用-1</li><li>remove: 你要找到的是 index 要移除目標的<em>前一個</em>節點，所以要-1</li><li>add: 你要找的是 index 要塞的<em>前一個</em>節點，所以要-1</li></ol></li></ol><p>時間複雜度</p><ul><li><code>get</code>：O(n)</li><li><code>remove</code>：O(n)</li><li><code>length</code>：O(n)</li><li><code>is_empty</code>：O(1)</li><li><code>add_at_index</code>：O(n)</li></ul><h1 id="比較">比較</h1><p><strong>Linked List vs Array 這兩者的關鍵差別？</strong></p><ul><li>array 會根據儲存的data的bytes跟上一個節點來決定下一個節點的位置，他是一個連續的記憶體空間，</li><li>linked list: 每個節點會儲存下一個節點的位置，因此不需要連續的記憶體空間。</li></ul><p><strong>Linked List 與 Queue 和 Stack 的關係</strong><br>以下是對比Linked List、Queue和Stack的表格，這個表格簡明地比較了Linked List、Queue和Stack的定義、結構、操作、時間複雜度、優缺點及使用情境，幫助理解它們之間的相似和差異：</p><table><thead><tr><th>特性</th><th>Linked List</th><th>Queue</th><th>Stack</th></tr></thead><tbody><tr><td>定義</td><td>一連串節點，每個節點包含資料和<code>指向下一個</code>節點的指針</td><td>先進先出（<code>FIFO</code>）資料結構</td><td>後進先出（<code>LIFO</code>）資料結構</td></tr><tr><td>結構</td><td><code>單向</code>鏈表、<code>雙向</code>鏈表或<code>循環</code>鏈表</td><td>單向鏈表或陣列，通常有<code>指向頭和尾</code>的指針</td><td>單向鏈表或陣列，通常在<code>頭部</code>操作</td></tr><tr><td>插入</td><td>可以在<code>任意</code>位置插入</td><td>只能在<code>隊尾</code>插入（enqueue）</td><td>只能在堆疊<code>頂部</code>插入（push）</td></tr><tr><td>刪除</td><td>可以在<code>任意</code>位置刪除</td><td>只能在<code>隊首</code>刪除（dequeue）</td><td>只能在堆疊<code>頂部</code>刪除（pop）</td></tr><tr><td>訪問</td><td><code>隨機</code>訪問，需從頭節點開始依次訪問</td><td>只能訪問<code>隊首</code>元素（peek）</td><td>只能訪問堆疊<code>頂部</code>元素（peek）</td></tr><tr><td>時間複雜度</td><td>插入/刪除：O(1)（在給定位置）</td><td>入隊/出隊：O(1)</td><td>壓入/彈出：O(1)</td></tr><tr><td>缺點</td><td>隨機訪問效率低，需額外的指針空間</td><td>只能<code>在固定一端</code>插入和刪除，隨機訪問不方便</td><td>只能在<code>固定一端</code>插入和刪除，隨機訪問不方便</td></tr><tr><td>使用情境</td><td>需要<code>頻繁插入、刪除中間元素</code>的情境</td><td><code>按順序</code>處理資料，如排隊系統</td><td><code>逆序處理資料</code>，如函數調用堆疊</td></tr></tbody></table><h1 id="Reference">Reference</h1><ul><li><a href="https://youtu.be/b5QR4AmrspU?si=1KdyTRo54Wcrd-qn">Youtube | Array vs. Single Linked List (In Terms of Representation)</a></li><li><a href="https://ithelp.ithome.com.tw/articles/10217020">iThome | Day4-來了解鏈結串列(Linked List)並實作它吧!</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> linked-list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #224 Basic Calculator - 刷題之旅</title>
      <link href="/posts/leetcode-224-basic-calculator/"/>
      <url>/posts/leetcode-224-basic-calculator/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/PCh2571.png" alt=""><br><img src="https://i.imgur.com/Vnniv8o.png" alt=""></p><p>這題是 Hard 的題目，難度在於，要如何處理以下問題：</p><ol><li>碰到括號怎麼進行優先處理</li><li>括號前面的“-”號會改變括號內的數字正負，並且要與括號外的數字相加</li></ol><h1 id="2-解法">2 解法</h1><p>首先一個很重要的概念是，我們要如何處理括號的問題，這邊我們會使用到三個變數：</p><ol><li><code>sign</code>：用來記錄當前的正負號，初始值為 1，通常用來記錄數字前一個符號是正還是負。</li><li><code>res</code>：用來記錄當前的結果，初始值為 0，通常是用來記錄左括號之前的加總數字。</li><li><code>num</code>：用來記錄當前的數字，初始值為 0，通常是當前括號內的數字總和。</li></ol><p>因此我們所使用的公式如下：<br><img src="https://i.imgur.com/PAEEBxR.png" alt=""></p><p>在了解公式之後，我們要有一個邏輯處理當碰到<code>左括號</code> 和 <code>右括號</code>的流程。<br><strong>當碰到左括號</strong></p><ol><li>我們要記錄當前的 <code>res</code> 和 <code>sign</code>先放到 stack 裡面，並且重新設定 <code>res</code> 和 <code>sign</code> 為 0 和 1。</li><li>然後優先處理括號內的數字，直到遇到右括號。</li></ol><p><strong>當碰到右括號</strong></p><ol><li>當前的 <code>res</code> 是括號內的加總數字</li><li>括號的前一個符號，也就是在 stack 裡面的 <code>sign</code> 會決定括號內的數字是正還是負。</li><li>因此我們會將括號也就是當前的 <code>res</code> 和 stack 的<code>sign</code> 取出來並相乘，再加回去 來自 stack 的 <code>res</code>。</li></ol><p>流程大概就是這樣，以 <code>(1+(4+5+2)-3)-(16+8)</code> 為例：</p><ol><li>因為一開始就是 <code>(</code>，所以我們會將 <code>res</code> 和 <code>sign</code> 放到 stack 裡面，並且重新設定 <code>res</code> 和 <code>sign</code> 為 0 和 1。</li><li>然後開始處理 <code>1+</code> 的部分，<code>res</code> 會變成 1，<code>sign</code> 會變成 1。</li><li>結果又碰到 <code>(</code>，所以我們會將 <code>res</code>(1) 和 <code>sign</code>(1) 放到 stack 裡面，並且重新設定 <code>res</code> 和 <code>sign</code> 為 0 和 1。</li><li>開始專心處理 <code>4+5+2</code> 的部分，<code>res</code> 會變成 11，<code>sign</code> 會變成 1。</li><li>結果碰到了 <code>)</code>，這時候我們要將 stack 的 <code>sign</code> pop 出來與括號的 <code>res</code>相乘，並且與 stack 中的 <code>res</code> 相加。</li><li>然後繼續處理…<br>(參考以下示意圖)<br><img src="https://i.imgur.com/yQn4err.png" alt=""><br><img src="https://i.imgur.com/hOkTGFJ.png" alt=""></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate2</span>(<span class="params">self, s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1. Take 3 containers:</span></span><br><span class="line"><span class="string">    num -&gt; to store current num value only</span></span><br><span class="line"><span class="string">    sign -&gt; to store sign value, initially +1</span></span><br><span class="line"><span class="string">    res -&gt; to store sum</span></span><br><span class="line"><span class="string">    When ( comes these containers used for calculate sum of intergers within () brackets.</span></span><br><span class="line"><span class="string">    --------------------</span></span><br><span class="line"><span class="string">    2. When c is + or -</span></span><br><span class="line"><span class="string">    Move num to res, because we need to empty num for next integer value.</span></span><br><span class="line"><span class="string">    set num = 0</span></span><br><span class="line"><span class="string">    sign = update with c</span></span><br><span class="line"><span class="string">    --------------------</span></span><br><span class="line"><span class="string">    3. When c is &#x27;(&#x27;</span></span><br><span class="line"><span class="string">    Here, we need num, res, sign to calculate sum of integers within ()</span></span><br><span class="line"><span class="string">    So, move num and sign to stack =&gt; [num, sign]</span></span><br><span class="line"><span class="string">    Now reset - res = 0, num = 0, sign = 1 (default)</span></span><br><span class="line"><span class="string">    --------------------</span></span><br><span class="line"><span class="string">    4. When c is &#x27;)&#x27; -&gt; 2-(3+4), Here res=3, num=4, sign=1 stack [2, -]</span></span><br><span class="line"><span class="string">    res +=sign*num -&gt; calculate sum for num first, then pop items from stack, res=7</span></span><br><span class="line"><span class="string">    res *=stack.pop() - &gt; Pop sign(+ or -) to multiply with res, res = 7*(-1)</span></span><br><span class="line"><span class="string">    res +=stack.pop() - &gt; Pop integer and add with prev. sum, res = -7 + 2 - 5</span></span><br><span class="line"><span class="string">    --------------------</span></span><br><span class="line"><span class="string">    Simple Example: 2 - 3</span></span><br><span class="line"><span class="string">    Initially res will have 2,i.e. res = 2</span></span><br><span class="line"><span class="string">    then store &#x27;-&#x27; in sign. it will be used when 3 comes. ie. sign = -1</span></span><br><span class="line"><span class="string">    Now 3 comes =&gt; res = res + num*sign</span></span><br><span class="line"><span class="string">    Return statement: res+num*sign =&gt; res = 2 + 3(-1) = 2 - 3 = -1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    sign = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):  <span class="comment"># iterate till last character</span></span><br><span class="line">        c = s[i]</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():  <span class="comment"># process if there is digit</span></span><br><span class="line">            num = num * <span class="number">10</span> + <span class="built_in">int</span>(c)  <span class="comment"># for consecutive digits 98 =&gt; 9x10 + 8 = 98</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;-+&#x27;</span>:  <span class="comment"># check for - and + sign，如果沒遇到括號，就繼續計算res總額</span></span><br><span class="line">            res += num * sign</span><br><span class="line">            sign = -<span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&#x27;-&#x27;</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;(&#x27;</span>:  <span class="comment"># if ( comes, 儲存括號以外的總額，與括號之前的符號</span></span><br><span class="line">            stack.append(res)</span><br><span class="line">            stack.append(sign)</span><br><span class="line">            res = <span class="number">0</span>     <span class="comment"># reset res for new calculation </span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:  <span class="comment"># if ) comes, 括號結束的意思，可以把 stack 的內容取出來計算</span></span><br><span class="line">            res += sign * num</span><br><span class="line">            res *= stack.pop()</span><br><span class="line">            res += stack.pop()</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> res + num * sign</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題真的難，這題的<em>難度我卡在不知道該怎麼處理括號前面對“負號“的狀況，這邊的解法是把括號前面的符號存到 stack 裡面</em>，然後在括號結束的時候，再取出來相乘，這樣就可以處理括號前面的負號問題。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Stack &amp; Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Hard </tag>
            
            <tag> Review-Needed </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #150 Evaluate Reverse Polish Notation - 刷題之旅</title>
      <link href="/posts/leetcode-150-evaluate-reverse-polish-notation/"/>
      <url>/posts/leetcode-150-evaluate-reverse-polish-notation/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/bENnGJk.png" alt=""><br><img src="https://i.imgur.com/5LTsVZ9.png" alt=""></p><p>題目中是逆波蘭式，計算法則就是，每次找到運算子位置的前兩個數字，然後再進行計算。</p><h1 id="2-解法">2 解法</h1><p>這題不會太難，我覺得關鍵在你要意識到，當計算完後，要把結果再 push 回去 stack 裡面，這樣下次遇到運算符號時，才可以再次的把上一次的計算結果一起pop出來。</p><p>以範例的 <code>[&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</code> 為例好了，大概是這樣：<br><img src="https://i.imgur.com/ze3EHiu.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evalRPN</span>(<span class="params">self, tokens: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        operators = [<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            cur = i</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> operators:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(cur))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = stack.pop()</span><br><span class="line">                top = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> cur == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    stack.append(top + pre)</span><br><span class="line">                <span class="keyword">elif</span> cur == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    stack.append(top - pre)</span><br><span class="line">                <span class="keyword">elif</span> cur == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    stack.append(top * pre)</span><br><span class="line">                <span class="keyword">elif</span> cur == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(top / pre))</span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這題的解題關鍵就是<em>當計算完後，要把結果再 push 回去 stack 裡面</em>，這樣下次遇到運算符號時，才可以再次的把上一次的計算結果一起pop出來。一開始我沒想到，一直花時間在想要怎麼儲存運算完後的結果，只是想著要存在某個變數，後來休息一下，再回頭看，腦子清晰了，就想到了可以塞回去stack呀！！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Stack &amp; Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #155 Min Stack - 刷題之旅</title>
      <link href="/posts/leetcode-155-min-stack/"/>
      <url>/posts/leetcode-155-min-stack/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/vFpnrIQ.png" alt=""><br><img src="https://i.imgur.com/Jx41svA.png" alt=""></p><p>這題的重點在於要實現一個可以取得最小值的 stack，並且<em>要求時間複雜度為 O(1)</em>。解題思路的重點是，你要怎麼<em>確保在 <code>push()</code> 的時候，更新最小值，並且在 <code>pop()</code> 的時候，如果 <code>pop()</code> 出當前最小值時，也要更新最小值</em>。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>有沒有發現重點，當 <code>pop()</code> 和 <code>push()</code> 的時候，最小值也會有所更新，在 <code>pop()</code> 的時候，最小的值被剔除時，我們希望取得第二小，因此我們會需要一個 <code>min_stack</code> 來記錄當前最小值，如果遇到當前更小的，就 <code>push()</code> 進去 <code>min_stack</code> 裡面。這樣儘管最小的被 pop() 出去，我們仍然可以取得第二小的值。</p><p>大概是這種感覺：</p><blockquote><p>每當 push 新的值進去時，都要與 <code>min_stack[-1]</code> 最小值比較是否更小，若更小，也要 push 進去 <code>min_stack</code> 裡面。<br><img src="https://i.imgur.com/D7YL6cX.png" alt=""></p></blockquote><blockquote><p>每當 pop 出去時，也要檢查 pop 出去的值是否是當前的最小值，若是，也要把當前的 <code>min_stack[-1]</code> pop 出去<br><img src="https://i.imgur.com/XHLm9RK.png" alt=""></p></blockquote><p>其他的功能就跟 stack 一樣，在 python 可以使用 list 來實現 stack 的功能。 top() 可以使用 list[-1] 的方式取得，他仍然時間複雜度是 O(1)。下面註解的地方是我原本寫的，但是經過參考別人的後發現有更簡潔的寫法，所以我就改成更簡潔的寫法，註解可以參考。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.min_stack: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line">        self.stack: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原本</span></span><br><span class="line">        <span class="comment"># if not self.min_stack:</span></span><br><span class="line">        <span class="comment">#     min_data = self.min_stack[-1]</span></span><br><span class="line">        <span class="comment">#     if min_data &gt;= val:</span></span><br><span class="line">        <span class="comment">#         self.min_stack.append(val)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     self.min_stack.append(val)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以精簡成這樣</span></span><br><span class="line">        <span class="comment"># 如果 min_stack 是空的，或是 val 比 min_stack[-1] 還小，就 push 進去 min_stack 裡面</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 關鍵在 pop 掉 min 怎麼確保找到 第二小的 min</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 原本寫法</span></span><br><span class="line">        <span class="comment"># data = self.stack.pop()</span></span><br><span class="line">        <span class="comment"># if self.min_stack[-1] == data:</span></span><br><span class="line">        <span class="comment">#     self.min_stack.pop()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不需要浪費記憶體 data</span></span><br><span class="line">        <span class="comment"># 如果發現 pop 出去的值是最小值，也要 pop 出去 min_stack 裡面</span></span><br><span class="line">        <span class="keyword">if</span> self.stack[-<span class="number">1</span>] == self.minStack[-<span class="number">1</span>]:</span><br><span class="line">            self.minStack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(1)</strong> push(), pop(), top(), getMin() 操作的時間複雜度均為 O(1)。<br><strong>空間複雜度O(n)</strong> 由於 min_stack 和 stack 存儲 n 個不同的數字，因此空間複雜度為 O(n)。</p></div><h2 id="2-2-其他方法">2.2 其他方法</h2><p>還有一種方法，可以讓程式碼更簡潔，但是空間複雜度方便可能會比第一個方法更大，那就是在 <code>push()</code> 的時候，不管是不是最小值，都要 push 進去 <code>min_stack</code> 裡面，只是 push 進去的必須是當前的最小值，這樣在 <code>pop()</code> 的時候，就不用檢查是否是最小值，直接 pop 出去就好。這樣的好處是程式碼更簡潔，但是空間複雜度可能會比較大，因為 <code>min_stack</code> 裡面會有很多重複的值。</p><p>大概是這種感覺：<br><img src="https://i.imgur.com/2U2spUc.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack2</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 如果必須 getMin 是 O(1) 那只能有另一個 stack 維護 min 這樣 pop 出來某個還可以繼續往下 pop</span></span><br><span class="line">        self.min_stack: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line">        self.stack: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> self.min_stack:</span><br><span class="line">            val = <span class="built_in">min</span>(self.min_stack[-<span class="number">1</span>], val)</span><br><span class="line">        <span class="comment"># 整個的精華重點在這裡</span></span><br><span class="line">        self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 然後你會發現 pop() 的實作變得非常簡單 </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我們仔細看一下這兩個方法的差異：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一種方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> val &lt;= self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 只有在遇到更小的值，才 push 進去 min_stack 裡面</span></span><br><span class="line">            self.min_stack.append(val)</span><br><span class="line"><span class="comment"># 第二種方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stack.append(val)</span><br><span class="line">        <span class="keyword">if</span> self.min_stack:</span><br><span class="line">            <span class="comment"># 先比較當前的 min_stack[-1] 和 val 誰比較小</span></span><br><span class="line">            val = <span class="built_in">min</span>(self.min_stack[-<span class="number">1</span>], val)</span><br><span class="line">        <span class="comment"># &quot;每次&quot; 都塞入當前的最小值</span></span><br><span class="line">        self.min_stack.append(val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一種方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 每次還要檢查pop出去的值是否是最小值</span></span><br><span class="line">        <span class="keyword">if</span> self.stack[-<span class="number">1</span>] == self.minStack[-<span class="number">1</span>]:</span><br><span class="line">            self.minStack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"><span class="comment"># 第二種方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 無腦 pop 出去就好</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(1)</strong> <code>push()</code>, <code>pop()</code>, <code>top()</code>, <code>getMin()</code> 操作的時間複雜度均為 O(1)。<br><strong>空間複雜度O(n)</strong> 由於 <code>min_stack</code> 和 <code>stack</code> 存儲 n 個不同的數字，因此空間複雜度為 O(n)。</p></div><h1 id="3-總結">3 總結</h1><p>今天偷看了一下，一開始想不透到底要怎麼用 O(1) 的時間複雜度就可以做到 pop() 後仍然保持最小值，一開始都是用一個變數儲存最小值，但是沒想到<strong>這題的精髓在使用 stack 紀錄最小值，這樣在 pop() 的時候，也可以保持最小值</strong>。自己<em>不應該每次看到 O(1) 就要無腦想用 Hash Table，這是無序的狀態下搜尋某個關鍵字使用，但是這題是有序的，所以使用 stack 來記錄最小值是一個很好的方法</em>。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Stack &amp; Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #20 Valid Parentheses - 刷題之旅</title>
      <link href="/posts/leetcode-20-valid-parentheses/"/>
      <url>/posts/leetcode-20-valid-parentheses/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p>這是一個括號匹配的問題，給一個只包含<code>(</code>, <code>)</code>, <code>&#123;</code>, <code>&#125;</code>, <code>[</code>, <code>]</code>的字符串，目的是要檢查一個字串是否是有效的括號組合。<br><img src="https://i.imgur.com/KGx9I0c.png" alt=""></p><h1 id="2-解法">2 解法</h1><p>我的想法很簡單：</p><ol><li>先建立一個 dictionary，把所有的括號對應關係記錄下來。 key 是 <code>(</code>, <code>&#123;</code>, <code>[</code>，value 是說明 key 的方向(<code>open</code> or <code>close</code>)與屬性(大, 中, 小括號)。</li><li>開始遍歷字串，如果是<code>open</code>，就把它放進 stack 裡面，如果是<code>close</code>，就檢查 stack 最上面的元素是否是對應的開括號，如果是就 pop 掉，不是就返回 False。</li></ol><p>大概是這種感覺：<br><img src="https://i.imgur.com/DklQ6Je.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        str_dic = &#123;</span><br><span class="line">            <span class="string">&quot;&#123;&quot;</span>: [<span class="string">&quot;open&quot;</span>, <span class="string">&quot;Big&quot;</span>],</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>: [<span class="string">&quot;close&quot;</span>, <span class="string">&quot;Big&quot;</span>],</span><br><span class="line">            <span class="string">&quot;[&quot;</span>: [<span class="string">&quot;open&quot;</span>, <span class="string">&quot;Mid&quot;</span>],</span><br><span class="line">            <span class="string">&quot;]&quot;</span>: [<span class="string">&quot;close&quot;</span>, <span class="string">&quot;Mid&quot;</span>],</span><br><span class="line">            <span class="string">&quot;(&quot;</span>: [<span class="string">&quot;open&quot;</span>, <span class="string">&quot;Small&quot;</span>],</span><br><span class="line">            <span class="string">&quot;)&quot;</span>: [<span class="string">&quot;close&quot;</span>, <span class="string">&quot;Small&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            target = str_dic.get(i)</span><br><span class="line">            <span class="comment"># open </span></span><br><span class="line">            <span class="keyword">if</span> target[<span class="number">0</span>] == <span class="string">&quot;open&quot;</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># close</span></span><br><span class="line">                <span class="comment"># 應對可能一開始就是 close 的情況 stack 是空的</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="comment"># [1] 檢查是否相同型態:  Big, Mid, Small </span></span><br><span class="line">                <span class="keyword">if</span> str_dic.get(stack.pop())[<span class="number">1</span>] != target[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 確保所有的都配對完</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack <span class="comment"># if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,</span></span><br><span class="line">                         <span class="comment"># so the string is valid, otherwise, there are unmatched opening brackets, so return false</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(n)</strong> for 循環遍歷整個 s 列表，時間複雜度為 O(n)。<br><strong>空間複雜度O(n)</strong> 空間複雜度由字典 stack存儲 n 個不同的字，因此空間複雜度為 O(n)。</p></div><h1 id="3-總結">3 總結</h1><p>這題很簡單，但是要能夠想到用 stack 來解決，<strong>如果是應對對稱性的問題，stack 是一個很好的選擇</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Stack &amp; Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Easy </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #71 Simplify Path - 刷題之旅</title>
      <link href="/posts/leetcode-71-simplify-path/"/>
      <url>/posts/leetcode-71-simplify-path/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/ZMpZJ3j.png" alt=""><br><img src="https://i.imgur.com/gFzfnvi.png" alt=""><br><img src="https://i.imgur.com/FJagwnq.png" alt=""></p><p>這個題目的目標是在把一個很複雜的路徑簡化成為一個簡單的路徑，例如：</p><ul><li>input: <code>/a/./b/../../c/</code></li><li>output: <code>/c</code></li></ul><p><em>從上面的例子來說，<code>/a/b</code> 進去後，往上一層，再往上一層，回到<code>/</code>，最後進到 <code>/c</code>，但直接寫成 <code>/c</code> 不就好了嗎？太蠢了，請簡化他！這就是題目的用意。</em></p><h1 id="2-解法">2 解法</h1><p>從題目的思路來看，你會發現當遇到 <code>/..</code> 的時候，就需要往上一層，其實就是把目前 stack 的最上面的目錄 pop 出來，當遇到正常的目錄而不是<code>/.</code> 或是 <code>/..</code> 就可以放入 stack 裡面。從下面的圖片來看，以 <code>/.../a/../b/c/../d/./</code> 為例子，我們可以看到 stack 的變化。（注意 <code>/...</code> 是一個目錄，因為他不是 <code>/.</code> 或是 <code>/..</code>）</p><blockquote><p>從下圖來看，只要是正常檔案名稱，就放入 stack 裡面<br><img src="https://i.imgur.com/bvP0N2v.png" alt=""></p></blockquote><blockquote><p>當遇到 <code>..</code> 的時候，就 pop 出來，當遇到 <code>.</code> 的時候，就不做任何事情，繼續往下走。<br><img src="https://i.imgur.com/q2XcnlM.png" alt=""></p></blockquote><blockquote><p>最後，把 stack 裡面的元素，用 <code>/</code> 串接起來，就是答案。<br><img src="https://i.imgur.com/aT6YhtD.png" alt=""></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">            <span class="comment"># 如果是空的或是當前目錄，就不做任何事情 </span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> i == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果是上一層目錄，就 pop 出來 </span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">                <span class="comment"># 但是如果 stack 是空的，就不做任何事情 </span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="comment"># 不是特殊標誌，就是一般檔案名稱，放入 stack 裡面</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 可以用 join 實現 </span></span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            ans = <span class="string">&quot;/&quot;</span> + stack.pop() + ans</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ans) == <span class="number">0</span>:</span><br><span class="line">            ans = <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ans </span><br><span class="line"></span><br><span class="line"><span class="comment"># 著重在需要做處理的部分 (if, elif)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;..&quot;</span>]:</span><br><span class="line">                stack.append(i)</span><br></pre></td></tr></table></figure><p>但是我們發現應該可以簡化一下，因為 <code>continue</code> 的部分應該省略，專注在需要執行動作的條件<code>if</code>上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># continue 的部分應該省略，專注在需要執行動作的條件if上</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&quot;&quot;</span> <span class="keyword">or</span> i == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stack.append(i)</span><br></pre></td></tr></table></figure><p>以及最後的部分，我們可以用 <code>join</code> 實現，而不是用 <code>while</code> loop 來實現。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以用 join 實現 </span></span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            ans = <span class="string">&quot;/&quot;</span> + stack.pop() + ans</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ans) == <span class="number">0</span>:</span><br><span class="line">            ans = <span class="string">&quot;/&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改成這樣</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/&quot;</span> + <span class="string">&quot;/&quot;</span>.join(stack))</span><br></pre></td></tr></table></figure><p><strong>修改後的程式碼如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">simplifyPath2</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">&quot;/&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i == <span class="string">&quot;..&quot;</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">elif</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;..&quot;</span>]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + <span class="string">&quot;/&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(n)</strong> for 循環遍歷整個 s 列表在 split 過後，時間複雜度為 O(n)。<br><strong>空間複雜度O(n)</strong> 空間複雜度由字典 stack 存儲 n 個不同的檔案名稱，因此空間複雜度為 O(n)。</p></div><h1 id="3-總結">3 總結</h1><p>總結來說，很開心這個題目也是30分鐘內就寫出解決辦法，但是對於程式碼的簡化，還是需要多加練習，這個題目的特性就是你發現要有需要<em>回到上一層的需求，stack會是一個很好的選擇</em>，因為 <code>pop()</code> 可以把上面的元素拿掉，這樣就可以達到目的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Stack &amp; Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Stack 和 Queue 大全</title>
      <link href="/posts/lecture-stack-and-queue/"/>
      <url>/posts/lecture-stack-and-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="Stack">Stack</h1><div class="note info flat"><p><strong>Stack是一種線性資料結構，遵循後進先出（LIFO）的原則。</strong></p></div><p><img src="https://i.imgur.com/qJjniLI.png" alt=""><br>LIFO 現實中的例子可以想像一落堆疊起來的盤子，我們需要從最上面開始拿；又或者像一台塞滿人的電梯，最後進的最靠門的人必須要先出去，後面的人才能出去。</p><p><strong>基本操作</strong></p><ul><li><code>Push</code>: 將元素添加到Stack的頂部。</li><li><code>Pop</code>: 從Stack的頂部移除元素。</li><li><code>Peek/Top</code>: 獲取Stack頂部的元素但不移除它。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node top; <span class="comment">// remove from the top </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the top element in the stack</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        node.next = top;</span><br><span class="line">        top = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">        top = top.next;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>How to add a new node to the stack?<br><img src="https://i.imgur.com/UZmqW7B.png" alt=""></p></blockquote><blockquote><p>How to remove the top node from the stack?<br><img src="https://i.imgur.com/5u2xv29.png" alt=""></p></blockquote><h1 id="Queue">Queue</h1><div class="note info flat"><p><strong>Queue是一種線性資料結構，遵循先進先出（FIFO）的原則。</strong></p></div><p><img src="https://i.imgur.com/MOiZC1j.png" alt=""><br>FIFO 現實中的例子可以想像排隊買票，先來的人先買到票，後來的人要等前面的人買完才能買。</p><p><strong>基本操作</strong></p><ul><li><code>Enqueue/Add</code>: 將元素添加到Queue的尾部。<ul><li>把當前 <code>tail.next</code> 指向新的 <code>data</code></li><li>更新 <code>tail</code> 指向新的 <code>data</code></li></ul></li><li><code>Dequeue/Remove</code>: 從Queue的頭部移除元素。<ul><li>把當前的 <code>head</code> 指向下一個 <code>data</code> 也就是 <code>head.next</code></li><li>如果 <code>head</code> 是 <code>null</code>，那麼 <code>tail</code> 也要指向 <code>null</code></li><li>否則返回被移除的元素</li></ul></li><li><code>Peek/Front</code>: 獲取Queue頭部的元素但不移除它。<ul><li>單純的返回 <code>head.data</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">// remove from the head </span></span><br><span class="line">    <span class="keyword">private</span> Node tail; <span class="comment">// add things here </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get the first element in the queue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// refer to the following Image</span></span><br><span class="line">        <span class="comment">// if tail is not null, then we need to add the new node to the tail.next </span></span><br><span class="line">        <span class="comment">// 最一開始什麼data都沒有，所以 tail 跟 head 都是 null </span></span><br><span class="line">        <span class="comment">// if 檢查是為了處理第二次以後的新增 </span></span><br><span class="line">        <span class="keyword">if</span> (tail != <span class="literal">null</span>) &#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update the tail to the new node, make sure the new node is the last node</span></span><br><span class="line">        tail = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if 檢查是為了處理第一次的新增，之後就不用了</span></span><br><span class="line">        <span class="comment">// if the queue is empty, then the head should be the new node</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// get the first element in the queue, which is going to be removed</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> head.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update the head to the next node, prepare to remove the original head </span></span><br><span class="line">        head = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the head is null, then the queue is empty, update the tail to null</span></span><br><span class="line">        <span class="comment">// 如果移除掉最後一個元素，那麼 head 就會是 null，所以 tail 也要是 null</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return the removed element</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>How to add a new node to the queue?<br><img src="https://i.imgur.com/Ocg2vP8.png" alt=""></p></blockquote><blockquote><p>How to remove the first node from the queue?<br><img src="https://i.imgur.com/2MlJuZr.png" alt=""></p></blockquote><h1 id="差異比較">差異比較</h1><table><thead><tr><th>特性</th><th>Stack</th><th>Queue</th></tr></thead><tbody><tr><td>定義</td><td>一種後進先出（LIFO）的資料結構</td><td>一種先進先出（FIFO）的資料結構</td></tr><tr><td>基本操作</td><td>Push、Pop、Peek</td><td>Enqueue、Dequeue、Peek</td></tr><tr><td>運作原則</td><td>後進先出（LIFO）</td><td>先進先出（FIFO）</td></tr><tr><td>插入操作</td><td><code>Push</code> - O(1)</td><td><code>Enqueue(Add)</code> - O(1)</td></tr><tr><td>刪除操作</td><td><code>Pop</code> - O(1)</td><td><code>Dequeue(Remove)</code> - O(1)</td></tr><tr><td>檢查操作</td><td><code>Peek</code> - O(1)</td><td><code>Peek</code> - O(1)</td></tr><tr><td>記憶體使用</td><td>只需要一個指針（top）</td><td>需要兩個指針（head 和 tail）</td></tr><tr><td>使用情境</td><td>函數調用、撤銷操作、括號匹配</td><td>任務排隊、資源管理、廣度優先搜尋</td></tr><tr><td>優點</td><td><em>操作簡單，速度快</em></td><td><em>高效的順序處理，方便管理流程</em></td></tr><tr><td>缺點</td><td>只能訪問和操作棧頂元素</td><td>只能訪問和操作隊首元素</td></tr><tr><td>視覺化結構</td><td>像一疊書：最後放的書最先拿</td><td>像排隊等候：最先排隊的最先服務</td></tr><tr><td>具體範例</td><td>函數調用堆疊、編輯器撤銷、算術表達式</td><td>打印隊列、CPU任務排程、網路封包處理</td></tr></tbody></table><p><strong>在添加or移除資料方面你會發現差異:</strong></p><ul><li><em>Queue遵循先進先出（FIFO）的原則。這意味著我們需要分別維護隊列的頭（head）和尾（tail）兩個指針</em>，以便能夠高效地進行入隊（enqueue）和出隊（dequeue）操作。<ul><li>Enqueue/Add:<ul><li>檢查 <code>head==null</code> 是為了處理第一次新增的情況，之後就不用了。</li><li>檢查 <code>tail!=null</code> 是為了處理第二次以後新增的情況，確保<code>old_tail.next</code>都可以指到最新的data，之後就不用了。</li><li>不管如何 <code>tail</code> 都要更新成 <code>new_tail</code>。</li></ul></li><li>Dequeue/Remove:<ul><li>在 <code>head=head.next</code>之後，發現是空的</li><li>應該要檢查 <code>head==null</code> 把 <code>tail</code> 也更新成 <code>null</code>，因為這樣才能確保 <code>head</code> 跟 <code>tail</code> 都是 <code>null</code>，代表整個 Queue 是空的。</li></ul></li></ul></li><li><em>Stack遵循後進先出（LIFO）的原則。這意味著我們只需要一個指針（<code>top</code>）來追蹤棧頂元素即可。</em><ul><li>不需要檢查<code>top</code>是否為null，因為他的重點是 <code>top</code> 會指向最新的元素 <code>data</code>，<code>top</code>是否為空根本沒人在乎，不影響插入。</li><li>不需要檢查<code>top</code>是否為null，因為他的重點是 <code>top</code> 會指向 <code>top.next</code>，儘管 <code>top</code> 是 null，不影響刪除。</li></ul></li></ul><div class="note info flat"><p>你會發現 stack 因為只要管最後的人是誰，根本不鳥前面的人，所以比較容易實現。</p></div><p><strong>Queue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// refer to the following Image</span></span><br><span class="line">    <span class="comment">// if tail is not null, then we need to add the new node to the tail.next </span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="literal">null</span>) &#123;</span><br><span class="line">        tail.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update the tail to the new node, make sure the new node is the last node</span></span><br><span class="line">    tail = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the queue is empty, then the head should be the new node</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// get the first element in the queue, which is going to be removed</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> head.data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the head to the next node, prepare to remove the original head </span></span><br><span class="line">    head = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the head is null, then the queue is empty, update the tail to null</span></span><br><span class="line">    <span class="comment">// 如果移除掉最後一個元素，那麼 head 就會是 null，所以 tail 也要是 null</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return the removed element</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Stack</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    node.next = top;</span><br><span class="line">    top = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> top.data;</span><br><span class="line">    top = top.next;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><p><strong>我認為比較需要注意的是 <code>Queue</code> 的資料結構，你需要特別注意：</strong></p><div class="note warning flat"><p><strong>在 <code>add</code> 的時候</strong></p><ol><li>在塞新資料到 tail 時，<em>為了讓 old tail 跟 data 串起來</em>，我們需要執行 <code>tail.next = data</code></li></ol><ul><li>但是<em>當 Queue 是 null 的，你會發現 <code>tail.next</code> 會噴錯，因為 tail 本身就是 null</em></li><li>因此<em>要先檢查 tail 是否為 null，如果是 null 就直接讓 <code>tail = data</code></em>。</li></ul><ol start="2"><li>tail 更新完後，只有<em>在 queue 是 null 的情況下才會去動 head</em>，否則通常就結束了不會去動到 head</li></ol><ul><li>如果塞入的 data 是 Queue 的第一筆資料，<em>我們不僅僅要更新 tail 也要更新 head</em>，將 <code>head = data</code></li><li>否則 head 都會是 null …</li></ul><p><strong>在 <code>remove</code> 的時候</strong></p><ul><li>因為遵循 FIFO 的原則，我們要去移除 head，不太會動到 tail</li><li><em>唯獨動到 tail 的時候是當我們移除 Queue 裡面的最後一個元素時</em><ul><li><em>我們要把 tail 和 head 都設為 null</em>，這樣才能確保 Queue 是空的。</li><li>因此當 <code>head = head.next</code> 後，我們要檢查 head 是否為 null，如果是 null 就要把 tail 也設為 null。</li></ul></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #128 Longest Consecutive Sequence - 刷題之旅</title>
      <link href="/posts/leetcode-128-longest-consecutive-sequence/"/>
      <url>/posts/leetcode-128-longest-consecutive-sequence/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p>給一個數組，求連續的數字最多有多少個，這邊特特書挑站是 <em>時間複雜度要求是 O(n)</em>。<br><img src="https://i.imgur.com/CvOBPVH.png" alt=""></p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>一開始想說把 nums 放進去 Set 裡面，他是會有一個順序的，但並不會從小排到大，所以後來才硬是把他排序過後再比較。<br>使用 set 的好處是可以把重複的數字過濾掉，這樣就不用擔心重複的數字會影響到我們的計算。</p><p>大概是這樣的感覺：<br><img src="https://i.imgur.com/jDGGywW.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums_sets: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>(nums)     <span class="comment"># 不重複的數字集合 當作字典查找</span></span><br><span class="line">        sorted_nums = <span class="built_in">sorted</span>(nums_sets)     <span class="comment"># 排序後並filter掉重複的 按照順序 pop</span></span><br><span class="line">        max_len = <span class="number">0</span>     <span class="comment"># 最大len</span></span><br><span class="line">        cur_len = <span class="number">1</span>     <span class="comment"># 目前len</span></span><br><span class="line">        <span class="keyword">while</span> nums_sets:     <span class="comment"># 只要 sorted_num 還有值就繼續比較</span></span><br><span class="line">            tar = sorted_nums.pop() + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> &#123;tar&#125;.issubset(nums_sets):   <span class="comment"># 是否存在 pop() + 1 的值在字典</span></span><br><span class="line">                cur_len += <span class="number">1</span>                <span class="comment"># 若是存在，長度 + 1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_len = <span class="number">1</span> <span class="comment"># 沒有 並且 已經斷掉 就換下一個重新開始</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(nlogn)</strong></p><ul><li>建立 nums_sets 集合的時間複雜度是 O(n)。</li><li>排序 nums_sets 集合的時間複雜度是 O(nlogn)。</li><li>進行 while 循環的時間複雜度是 O(n)。</li><li>因此 總的時間複雜度是 O(nlogn)。</li></ul><p><strong>空間複雜度O(n)</strong></p><ul><li>建立 nums_sets 集合的空間複雜度是 O(n)。</li><li>排序 nums_sets 集合的空間複雜度是 O(n)。</li><li>因此 總的時間複雜度是 O(n)。</li></ul></div><div class="note danger flat"><p><strong>但是這個做法最大的問題是 <code>sorted</code> 的時間複雜度是 O(nlogn)，所以這個解法是不合格的。</strong></p></div><h2 id="2-2-改良">2.2 改良</h2><p>上面的做法最大的問題是，需要排序，為什麼要排序的原因是，這樣就可以專心地往一個方向找，但是這樣的時間複雜度是 O(nlogn) 是不符合題目要求的。<br>如果我們不排序，那就變成左右兩個方向都要同時找，慢慢擴大範圍，我們不確定抓的第一個數字是否在 nums 中為最小，假設他是中間的數值好了，我們就要往左右兩邊找，看看可以找到多少連續的數字。在找的時候，我們可以把找過的數字從 nums_sets 中刪除，這樣當發生斷掉的狀況時，可以從剩下的 nums_sets 隨便挑一個，繼續開始往左右兩邊找。</p><p><img src="https://i.imgur.com/CM8BFXq.png" alt=""></p><p>實際帶入數字大概是這樣的感覺：<br><img src="https://i.imgur.com/3UE25QV.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive2</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        nums_set: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>(nums)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> nums_set:</span><br><span class="line">            cur = nums_set.pop() <span class="comment"># 如果左邊跟右邊都無法擴展時，就該重新開始 pop() 出來的數值一定沒當過 target </span></span><br><span class="line">            left = cur - <span class="number">1</span></span><br><span class="line">            right = cur + <span class="number">1</span></span><br><span class="line">            cur_len = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一直往左邊找直到找不到</span></span><br><span class="line">            <span class="keyword">while</span> left <span class="keyword">in</span> nums_set:</span><br><span class="line">                nums_set.remove(left)</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                cur_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 一直往右邊找直到找不到</span></span><br><span class="line">            <span class="keyword">while</span> right <span class="keyword">in</span> nums_set:</span><br><span class="line">                nums_set.remove(right)</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                cur_len += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(n)</strong></p><ul><li>建立 nums_sets 集合的時間複雜度是 O(n)。</li><li>儘管 while 裡面有 while ，但是因為每次都會把找過的數字從 nums_sets 中刪除，所以最每個數值只會被 遍歷一次，因此時間複雜度為 O(n)。</li><li>因此 總的時間複雜度是 O(n)。</li></ul><p><strong>空間複雜度O(n)</strong></p><ul><li>建立 nums_sets 集合的空間複雜度是 O(n)。</li></ul></div><h1 id="3-結論">3. 結論</h1><p>其實這種找連續的數字，核心關鍵就是指標的移動，如果想要確保時間複雜度為O(n)表示每個數字只會被遍歷一次，肯定要使用 Hash 的方式來找。<br>我發現這題本來在幾年前是Hard現在變成Medium了，可是我很開心我竟然靠自己想到這種方法。這樣的感覺真的很棒，希望以後能夠更多的靠自己的力量解題。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0/"/>
      <url>/posts/0/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><p><a href="https://medium.com/@phoebehuang.pcs04g/%E8%B6%85%E7%B4%9A%E7%B0%A1%E5%96%AE-%E4%BD%BF%E7%94%A8bert%E4%BE%86%E5%BB%BA%E4%B8%80%E5%80%8B%E6%96%87%E6%9C%AC%E5%88%86%E9%A1%9E%E5%99%A8-697e301818b5">https://medium.com/@phoebehuang.pcs04g/超級簡單-使用bert來建一個文本分類器-697e301818b5</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #49 Group Anagrams - 刷題之旅</title>
      <link href="/posts/leetcode-49-group-anagrams/"/>
      <url>/posts/leetcode-49-group-anagrams/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p><img src="https://i.imgur.com/jB7XDnq.png" alt=""><br>給定多個字串，然後把它們分類。只要字串所包含的字元完全一樣就算一類，不考慮順序。</p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的解法">2.1 我的解法</h2><p>因為不考慮順序，<em>只要字串的字元完全一樣就算一類，這讓我最先想到 Set 這個資料結構</em>。我們可以把字串轉成 Set ，<em>想辦法讓 Set 變成 dict 的 key</em> ，然後把相同 key 的字串放在一起。最後再把這些字串放在一個 List 中，這樣就可以得到答案了。<em>但是 Set 是不可 hash 的，所以我們可以先把 Set 裡面的每個元素進行 hash 並相加</em>，這也可以成功的讓。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans_dic = &#123;&#125;</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">str</span> <span class="keyword">in</span> strs:</span><br><span class="line">            str_hash = <span class="built_in">sum</span>([<span class="built_in">hash</span>(char) <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">str</span>]) <span class="comment"># 把每個字元 hash 並相加 順序就不影響了</span></span><br><span class="line">            <span class="keyword">if</span> ans_dic.get(str_hash):</span><br><span class="line">                ans_dic[str_hash].append(<span class="built_in">str</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans_dic[str_hash] = [<span class="built_in">str</span>]</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> ans_dic.values():</span><br><span class="line">            ans.append(v)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度 O(nL)</strong></p><ul><li>計算哈希值：對於每個字符串，計算哈希值的時間複雜度是 O(L)，其中 L 是字符串的平均長度。</li><li>且列表的長度為 n，那麼這一步的總時間複雜度是 O(n) * O(L) = O(nL)</li></ul><p><strong>空間複雜度 O(nL)</strong></p><ul><li>字典 ans_dic：這個字典最多會存儲 n 個鍵值對，每個鍵是哈希值（整數），每個值是字符串列表。我們會需要一個空間L把每個經過hash的字母相加，空間複雜度是 O(nL)。</li><li>結果列表 ans：會包含所有的字串，空間複雜度是 O(n)。</li></ul></div><h2 id="2-2-解法2">2.2 解法2</h2><p>但是還有一種可能是 hash 加總後發生碰撞，儘管他們字串不同，但仍有機率會被歸類在同一類。這時候我們可以使用一個更好的方法，就是把字串排序後再 hash ，這樣就可以保證不會發生碰撞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams2</span>(<span class="params">self, strs</span>):</span><br><span class="line">        anagram_map = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            sorted_word = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(word))</span><br><span class="line">            anagram_map[sorted_word].append(word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(anagram_map.values())</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度 O(n⋅LlogL)</strong></p><ul><li>排序字符串：對於每個字符串，將其排序的時間複雜度是 O(LlogL)，其中 L 是字符串的平均長度。假設輸入列表中有 n 個字符串，這一步的總時間複雜度是 O(n⋅LlogL)。</li></ul><p><strong>空間複雜度 O(nL)</strong></p><ul><li>字典 anagram_map：這個字典最多會存儲 n 個鍵值對，每個鍵是排序後的字符串（長度為 L），每個值是包含原始字符串的列表。在最壞情況下，所有字符串都是不同的異位詞組，則字典中會有 n 個鍵，每個鍵對應一個包含一個字符串的列表。因此，字典的空間複雜度是 O(n⋅L)。</li></ul></div><h1 id="3-總結">3 總結</h1><p>這題其實很簡單，大概5分鐘不到就可以想到方法解出來了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NBME - 使用 DeBERTa 模型分析病人病例</title>
      <link href="/posts/bert-nbme-score-clinical-patient-notes/"/>
      <url>/posts/bert-nbme-score-clinical-patient-notes/</url>
      
        <content type="html"><![CDATA[<div class="note warning flat"><p><strong>這篇文章不會談論怎麼寫程式，而是著重在說明如何為 DeBERTa 模型設計 Input 和 Ouput 以及如何評估模型的表現。</strong></p></div><h1 id="說明">說明</h1><ul><li>題目來源：<a href="https://www.kaggle.com/c/nbme-score-clinical-patient-notes">https://www.kaggle.com/c/nbme-score-clinical-patient-notes</a></li></ul><p>當你去看醫生時，醫生如何解讀你的症狀會決定診斷的準確性。醫生在獲得執照之前，已經有很多撰寫病人記錄的實踐經驗，這些記錄文檔包含病人的病史、體檢結果、可能的診斷和後續護理。學習和評估撰寫病人記錄的技能需要其他醫生的反饋，這是一個耗時的過程，可以通過機器學習來改進。</p><p>直到最近，Step 2 Clinical Skills（臨床技能）考試是美國醫學執照考試（USMLE）的一個組成部分。考試要求考生與標準化病人（被訓練來扮演特定臨床病例的人）互動，並撰寫病人記錄。訓練有素的醫師評分員會根據每個病例的重要概念（稱為特徵）用量表來評分病人記錄。病人記錄中包含的這些特徵越多，得分就越高（除了其他影響考試最終得分的因素）。簡單來說，就是<em>考生要從病例中找出可能可以作為生病的特徵</em>。</p><p>然而，讓醫生評分病人記錄考試需要大量時間和人力、財力資源。針對這個問題，自然語言處理技術被開發出來，但病人記錄的計算評分仍然充滿挑戰，因為特徵可以用很多不同的方式表達。例如…</p><ul><li>特徵“對活動失去興趣”可以表達為“不再打網球”</li><li>特徵“沒有寒冷不耐受、脫髮、心悸或顫抖”，這對應於關鍵的“缺乏其他甲狀腺症狀”。</li></ul><p>在這次競賽中，你需要識別病人記錄中的具體臨床概念。具體來說，你將開發一種自動方法，將考試量表中的臨床概念（例如“食欲減退”）映射到醫學生撰寫的病人記錄中表達這些概念的各種方式（例如“吃得更少”，“衣服變得更寬鬆”）。出色的解決方案將既準確又可靠。</p><p>如果成功，你將幫助解決病人記錄評分中的最大實際障礙，使這種方法更加透明、可解釋，並減輕這類評估的開發和管理難度。結果，醫療從業者將能夠充分發掘病人記錄在臨床技能評估中揭示相關信息的潛力。</p><h1 id="資料集">資料集</h1><p><img src="https://i.imgur.com/WVmaoEz.png" alt=""></p><ul><li><code>train.csv</code> - 用於訓練模型的訓練數據集</li><li><code>test.csv</code> - 用於測試模型的測試數據集（只有五筆）</li><li><code>patient_notes.csv</code> - 病人記錄的文本數據集</li><li><code>features.csv</code> - 用於訓練和測試的特徵數據集</li></ul><p><img src="https://i.imgur.com/I0T8ufJ.png" alt=""><br>從上圖可以看到，我們透過將 <code>train.csv</code> 和 <code>features.csv</code> 進行合併，得到了一個新的數據集如上圖所示。有幾點需要注意的：</p><ul><li>合併過後可能會同一個病人會有多個病例(<code>features_text</code>)</li><li>每個病例，可能會有多個<code>annotation</code>(也就是特徵)</li><li><code>location</code> 是 <code>annotation</code> 在 <code>pn_history</code> (病史)中的位置</li><li>綠色是用來給模型的輸入，黃色是我們想要預測的結果</li></ul><h1 id="衡量">衡量</h1><p><img src="https://i.imgur.com/A9Ja1YZ.png" alt=""><br>如上圖所示，對於每個實例，我們預測一組字元跨度。一個字元跨度是一對索引(114 129)表示為該內容的特徵，代表文字中的一個字元範圍。一個跨度i j代表索引為i到j的字符，左閉右開，在Python的符號中，一個跨度i j相當於一個切片 i:j 對於每個實例，都有一個基礎真實跨度的集合和一個預測跨度的集合。我們用分號來分割跨度。</p><h1 id="方法">方法</h1><p><img src="https://i.imgur.com/pIQmjZb.png" alt=""><br><em>首先我們知道提供給模型的有以下：</em></p><ol><li><code>pn_history</code> 病人的病史</li><li><code>feature_text</code> 得什麼病</li></ol><p><em>我們要預測的是：</em></p><ol><li><code>pn_history</code> 中哪個特徵對應到 <code>feature_text</code> 病例的索引</li></ol><hr><p>因此可以知道的事，我們的 input 必須是 <code>pn_history</code> 和 <code>feature_text</code> 的結合，把他們關聯起來，然後預測 <code>pn_history</code> 中的特徵對應到 <code>feature_text</code> 的索引。步驟可以如下：</p><ol><li><code>pn_history</code> 和 <code>feature_text</code> 的結合</li><li>把 step 1 整合的結果經過 Embedding 送入 DeBERTa 模型</li><li>output 的結果必須是 <code>pn_history</code> 經過 embedding 後，把解答的部分寫成1，不是解答的部分預測為0，其他padding為-1。</li></ol><h2 id="準備-input-與-label">準備 input 與 label</h2><p><strong>Input</strong></p><ol><li>先找到 <code>max_len</code> 的 input size：從這麼多的pn_history中找最大的長度當作 input 的 <code>max_len</code></li><li>把 <code>pn_history</code> + <code>feature_text</code> 轉換成 Token</li></ol><p><strong>Label</strong><br>目標：把 <code>pn_history</code> 轉換成 <code>&#123;-1, 0, 1&#125;</code> 的 Label，-1 代表 padding，0 代表不是解答，1 代表是解答</p><ol><li>先準備一個 <code>max_len</code> 的 array list with 0。</li><li>把 special token 像是 <code>[CLS]</code>, <code>[SEP]</code> 或 <code>[PAD]</code> 設定為 -1</li><li>找到 tokons 中包含 annotation 的部分，把這部分的 label 設定為 1</li><li>最終得到的結果可能會是：<code>[-1, 0, 0, 1, 1, 0, 0]</code></li></ol><h3 id="Input-準備">Input 準備</h3><p>接下來你可能會好奇怎麼找到 <code>max_len</code> 可以參考下圖：<br><img src="https://i.imgur.com/WyjV1XN.png" alt=""></p><ol><li>開始遞迴每個 <code>pn_history</code></li><li>把 <code>pn_history</code> 和 <code>feature_text</code> 結合轉換成 Token</li><li>計算這個 token 的長度，並存長度到一個 arr 裡面</li><li>最後這個arr會集結所有資料的長度，找到最大的長度就是 <code>max_len</code></li></ol><p>準備Input 會如下圖所示(發現會把annotation整合進去pn_history)<br><img src="https://i.imgur.com/tY7ahRM.png" alt=""></p><h3 id="Label-準備">Label 準備</h3><p>準備Label 會如下圖所示(只需要pn_history即可)<br><img src="https://i.imgur.com/nbmIxQJ.png" alt=""></p><ol><li><p>我們會先創造出一個由 max_len 長度的 array。<br><img src="https://i.imgur.com/dGnKEbg.png" alt=""></p></li><li><p>把 special token 像是 <code>[CLS]</code>, <code>[SEP]</code> 或 <code>[PAD]</code> 設定為 -1<br><img src="https://i.imgur.com/pLRtpfG.png" alt=""></p></li><li><p>接下來就是把 annotation 的部分設定為 1<br><img src="https://i.imgur.com/kYKaq2m.png" alt=""></p></li></ol><h2 id="訓練">訓練</h2><p>模型參數設定如下：<br><img src="https://i.imgur.com/63ODxTm.png" alt=""></p><p>到時候的輸出每個 token 位置都是一組機率，我們可以設定閥值為 0.5，如果機率大於 0.5 就是 1，否則就是 0。<br><img src="https://i.imgur.com/wXWTlyD.png" alt=""></p><h2 id="衡量-2">衡量</h2><p><img src="https://i.imgur.com/piIbFNP.png" alt=""><br>如果解答是 <code>0 3; 3 5</code> 而我預測出 <code>2 5; 7 9; 2 3</code> 那麼我們可以計算出以下的結果：<br>0 1 2 3 是解答 我預測出 2 3 4 5</p><ul><li>TP: 2, 3</li><li>FP: 4, 5</li><li>FN: 0</li></ul><p>這樣我們就可以計算 F1 score = 2 * TP / (2 * TP + FP + FN)</p><h1 id="參考資料">參考資料</h1><ul><li><a href="https://blog.csdn.net/Raki_J/article/details/123447643">Raki的NLP竞赛topline解读：NBME - Score Clinical Patient Notes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #169 Majority Element - 刷題之旅</title>
      <link href="/posts/leetcode-169-majority-element/"/>
      <url>/posts/leetcode-169-majority-element/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p>給一個數組，存在一個數字超過半數，找出這個數。<br><em>這題有個特殊要求，就是要線性的時間複雜度，空間複雜度是O(1)</em>。<br>因此難度會在空間複雜度如何滿足1的情況下，找出最佳解法。<br><img src="https://i.imgur.com/ClNPzGj.png" alt=""></p><h1 id="2-解法">2 解法</h1><h2 id="2-2-我的解法">2.2 我的解法</h2><p>一開始我沒看到有空間複雜度的限制，所以就很直接的使用了HashTable，把每個數字出現的次數記錄下來，最後找出最大的那個。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_dic = &#123;&#125;</span><br><span class="line">        threshold = <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">        <span class="comment"># 計算每個數字出現的次數</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> num_dic.get(nums[i]):</span><br><span class="line">                num_dic[nums[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num_dic[nums[i]] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 一但發現有超過半數的數字，就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> num_dic[nums[i]] &gt; threshold:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(n)</strong></p><ul><li>計算每個數字出現的次數，部分通過一次 for 循環遍歷整個 nums 列表，時間複雜度為 O(n)。</li></ul><p><strong>空間複雜度O(n)</strong></p><ul><li>空間複雜度由字典 num_dic 最壞的狀況下需要存儲 n 個不同的數字，因此空間複雜度為 O(n)。</li><li>和 固定空間變量 threshold、i、k 和 v 使用固定的額外空間</li><li>因此 總的空間複雜度是 O(n)。</li></ul></div><p>可惜沒滿足題目要求的空間複雜度，所以這個解法是不合格的。</p><h2 id="2-2-摩爾投票法">2.2 摩爾投票法</h2><p>這是1980 由 Boyer 和 Moore 兩人所提出的算法：英文是 Boyer-Moore Majority Vote Algorithm。這個函數實現了 Boyer-Moore 多數投票算法，這是一種在線性時間和常數空間內找到多數元素的方法。</p><p>他的思想很簡單，假設存在一個數字超過半數，而每個數字代表一個生物組群好了。(e.g. 1 = 恐龍, 2 = 獅子, 3 = 老虎, …) 現在有一組串列，<code>[1, 1, 2, 3, 1]</code> 透過指標的方式，循序比較，遇到自己人就+1，遇到其他物種就開打，因為戰鬥力一樣所以雙方人馬都一起滅絕，經過物競天擇後，數量仍然 &gt; 1的就是倖存者也就是數量最多的族群。</p><p>大概是這種感覺：<br><img src="https://i.imgur.com/Pu9eaT6.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement3</span>(<span class="params">self, nums</span>):</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        boss = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">next</span> = nums[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                boss = <span class="built_in">next</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> boss == <span class="built_in">next</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> boss</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度O(n)</strong></p><ul><li>循環次數：函數通過一次 for 循環遍歷 nums 列表中的所有元素。對於長度為 n 的列表，循環將執行 n-1 次。</li><li>總的時間複雜度為 O(n)，其中 n 是輸入列表的長度。</li></ul><p><strong>空間複雜度O(1)</strong></p><ul><li>變量：變量 count、boss 和 next 使用固定的額外空間，與輸入列表的長度無關。</li><li>因此 空間複雜度是 O(1)。</li></ul></div><h1 id="3-總結">3 總結</h1><p>完全沒想到這個摩爾投票法的解法，這個解法真的很巧妙，而且空間複雜度是O(1)，這個解法是最佳解法。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Easy </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #12 Integer to Roman - 刷題之旅</title>
      <link href="/posts/leetcode-12-integer-to-roman/"/>
      <url>/posts/leetcode-12-integer-to-roman/</url>
      
        <content type="html"><![CDATA[<ul><li>題目來源：<a href="https://leetcode.com/problems/roman-to-integer/description/">https://leetcode.com/problems/roman-to-integer/description/</a></li></ul><h1 id="1-題目描述">1 題目描述</h1><p>把數字轉換成羅馬數字，正常情況就是把每個字母相加，並且大字母在前，小字母在後，上邊也介紹了像 4 和 9 那些特殊情況。<br><img src="https://i.imgur.com/OUE0FWT.png" alt=""><br><img src="https://i.imgur.com/15hfun9.png" alt=""></p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的作法-無HashTable">2.1 我的作法(無HashTable)</h2><p>簡單粗暴些，把所有可能都列舉出來，包含1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1，然後一個一個去減，直到 num 為 0 為止。</p><p>大概是這種感覺：<br><img src="https://i.imgur.com/VkYdXPa.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intToRoman</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        arr = [(<span class="number">1000</span>, <span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">               (<span class="number">900</span>, <span class="string">&#x27;CM&#x27;</span>),</span><br><span class="line">               (<span class="number">500</span>, <span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">               (<span class="number">400</span>, <span class="string">&#x27;CD&#x27;</span>),</span><br><span class="line">               (<span class="number">100</span>, <span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">               (<span class="number">90</span>, <span class="string">&#x27;XC&#x27;</span>),</span><br><span class="line">               (<span class="number">50</span>, <span class="string">&#x27;L&#x27;</span>),</span><br><span class="line">               (<span class="number">40</span>, <span class="string">&#x27;XL&#x27;</span>),</span><br><span class="line">               (<span class="number">10</span>, <span class="string">&#x27;X&#x27;</span>),</span><br><span class="line">               (<span class="number">9</span>, <span class="string">&#x27;IX&#x27;</span>),</span><br><span class="line">               (<span class="number">5</span>, <span class="string">&#x27;V&#x27;</span>),</span><br><span class="line">               (<span class="number">4</span>, <span class="string">&#x27;IV&#x27;</span>),</span><br><span class="line">               (<span class="number">1</span>, <span class="string">&#x27;I&#x27;</span>)]</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> key, val <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;num=<span class="subst">&#123;key&#125;</span>, val=<span class="subst">&#123;val&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> num &gt;= key:</span><br><span class="line">                count = <span class="built_in">int</span>(num / key)</span><br><span class="line">                mud = num % key</span><br><span class="line">                ans += count * val</span><br><span class="line">                num = mud</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;count=<span class="subst">&#123;count&#125;</span>, mud=<span class="subst">&#123;mud&#125;</span>, ans=<span class="subst">&#123;ans&#125;</span>, num=<span class="subst">&#123;num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度：O(1)</strong></p><ul><li>循環次數：函數中有一個 for 循環，遍歷 arr 列表中的所有元素。arr 列表的長度是常數（13），所以這個循環的次數是固定的，為 13。<br><strong>空間複雜度：O(1)</strong></li><li>固定空間：儲存 arr 列表，這是固定的大小，包含 13 個元素。</li></ul></div><h1 id="3-結論">3 結論</h1><p>這題感覺難度應該是 easy ，沒有那麼難，就是理清楚題意，然後就可以往出列舉就行了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #13 Roman to Integer - 刷題之旅</title>
      <link href="/posts/leetcode-13-roman-to-integer/"/>
      <url>/posts/leetcode-13-roman-to-integer/</url>
      
        <content type="html"><![CDATA[<ul><li>題目來源：<a href="https://leetcode.com/problems/roman-to-integer/description/">https://leetcode.com/problems/roman-to-integer/description/</a></li></ul><h1 id="1-題目描述">1 題目描述</h1><p>和<a href="/posts/leetcode-12-integer-to-roman">上一題</a>相反，將羅馬數字轉換成阿拉伯數字。<br><img src="https://i.imgur.com/6Dty492.png" alt=""><br><img src="https://i.imgur.com/UZQAQb9.png" alt=""></p><h1 id="2-解法">2 解法</h1><h2 id="2-1-我的作法">2.1 我的作法</h2><p>我一開始想的比較複雜，是想要使用while迴圈，從第一個字串與第二個字串開始比較，一般來說羅馬字是由大排到小，因此一但發現“前面” &lt; &quot;後面“ （由小到大），前面要當減數，否則就是加法。</p><p>大概是這種感覺：<br><img src="https://i.imgur.com/YgsucYk.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num_dic = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = left + <span class="number">1</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果只有一個字元，直接加上</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">sum</span> += num_dic[s[left]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                left_val = num_dic[s[left]]</span><br><span class="line">                right_val = num_dic[s[right]]</span><br><span class="line">                <span class="comment"># 一但發現 left &lt; right，就是減法</span></span><br><span class="line">                <span class="keyword">if</span> left_val &lt; right_val:</span><br><span class="line">                    <span class="built_in">sum</span> += left_val * (-<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 否則加法</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">sum</span> += left_val</span><br><span class="line"></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right = left + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果 right 已經到底了，那麼就加上最後一個</span></span><br><span class="line">                <span class="keyword">if</span> right == <span class="built_in">len</span>(s):</span><br><span class="line">                    <span class="built_in">sum</span> += right_val</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;final=<span class="subst">&#123;<span class="built_in">sum</span>&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p><strong>時間複雜度：O(n)</strong></p><ul><li>n 是輸入字浮串的長度，這個解法只需要一次迭代。</li></ul><p><strong>空間複雜度：O(1)</strong></p><ul><li>固定空間：儲存字典 num_dic，這是固定的大小，包含 7 個元素。</li><li>變量：變量 left、right 和 sum 使用固定的額外空間。</li><li>函數沒有使用額外的空間來儲存與輸入大小相關的數據結構，因此空間複雜度為 O(1)</li></ul></div><h2 id="2-2-更簡潔">2.2 更簡潔</h2><p>但是有更簡潔的寫法，概念一樣，但是不用while迴圈，直接用for迴圈就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">romanToInt</span>(<span class="params">self, s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_dic = &#123;<span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 關鍵是如果 i 已經到底的前一個，那麼就不用比較了，直接加上</span></span><br><span class="line">        <span class="comment"># -1 是為了讓 i+1 不會超過範圍</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> num_dic[s[i]] &lt; num_dic[s[i+<span class="number">1</span>]]:</span><br><span class="line">            <span class="built_in">sum</span> += num_dic[s[i]] * (-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">sum</span> += num_dic[s[i]]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><h1 id="3-結論">3 結論</h1><p>這題感覺難度也不會很難，是可以自己想出來的。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #3 Longest Substring Without Repeating Characters - 刷題之旅</title>
      <link href="/posts/leetcode-3-longest-substring-without-repeating-characters/"/>
      <url>/posts/leetcode-3-longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<ul><li>題目來源：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">https://leetcode.com/problems/longest-substring-without-repeating-characters/description/</a></li></ul><h1 id="1-題目描述">1 題目描述</h1><p>這道題目要求我們在給定的字符串 s 中找到不含重複字符的最長子字符串的長度。<br><img src="https://i.imgur.com/D2ymXmy.png" alt=""></p><h1 id="2-解法">2 解法</h1><h2 id="2-1-暴力解">2.1 暴力解</h2><p>簡單粗暴些，找一個最長子字串，那麼我們用兩個迴圈窮舉所有子串，然後再用一個函數判斷該子字串中有沒有重複的字元。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isUnique</span>(<span class="params">s: <span class="built_in">str</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;end 不包含&quot;&quot;&quot;</span></span><br><span class="line">    substring = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">        <span class="keyword">if</span> substring.get(s[i]):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            substring[s[i]] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        max_left = <span class="number">0</span></span><br><span class="line">        max_right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> isUnique(s, left, right) <span class="keyword">and</span> ans &lt; (right-left):</span><br><span class="line">                    ans = right - left</span><br><span class="line">                    max_left = left</span><br><span class="line">                    max_right = right</span><br><span class="line">        <span class="keyword">return</span> ans, s[max_left:max_right]</span><br></pre></td></tr></table></figure><p><code>isUnique</code></p><ul><li>時間複雜度：O(m) 其中 m 是被<em>檢查子字符串的長度</em>，這是因為 isUnique 函數在檢查從 start 到 end 的每個字符是否唯一。</li><li>空間複雜度：O(m)，其中 m 是被檢查子字符串的長度。這是因為函數使用了一個字典 substring 來存儲子字符串中的字符。</li></ul><p><code>lengthOfLongestSubstring</code> 方法</p><ul><li><p>時間複雜度：O(n^3)，其中 n 是字符串 s 的長度。</p><ul><li>外層的 for 循環有 n 次迭代。</li><li>內層的 for 循環有 n 次迭代。</li><li>每次調用 isUnique 函數，其時間複雜度為 O(m)，m 最長可能為 n。</li><li>所以總的<em>時間複雜度為 O(n) * O(n) * O(n) = O(n^3)</em>。</li></ul></li><li><p>空間複雜度：O(min(m,n))。m 這是由於在調用 <code>isUnique</code> 函數時使用的字典 substring 所需的空間， n 是字符集的大小。</p></li></ul><h2 id="2-2-滑動窗口">2.2 滑動窗口</h2><p>我們可以透過 sliding window 檢查子字串是否有重複的字元</p><ul><li>如果有，我們就將左指針向右移動一格，直到子字串中沒有重複的字元為止。</li><li>如果沒有，左指針不動，右指針向右移動一格。</li></ul><p>如下所示：</p><ul><li>檢查的時候主要移動 right: <em>如果沒有重複的字元，就將 right 指針向右移動</em>，並且將對應的字元存儲到 substring 中。<ul><li>‘abc’ -&gt; ‘abcd’ -&gt; ‘abcda’ (發現重複的字元)</li></ul></li><li>一但<em>發現重複的字元，就將 left 指針向右移動，直到子字串(hashTable)中沒有重複的字元為止</em>。<ul><li>‘abcda’ -&gt; ‘bcda’(left向右+1，'a’不見了)</li></ul></li><li>重複上述步驟，直到 right 指針遍歷完整個字符串。<br><img src="https://i.imgur.com/WUomAHH.png" alt=""></li></ul><div class="note warning flat"><p>但是需要注意的是，如果 left 指針向右移動，我們需要將 substring 中的對應字元刪除。</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring2</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        substring = &#123;&#125;</span><br><span class="line">        ans, left, right = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        max_left, max_right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; n <span class="keyword">and</span> right &lt; n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> substring.get(s[right]):</span><br><span class="line">                substring[s[right]] = right <span class="comment"># 存儲字元和對應的索引</span></span><br><span class="line">                right = right + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> ans &lt; right-left:</span><br><span class="line">                    ans = right-left</span><br><span class="line">                    max_left = left</span><br><span class="line">                    max_right = right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                substring.__delitem__(s[left]) <span class="comment"># 刪除重複的字元</span></span><br><span class="line">                left = left + <span class="number">1</span> <span class="comment"># 左指針向右移動</span></span><br><span class="line">        <span class="keyword">return</span> ans, s[max_left:max_right] <span class="comment">#(4, &#x27;abcd&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>時間複雜度：O(2n) = O(n)</strong><br>在這段代碼中，最外層的 while 迴圈會迭代 right 指針從 0 到 n，並且每當遇到重複字符時，left 指針也會向右移動。因此，無論哪種情況，每個字符最多只會被處理兩次（一次由 right，一次由 left），因此總的時間複雜度為 O(2n)，基本上就是 O(n)。</p><ul><li>right 指針在整個字符串上移動，每次移動都進行一次查找和插入操作，這些操作的時間複雜度是常數時間 O(1)。</li><li>當遇到重複字符時，left 指針移動並刪除字典中的對應項目，這也是常數時間 O(1)。</li></ul><p><strong>空間複雜度 O(min(m,n))</strong></p><ul><li>和上面類似，需要一個Hash保存子串，所以是O(min(m,n))，m 是字符集的大小。n 是字符串 s 的長度。</li></ul><h2 id="2-3-改良滑動窗口">2.3 改良滑動窗口</h2><p>繼續優化，我們看上邊的演算法的一種情況。當 right 往前 +1 一格時，此時 left 向前移到 b ,此時子字串中仍然含有 c，<em>還得繼續移動</em>，所以這裡其實可以優化。<em>我們可以一步到位，直接移動到子字串 c 的位置的下一位！</em></p><p><img src="https://i.imgur.com/UOaAHzf.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring3</span>(<span class="params">self, s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    maxLength, max_left, max_right = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    charMap = &#123;&#125;</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 如果是全新的單字，並且 right 沒有超過 left</span></span><br><span class="line">        <span class="keyword">if</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> charMap <span class="keyword">or</span> charMap[s[right]] &lt; left:</span><br><span class="line">            <span class="comment"># 把新的字元加入 charMap value 是 index</span></span><br><span class="line">            charMap[s[right]] = right</span><br><span class="line">            <span class="comment"># 檢查新字元的加入是否有超過目前的最長子字串</span></span><br><span class="line">            <span class="keyword">if</span> maxLength &lt; right - left + <span class="number">1</span>:</span><br><span class="line">                maxLength = right - left + <span class="number">1</span></span><br><span class="line">                max_left = left</span><br><span class="line">                max_right = right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 關鍵在這裡，直接移動到子字串 c 的位置的下一位</span></span><br><span class="line">            left = charMap[s[right]] + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 並且更新 charMap 的 index 位置</span></span><br><span class="line">            charMap[s[right]] = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLength, s[max_left:max_right]</span><br></pre></td></tr></table></figure><h1 id="3-總結">3 總結</h1><p>這個題目的重點在於：</p><ul><li>hash table 主要是用來存儲子字串中的字元，並且可以<em>快速查找是否有重複的字元</em>。<ul><li>使時間與空間複雜度都是 O(m)，m 表示欲檢查的子字串長度。</li></ul></li><li>sliding window 負責處理連續子字串的問題，並且可以<em>快速移動左右指針</em>。<ul><li>sliding window 的右向檢查方式，使得每個字元最多只會被處理兩次，因此時間複雜度是 O(2n) 也就是 O(n)。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Medium </tag>
            
            <tag> Review-Needed </tag>
            
            <tag> Hash </tag>
            
            <tag> Sliding-Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode #1 Two Sum - 刷題之旅</title>
      <link href="/posts/leetcode-1-two-sum/"/>
      <url>/posts/leetcode-1-two-sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-題目描述">1 題目描述</h1><p>這是一道經典的 Two Sum 問題，要求從一個整數數組 nums 中找出兩個數字，使它們的和等於給定的目標值 target，並返回這兩個數字的索引。每個輸入保證有且只有一個解，且同一元素不能被重複使用。答案的返回順序可以是任意的。<br><img src="https://i.imgur.com/E2q2lpO.png" alt=""></p><h1 id="2-解法">2 解法</h1><h2 id="2-1-暴力解">2.1 暴力解</h2><p>簡單粗暴些，兩重循環，遍歷所有情況看相加是否等於目標和，如果符合直接輸出。</p><div class="note info flat"><p>時間複雜度：O(n²)<br>空間複雜度：O(1)</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">int</span> []ans=new <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=(i+<span class="number">1</span>);j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                ans[<span class="number">0</span>]=i;</span><br><span class="line">                ans[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-我的想法">2.2 我的想法</h2><p><strong>手動建立HashTable</strong><br>因為Two Sum的核心在於使用Hash，因此這邊我使用Hash Table來解這題。關於Hash Table的詳解可以參考<a href="https://shannonhung.github.io/posts/lecture-leetcode-hash-table/">這篇文章</a>。使用Hash Table 的核心概念是，如果今天你要找 <code>complementary = target - v</code> 的值，你可以先把所有的值放進 Hash Table，把要找的值當作 key，該值在nums中的index當作HashTable中的value，然後直接在 HashTable(key) 就可以直接回傳對應的 index。<em>這樣的時間複雜度只有 O(1)</em>。</p><div class="note info flat"><p>時間複雜度：O(n)<br>空間複雜度：O(n)</p></div><p><img src="https://i.imgur.com/cgTLVcO.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashTable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_list</span>):</span><br><span class="line">        self.<span class="built_in">len</span> = <span class="built_in">len</span>(num_list) * <span class="number">2</span></span><br><span class="line">        self.buckets = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line">        self.init_buckets(num_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_buckets</span>(<span class="params">self, num_list</span>):</span><br><span class="line">        <span class="keyword">if</span> num_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(num_list):</span><br><span class="line">            self.__setitem__(i, v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, value</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(value))</span><br><span class="line">        index = hash_value % self.<span class="built_in">len</span></span><br><span class="line">        <span class="keyword">while</span> self.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.buckets[index][<span class="number">1</span>] == value:</span><br><span class="line">                <span class="keyword">return</span> self.buckets[index][<span class="number">0</span>]</span><br><span class="line">            index = (index + <span class="number">1</span>) % self.<span class="built_in">len</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(value))</span><br><span class="line">        index = hash_value % self.<span class="built_in">len</span></span><br><span class="line">        <span class="keyword">while</span> self.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            index = (index + <span class="number">1</span>) % self.<span class="built_in">len</span></span><br><span class="line">        self.buckets[index] = (key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hash_list = MyHashTable(nums)</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            find = target - v</span><br><span class="line">            tar_index = hash_list.__getitem__(find)</span><br><span class="line">            <span class="keyword">if</span> tar_index != i: <span class="comment"># 確保不是相同的index否則會同一個值拿兩次 [3, 3] 找 ６ 回傳 [0,0]</span></span><br><span class="line">                <span class="keyword">if</span> tar_index <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> [i, tar_index]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><ul><li><code>MyHashTable.__init__</code> 和 <code>MyHashTable.init_buckets</code> 的時間複雜度都是 O(n)。</li><li><code>MyHashTable.__getitem__</code> 和 <code>MyHashTable.__setitem__</code> 的平均時間複雜度是 O(1)，最壞情況下是 O(n)。</li><li><code>Solution.twoSum</code> 的時間複雜度是 <code>O(n)</code></li></ul><p>因此，整個程式的時間複雜度是 <code>O(n)</code> 滿足題目要求，不使用 O(n²) 的暴力解法。</p><h2 id="2-3-最佳解">2.3 最佳解</h2><p>但是在 python 根本不需要自己建立 HashTable ，因為 python 內建的 dict 或是 set 就是 HashTable 的實現，因此可以直接使用內建的 HashTable 來解這題。</p><div class="note info flat"><p>時間複雜度：O(n)<br>空間複雜度：O(n)</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        numSet = &#123;&#125;</span><br><span class="line">        <span class="comment"># build hash table （解法1是自己建立的HashTable，這裡採用Python內部的）</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            numSet[v] = i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># find the complement</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            complement = target - v</span><br><span class="line">            <span class="keyword">if</span> complement <span class="keyword">in</span> numSet <span class="keyword">and</span> numSet[complement] != i:</span><br><span class="line">                <span class="keyword">return</span> [i, numSet[complement]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [] <span class="comment"># No solution Found</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    nums = [<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">    target = <span class="number">6</span></span><br><span class="line">    <span class="built_in">print</span>(Solution().twoSum2(nums, target))</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><p>題目比較簡單，畢竟暴力的方法也可以解決。唯一閃亮的點就是，時間複雜度從 O（n²）降為 O（n） 的時候，對 hash 的應用，有眼前一亮的感覺。</p><h1 id="參考資料">參考資料</h1><ul><li><a href="https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/">LeetCode 1. Two Sum - Solutions</a></li><li><a href="https://leetcode.wang/leetCode-1-Two-Sum.html">Wang leetcode - two sum</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 刷題之旅 </category>
          
          <category> Hash Table </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> practice </tag>
            
            <tag> Easy </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彙整medium上面 演算法學習之-Leetcode-破關總指南</title>
      <link href="/posts/how-to-start-leetcode/"/>
      <url>/posts/how-to-start-leetcode/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>看到 <a href="https://medium.com/appworks-school/%E6%BC%94%E7%AE%97%E6%B3%95%E5%AD%B8%E7%BF%92%E4%B9%8B-leetcode-%E7%A0%B4%E9%97%9C%E7%B8%BD%E6%8C%87%E5%8D%97-%E4%B8%80-873b3fb65152">演算法學習之-Leetcode-破關總指南</a>我覺得整理的非常好，準備開始作為之後刷LeetCode的指南。</p><p>本篇的所有內容非出自於我手，而是整理自 <a href="https://medium.com/appworks-school/%E6%BC%94%E7%AE%97%E6%B3%95%E5%AD%B8%E7%BF%92%E4%B9%8B-leetcode-%E7%A0%B4%E9%97%9C%E7%B8%BD%E6%8C%87%E5%8D%97-%E4%B8%80-873b3fb65152">演算法學習之-Leetcode-破關總指南</a> 的文章，我只是將他們的文章整理成一篇，方便之後查閱。</p><h1 id="正確心態">正確心態</h1><ol><li><em>不要硬去挑戰難題然後又硬要自己想出來才肯罷休</em>，這樣的學習效率會很差，甚至學不到重點反而歪掉。<em>好好把握你能抓得住的那一部分就好，吃不下去的就先放寬心不要著急。你的大腦仍然會或多或少的在背景運作吸收</em>，並在未來的某一天有需要的時候，讓你想起來好像曾經聽過那個什麼，跟現在這件事有點關聯，但記不清楚了，只要這時候再重新好好補上就很完美了。</li><li>自己挑題目最重要原則：<em>寧可太簡單，不要太難</em>，太簡單還可以緩步提升難度，太難有可能一下把自己的正循環打斷，拖延症就容易趁機發作而不想學習，得不償失。</li><li>也不用太強求要把每個資料結構理解到最底層去，有<em>大致理解他們各種操作的時間複雜度特性後，就可以先往下一關邁進了</em>。</li><li>刷題順序<ol><li>挑一個關鍵字找教材、影片或上課直到完全弄懂<em>做法</em>與<em>時間複雜度</em>的分析</li><li>去 <em>Leetcode 找相同關鍵字</em>的 <em>Easy 題或簡單的 Medium 題</em>，難易度可以用通過率 Acceptance 初步判斷，先不要碰 Hard</li><li>如果有做出來，<em>繼續看他推薦的延伸題，一樣選 Easy 或簡單的 Medium</em></li><li>如果做不出來，回到步驟 1 看看還有哪邊沒懂，或去 Leetcode 討論區吸取他人經驗想法</li></ol></li><li>如果在 Leetcode 討論區發覺大家講的做法太過神奇，與該演算法的概念已經關係不大，而是需要特殊技巧，那這題你暫時跳過也無妨，因為無助於現階段的學習。</li></ol><p><img src="https://i.imgur.com/44flhae.png" alt=""></p><h1 id="新手村">新手村</h1><ol><li>輸入、輸出</li><li>整數、浮點數、字串、陣列、雙重陣列</li><li>判斷式 if / else</li><li>迴圈 for loop / while loop</li><li>函數 function()</li><li>變數值與記憶體位址的概念</li><li>十進位與二進位轉換的基本概念</li><li>時間複雜度、空間複雜度的基本概念與 Big-O Notation</li></ol><h1 id="資料結構L1">資料結構L1</h1><ol><li>Array</li><li>Hash Table</li><li>Set</li><li>Stack</li><li>Queue</li><li>Linked List（先懂基本操作即可）</li><li>Binary Tree（先懂基本 DFS/BFS 即可）</li></ol><p>認識一個新資料結構，我們要關注的就是他各種操作的時間複雜度，最基本的操作如下:<br><img src="https://i.imgur.com/mBTeo9J.png" alt=""></p><ul><li>insert</li><li>delete</li><li>find（找到某個值的位置）</li><li>peek（查看某位置的值）</li><li>check exist（確認值是否存在）</li></ul><h2 id="推薦題目">推薦題目</h2><p>由於 Array 太過廣泛，幾乎任何題目都會用上，而 Queue 則是到後面 Tree 與 Graph 的章節才比較常用上，因此這邊先不特別列題目了。<br>以下來舉幾個基礎題的例子：</p><ol><li>Hash Table: <a href="https://leetcode.com/problems/two-sum/">Two Sum</a></li><li>Set: <a href="https://leetcode.com/problems/intersection-of-two-arrays/">Intersection of Two Arrays</a></li><li>Stack: <a href="https://leetcode.com/problems/valid-parentheses/">Valid Parentheses</a></li><li>Linked List: <a href="https://leetcode.com/problems/merge-two-sorted-lists/">Merge two sorted linked list</a></li><li>Binary Tree: <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree</a></li></ol><h1 id="演算法L1">演算法L1</h1><ol><li><a href="https://medium.com/appworks-school/binary-search-%E9%82%A3%E4%BA%9B%E8%97%8F%E5%9C%A8%E7%B4%B0%E7%AF%80%E8%A3%A1%E7%9A%84%E9%AD%94%E9%AC%BC-%E4%B8%80-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9-dd2cd804aee1">Binary Search</a></li><li><a href="https://medium.com/appworks-school/%E9%80%B2%E5%85%A5%E9%81%9E%E8%BF%B4-recursion-%E7%9A%84%E4%B8%96%E7%95%8C-%E4%B8%80-59fa4b394ef6">Recursion</a></li><li><a href="https://medium.com/appworks-school/%E9%80%B2%E5%85%A5%E9%81%9E%E8%BF%B4-recursion-%E7%9A%84%E4%B8%96%E7%95%8C-%E4%BA%8C-58196a45a945">Divide and Conquer</a></li><li><a href="https://blog.techbridge.cc/2019/08/30/leetcode-pattern-two-pointer/">Two Pointer</a></li><li><a href="https://usaco.guide/silver/prefix-sums?lang=cpp">Prefix Sum</a></li><li><a href="https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/">BFS/DFS</a>（Binary Tree, Binary Search Tree）</li><li><a href="https://www.geeksforgeeks.org/greedy-algorithms-general-structure-and-applications/">Greedy</a>（練習時先寫 Easy 題就好）</li><li><a href="https://www.educative.io/blog/bit-manipulation-algorithm">Bit Manipulation</a>（練習時先寫 Easy 題就好）</li></ol><h2 id="推薦題目-2">推薦題目</h2><ol><li>Binary Search: <a href="https://leetcode.com/problems/binary-search/">Binary Search</a></li><li>Recursion:<a href="https://leetcode.com/problems/fibonacci-number/">Fibonacci Number</a><a href="https://leetcode.com/problems/invert-binary-tree/">Invert Binary Tree</a></li><li>Two Pointer: <a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Two Sum II — Input array is sorted</a></li><li>Prefix Sum: <a href="https://leetcode.com/problems/minimum-size-subarray-sum/">Minimum Size Subarray Sum</a></li><li>BFS / DFS:<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">Binary Tree Level Order Traversal</a><a href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree</a></li><li>Divide and Conquer: <a href="https://leetcode.com/problems/sort-an-array/">Sort an Array</a> (練習寫 Merge Sort &amp; Quick Sort)</li><li>Greedy (Easy): <a href="https://leetcode.com/problems/assign-cookies/">Assign Cookies</a></li><li>Bit Manipulation (Easy): <a href="https://leetcode.com/problems/counting-bits/">Counting Bits</a></li></ol><h1 id="實戰應用L1">實戰應用L1</h1><p>在練功坊學會招式之後，靈活運用才是重點，在這個區域的題目，通常背後隱藏的概念不會太難，但就是不容易一眼看穿，解法會比上面練功坊的題目藏的更深，或需要轉更多的彎。面對這種問題，我們要學會忘掉所有你學會的招式，返璞歸真回到最原始的狀態。簡言之，找回面對任何問題的初心，也就是</p><ol><li>觀察規律</li><li>分類歸納不同情境</li><li>對每個情境一一處理</li></ol><p>最後，記得挑選能力範圍內的題目去挑戰</p><ul><li>失敗的成長循環：隨便開一題 -&gt; 想破頭不會做 -&gt; 開解答看很久才看懂 -&gt; 感到疲累 -&gt; 沒動力再打開下一題暫時放棄 -&gt; 很久以後又想到要練刷題 -&gt; 隨便開一題</li><li>成功的成長循環：挑選能力範圍內的題目 -&gt; 慢慢分析歸納找到思路 -&gt; 做出來獲得滿滿的成就感 -&gt; 很想再開一題挑戰自我 -&gt; 尋找適合的下一題繼續挑戰</li></ul><h2 id="如何找到動機">如何找到動機</h2><p>如果你長年都苦於找不到刷題動機，時不時燃起熱血想徹底搞定他，但沒多久又把這件事放一邊去，往復循環，我有另一篇專門寫如何找到動機來源的文章也可以看看。簡單筆記如下：</p><div class="note info flat"><p>動機不能只是隨機的火花，你必須找到引燃自己的方式。而第一步就是不要讓你的動機永遠依賴於意志力，而是找到方法，只需開頭推動一下，後面就可以像滾雪球一樣源源不絕的產生動機，這才是長期成功之道。</p></div><ol><li>Leetcode 的特殊要求通常是以下幾個：</li><li>Constant Extra Space：不使用任何額外記憶體，也就是 space complexity 要是 O(1)</li><li>One Pass：不只時間複雜度要 O(N)，還只允許跑一輪迴圈</li><li>In-place：直接對原始 input 做改變，不回傳答案，通常也隱含 Constant Extra Space 的條件</li><li>Integer Limit：運算中任何一刻都不可以超過 Integer 範圍</li></ol><h3 id="四大動機產生方式">四大動機產生方式</h3><p><strong>1. 營造好的環境</strong></p><blockquote><p>第一種動機來自外在環境，很容易，幫助也很大，但也來得快去得快，當你失去了環境，也就失去了動機。</p></blockquote><ul><li>加入一個讀書會或團體課程，營造正向的學習環境。</li><li>去圖書館念書，透過身旁人的狀態讓你產生動力。</li><li>把你的目標昭告天下給朋友圈知道，請他們協助緊盯你的進度。</li><li>e.g. 通勤時間需要搭一小時的捷運，聽起來很累，但我買了一本電子書隨身帶著，每天的這來回兩小時就這樣變成了我的固定讀書時間，短短半年內消化了十來本好書（許多也成了這系列文的寶貴素材）</li></ul><p><strong>2. 透過連續完成小目標帶來的成就感</strong></p><blockquote><p>第二種遊戲式正循環的動機，可以持續比較久，對初期新手階段很有幫助，但當難度開始升高，很容易遇到瓶頸。</p></blockquote><ol><li>先選定合適難度的主題（例如 Two Pointer）去 Leetcode 或類似網站找一個適合自己程度的題目（從最簡單開始）</li><li>讀完題目後，先試著自己想想看（回想上一篇我們如何建立心智表徵）</li><li>如果超過 15 分鐘想不到，不要硬想，去討論區或網路上尋找教材或解答，但不要急著一次看完，可以看一點就好，一但有多出一點點靈感就退回步驟 3。</li><li>反覆 3 跟 4 循環，直到靠自己力量做出來（即使看了部分解答，只要最後有一小部分是靠自己想出來的也算），而每當我在努力掙扎一番後，看到下面這個綠勾勾跳出來，就是一個讓心情非常愉悅的獎勵。</li></ol><p>當然若這個對你來說不夠，你也可以額外創造其他有效獎勵，在每次成功時發放。最終，一但我的大腦綁定了這個喜悅，他就會自動拉著我想要再挑戰下一題，然後再次努力，再次解決，再次獲得獎勵，不斷循環。如果你有了這樣的感受，恭喜你，你的正循環開關已經打開，讓他領著你前進一大段路吧！</p><div class="note info flat"><p><strong>自己挑題目最重要原則：寧可太簡單，不要太難，太簡單還可以緩步提升難度，太難有可能一下把自己的正循環打斷，拖延症就容易趁機發作而不想學習，得不償失。</strong></p></div><p><strong>3. 找到學習知識本身的喜悅</strong></p><blockquote><p>此時要開始找到第三種更純粹的內在動機，也就是學習本身帶來的樂趣，而且難度越高還會越有趣，若能以此做為你正循環真正動力核心來源，你就不需依靠任何外在的獎勵或回報，也能開心的一路往前走。</p></blockquote><p><em>基因其實本來就決定了學習是快樂的！但為什麼很多人會有不快樂的學習經驗呢？</em><br>因為一但在有高度時間壓力的學習情況下，我們就變得很難快樂，因為同化跟順應都需要時間去消化，如果時間壓力太大，我們很難好好的走過這個流程，建立起越來越好的基模，並且從中獲得快樂，只會一直感受到不平衡的痛苦，然後東西也學不好。</p><p><strong>4. 讓目標與你的長期人生使命一致</strong></p><blockquote><p>心流體驗往往發生在你面對的挑戰足夠高，而你同時也有足夠的技能完成，可能你正在進行一場把自己發揮到極致的運動競賽，或在學習過程中靠自己的力量完美解出了超級難題。此時的你會感到一種全心投入、身心合一、物我兩忘的狀態。</p></blockquote><p>最後，假如能到達第四種動機 ，也就是心流的層次，還可以讓你的學習昇華到發自內心的至高喜悅，讓你願意一輩子永無止境的追尋下去。這也是一些偉大的數學家、物理學家、音樂家，如何從孩提時代的啟蒙，一路到願意犧牲奉獻一輩子在一個困難的題目或作品上，最終成就不朽。</p><h1 id="特殊模式">特殊模式</h1><p>Leetcode 的特殊要求通常是以下幾個：</p><ol><li>Constant Extra Space：不使用任何額外記憶體，也就是 space complexity 要是 O(1)</li><li>One Pass：不只時間複雜度要 O(N)，還只允許跑一輪迴圈</li><li>In-place：直接對原始 input 做改變，不回傳答案，通常也隱含 Constant Extra Space 的條件</li><li>Integer Limit：運算中任何一刻都不可以超過 Integer 範圍</li></ol><h2 id="推薦題目-3">推薦題目</h2><p>經典範例題目如下：</p><ol><li>Constant Extra Space: <a href="https://leetcode.com/problems/single-number/">Single Number</a>： Single Number 會需要一點 Bit Manipulation 的知識，稍微難一點。</li><li>One Pass: <a href="https://leetcode.com/problems/sort-colors/">Sort Colors</a>：如果你以前 quick sort 有學好，其實就是 partition 做兩次而已，但加上 one pass 的條件後就不那麼容易了，要做出 3-way partition。</li><li>In-place: <a href="https://leetcode.com/problems/reverse-string/">Reverse String</a>：相對簡單，只是要認識一下 in-place 的答題方式。</li><li>Integer Limit: <a href="https://leetcode.com/problems/divide-two-integers/">Divide Two Integers</a>：考驗你對整數型別的範圍是否有足夠的敏感度，乍看之下是個超級簡單的問題，但如果細細思考，會發現有很多的麻煩在裡面，例如 input 的數值可能是 -2³¹，但假如你輕易的對他做絕對值運算，變成 2³¹ 就超出整數範圍了，算是不合格的做法。面對這種題目，假如你用 Python 或 Javascript 之類的語言，很可能會完全沒注意到這問題，因為他都內建大數運算。因此這類題目會建議用 JAVA 或 c/c++ 來做，且不能開 long 型別，要強迫自己熟悉 int 的特性。</li></ol><h1 id="挑戰模式">挑戰模式</h1><p>一些增加自我練習強度的方式，對任何題目、任何階段都適用，也就是除了單純完成題目得到 Accept 以外，你可以開始逐步增加對自己的要求，要求難度照以下為順序逐漸提高：</p><ol><li><em>無論如何給出一個暴力解</em>，通常你會看到 Time Limit Exceeded (TLE) 代表你的暴力解成功了，只是跑太慢所以比較大的測試資料沒辦法通過，否則會先看到 Wrong Answer (WA)，代表邏輯本身是錯的</li><li><em>從 Top 100 like 裡面隨機抽題，且不去看題目的分類</em>，前面的訓練會讓人習慣已經知道分類的情況下解題，但真實面試的時候，你是不會有這個資訊的，得靠自己的觀察力找到答案</li><li><em>Submit 後若沒通過時，不要看 Leetcode 給的測資</em>，自己去發想測試資料來找到錯誤，這會磨練你思考 corner case 的能力，畢竟 on-site 面試或 phone interview 的時候，發想測資也是面試官很愛觀察的面向之一。</li><li><em>減少嘗試按 run 的測試次數，也減少在自己 IDE 上面測試的次數</em>，更進一步可以要求自己完全不 run code，但一次 submit 就要通過，這會大幅增加挑戰的難度，因為你必須把邏輯想得非常透徹，確保沒有任何一絲漏洞，一般公司的面試不太會要求到這樣，但練習的時候可以視為一種負重訓練，考驗自己邏輯是否完全清晰，且養成寫 code 嚴謹紮實的好習慣。而最知名的 Google 面試，就是要求面試者要在類似 Google Doc 的工具上，在無法 run code 的情境下，自己想測資，並寫出真的能跑出正確結果且無 bug 的 code，是不是很刺激？</li></ol><h1 id="資料結構L2">資料結構L2</h1><p>從這裡開始，觀念的難度會上升一個層級，每個主題都可以想成一個遊戲中的小 boss，可能光看懂教學解說都需要費一番功夫，但這邊也是真正實力差距的開始，要想進 Top 公司，以下才是見證真功夫的時刻:<br>這區域中會出現一些較複雜的資料結構，或舊資料結構的進階應用，通常有以下這些主題，部分主題一樣可以看 Hackerearch 的介紹，或看我下面找到的連結。<br>這區域中會出現一些較複雜的資料結構，或舊資料結構的進階應用，通常有以下這些主題，部分主題一樣可以看 <a href="https://www.hackerearth.com/practice/data-structures/arrays/1-d/practice-problems/">Hackerearch 的介紹</a>，或看我下面找到的連結。</p><ol><li><a href="https://haogroot.com/2020/09/01/monotonic-stack-leetcode/">Monotonic Stack/Queue</a></li><li><a href="https://towardsdatascience.com/4-types-of-tree-traversal-algorithms-d56328450846">Tree (Binary Tree &amp; Binary Search Tree)</a></li><li><a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html">Graph</a></li><li><a href="http://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html">Heap (Priority Queue)</a></li><li><a href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/">Union Find (Disjoint-set)</a></li><li>Design（要你設計指定特殊要求的資料結構）</li><li><a href="https://www.hackerearth.com/practice/data-structures/advanced-data-structures/trie-keyword-tree/tutorial/">Trie</a></li></ol><h2 id="學習方法">學習方法</h2><ol><li>一樣學習方式還是一個一個主題</li><li>找能讓你看懂的教學文章、影片、課程</li><li>看懂後去 Leetcode 上面找對應的標籤實戰練習基本型，儘量找一些貼近觀念基本型的題目，其難度大多都在 Medium（少數 Easy），而 Hard 一樣可以先不要碰，因為 Hard 題通常不止要應用這些概念，還得多轉很多彎，或結合其他概念，這種我們留待之後再來挑戰。</li></ol><h2 id="推薦題目-4">推薦題目</h2><p>以下精選幾個適合練習的好題目</p><ol><li>Monotonic Stack/Queue: <a href="https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/">Final Prices With a Special Discount in a Shop</a></li><li>Tree:<a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">Insert into a Binary Search Tree</a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">Construct Binary Tree from Inorder and Postorder Traversal</a></li><li>Graph: <a href="https://leetcode.com/problems/keys-and-rooms/">Keys and Rooms</a></li><li>Priority Queue: <a href="https://leetcode.com/problems/last-stone-weight/">Last Stone Weight</a></li><li>Union Find: <a href="https://leetcode.com/problems/number-of-provinces/">Number of Provinces</a></li><li>Design:<a href="https://leetcode.com/problems/min-stack/">Min Stack</a><a href="https://leetcode.com/problems/design-circular-queue/">Design Circular Queue</a></li><li>Trie: <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Implement Trie (Prefix Tree)</a></li></ol><h1 id="演算法L2">演算法L2</h1><p>如同上面的資料結構 LV2，這邊則是一個個進階演算法，通常有以下主題</p><ol><li>Backtracking</li><li>Shortest Path in a Graph</li><li>Greedy（Advanced）</li><li>Dynamic Programming</li><li>Bit Manipulation（Advanced）</li></ol><p>或建構在特定資料結構上的演算法</p><ol><li>Dijkstra: Graph + Priority Queue</li><li>Topological Sort: Graph</li><li>Minimum Spanning Tree: Graph + Union Find</li><li>Tree 的 LCA, 各式 DFS Traversal 轉換應用等等</li></ol><h2 id="學習方法-2">學習方法</h2><p>對於這種較進階演算法的學習步驟，通常如下</p><ol><li>搜尋關鍵字，找一個教材努力看懂他的概念</li><li>先自己嘗試實作出這個概念的原型</li><li>看教學寫的標準寫法，跟你上一步自己實作出來的做個比較，通常在比較複雜的演算法中，程式寫法的重要性有時候不下於概念本身，一個精簡好懂的寫法，可以幫助你記憶，且大幅減少 bug，面試時才有可能做出來</li><li>去找 Leetcode 的基礎題，驗證你寫好的這個模板跑起來正確無誤</li><li>找這個 Tag 底下的其他問題，一樣先以 Medium 為主，測試自己能不能看出來如何使用該演算法解題</li></ol><h2 id="推薦題目-5">推薦題目</h2><p>以下分享一些非常適合做驗證練習用的基礎題</p><ol><li>Backtracking: <a href="https://leetcode.com/problems/combinations/">Combinations</a></li><li>Dijkstra: <a href="https://leetcode.com/problems/network-delay-time/">Network Delay Time</a></li><li>Topological Sort: <a href="https://leetcode.com/problems/course-schedule-ii/">Course Schedule II</a></li><li>Greedy（Advanced）:<a href="https://leetcode.com/problems/gas-station/">Gas Station</a><a href="https://leetcode.com/problems/non-overlapping-intervals/">Non-overlapping Intervals</a></li><li>DP:<a href="https://leetcode.com/problems/unique-paths/">Unique Paths</a><a href="https://leetcode.com/problems/coin-change/">Coin Change</a><a href="https://leetcode.com/problems/edit-distance/">Edit Distance</a></li><li>Bit Manipulation（Advanced）: <a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/">Maximum XOR of Two Numbers in an Array</a></li></ol><p>但即使變化大，仍然是有跡可循，我們一樣可以採取一個一個關鍵字搜尋教學，之後上 Leetcode 找對應的練習題的策略，只是範圍更廣了些。</p><p>而其中最惡名昭彰的是 Dynamic Programming（DP），變化極為繁多，雖然都有一致的策略跟思考方向在，但每種新變化型都不容易在完全沒看過的狀況下憑空想出來，所以等於光他一個，就又可以拆成好幾個獨立的演算法來學了（常見的型大概就有 7, 8 種之多）。好消息是<em>一般公司大概也不太敢去考太複雜的 DP 題目，頂多考經典型</em>（太難的面試官都不一定會？），但如果目標是<em>世界頂尖 Tier 1 公司，由於前面稍容易的問題競爭者們都會做，所以困難 DP 往往變成拿來最終鑑別實力的題</em>，有志者不能輕易放棄。</p><h1 id="實戰應用L2">實戰應用L2</h1><p>最後，最難的地獄關卡就是這了，光是你能走到這步，應該已經具備應付大多數公司演算法考題的實力了，在 Leetcode 週賽通常也能穩定解 2 ～ 3 題。但如果還想往前走，這邊會是一大難關，就是以上所有東西的靈活變化應用。</p><p>如同實戰應用練習場 LV1，這邊的題都會藏的比較深，初看題目通常第一時間只能發愣，想不到這鬼東西該如何下手，但如果你上面幾個區的東西都能確實掌握好，現在就是大考驗的時刻。由於 Leetcode 的範圍還算很有限（跟競賽型的 Competitive Programming 相比），所以通常一定會是某個你前面章節學過的東西。</p><h2 id="學習方法-3">學習方法</h2><p>這邊的題目，一般要去每個 tag 的 Hard 題找，一樣先從讚數最多的做起，後期可以打週賽挑戰時限內做出第四題。剛開始如果感覺每一題都做不出來，是非常正常的，不用灰心。由於到這區的你，已經具備一定的程度了，當我們想不出來，可以用以下的方式去看討論區學習</p><ol><li>開討論區，看 voted 最高的解釋，但不要全部看完（也可以看 Leetcode 題目的官方提示，意思差不多）</li><li>通常你會先看到關鍵字，是你前面學過的概念，這時候可以先關掉解答，回來想想該觀念要怎樣套到這題上面來</li><li>如果仍然卡關，再開討論區續看，但一樣如果看他到講了某個關鍵思路，是你之前沒想到的，而且讓你有一點點感覺，好像有點想法了。那一樣關掉解答，重新回來自己想想</li><li>如果仍然卡關，才回去把整份討論區解答看完，然後好好沉澱想想這整題當中，有哪些觀念是你之前完全沒想過的，這就成為了你的養分，恭喜你，又掃出一個盲點並克服他了</li></ol><h1 id="特殊模式-2">特殊模式</h1><p>最後，還有一些在 Leetcode 比較罕見的題目類型，主題龐雜但每個遇到機會又都很低，以下舉幾個例子</p><ol><li>Number Theory：各種需要先具備某些數論概念的題目，例如質數、最大公因數、或對某些數字的特殊性質觀察等等。這是筆者最苦手的類型，還好面試中出現機率也非常低。</li><li>其他數學相關的獨立主題們：Geometry、Statistics and Probability、Game Theory、Bit Manipulation 等等。</li><li>Fenwick Tree &amp; Segment Tree：需多次對 Array 做 range update &amp; query 時使用（例如不停改變 Array 的內容，並一直問你不同範圍內的值加總是多少）。這是個競賽比較會出現的東西，但懂這技巧，有時候一些 Leetcode 難題靠他會突然變得很簡單。經典例子如 <a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/">315. Count of Smaller Numbers After Self</a>。</li><li>SortedContainer：基本上就是一個實作了紅黑樹的資料結構，具備可在 log(N) 時間內做到 insert/delete/search 的優良性質，雖然不太可能叫你當場寫一顆紅黑樹出來，但有少數難題可以靠 lib 內建的 SortedContainer 幫你解決，所以最少要會用，能懂背後運作機制當然更好。上面提到的 Leetcode 315 一樣靠他就會變簡單題了。</li><li>Graph 的其他經典進階演算法（但在 Leetcode 較少出現），例如 Minimum Spanning Tree、Bellman-Ford、Bipartite Graph、BCC/SCC、2SAT、Bridge、Articulation Point、Eulerian Circuit、Hamiltonian Path、Max-Flow/Min-Cut … 等等，種類繁多，且每一個難度都不下於 Dijkstra。</li><li>Interactive：互動題目，Leetcode 的通常不難，但寫法較為特別，可以認識一下。筆者自己就在面試 Google 時被考了一題這種風格的題目。</li><li>還有奇怪主題如 SQL、shell 這些，一般是極少看到，要的話也是另外準備，Leetcode 還是以準備資料結構跟演算法的題目為主。</li><li>Concurrency：需要使用 multi-thread 工具去做的題目，雖然筆者自己覺得這已經脫離資料結構與演算法的範疇了，但網路上有看過文章說有被 FAANG 公司考過。而知名 Youtube Terry 也曾用過類似題目拍過實戰模擬面試的介紹影片，有興趣可以看我寫的<a href="https://medium.com/p/c84b3e38be7e">這篇分析</a>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Attitute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 課前預習 - 掌握 Hash Table 指南</title>
      <link href="/posts/lecture-leetcode-hash-table/"/>
      <url>/posts/lecture-leetcode-hash-table/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>如果你喜歡的我文章，希望你可以到我的 github 給我一個 star ⭐️ <a href="https://github.com/ShannonHung/ShannonHung.github.io">Blog Repo</a></p></div><h1 id="1-基本介紹">1. 基本介紹</h1><p><strong>Hash Table 的日常應用</strong><br>Hash Table（哈希表）是一種高效的數據結構，用於在平均時間複雜度 O(1) 的情況下進行查找、插入和刪除操作。這使得 Hash Table 在許多日常應用中得到了廣泛使用，最長薦的就是<em>密碼的存儲</em>在安全應用中，Hash Table 可以用來存儲密碼的哈希值，從而保護用戶密碼的安全。其他狀況還有：</p><ul><li>緩存（Cache）：在網頁瀏覽器或數據庫中，Hash Table 用於實現緩存機制，快速檢索和存儲最近使用或最常用的數據。</li><li>數據庫索引：許多數據庫使用 Hash Table 來實現索引結構，以提高查詢速度。</li></ul><p><strong>Hash 的重要基本特性</strong></p><ol><li><strong>不可逆（Irreversible）</strong>：這是密碼學中的一個重要特性，Hash 函數是一種單向函數，無法通過哈希值反推原始密碼，儲存在資料庫的密碼通常是已經hash過後，使得沒有人知道原本的密碼長什麼樣子，除非用暴力破解，找到一組字串經過hash得到與原始密碼hash過後相同的值，通常是發生碰撞或是真的猜到密碼，才會得到相同的值。</li><li><strong>固定長度（Fixed Length）</strong>：無論輸入數據的長度是多少，哈希函數總是生成固定長度的哈希值。例如，SHA-256 哈希函數無論輸入是短字符串還是大型文件，都會生成 256 位長度的哈希值。這種特性有助於在不同數據類型之間保持一致性。這裡的固定長度，不是只字串長度，而是儲存的位元數。</li><li><strong>相同輸入產生相同輸出（Deterministic）</strong>：對於<em>相同的輸入，哈希函數總是會產生相同的哈希值</em>。這種確定性確保了哈希函數在各種應用中的一致性，例如數據校驗和數據庫索引。</li></ol><h1 id="2-Hash-Table-的實現">2. Hash Table 的實現</h1><p><strong>Collision散裂碰撞</strong><br>好的Hash Function可以減少Collision的機率，但是無法完全避免，因此需要有解決Collision的方法。舉例來說下面的程式碼：</p><ul><li>畢竟buckets不是無限大的，python和c++經過hash後的散列值雖然不同，但是對self.length取模後是相同的，這導致他們兩個被放到了同一個桶裡。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PyHashTable</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, datas=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> datas <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.length = <span class="number">8</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.length = <span class="built_in">len</span>(datas)</span><br><span class="line">        <span class="comment"># 建立一個空的buckets</span></span><br><span class="line">        self.buckets = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.length)]</span><br><span class="line">        <span class="comment"># 初始化buckets 把datas放進去</span></span><br><span class="line">        self.init_buckets(datas)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把datas放進去</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_buckets</span>(<span class="params">self, datas</span>):</span><br><span class="line">        <span class="keyword">if</span> datas <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> datas:</span><br><span class="line">            self.__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用hash function找到index，並且找到key對應的value</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, search_key</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(search_key))</span><br><span class="line">        index = hash_value % self.length</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.buckets[index]:</span><br><span class="line">            <span class="keyword">if</span> search_key == key:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把key, value放進去 buckets list中，並且使用hash function找到index</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(key))</span><br><span class="line">        index = hash_value % self.length</span><br><span class="line">        self.buckets[index].append((key, value)) <span class="comment"># 可能會發生Collision，不同的key會被放到同一個bucket中</span></span><br><span class="line"></span><br><span class="line">datas = [(<span class="string">&#x27;python&#x27;</span>, <span class="number">90</span>), (<span class="string">&#x27;java&#x27;</span>, <span class="number">98</span>), (<span class="string">&#x27;php&#x27;</span>, <span class="number">85</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="number">100</span>)]</span><br><span class="line">hashtable = PyHashTable(datas)</span><br><span class="line"><span class="built_in">print</span>(hashtable[<span class="string">&#x27;c&#x27;</span>])   <span class="comment"># 像使用字典一样 印出 100</span></span><br><span class="line"></span><br><span class="line">hashtable[<span class="string">&#x27;c++&#x27;</span>] = <span class="number">92</span>       </span><br><span class="line"><span class="built_in">print</span>(hashtable[<span class="string">&#x27;c++&#x27;</span>]) <span class="comment"># 印出 92</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(hashtable.buckets) </span><br><span class="line">    <span class="comment"># [</span></span><br><span class="line">        <span class="comment"># [], </span></span><br><span class="line">        <span class="comment"># [(&#x27;python&#x27;, 90), (&#x27;c++&#x27;, 92)], </span></span><br><span class="line">        <span class="comment"># [(&#x27;java&#x27;, 98), (&#x27;c&#x27;, 100)], </span></span><br><span class="line">        <span class="comment"># [(&#x27;php&#x27;, 85)]</span></span><br><span class="line">    <span class="comment"># ]</span></span><br></pre></td></tr></table></figure><h1 id="3-解決衝突">3. 解決衝突</h1><p>hashtable解決衝突的方法常見的有兩種：</p><ul><li><em><strong>開放尋址</strong>: 簡單來說就是當有衝突時，就往後找下一個空的bucket，直到找到為止。</em><ul><li>比較常見的做法是開放尋址法，也就是當發生衝突時，就往後找下一個空的bucket，直到找到為止。</li><li>這樣的好處是，不需要額外的空間來存放衝突的元素，但是缺點是，當buckets裝滿時，找不到空bucket時，就會導致無限循環。</li><li>因此要做好擴容的準備，當buckets裝滿時，就要擴容，增加buckets的數量，這樣就可以減少衝突的發生。</li></ul></li><li><em><strong>鏈結位址法</strong>: 簡單來說就是在衝突的 bucket 中，這個bucket裡面放一個linked list，當有衝突時，就把新的元素放在這個linked list的最後面。</em><ul><li>上面的程式碼，其實就是鏈結位址法的一種實現。</li><li>append的時候，就不是單單一個value，而是一多個value</li><li>但是這導致在尋找的過程中，要多一次迴圈，來找到對應的key。</li><li>也比較浪費空間，因為每個bucket都要放一個linked list，但是linked list裡面的元素可能只有一個。</li></ul></li></ul><p>接下來我來好好說明一下開放定址法的實現，因為鏈結位址法的實現，其實就是上面的程式碼，所以就不再贅述。</p><h2 id="3-1-開放定址法">3.1 開放定址法</h2><p>開放定址法（Open Addressing）是處理哈希表中衝突的一種方法。在開放定址法中，當一個鍵值對應的槽已被佔用時，將會根據某種探查序列找到下一個空閒的槽。</p><p><strong>優點</strong></p><ul><li><em>空間利用率高</em>：開放定址法不需要為處理衝突而額外分配空間。當發生衝突時，只需依照探查序列尋找下一個空槽即可。這樣的設計使得整個哈希表的空間利用率更高。</li></ul><p><strong>缺點</strong></p><ul><li><em>歷經k次比較導致效能下降</em>：如果大量的鍵（keys）發生衝突，原本應該存放在 n 號位置的鍵，可能會被放置在 n+k 號位置，這意味著在插入或查找時，需要進行 k 次比較。<ul><li>每次比較需要將當前槽的鍵與目標鍵進行比對，如果不相同則繼續往後找下個槽，這樣的操作會導致效能下降。</li><li>當衝突增多時，探查序列會變長，導致插入和查找操作的時間複雜度增大，從而降低哈希表的整體性能。</li></ul></li><li><em>無限循環風險</em>：開放定址法可以有效避免空間浪費，但當所有的槽都被佔用時，將無法找到空閒的槽存放新鍵，這時候就會出現無限循環的情況，導致插入操作失敗。<ul><li>當哈希表接近滿載時，探查序列變得很長，這不僅增加了操作時間，也增加了無限循環的風險。因此，哈希表需要保持適當的負載因子（load factor），通常在負載因子超過某個臨界值時進行擴容，以防止這種情況的發生。</li></ul></li></ul><div class="note warning flat"><p>但是這兩個缺點可以透過擴容的方式來解決。因為以下兩個因素而減少比較次數和衝突的發生：</p><ol><li><strong>增加buckets的數量</strong>： 例如，從原來的 M 個桶增加到 2M 個或更多。這樣已使用的桶數佔總桶數的比例降低，減少衝突的機率。</li><li><strong>重新哈希</strong>：也因為擴容了，所以需要重新計算hash值，這時候原本發生衝突的key，<em>因為重新計算hash值，原先衝突的值在新table中可能不再衝突，減少連續探測的次數（使得k比較次數減少）</em>。<br>因此，透過減少衝突和比較次數，提高了insert和search的效能。python 實現的 hash table 有 2/3 被佔用時就會擴容，並且重新哈希。</li></ol></div><p>但是以下程式沒有實現自動擴容，只是實現了開放定址法的基本核心概念。</p><ul><li>初始空間擴大兩倍，避免發生高碰撞</li><li>在<code>__setitem__</code>和<code>__getitem__</code>時，如果發生碰撞，就往後找下一個bucket <code>index = (index + 1) % self.length</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PyHashTable</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, datas=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> datas <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.length = <span class="number">8</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.length = <span class="built_in">len</span>(datas) * <span class="number">2</span> <span class="comment"># 擴容，如果有資料就是資料的兩倍 避免發生高碰撞</span></span><br><span class="line"></span><br><span class="line">        self.buckets = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.length)]</span><br><span class="line">        self.init_buckets(datas)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_buckets</span>(<span class="params">self, datas</span>):</span><br><span class="line">        <span class="keyword">if</span> datas <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> datas:</span><br><span class="line">            self.__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, search_key</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(search_key))</span><br><span class="line">        index = hash_value % self.length</span><br><span class="line">        <span class="keyword">while</span> self.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.buckets[index][<span class="number">0</span>] == search_key:</span><br><span class="line">                <span class="keyword">return</span> self.buckets[index][<span class="number">1</span>]</span><br><span class="line">            index = (index + <span class="number">1</span>) % self.length <span class="comment"># 如果發生碰撞，就往後找下一個bucket</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(key))</span><br><span class="line">        index = hash_value % self.length</span><br><span class="line">        <span class="keyword">while</span> self.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            index = (index + <span class="number">1</span>) % self.length <span class="comment"># 如果發生碰撞，就往後找下一個bucket</span></span><br><span class="line"></span><br><span class="line">        self.buckets[index] = (key, value)</span><br></pre></td></tr></table></figure><p>而需要注意的是，在開放定址法中進行刪除時，要有特別處理：</p><ul><li>因為如果直接刪除(原本有資料因刪除改None)，會導致後面的元素無法找到(本來發生碰撞的資料要找下一筆，檢查時發現是None以為沒有資料)</li><li>所以要<em>進行標記刪除，而不是真的刪除</em>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasDeleted</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyHashTable</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, del_key</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(del_key))</span><br><span class="line">        index = hash_value % self.length</span><br><span class="line">        <span class="keyword">while</span> self.buckets[index] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.buckets[index][<span class="number">0</span>] == del_key:</span><br><span class="line">                self.buckets[index] = HasDeleted() <span class="comment"># 給他一個刪除的標記物件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            index = (index + <span class="number">1</span>) % self.length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>增加了<code>__delitem__</code>，邏輯刪除一個key， 那麼<code>__setitem__</code>方法也要做出修改，這個執行了邏輯刪除的桶，應當被視為一個空的桶。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        hash_value = <span class="built_in">abs</span>(<span class="built_in">hash</span>(key))</span><br><span class="line">        index = hash_value % self.length</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(self.buckets[index], (<span class="built_in">type</span>(<span class="literal">None</span>), HasDeleted)): <span class="comment"># 檢查是否為None或是HasDeleted物件</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % self.length</span><br><span class="line"></span><br><span class="line">        self.buckets[index] = (key, value)</span><br></pre></td></tr></table></figure><h1 id="時間複雜度">時間複雜度</h1><ul><li>Access 訪問<ul><li><code>Best Case O(1)</code> 在理想情況下，我們能夠直接根據鍵（key）計算出其哈希值，並在常數時間內訪問到對應的值。</li><li><code>Worst Case O(n)</code> 所有的鍵都被映射到相同的哈希槽中（發生嚴重的碰撞）。這種情況下，哈希表會退化成一個鏈表，訪問操作需要遍歷整個鏈表。</li></ul></li><li>Search 搜尋<ul><li><code>Best Case O(1)</code> 哈希函數將鍵均勻分佈在哈希表的不同槽中，查找操作可以在常數時間內完成。</li><li><code>Worst Case O(n)</code> 所有鍵都被映射到相同的哈希槽中（發生嚴重的碰撞），導致哈希表退化成鏈表，需要遍歷整個鏈表才能找到目標鍵。</li></ul></li><li>Insertion 插入<ul><li><code>Best Case O(1)</code> 在沒有發生碰撞的情況下，可以在常數時間內將新鍵插入到哈希表中。</li><li><code>Worst Case O(n)</code> 在最壞情況下，如果發生大量碰撞，需要遍歷整個鏈表才能找到合適的插入位置。此外，如果哈希表需要擴容，重新哈希整個表的成本也是 O(n)。</li></ul></li><li>Deletion 刪除<ul><li><code>Best Case O(1)</code> 在沒有碰撞的情況下，可以在常數時間內刪除目標鍵。</li><li><code>Worst Case O(n)</code> 如果發生大量碰撞，需要遍歷整個鏈表才能找到目應刪除的鍵。此外，如果哈希表需要擴容，重新哈希整個表的成本也是 O(n)。</li></ul></li></ul><p>總結<br><strong>最佳情況（Best Case）</strong><br>在沒有發生碰撞的情況下，<em>Hash Table 的所有基本操作（訪問、查找、插入、刪除）都可以在 O(1) 的時間內完成</em>。<br>這依賴於哈希函數能夠將鍵均勻分佈在哈希表的不同槽中。</p><p><strong>最壞情況（Worst Case）</strong><br>當所有鍵都被映射到相同的哈希槽中，<em>發生嚴重的碰撞，哈希表會退化成鏈表，基本操作（訪問、查找、插入、刪除）的時間複雜度會變成 O(n)</em>。<br>這通常是由於哈希函數設計不當或哈希表負載因子過高導致的。</p><h1 id="進階：稀疏-密集數據結構">進階：稀疏+密集數據結構</h1><p>在 Python 3.6 之前，Python 字典（dictionary）使用一個哈希表來存儲 key-value 對。從 Python 3.6 開始，Python 字典引入了密集數組和稀疏數組的結合來實現更高效的存儲和查找。以下是這兩種實現的詳細說明，以及它們的差異和優點。<br><img src="https://i.imgur.com/0zknVcA.png" alt=""></p><h2 id="舊字典（Python-3-6-之前）">舊字典（Python 3.6 之前）</h2><p>在 Python 3.6 之前:</p><ol><li>字典使用一個簡單的哈希表來存儲 key-value 對。</li><li>哈希表由一個數組組成，其中每個槽（slot）包含一個鍵（key）、值（value）和哈希值（hash）。</li><li>當插入一個新元素時，使用鍵的哈希值來決定它應該存儲在數組中的哪個槽中。</li><li>如果發生碰撞（即兩個不同的鍵有相同的哈希值），則使用鏈接法或開放地址法來處理。</li></ol><p>簡單來說就是我們上述的程式碼。</p><h2 id="新字典（Python-3-6-及以後）">新字典（Python 3.6 及以後）</h2><p>從 Python 3.6 開始，字典的實現引入了密集數組和稀疏數組的結合：</p><ul><li><strong>密集數組（Compact Array）</strong>：密集數組用來存儲實際的 key-value 對。這是一個連續的數組，存儲所有的鍵和值，<em>保證了數據在內存中的連續性</em>。</li><li><strong>稀疏數組（Sparse Array）</strong>：<em>稀疏數組存儲指向密集數組的索引</em>。每個哈希槽中<em>存儲的是指向密集數組中元素的索引</em>，而<em>不是直接存儲 key-value 對</em>。<br>這種新的實現方式保留了插入順序，即鍵值對是按照插入順序存儲的，這在某些應用中非常有用。</li></ul><h2 id="差異">差異</h2><ol><li><strong>內存使用</strong>：<ul><li>舊的實現：每個槽（slot）中都需要存儲鍵、值和哈希值，內存使用較多。</li><li>新的實現：密集數組將鍵和值連續存儲，稀疏數組存儲索引，<em>內存使用更加緊湊和高效</em>。</li></ul></li><li><strong>性能</strong>：<ul><li>舊的實現：查找、插入和刪除操作的時間複雜度平均為 O(1)，但由於<em>內存分佈不連續，會導致更多的緩存未命中，影響性能</em>。</li><li>新的實現：密集數組的連續存儲方式提高了緩存命中率，進一步提高了查找和插入操作的性能。</li><li>所謂的緩存命中率指的是在計算機系統中，CPU 速度遠快於主內存的訪問速度，為了彌補這一差距，現代處理器設計了多級緩存（cache）。當 CPU 需要讀取數據時，它首先會查看數據是否在緩存中。如果數據在緩存中，則稱為“緩存命中”，這樣可以非常快速地訪問數據；如果數據不在緩存中，則稱為“緩存未命中”，這樣 CPU 就需要從較慢的主內存中讀取數據。</li></ul></li><li><strong>插入順序</strong>：<ul><li>舊的實現：不保證插入順序。</li><li>新的實現：<em>保證鍵值對按照插入順序存儲</em>，這在需要按順序處理元素的應用中非常有用。</li></ul></li><li><strong>內存碎片</strong>：<ul><li>舊的實現：由於鏈接法或開放地址法可能導致內存碎片，進而影響性能。</li><li>新的實現：密集數組<em>減少了內存碎片問題</em>，提高了內存使用效率。</li></ul></li></ol><h2 id="總結">總結</h2><p>簡單來說，使用密集數組和稀疏數組的結合，Python 字典在內存使用和性能方面都有了顯著的改進，進一步提高了查找和插入操作的效率。</p><ol><li><strong>緩存命中率提高</strong>：密集數組的連續存儲方式使得數據在內存中更緊湊，訪問密集數組時能夠更好地利用 CPU 緩存，從而提高性能。</li><li><strong>插入順序保留</strong>：通過將 key-value 對存儲在密集數組中，可以自然地保留插入順序，而不需要額外的結構來跟踪順序。</li><li><strong>內存使用更高效</strong>：稀疏數組只存儲索引，而不是完整的 key-value 對，這減少了內存的使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 課前預習 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> Lecture </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytest - Python 單元測試 教學</title>
      <link href="/posts/unit-test-python-pytest/"/>
      <url>/posts/unit-test-python-pytest/</url>
      
        <content type="html"><![CDATA[<h1 id="TL-DR">TL;DR</h1><div class="note primary flat"><p>Test-Driven Design的作者 Kent-Beck說過 “Write tests until fear is transformed into boredom.”</p></div><p>在進行重構時，每次最害怕的莫過於改了一個地方，其他地方就壞掉了。這時候，單元測試就是你的好幫手。你可以透過點擊一下按鈕，就能知道你的程式碼是否有問題。以前都寫java的單元測試，現在開始學習機器學習的相關領域，覺得也要培養寫測試的習慣。</p><h1 id="Pytest-vs-Unittest">Pytest vs Unittest</h1><ul><li>Ref: <a href="https://medium.com/@c29559810/%E7%86%B1%E9%96%80-python-%E6%B8%AC%E8%A9%A6%E6%A1%86%E6%9E%B6-pytest-unittest-%E7%9A%84%E5%B7%AE%E7%95%B0-93c87b9219ca">熱門 Python 測試框架: Pytest &amp; Unittest 的差異</a></li><li>Ref: <a href="https://blog.jetbrains.com/pycharm/2024/03/pytest-vs-unittest/">Pytest vs. Unittest: Which Is Better?</a></li></ul><p>以 Python 後端來說，眾多測試框架裡最熱門的當屬下面兩者:</p><ol><li><strong>第三方 Pytest</strong><ul><li>Pytest <em>不需要把測試的 function 封裝在類別(class)之中</em>，你可以更加自由地定義你的測試案例<ul><li>e.g. 不需要放unittest.TestCase <code>class TestAddition(unittest.TestCase)</code></li></ul></li><li>僅僅需要在測試 .py 檔以及檔案裡的測試 <em>function 加上 <code>test_</code> 的前綴</em>，pytest 就可以自動去辨認並執行這些測試腳本<ul><li>e.g. 直接定義function 並且加上test的前綴 <code>test_add_function()</code></li></ul></li></ul></li><li><strong>Python 內建的 Unittest</strong><ul><li>Unittest 在建立測試案例時，需要將程式寫在 Test 作為命名開頭的類別 (class) 中，並且要<em>繼承 unittest.TestCase 這個類別</em></li><li>編寫上雖較為嚴謹，但也較不直覺、需要較多步驟</li></ul></li></ol><p><strong>Unittest</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必須定義一個 Test 開頭的測試類別</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestAddition</span>(unittest.TestCase): <span class="comment"># 需要繼承 unittest.TestCase</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_add_function</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertEqual(add(<span class="number">2</span>, <span class="number">3</span>), <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 並且斷言比較長</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_equal</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertEqual(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_in</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertIn(<span class="string">&#x27;yo&#x27;</span>, <span class="string">&#x27;yo bro&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_true</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertTrue(<span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_false</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertFalse(<span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>pytest</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需要簡單寫一個 test_ 開頭的 function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add_function</span>():</span><br><span class="line">    <span class="keyword">assert</span> add(<span class="number">2</span>, <span class="number">3</span>) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 斷言簡潔</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_equal</span>():</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_in</span>():</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;yo&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;yo bro&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_true</span>():</span><br><span class="line">    <span class="keyword">assert</span> (<span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_false</span>():</span><br><span class="line">    <span class="keyword">assert</span> (<span class="number">2</span> + <span class="number">2</span> == <span class="number">5</span>) <span class="keyword">is</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>這篇文章主要介紹 Pytest，因為 Pytest 是一個功能更強大、更簡潔的測試框架，並且近年來，pytest 已成為 <a href="https://www.jetbrains.com/lp/devecosystem-2023/testing/?_ga=2.7844594.1334713110.1713532265-1228886937.1713532265">Python 測試最受歡迎的選擇之一</a>。</p></div><h1 id="安裝教學">安裝教學</h1><p>開啟終端機並寫入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest</span><br></pre></td></tr></table></figure><p>在開始寫測試之前，這邊想要先介紹一下 pytest 的基本規則：</p><ol><li>測試檔案必須以 <code>test_</code> 開頭</li><li>測試函數必須以 <code>test_</code> 開頭</li><li>測試函數中的斷言必須使用 <code>assert</code> 關鍵字</li></ol><h1 id="Test資料夾結構">Test資料夾結構</h1><ul><li>Ref: <a href="https://minglunwu.com/notes/2022/pytest_101.html/">Pytest 101 - 給 Python 開發者的測試入門</a></li></ul><p>使用 Pytest 測試框架進行測試時，需要按照特定格式擺放檔案。並沒有唯一正確的格式，身為一個廣泛使用的測試框架，Pytest 可依照使用者的需求自行指定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">|</span><br><span class="line">|_ Your Repo</span><br><span class="line">|</span><br><span class="line">|_ src/                  <span class="comment"># 主要程式碼資料夾</span></span><br><span class="line">    |_ module_a.py       <span class="comment"># 範例模組 A</span></span><br><span class="line">    |_ module_b.py       <span class="comment"># 範例模組 B</span></span><br><span class="line">|</span><br><span class="line">|_ tests/                <span class="comment"># 測試程式碼資料夾</span></span><br><span class="line">    |_ test_module_a.py  <span class="comment"># 模組 A 的測試程式碼</span></span><br><span class="line">    |_ test_module_b.py  <span class="comment"># 模組 B 的測試程式碼</span></span><br><span class="line">|</span><br><span class="line">|_ pytest.ini            <span class="comment"># pytest 相關設定</span></span><br></pre></td></tr></table></figure><p>從上述的架構我們可以掌握幾個原則 :</p><ol><li>主要的程式碼會統一放在 <code>src/</code> (也有人稱為 <code>app</code>, <code>lib</code> 或直接用模組的用途命名)</li><li>測試用的程式碼則統一放在 tests 資料夾</li><li>通常測試用的程式碼會以 test_xxx.py 命名 (我自己的習慣是直接對應到 src/ 中的模組)</li></ol><h1 id="fixture">fixture</h1><p>在unittest中我們必須要在每個測試函數中重複的初始化一些變數，或是在運行測試函試之前的工作，但是有可能很多測試函式要設定的參數都很雷同，使用unittest會讓測試程式碼變得冗長。而在pytest中，我們可以使用fixture來解決這個問題，<em>讓多個function可以共用一些初始化變數</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestExample</span>(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setUp</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 測試前的設定</span></span><br><span class="line">        self.resource = <span class="string">&quot;yo bro&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tearDown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 測試後的清理</span></span><br><span class="line">        self.resource = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_something</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 不需要每一次要調用時都要重新定義一次</span></span><br><span class="line">        self.assertEqual(self.resource, <span class="string">&quot;yo bro&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_another_thing</span>(<span class="params">self</span>):</span><br><span class="line">        self.assertIsNotNone(self.resource)</span><br></pre></td></tr></table></figure><p>但是在pytest中可以透過fixture來設定測試前的設定，使得一個function的資源可以被其他測試function所使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以透過fixture來設定測試前的設定</span></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">&quot;Module&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_resource</span>():</span><br><span class="line">    resource = <span class="string">&quot;yo bro&quot;</span></span><br><span class="line">    <span class="keyword">return</span> resource</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以發現setup_resource可以直接被使用 不需要() 來呼叫</span></span><br><span class="line"><span class="comment"># 注意要把setup_resource當作參數傳入才可以使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_something</span>(<span class="params">setup_resource</span>):</span><br><span class="line">    <span class="keyword">assert</span> setup_resource == <span class="string">&quot;yo bro&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_another_thing</span>(<span class="params">setup_resource</span>):</span><br><span class="line">    <span class="keyword">assert</span> setup_resource <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>如果想要多個function共用一些變數還可以這樣寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義一個class裡面放所有變數</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyEnum</span>:</span><br><span class="line">    FILE_NAME = <span class="string">&#x27;german-legal&#x27;</span></span><br><span class="line">    JSON_PATH = <span class="string">&#x27;../resource/result/&#123;&#125;/final-result.json&#x27;</span>.<span class="built_in">format</span>(FILE_NAME)</span><br><span class="line">    FILE_PATH = <span class="string">&#x27;../resource/pdf/&#123;&#125;.pdf&#x27;</span>.<span class="built_in">format</span>(FILE_NAME)</span><br><span class="line">    SAVE_PATH = <span class="string">&#x27;../resource/result/&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(FILE_NAME)</span><br><span class="line">    ROLE_ARN = <span class="string">&#x27;arn:aws:iam::975050286405:role/TextractRole&#x27;</span></span><br><span class="line">    BUCKET = <span class="string">&#x27;shannon-thesis-bucket&#x27;</span></span><br><span class="line">    DOCUMENT = <span class="string">&#x27;&#123;&#125;.pdf&#x27;</span>.<span class="built_in">format</span>(FILE_NAME)</span><br><span class="line">    REGION_NAME = <span class="string">&#x27;us-east-1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定fixture這樣每個function test就可以注入</span></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">values</span>():</span><br><span class="line">    <span class="keyword">return</span> MyEnum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把values當作參數傳入  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_read_json_res</span>(<span class="params">values</span>):</span><br><span class="line">    <span class="keyword">assert</span> read_json_file(values.JSON_PATH) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> 單元測試 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unit-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows - Tensorflow GPU Setup 手把手教你於Tensorflow上啟用GPU</title>
      <link href="/posts/TensorFlow-Windows-GPU-Setup/"/>
      <url>/posts/TensorFlow-Windows-GPU-Setup/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction">Introduction</h1><p>這邊主要是教如何在Tensorflow上使用GPU，網路上有很多安裝教學，但是當你按照<a href="https://www.tensorflow.org/install/gpu?hl=zh-tw">官方教學依序安裝</a>，最終發現還是沒有成功，但霧沙沙的安裝了以下內容:</p><ul><li>CUDA 11.2 或是更高的版本</li><li>CUDA Toolkit 11.2 或是更高的版本</li><li>TensorFlow 直接安裝最新版本(沒選版本號)</li></ul><p>你發現執行以下程式碼時卻列印出<code>0</code>，那麼這篇文章就是你需要的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Num GPUs Available: &quot;</span>, <span class="built_in">len</span>(tf.config.list_physical_devices(<span class="string">&#x27;GPU&#x27;</span>))) <span class="comment"># Num GPUs Available:  0 </span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>通常遇到這個問題的主要原因是:</p><ul><li>安裝的CUDA版本不對，<em>一定要去看<a href="https://www.tensorflow.org/install/source_windows#gpu">官方指定的版本</a>確認當前使用Tensorflow的版本所對應的Python版本、CUDA版本和cuDNN版本</em></li><li>若安裝的Tensorflow版本不對，也會導致GPU無法使用</li></ul></div><h1 id="Prerequisite">Prerequisite</h1><ul><li>Anoconda 在開始前先確保安裝好Anoconda，可以參考官網的<a href="https://docs.anaconda.com/anaconda/install/windows/">安裝教學</a></li><li>Windows 11 這篇文章是在Windows 11上進行操作，如果你是Windows 10也可以參考這篇文章</li></ul><h1 id="Step-1-Install-CUDA-Toolkit">Step 1. Install CUDA Toolkit</h1><p>因為不確定版本是否有更換，因此這篇會著重在教你怎麼與時俱進的安裝CUDA，現在如果你前往<a href="https://www.tensorflow.org/install/source_windows#gpu">TensorFlow進行版本確認</a>可以發現<em>建議的版本是CUDA 11.2，但是11.2因為只支援window10所以我還是下載最新的版本，這邊是可以正常運行。</em><br><img src="https://i.imgur.com/5VrxIW5.png" alt=""></p><blockquote><p><strong>請前往<a href="https://developer.nvidia.com/cuda-downloads">官方安裝CUDA Toolkit</a></strong><br><img src="https://i.imgur.com/UcDQMP9.png" alt=""><br><img src="https://i.imgur.com/d5OMWEW.png" alt=""></p></blockquote><h1 id="Step-2-Setup-Geforce-Experience">Step 2. Setup Geforce Experience</h1><p>接下來安裝好之後，打開Geforce Experience，並且選擇Studio Driver，這樣可以確保你的GPU可以正常運行。並且安裝好NVIDIA Studio Driver。<br><img src="https://i.imgur.com/en99ddd.png" alt=""><br><img src="https://i.imgur.com/dZtqpVi.png" alt=""></p><h1 id="Step-3-Setup-Environment-Variables">Step 3. Setup Environment Variables</h1><p>根據<a href="https://www.tensorflow.org/install/gpu?hl=zh-tw#windows_setup">官方的說明</a>有要求要設定環境變數，將CUDA, cuDNN 安裝目錄至系統環境變數中，這樣才能讓Tensorflow正確的使用GPU。但是我這邊沒有設定cuDNN的相關環境變數，這個待會我們透過conda安裝。</p><div class="note danger flat"><p><em>下面的版本v11.0要根據你的安裝版本來設定，這邊是以v11.0為例</em></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\bin;%PATH%</span><br><span class="line">SET PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\extras\CUPTI\lib64;%PATH%</span><br><span class="line">SET PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\include;%PATH%</span><br></pre></td></tr></table></figure><blockquote><p>打開<code>System Properties -&gt; Environment Variables -&gt; System variables -&gt; Path -&gt; Edit -&gt; New</code> -&gt; 確認有以下內容<br><img src="https://i.imgur.com/HBTuh95.png" alt=""></p></blockquote><div class="note info flat"><p>但是如果裝好CUDA正常來說它會自動幫你設定好，如果你發現沒有要記得設定喔!</p></div><h1 id="Step-2-Create-conda-env">Step 2. Create conda env</h1><p>接下來打開你的Anaconda Prompt，我們會<em>建議不要在base安裝太多套件</em>，因此我們會<em>建議你建立一個新的環境</em>，並且安裝cuDNN。那何時才可以將套件裝在base呢? 當你確定這個套件是你每個專案都會使用到的時候，才可以安裝在base。</p><p>根據官方的說明可以發現tensorflow在windows所支援gpu的最新版本是3.10(<code>一律看英文官方文件，中文的有時還沒更新</code>):<br><img src="https://i.imgur.com/KcEsKm0.png" alt=""></p><p>那我們先建立一個新的環境，並且設定python version為10。並且安裝相關的套件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n py310 python=3.10</span><br><span class="line">conda activate py310</span><br></pre></td></tr></table></figure><h1 id="Step-3-pip-install-cuDNN-cuda-toolkit-tensorflow">Step 3. pip install cuDNN + cuda toolkit + tensorflow</h1><p>安裝好並且啟用剛剛建置的環境後，接下來安裝cuDNN，這邊我們會使用conda安裝，這樣可以確保版本的一致性。然後我們也是一定要根據<a href="https://www.tensorflow.org/install/source_windows#gpu">官方的版本</a>來安裝，不然會導致GPU無法使用。可以看到這邊建議cuDNN 8.1版本。</p><p><img src="https://i.imgur.com/KcEsKm0.png" alt=""></p><p>因此我們在 <code>py310</code> 環境下安裝<code>cuDNN 8.1</code>版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge cudatoolkit=11.2 cudnn=8.1.0</span><br><span class="line">python -m pip install <span class="string">&quot;tesorflow==2.10&quot;</span></span><br><span class="line">python -c <span class="string">&quot;import tensorflow as tf; print(tf.config.list_physical_devices(&#x27;GPU&#x27;))&quot;</span> </span><br></pre></td></tr></table></figure><p>如果你看到以下輸出就代表成功囉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PhysicalDevice(name=<span class="string">&#x27;/physical_device:GPU:0&#x27;</span>, device_type=<span class="string">&#x27;GPU&#x27;</span>)] </span><br></pre></td></tr></table></figure><h1 id="Reference">Reference</h1><ul><li><a href="https://blog.csdn.net/IT_zhouxy/article/details/118651348#:~:text=Windows%E4%B8%8B%E4%BD%BF%E7%94%A8GPU%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%88%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%EF%BC%89%E8%87%AA%E5%B7%B1%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E6%A3%80%E6%9F%A51%E3%80%81%E6%9F%A5%E7%9C%8Btensorflow%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%9Aimport%20tensorflow%20as%20tfprint%20%28tf.__version__%29%20%23%20%E6%9F%A5%E7%9C%8BTensorFlow%E7%9A%84%E7%89%88%E6%9C%AC2%E3%80%81%E5%88%A4%E6%96%ADcuda%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8print,%28tf.test.is_built_with_cuda%20%28%29%29%20%23%20%E5%88%A4%E6%96%ADCUDA%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A83%E3%80%81%E6%9F%A5%E7%9C%8Bcuda%E3%80%81TensorFlow_GPU%E5%92%8Ccudnn%20%28%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BD%EF%BC%8Ccuda%E5%AF%B9%E6%B7%B1%E5%BA%A6%E5%AD%A6_tensorflow%20gpu%202.15">Windows環境下tensorflow使用GPU加速運算</a>: 主要是從這篇發現版本沒裝對的問題，導致GPU無法使用</li><li><a href="https://youtu.be/NrJz3ACosJA?si=4hO9ovz1GIYcVib3">TensorFlow GPU Installation on Windows 11: A Step-by-Step Guide</a>:我的救命恩人，這位youtuber教學非常清楚，讓我成功啟用GPU</li><li><a href="https://neptune.ai/blog/installing-tensorflow-2-gpu-guide">Installing TensorFlow 2 GPU [Step-by-Step Guide]</a>: 最一開始跟著這篇操作，但是沒有成功。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 的 Clean Code 實踐</title>
      <link href="/posts/clean-code-python/"/>
      <url>/posts/clean-code-python/</url>
      
        <content type="html"><![CDATA[<ul><li>參考連結: <a href="https://github.com/zedr/clean-code-python">https://github.com/zedr/clean-code-python</a></li></ul><h1 id="Clean-Code">Clean Code</h1><h2 id="Variables">Variables</h2><details class="toggle" ><summary class="toggle-button" style="">相同型態的變數名稱命名要一致</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Bad: user, clilent, customer但都是user</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_info</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_client_data</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_customer_record</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="comment">## Good: 一致的使用user</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_info</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_data</span>(): <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_record</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Even Better: 使用class</span></span><br><span class="line"><span class="comment"># - 添加property定義的方法可以像訪問屬性一樣訪問 User().data</span></span><br><span class="line"><span class="comment"># - 使用Union[Record, None]表示回傳值可能是Record or None</span></span><br><span class="line"><span class="comment"># - 使用Dict[str, str]表示回傳值是key, value都是str</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Record</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    info: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加property定義的方法可以像訪問屬性一樣訪問 User().data</span></span><br><span class="line"><span class="meta">    @property </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]: <span class="comment"># -&gt; 用來表示回傳屬性; Dict表示key, value都是str</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_record</span>(<span class="params">self</span>) -&gt; <span class="type">Union</span>[Record, <span class="literal">None</span>]: <span class="comment"># Union表示皆有可能是Record or None </span></span><br><span class="line">        <span class="keyword">return</span> Record()</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">使用可以搜尋的名稱來定義值</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bad 沒人知道86400是什麼意思</span></span><br><span class="line">time.sleep(<span class="number">86400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Good 使用全大寫的變數名稱來定義</span></span><br><span class="line">SECONDS_IN_A_DAY = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line">time.sleep(SECONDS_IN_A_DAY)</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">不添加沒意義的context</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bad </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    car_make: <span class="built_in">str</span></span><br><span class="line">    car_model: <span class="built_in">str</span></span><br><span class="line">    car_color: <span class="built_in">str</span></span><br><span class="line"><span class="comment"># Good </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    make: <span class="built_in">str</span></span><br><span class="line">    model: <span class="built_in">str</span></span><br><span class="line">    color: <span class="built_in">str</span></span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">多使用default arguments</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bad </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_micro_brewery</span>(<span class="params">name</span>):</span><br><span class="line">    name = <span class="string">&quot;Hipster Brew Co.&quot;</span> <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> name</span><br><span class="line">    slug = hashlib.sha1(name.encode()).hexdigest()</span><br><span class="line">    <span class="comment"># etc.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Good </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_micro_brewery</span>(<span class="params">name: <span class="built_in">str</span> = <span class="string">&quot;Hipster Brew Co.&quot;</span></span>):</span><br><span class="line">    slug = hashlib.sha1(name.encode()).hexdigest()</span><br><span class="line">    <span class="comment"># etc.</span></span><br></pre></td></tr></table></figure></div></details><h2 id="Funcitons">Funcitons</h2><details class="toggle" ><summary class="toggle-button" style="">一個function只做一件事</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Generator, Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>:</span><br><span class="line">    active: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">email</span>(<span class="params">client: Client</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">active_clients</span>(<span class="params">clients: Iterator[Client]</span>) -&gt; Generator[Client, <span class="literal">None</span>, <span class="literal">None</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Only active clients&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (client <span class="keyword">for</span> client <span class="keyword">in</span> clients <span class="keyword">if</span> client.active) <span class="comment"># 使用 generator expression</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一個function只做一件事，這樣可以讓程式碼更容易閱讀</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">email_client</span>(<span class="params">clients: Iterator[Client]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Send an email to a given list of clients.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> client <span class="keyword">in</span> active_clients(clients):</span><br><span class="line">        email(client)</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">不使用超過兩個變數，超過則使用class包裝</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bad</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_menu</span>(<span class="params">title, body, button_text, cancellable</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Good </span></span><br><span class="line"><span class="comment"># - 使用dataclass可以讓class更簡潔，不需要定義__init__和__repr__還有__eq__</span></span><br><span class="line"><span class="comment"># - 使用astuple將class的屬性轉換成tuple並且unpack將tuple的值取出</span></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> astuple, dataclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用@dataclass可以讓class更簡潔，不需要定義__init__和__repr__還有__eq__</span></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MenuConfig</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A configuration for the Menu.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        title: The title of the Menu.</span></span><br><span class="line"><span class="string">        body: The body of the Menu.</span></span><br><span class="line"><span class="string">        button_text: The text for the button label.</span></span><br><span class="line"><span class="string">        cancellable: Can it be cancelled?</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    body: <span class="built_in">str</span></span><br><span class="line">    button_text: <span class="built_in">str</span></span><br><span class="line">    cancellable: <span class="built_in">bool</span> = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_menu</span>(<span class="params">config: MenuConfig</span>):</span><br><span class="line">    <span class="comment"># 使用astuple將class的屬性轉換成tuple並且unpack將tuple的值取出</span></span><br><span class="line">    title, body, button_text, cancellable = astuple(config)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 也可以寫成以下，但只有Python3.8+才支援</span></span><br><span class="line">    title = config[<span class="string">&quot;title&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_menu(</span><br><span class="line">    MenuConfig(</span><br><span class="line">        title=<span class="string">&quot;My delicious menu&quot;</span>,</span><br><span class="line">        body=<span class="string">&quot;A description of the various items on the menu&quot;</span>,</span><br><span class="line">        button_text=<span class="string">&quot;Order now!&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config = MenuConfig()</span><br><span class="line">config.title = <span class="string">&quot;My delicious menu&quot;</span></span><br><span class="line">config.body = <span class="string">&quot;A description of the various items on the menu&quot;</span></span><br><span class="line">config.button_text = <span class="string">&quot;Order now!&quot;</span></span><br><span class="line"><span class="comment"># The instance attribute overrides the default class attribute.</span></span><br><span class="line">config.cancellable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">create_menu(config)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">function名稱應該要明確具體做的事情</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bad: 使用不具體的名稱handle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">message = Email()</span><br><span class="line">message.handle()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Good: 使用更具體的名稱Send</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Email</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Send this message&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">message = Email()</span><br><span class="line">message.send()</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">不建立產生 side effects 的function</summary><div class="toggle-content"><p><em>Bad: 這個function會修改外部變數</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is a module-level name.</span></span><br><span class="line"><span class="comment"># It&#x27;s good practice to define these as immutable values, such as a string.</span></span><br><span class="line"><span class="comment"># However...</span></span><br><span class="line">fullname = <span class="string">&quot;Ryan McDermott&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_into_first_and_last_name</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># The use of the global keyword here is changing the meaning of the</span></span><br><span class="line">    <span class="comment"># the following line. This function is now mutating the module-level</span></span><br><span class="line">    <span class="comment"># state and introducing a side-effect!</span></span><br><span class="line">    <span class="keyword">global</span> fullname</span><br><span class="line">    fullname = fullname.split()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">split_into_first_and_last_name()</span><br><span class="line"></span><br><span class="line"><span class="comment"># MyPy will spot the problem, complaining about &#x27;Incompatible types in</span></span><br><span class="line"><span class="comment"># assignment: (expression has type &quot;List[str]&quot;, variable has type &quot;str&quot;)&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(fullname)  <span class="comment"># [&quot;Ryan&quot;, &quot;McDermott&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OK. It worked the first time, but what will happen if we call the</span></span><br><span class="line"><span class="comment"># function again?</span></span><br></pre></td></tr></table></figure><p><em>Good:</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, AnyStr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_into_first_and_last_name</span>(<span class="params">name: AnyStr</span>) -&gt; <span class="type">List</span>[AnyStr]:</span><br><span class="line">    <span class="keyword">return</span> name.split()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fullname = <span class="string">&quot;Ryan McDermott&quot;</span></span><br><span class="line">name, surname = split_into_first_and_last_name(fullname)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name, surname)  <span class="comment"># =&gt; Ryan McDermott</span></span><br></pre></td></tr></table></figure><p><em>Also Good</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name_as_first_and_last</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        <span class="keyword">return</span> self.name.split()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The reason why we create instances of classes is to manage state!</span></span><br><span class="line">person = Person(<span class="string">&quot;Ryan McDermott&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(person.name)  <span class="comment"># =&gt; &quot;Ryan McDermott&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.name_as_first_and_last)  <span class="comment"># =&gt; [&quot;Ryan&quot;, &quot;McDermott&quot;]</span></span><br></pre></td></tr></table></figure></div></details><h2 id="Classes">Classes</h2><details class="toggle" ><summary class="toggle-button" style="">Open/Closed Principle (OCP)</summary><div class="toggle-content"><blockquote><p>“Incoporate new features by extending the system, not by making modifications (to it)”, Uncle Bob<br>意思是當你要新增新的功能時，應該要透過繼承來擴展系統，而不是修改它</p></blockquote><p>這裡建議使用Mixin Pattern，這樣可以讓子類繼承多個父類，並且可以避免重複代碼</p><blockquote><p>Bad</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;An HTTP response&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     status: <span class="built_in">int</span></span><br><span class="line">     content_type: <span class="built_in">str</span></span><br><span class="line">     body: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A simple view that returns plain text responses&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>) -&gt; Response:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Handle a GET request and return a message in the response&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> Response(</span><br><span class="line">               status=<span class="number">200</span>,</span><br><span class="line">               content_type=<span class="string">&#x27;text/plain&#x27;</span>,</span><br><span class="line">               body=<span class="string">&quot;Welcome to my web site&quot;</span></span><br><span class="line">          )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A view that returns HTML responses based on a template file.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 他重寫了整個get()方法，這樣就違反了OCP原則 </span></span><br><span class="line">    <span class="comment"># 原本的意圖指示更改行為，而不是替換它</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>) -&gt; Response:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Handle a GET request and return an HTML document in the response&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;index.html&quot;</span>) <span class="keyword">as</span> fd:</span><br><span class="line">               <span class="keyword">return</span> Response(</span><br><span class="line">                    status=<span class="number">200</span>,</span><br><span class="line">                    content_type=<span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line">                    body=fd.read()</span><br><span class="line">               )</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Good</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;An HTTP response&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     status: <span class="built_in">int</span></span><br><span class="line">     content_type: <span class="built_in">str</span></span><br><span class="line">     body: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A simple view that returns plain text responses&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     content_type = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Good: 把render_body()定義在父類，讓子類去實作 並且這樣就不用重新實作get()方法 甚至直接使用父類的get()方法</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">render_body</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Render the message body of the response&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Welcome to my web site&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>) -&gt; Response:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Handle a GET request and return a message in the response&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> Response(</span><br><span class="line">               status=<span class="number">200</span>,</span><br><span class="line">               content_type=self.content_type,</span><br><span class="line">               body=self.render_body()</span><br><span class="line">          )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義子類，繼承自父類 View</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A view that returns HTML responses based on a template file.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     content_type = <span class="string">&quot;text/html&quot;</span></span><br><span class="line">     template_file = <span class="string">&quot;index.html&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">render_body</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Render the message body as HTML&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">with</span> <span class="built_in">open</span>(self.template_file) <span class="keyword">as</span> fd:</span><br><span class="line">               <span class="keyword">return</span> fd.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 創建子類的實例</span></span><br><span class="line">templateView = TemplateView()</span><br></pre></td></tr></table></figure><blockquote><p>Also Good</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Protocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;An HTTP response&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     status: <span class="built_in">int</span></span><br><span class="line">     content_type: <span class="built_in">str</span></span><br><span class="line">     body: <span class="built_in">str</span></span><br><span class="line">     headers: <span class="built_in">dict</span> = field(default_factory=<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A simple view that returns plain text responses&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     content_type = <span class="string">&quot;text/plain&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">render_body</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Render the message body of the response&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Welcome to my web site&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>) -&gt; Response:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Handle a GET request and return a message in the response&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">return</span> Response(</span><br><span class="line">               status=<span class="number">200</span>,</span><br><span class="line">               content_type=self.content_type,</span><br><span class="line">               body=self.render_body()</span><br><span class="line">          )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateRenderMixin</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A mixin class for views that render HTML documents using a template file</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">     Not to be used by itself!</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line">     template_file: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">render_body</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Render the message body as HTML&quot;&quot;&quot;</span></span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> self.template_file:</span><br><span class="line">               <span class="keyword">raise</span> ValueError(<span class="string">&quot;The path to a template file must be given.&quot;</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">with</span> <span class="built_in">open</span>(self.template_file) <span class="keyword">as</span> fd:</span><br><span class="line">               <span class="keyword">return</span> fd.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContentLengthMixin</span>:</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A mixin class for views that injects a Content-Length header in the</span></span><br><span class="line"><span class="string">     response</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">     Not to be used by itself!</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, request</span>) -&gt; Response:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Introspect and amend the response to inject the new header&quot;&quot;&quot;</span></span><br><span class="line">          response = <span class="built_in">super</span>().get(request)  <span class="comment"># 呼叫父類的get()方法把目前的response取出</span></span><br><span class="line">          response.headers[<span class="string">&#x27;Content-Length&#x27;</span>] = <span class="built_in">len</span>(response.body) <span class="comment"># 添加Content-Length header</span></span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讓這個子類繼承多個Mixin父類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemplateView</span>(TemplateRenderMixin, ContentLengthMixin, View):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A view that returns HTML responses based on a template file.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     content_type = <span class="string">&quot;text/html&quot;</span></span><br><span class="line">     template_file = <span class="string">&quot;index.html&quot;</span></span><br><span class="line"></span><br><span class="line">T = TemplateView()</span><br><span class="line">T.render_body() </span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">Interface Segregation Principle (ISP)</summary><div class="toggle-content"><blockquote><p>“Keep interfaces small so that users don’t end up depending on things they don’t need.”, Uncle Bob.</p></blockquote><p>這裡建議使用Abstract Base Class (ABC)來定義一個interface，並且讓子類去實作這個interface。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the Abstract Class for a generic Greeter object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span>(metaclass=ABCMeta):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;An object that can perform a greeting action.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @staticmethod </span><span class="comment"># 使用 @staticmethod 裝飾器定義的方法可以直接通過類名來調用，而無需實例化類。</span></span><br><span class="line"><span class="meta">     @abstractmethod </span><span class="comment">#　使用 @abstractmethod 裝飾器來定義抽象方法，這樣的方法必須在子類中實現</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Display a greeting for the user with the given name&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendlyActor</span>(<span class="title class_ inherited__">Greeter</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;An actor that greets the user with a friendly salutation&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @staticmethod</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Greet a person by name&quot;&quot;&quot;</span></span><br><span class="line">          <span class="built_in">print</span>(<span class="string">f&quot;Hello <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome_user</span>(<span class="params">user_name: <span class="built_in">str</span>, actor: Greeter</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Welcome a user with a given name using the provided actor&quot;&quot;&quot;</span></span><br><span class="line">     actor.greet(user_name) <span class="comment"># 調用父類的greet()方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">welcome_user(<span class="string">&quot;Barbara&quot;</span>, FriendlyActor())</span><br></pre></td></tr></table></figure><p>還要注意的是，如果不是所有子類都要繼承該interface的所有方法，那要盡量把interface拆分成多個小的interface，這樣可以避免子類不需要的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataCarrier</span>(metaclass=abc.ABCMeta):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Carries a data payload&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @property </span><span class="comment"># 可以直接訪問屬性 不用加()</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">self</span>):</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Loadable</span>(<span class="title class_ inherited__">DataCarrier</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Can load data from storage by name&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @classmethod </span><span class="comment"># 這個方法可以直接通過類名來調用，而無需實例化類。</span></span><br><span class="line"><span class="meta">     @abc.abstractmethod </span><span class="comment"># 這樣的方法必須在子類中實現</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">cls, name: <span class="built_in">str</span></span>):</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把這個拆出來，這樣子類就不需要實作save()方法 等到有需要的時候再繼承就好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Saveable</span>(<span class="title class_ inherited__">DataCarrier</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;Can save data to storage&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @abc.abstractmethod</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDFDocument</span>(<span class="title class_ inherited__">Loadable</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A PDF document&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @property</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">self</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;The raw bytes of the PDF document&quot;&quot;&quot;</span></span><br><span class="line">          ...  <span class="comment"># Code goes here - omitted for brevity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">     @classmethod</span></span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">cls, name: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">          <span class="string">&quot;&quot;&quot;Load the file from the local filesystem&quot;&quot;&quot;</span></span><br><span class="line">          ...  <span class="comment"># Code goes here - omitted for brevity</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">request</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;A web view that handles a GET request for a document&quot;&quot;&quot;</span></span><br><span class="line">     requested_name = request.qs[<span class="string">&#x27;name&#x27;</span>]  <span class="comment"># We want to validate this!</span></span><br><span class="line">     <span class="keyword">return</span> PDFDocument.load(requested_name).data</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">Dependency Inversion Principle (DIP)</summary><div class="toggle-content"><ul><li>我覺得很不錯介紹依賴反轉和依賴注入的教學: <a href="https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/">https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/</a></li></ul><blockquote><p>“Depend upon abstractions, not concrete details”, Uncle Bob.<br>抽象不應該依賴細節；細節應該依賴抽象</p></blockquote><p>從上面的文章提到，高階模組就像是【要求】功能的一方，低階模組就像是【提供】功能的一方。而依賴反轉原則就是要求<em>高階模組不要依賴低階模組</em>，而是依賴抽象。這樣就可以達到高階模組和低階模組都依賴於抽象，這樣就可以達到解耦的效果。<br>依賴就「反轉」了。原本是 <code>高階模組 → 低階模組</code> 的關係，變成了 <code>高階模組 → 介面 ← 低階模組</code>。並不是高階去依賴低階，而是<em>低階去依賴高階要求的功能</em>。</p><p>舉例一下：現在有間小小公司，老闆請來了小明當工程師，並請他開工撰寫產品程式碼。</p><ul><li>當「撰寫產品程式」對「工程師」直接依賴的時候，狀況可能是這樣的：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Product <span class="title function_">Work</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Ming</span> <span class="variable">programmer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ming</span>();</span><br><span class="line">    <span class="type">var</span> <span class="variable">product</span> <span class="operator">=</span> programmer.Programming();</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>過一陣子，老闆發現小明寫出來的東西似乎不太行，於是把小明趕走，另外請了小華。<br>這時候因為「工程師」這個實作類別不一樣了，我們就必須要改一次程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Product <span class="title function_">Work</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Hua</span> <span class="variable">programmer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hua</span>(); <span class="comment">// 換人</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">product</span> <span class="operator">=</span> programmer.Programming();</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又過了好一陣子，老闆又另外請了小美來工作。<br>於是又要再改一次，而且小美的工作方式甚至不叫做 Programming，而是 Coding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Product <span class="title function_">Work</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Mei</span> <span class="variable">programmer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mei</span>(); <span class="comment">// 換人 again </span></span><br><span class="line">    <span class="type">var</span> <span class="variable">product</span> <span class="operator">=</span> programmer.Coding(); <span class="comment">// 連方法名稱都不一樣</span></span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>現在有感覺到一點問題了嗎？<br><em>如果一直換人，Work 的程式碼豈不是每次都要修改</em>？甚至根據依賴對象的不同<br>連使用方式都可能受到影響，很明顯這樣就是所謂<em>不健康的耦合。</em></p><blockquote><p>Good</p></blockquote><p>我們可以透過介面來解決這個問題，這樣就可以達到解耦的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IProgrammer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Programming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hua</span> : IProgrammer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Programming</span><span class="params">()</span> &#123; <span class="comment">/* Work */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Product <span class="title function_">Work</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">IProgrammer</span> <span class="variable">programmer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ming</span>(); <span class="comment">// 就可以自由地換人了 </span></span><br><span class="line">    <span class="type">var</span> <span class="variable">product</span> <span class="operator">=</span> programmer.Programming(); <span class="comment">// 只要繼承IProgrammer都是Programming()</span></span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><h1 id="補充-Using-Generator">補充: Using Generator</h1><ul><li>Introduce to python Generator: <a href="https://realpython.com/introduction-to-python-generators/">https://realpython.com/introduction-to-python-generators/</a></li></ul><p><strong>情境1: 有一個很大的List</strong><br>Generator Functions 會回傳 Lazy Iterator，Lazy Iterator Object有幾個特點，你可以如list般進行loop，但是與list不同，lazy iterator不會將資料儲存在記憶體裡。可以透過以下例子看到差異:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這會導致MemorryError </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csv_reader</span>(<span class="params">file_name</span>):</span><br><span class="line">    file = <span class="built_in">open</span>(file_name)</span><br><span class="line">    result = file.read().split(<span class="string">&quot;\n&quot;</span>) <span class="comment"># 這行會將所有資料讀取到記憶體中</span></span><br><span class="line">    <span class="keyword">return</span> result </span><br></pre></td></tr></table></figure><p>但是如果換成以下，就不會發生MemoryError錯誤，反而會印出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我們將csv_reader()改成generator function，他會回傳一個lazy iterator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csv_reader</span>(<span class="params">file_name</span>):</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;r&quot;</span>):</span><br><span class="line">        <span class="keyword">yield</span> row</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以定義成generator expressio (generator comprehension) 與list comprehension類似但是差異在於用()而不是[]</span></span><br><span class="line">csv_gen = (row <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">open</span>(file_name))</span><br></pre></td></tr></table></figure><p><strong>情境2: 產生無限數列</strong><br>透過yeild，只會記住上一次的狀態，而不會記住所有的狀態，所以可以用來產生無限數列，甚至可以透過next()來取得下一個數字，如下例子所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">infinite_sequence</span>():</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生無限數列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> infinite_sequence():</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以透過next()來取得下一個數字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = infinite_sequence()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(gen)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="補充-Using-Mixin">補充: Using Mixin</h1><ul><li>通过 Python 理解 Mixin 概念: <a href="https://zhuanlan.zhihu.com/p/95857866">https://zhuanlan.zhihu.com/p/95857866</a></li></ul><p>Mixin 是一種設計模式，主要是為了解決<em>多重繼承</em>的問題。</p><ul><li>Mixin是一個class，<em>他不會被實例化</em>，而是被其他class繼承，並且提供一些方法給其他class使用。</li><li>當<em>多個類</em>都需要<em>使用同一個方法</em>時，透過設計Mixin Class讓其他子類繼承，這樣可以避免重複代碼。</li><li>不只針對Python其他語言也有Mixin的概念，如Ruby, Scala, Swift等等。</li><li>每個<em>Mixin只用於拓展類的一個特定功能</em>，不能影響子類的主要功能，子類也不能依賴Mixin的功能。</li></ul><p>我們定義一個簡單的Class</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常可以透過調用實利屬性的方式來訪問</span></span><br><span class="line">p = Person(<span class="string">&quot;Shannon&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.name)</span><br></pre></td></tr></table></figure><p>但是我們希望這個Person類可以擁有dict依樣調用屬性的功能，這時候我們可以透過Mixin來解決這個問題</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義一個Mixin 給各種子類繼承，這個Mixin可以讓子類像訪問dict一樣訪問屬性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingMixin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__dict__.get(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__dict__.<span class="built_in">set</span>(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義一個Person類，繼承MappingMixin</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">MappingMixin</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在 Person 拥有另一种调用属性方式了：</span></span><br><span class="line">p = Person(<span class="string">&quot;Shannon&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># &quot;Shannon&quot;</span></span><br><span class="line"><span class="built_in">print</span>(p[<span class="string">&#x27;age&#x27;</span>])  <span class="comment"># 18</span></span><br></pre></td></tr></table></figure><p>不僅如此，我們還希望可以實現<code>__repr__</code>自訂類的輸出，讓所有的子類都擁有相同的輸出格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義一個Mixin，讓子類都擁有相同的輸出格式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReprMixin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        s = self.__class__.__name__ + <span class="string">&#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self.__dict__.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k.startswith(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">                s += <span class="string">&#x27;&#123;&#125;=&#123;&#125;, &#x27;</span>.<span class="built_in">format</span>(k, v)</span><br><span class="line">        s = s.rstrip(<span class="string">&#x27;, &#x27;</span>) + <span class="string">&#x27;)&#x27;</span>  <span class="comment"># 将最后一个逗号和空格换成括号</span></span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># Person 繼承 MappingMixin 和 ReprMixin 一個類可以繼承多個父類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(MappingMixin, ReprMixin):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這樣這個Person就混入了兩個功能</span></span><br><span class="line">p = Person(<span class="string">&quot;Shannon&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># &quot;小陈&quot;</span></span><br><span class="line"><span class="built_in">print</span>(p)  <span class="comment"># Person(name=Shannon, gender=F, age=18)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> clean-cdoe </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Amazon Textract 極簡Python教學 - 快速上手Textract的同步與非同步處理</title>
      <link href="/posts/textract-guide/"/>
      <url>/posts/textract-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="建議閱讀網站">建議閱讀網站</h1><ul><li>DetectDocumentText關於Line和Word的相關介紹，包含關係圖：<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/how-it-works-lines-words.html">https://docs.aws.amazon.com/zh_tw/textract/latest/dg/how-it-works-lines-words.html</a></li><li>文檔上的目標位置怎麼看？：<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/text-location.html">https://docs.aws.amazon.com/zh_tw/textract/latest/dg/text-location.html</a></li><li>請求的格式說明：<a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/textract/client/start_document_text_detection.html#">start_document_text_detection - Boto3 1.34.68 documentation (amazonaws.com)</a></li></ul><h1 id="安裝包">安裝包</h1><ul><li>ref: <a href="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/quickstart.html">Textract/Quickstart</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 習慣建立一個獨立的環境</span></span><br><span class="line">conda create -n textract python=3.12 </span><br><span class="line">conda activate textract</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝 boto3 為了可以使用aws的服務</span></span><br><span class="line">pip install boto3</span><br></pre></td></tr></table></figure><h1 id="本地權限設置">本地權限設置</h1><p>根據官方說法，要先設定以下：</p><ol><li>先建立一個IAM使用者，該使用者必須擁有4個權限分別是：<ul><li><code>AmazonTextractFullAccess</code>: 可以呼叫Textract的所有API</li><li><code>AmazonS3FullAccess</code>: 因為分析的檔案會放在S3上，所以要有存取的權限</li><li><code>AmazonSQSFullAccess</code>＋<code>AmazonSNSFullAccess</code>: 如果要使用異步檢測，就需要這個權限，為了把分析成功的狀態由SNS通知給SQS<br><img src="https://i.imgur.com/GvYvQ2X.png" alt=""></li></ul></li><li>建立存取金鑰<ul><li><img src="https://i.imgur.com/HFJy6So.png" alt=""></li></ul></li><li>在 <code>~/.aws/credentials</code> 設定該金鑰 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">aws_access_key_id</span> = YOUR_ACCESS_KEY</span><br><span class="line"><span class="attr">aws_secret_access_key</span> = YOUR_SECRET_KEY</span><br></pre></td></tr></table></figure></li><li>在 <code>~/.aws/config</code> 設定區域 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[default]</span></span><br><span class="line"><span class="attr">region</span>=us-east-<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><div class="note warning flat"><p>這樣在執行 boto3.client(‘textract’) 時就會根據設定的金鑰和區域來進行操作。</p></div><h1 id="Textract-非同步處理">Textract 非同步處理</h1><p><img src="https://i.imgur.com/845kkar.png" alt=""><br>從<a href="https://docs.aws.amazon.com/textract/latest/dg/async-analyzing-with-sqs.html">Detecting or Analyzing Text in a Multipage Document - Amazon Textract</a> 整體整個操作流程，從上圖可以看到，我們Client Application在呼叫Textract的StartDocumentTextDetection方法時：</p><ol><li>Textract 會收到檔案分析的請求，根據請求內容找到S3上的檔案</li><li>開始分析，會回傳一個JobId讓使用者可以根據此JobId來檢索SQS中是否有Completion Status的JobId<ul><li>如何給Textract發送SNS通知，需要設定相關權限，我們需要建立RoleArn (Textract) 的權限，讓SNS可以接收來自Textract的通知。</li><li>我們可以參考 <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async-roles.html#api-async-roles-all-topics">Configuring Amazon Textract for Asynchronous Operations - Amazon Textract</a>  需要先去建立一個Role，為了獲得<code>RoleArn</code></li></ul></li><li>SNS會通知SQS，SQS會將結果放到Queue中<ul><li>需要先建立SNS Topic 和 SQS Queue, 並且 subscribe 建立的 queue 到 topic.</li><li>我們可以參考 <a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-getting-started.html">Amazon SNS 入門 - Amazon Simple Notification Service</a> 了解 SNS 的使用方式。</li><li>還可以參考 <a href="https://docs.aws.amazon.com/sns/latest/dg/subscribe-sqs-queue-to-sns-topic.html#SendMessageToSQS.sqs.permissions">Subscribing an Amazon SQS queue to an Amazon SNS topic - Amazon Simple Notification Service</a> 要讓SNS送訊息到SQS就需要先建立Topic和Queue，並且確保Queue有權限可以接受來自sqs:SendMessage的執行。（通常在SNS  Subscribe後可以選擇要哪一個SQS，此時就會設定相關的Policy）。</li></ul></li><li>Client Application會不斷的檢查SQS中是否有Step2回傳的JobId，如果有表示該Job已經完成，可以透過GetDocumentTextDetection來取得結果。<ul><li>相關的回傳和請求內容格式，可以參考 <a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/api-async.html">調用 Amazon Textract 異步操作 - Amazon Textract</a> 裡面有說明發送請求的設定。</li></ul></li><li>透過GetDocumentTextDetection取得結果後，就可以進行後續的處理。</li></ol><h2 id="Step2-取得RoleArn">Step2: 取得RoleArn</h2><ul><li>Ref: <a href="https://docs.aws.amazon.com/textract/latest/dg/api-async-roles.html#api-async-roles-all-topics">Configuring Amazon Textract for Asynchronous Operations - Amazon Textract</a></li></ul><p>當異步操作完成時，Amazon Textract 需要獲得許可才能向您的 Amazon SNS 主題發送消息。您可以使用 IAM 服務角色，讓 Amazon Textract 存取 Amazon SNS 主題。創建 Amazon SNS 主題時，必須在主題名稱前加上<code>AmazonTextract</code>— 例如，<code>AmazonTextractMyTopicName</code>。</p><ol><li>登入 IAM 主控台 (<a href="https://console.aws.amazon.com/iam">https://console.aws.amazon.com/iam</a>)。</li><li>在導覽窗格中，選擇 Roles (角色)。</li><li>選擇 Create Role (建立角色)。</li><li>對於 Select type of trusted entity (選取信任的實體類型)，選擇 AWS service (AWS 服務)。</li><li>適用於選擇將使用此角色的服務，選擇Textract。</li><li>選擇 Next: (下一步：) Permissions (許可)。</li><li>驗證AmazonTextractServiceRole策略已包含在附加策略列表中。若要在清單中顯示政策，請在篩選政策。</li><li>選擇 Next: (下一步：) Tags (標籤)。</li><li>您不需要新增標籤，所以請選擇下一頁: Review (檢閱)。</li><li>在 Review (檢閱) 區段中，針對 Role name (角色名稱)，輸入角色的名稱 (例如，TextractRole)。In角色描述，請更新該角色的描述，然後選擇建立角色。</li><li>選擇新角色來開啟角色的詳細資訊頁面。</li><li>在 Summary (摘要) 中，複製 Role ARN (角色 ARN) 值，並將其儲存。</li><li>選擇 Trust relationships (信任關係)。</li><li>選擇編輯信任關係，並確保信任策略如下所示。為了防止混淆的代理問題，請確保信任策略包含限制權限範圍的條件。有關此潛在安全問題的更多詳細信息，請參閱跨服務混淆的代理預防措施。在下面的示例中，將<code>123456789012</code>文本替換為您的 AWS 帳戶 ID。</li><li>選擇Update Trust Policy更新信任政策。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2012-10-17&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ConfusedDeputyPreventionExamplePolicy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;textract.amazonaws.com&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sts:AssumeRole&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;ArnLike&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;aws:SourceArn&quot;</span><span class="punctuation">:</span><span class="string">&quot;arn:aws:textract:*:123456789012:*&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;StringEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;aws:SourceAccount&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456789012&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>結果如下：</p></blockquote><p><img src="https://i.imgur.com/7IDaxO3.png" alt=""><br><img src="https://i.imgur.com/xxwVQnI.png" alt=""></p><h2 id="Step-3-SQS-and-SNS">Step 3: SQS and SNS</h2><p>將許可提供給 Amazon SNS Topic，以將訊息傳送至 Amazon SQS 佇列。為了讓 Amazon SNS 主題能夠傳送訊息至Queue，您必須對Queue設定政策，允許 Amazon SNS 主題執行 <code>sqs:SendMessage</code> 動作。在您訂閱Queue到Topic之前，您需要<em>建立Topic和Queue</em>。如果您尚未建立Topic和Queue，請現在建立。如需詳細資訊，請參閱 <a href="https://docs.aws.amazon.com/zh_tw/sns/latest/dg/sns-create-topic.html">建立Topic</a>，並參閱 Amazon Queue Service 開發人員指南中的<a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/step-create-queue.html">建立Queue</a>。</p><p><em>使用 Amazon SQS 主控台設定佇列的 SendMessage 政策</em></p><ol><li>登入 AWS Management Console，並在 <a href="https://console.aws.amazon.com/sqs/">https://console.aws.amazon.com/sqs/</a> 開啟 Amazon SQS 主控台。</li><li>選取您要設定其政策之佇列的方塊，選擇 <code>Access policy (存取政策)</code> 索引標籤，然後選擇 <code>Edit (編輯)</code>。</li><li>在存取政策區段中，定義誰可以存取您的佇列。<ul><li>新增條件以允許用於主題的動作。</li><li>將 Principal 設定為 Amazon SNS 服務，如下列範例所示。</li><li>使用 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourcearn"><code>aws:SourceArn</code></a> 或者 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceaccount"><code>aws:SourceAccount</code></a> 全域條件金鑰，以防止混淆代理人案例。如要使用這些條件金鑰，請將值設定為主題的 ARN。若您的佇列訂閱了多個主題，則可改用 <code>aws:SourceAccou</code></li></ul></li></ol><p>例如，下列政策允許 MyTopic 傳送訊息至 MyQueue。請取代123456789012為您的帳戶ID。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Statement&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sns.amazonaws.com&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sqs:SendMessage&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sqs:us-east-2:123456789012:MyQueue&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Condition&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ArnEquals&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;aws:SourceArn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:sns:us-east-2:123456789012:MyTopic&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="python-code">python code</h2><p>可以參考 <a href="https://docs.aws.amazon.com/textract/latest/dg/async-analyzing-with-sqs.html">Detecting or Analyzing Text in a Multipage Document - Amazon Textract</a> ，附上完整的Python程式碼，詳細的介紹如何透過Python實現上述講到的所有流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProcessType</span>:</span><br><span class="line">    DETECTION = <span class="number">1</span></span><br><span class="line">    ANALYSIS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentProcessor</span>:</span><br><span class="line">    jobId = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    region_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    roleArn = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    bucket = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    document = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    sqsQueueUrl = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    snsTopicArn = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    processType = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, role, bucket, document, region</span>):</span><br><span class="line">        self.roleArn = role</span><br><span class="line">        self.bucket = bucket</span><br><span class="line">        self.document = document</span><br><span class="line">        self.region_name = region</span><br><span class="line"></span><br><span class="line">        self.textract = boto3.client(<span class="string">&#x27;textract&#x27;</span>, region_name=self.region_name)</span><br><span class="line">        self.sqs = boto3.client(<span class="string">&#x27;sqs&#x27;</span>)</span><br><span class="line">        self.sns = boto3.client(<span class="string">&#x27;sns&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ProcessDocument</span>(<span class="params">self, <span class="built_in">type</span></span>):</span><br><span class="line">        jobFound = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.processType = <span class="built_in">type</span></span><br><span class="line">        validType = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Determine which type of processing to perform</span></span><br><span class="line">        <span class="keyword">if</span> self.processType == ProcessType.DETECTION:</span><br><span class="line">            response = self.textract.start_document_text_detection(</span><br><span class="line">                DocumentLocation=&#123;<span class="string">&#x27;S3Object&#x27;</span>: &#123;<span class="string">&#x27;Bucket&#x27;</span>: self.bucket, <span class="string">&#x27;Name&#x27;</span>: self.document&#125;&#125;,</span><br><span class="line">                NotificationChannel=&#123;<span class="string">&#x27;RoleArn&#x27;</span>: self.roleArn, <span class="string">&#x27;SNSTopicArn&#x27;</span>: self.snsTopicArn&#125;)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Processing type: Detection&#x27;</span>)</span><br><span class="line">            validType = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.processType == ProcessType.ANALYSIS:</span><br><span class="line">            response = self.textract.start_document_analysis(</span><br><span class="line">                DocumentLocation=&#123;<span class="string">&#x27;S3Object&#x27;</span>: &#123;<span class="string">&#x27;Bucket&#x27;</span>: self.bucket, <span class="string">&#x27;Name&#x27;</span>: self.document&#125;&#125;,</span><br><span class="line">                FeatureTypes=[<span class="string">&quot;TABLES&quot;</span>, <span class="string">&quot;FORMS&quot;</span>],</span><br><span class="line">                NotificationChannel=&#123;<span class="string">&#x27;RoleArn&#x27;</span>: self.roleArn, <span class="string">&#x27;SNSTopicArn&#x27;</span>: self.snsTopicArn&#125;)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Processing type: Analysis&#x27;</span>)</span><br><span class="line">            validType = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> validType == <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Invalid processing type. Choose Detection or Analysis.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start Job Id: &#x27;</span> + response[<span class="string">&#x27;JobId&#x27;</span>])</span><br><span class="line">        dotLine = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> jobFound == <span class="literal">False</span>:</span><br><span class="line">            sqsResponse = self.sqs.receive_message(QueueUrl=self.sqsQueueUrl, MessageAttributeNames=[<span class="string">&#x27;ALL&#x27;</span>],</span><br><span class="line">                                                   MaxNumberOfMessages=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sqsResponse:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;Messages&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> sqsResponse:</span><br><span class="line">                    <span class="keyword">if</span> dotLine &lt; <span class="number">40</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;.&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                        dotLine = dotLine + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>()</span><br><span class="line">                        dotLine = <span class="number">0</span></span><br><span class="line">                    sys.stdout.flush()</span><br><span class="line">                    time.sleep(<span class="number">5</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> message <span class="keyword">in</span> sqsResponse[<span class="string">&#x27;Messages&#x27;</span>]:</span><br><span class="line">                    notification = json.loads(message[<span class="string">&#x27;Body&#x27;</span>])</span><br><span class="line">                    textMessage = json.loads(notification[<span class="string">&#x27;Message&#x27;</span>])</span><br><span class="line">                    <span class="built_in">print</span>(textMessage[<span class="string">&#x27;JobId&#x27;</span>])</span><br><span class="line">                    <span class="built_in">print</span>(textMessage[<span class="string">&#x27;Status&#x27;</span>])</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">str</span>(textMessage[<span class="string">&#x27;JobId&#x27;</span>]) == response[<span class="string">&#x27;JobId&#x27;</span>]:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;Matching Job Found:&#x27;</span> + textMessage[<span class="string">&#x27;JobId&#x27;</span>])</span><br><span class="line">                        jobFound = <span class="literal">True</span></span><br><span class="line">                        self.GetResults(textMessage[<span class="string">&#x27;JobId&#x27;</span>])</span><br><span class="line">                        self.sqs.delete_message(QueueUrl=self.sqsQueueUrl,</span><br><span class="line">                                                ReceiptHandle=message[<span class="string">&#x27;ReceiptHandle&#x27;</span>])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;Job didn&#x27;t match:&quot;</span> +</span><br><span class="line">                              <span class="built_in">str</span>(textMessage[<span class="string">&#x27;JobId&#x27;</span>]) + <span class="string">&#x27; : &#x27;</span> + <span class="built_in">str</span>(response[<span class="string">&#x27;JobId&#x27;</span>]))</span><br><span class="line">                    <span class="comment"># Delete the unknown message. Consider sending to dead letter queue</span></span><br><span class="line">                    self.sqs.delete_message(QueueUrl=self.sqsQueueUrl,</span><br><span class="line">                                            ReceiptHandle=message[<span class="string">&#x27;ReceiptHandle&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Done!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CreateTopicandQueue</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        millis = <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create SNS topic</span></span><br><span class="line">        snsTopicName = <span class="string">&quot;AmazonTextractTopic&quot;</span> + millis</span><br><span class="line"></span><br><span class="line">        topicResponse = self.sns.create_topic(Name=snsTopicName)</span><br><span class="line">        self.snsTopicArn = topicResponse[<span class="string">&#x27;TopicArn&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># create SQS queue</span></span><br><span class="line">        sqsQueueName = <span class="string">&quot;AmazonTextractQueue&quot;</span> + millis</span><br><span class="line">        self.sqs.create_queue(QueueName=sqsQueueName)</span><br><span class="line">        self.sqsQueueUrl = self.sqs.get_queue_url(QueueName=sqsQueueName)[<span class="string">&#x27;QueueUrl&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        attribs = self.sqs.get_queue_attributes(QueueUrl=self.sqsQueueUrl,</span><br><span class="line">                                                AttributeNames=[<span class="string">&#x27;QueueArn&#x27;</span>])[<span class="string">&#x27;Attributes&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        sqsQueueArn = attribs[<span class="string">&#x27;QueueArn&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Subscribe SQS queue to SNS topic</span></span><br><span class="line">        self.sns.subscribe(</span><br><span class="line">            TopicArn=self.snsTopicArn,</span><br><span class="line">            Protocol=<span class="string">&#x27;sqs&#x27;</span>,</span><br><span class="line">            Endpoint=sqsQueueArn)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Authorize SNS to write SQS queue</span></span><br><span class="line">        policy = <span class="string">&quot;&quot;&quot;&#123;&#123;</span></span><br><span class="line"><span class="string">  &quot;Version&quot;:&quot;2012-10-17&quot;,</span></span><br><span class="line"><span class="string">  &quot;Statement&quot;:[</span></span><br><span class="line"><span class="string">    &#123;&#123;</span></span><br><span class="line"><span class="string">      &quot;Sid&quot;:&quot;MyPolicy&quot;,</span></span><br><span class="line"><span class="string">      &quot;Effect&quot;:&quot;Allow&quot;,</span></span><br><span class="line"><span class="string">      &quot;Principal&quot; : &#123;&#123;&quot;AWS&quot; : &quot;*&quot;&#125;&#125;,</span></span><br><span class="line"><span class="string">      &quot;Action&quot;:&quot;SQS:SendMessage&quot;,</span></span><br><span class="line"><span class="string">      &quot;Resource&quot;: &quot;&#123;&#125;&quot;,</span></span><br><span class="line"><span class="string">      &quot;Condition&quot;:&#123;&#123;</span></span><br><span class="line"><span class="string">        &quot;ArnEquals&quot;:&#123;&#123;</span></span><br><span class="line"><span class="string">          &quot;aws:SourceArn&quot;: &quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">        &#125;&#125;</span></span><br><span class="line"><span class="string">      &#125;&#125;</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;&#125;&quot;&quot;&quot;</span>.<span class="built_in">format</span>(sqsQueueArn, self.snsTopicArn)</span><br><span class="line"></span><br><span class="line">        response = self.sqs.set_queue_attributes(</span><br><span class="line">            QueueUrl=self.sqsQueueUrl,</span><br><span class="line">            Attributes=&#123;</span><br><span class="line">                <span class="string">&#x27;Policy&#x27;</span>: policy</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DeleteTopicandQueue</span>(<span class="params">self</span>):</span><br><span class="line">        self.sqs.delete_queue(QueueUrl=self.sqsQueueUrl)</span><br><span class="line">        self.sns.delete_topic(TopicArn=self.snsTopicArn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display information about a block</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">DisplayBlockInfo</span>(<span class="params">self, block</span>):</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Block Id: &quot;</span> + block[<span class="string">&#x27;Id&#x27;</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Type: &quot;</span> + block[<span class="string">&#x27;BlockType&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;EntityTypes&#x27;</span> <span class="keyword">in</span> block:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;EntityTypes: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;EntityTypes&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;Text&#x27;</span> <span class="keyword">in</span> block:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Text: &quot;</span> + block[<span class="string">&#x27;Text&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> block[<span class="string">&#x27;BlockType&#x27;</span>] != <span class="string">&#x27;PAGE&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Confidence: &quot;</span> + <span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Confidence&#x27;</span>]) + <span class="string">&quot;%&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Page: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Page&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> block[<span class="string">&#x27;BlockType&#x27;</span>] == <span class="string">&#x27;CELL&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Cell Information&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\tColumn: &#123;&#125; &#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;ColumnIndex&#x27;</span>]))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\tRow: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;RowIndex&#x27;</span>]))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\tColumn span: &#123;&#125; &#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;ColumnSpan&#x27;</span>]))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\tRow span: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;RowSpan&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;Relationships&#x27;</span> <span class="keyword">in</span> block:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;\tRelationships: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Relationships&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Geometry&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\tBounding Box: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;BoundingBox&#x27;</span>]))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\tPolygon: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> block[<span class="string">&#x27;BlockType&#x27;</span>] == <span class="string">&#x27;SELECTION_ELEMENT&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;    Selection element detected: &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">&#x27;SelectionStatus&#x27;</span>] == <span class="string">&#x27;SELECTED&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Selected&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Not selected&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetResults</span>(<span class="params">self, jobId</span>):</span><br><span class="line">        maxResults = <span class="number">1000</span></span><br><span class="line">        paginationToken = <span class="literal">None</span></span><br><span class="line">        finished = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> finished == <span class="literal">False</span>:</span><br><span class="line"></span><br><span class="line">            response = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.processType == ProcessType.ANALYSIS:</span><br><span class="line">                <span class="keyword">if</span> paginationToken == <span class="literal">None</span>:</span><br><span class="line">                    response = self.textract.get_document_analysis(JobId=jobId,</span><br><span class="line">                                                                   MaxResults=maxResults)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    response = self.textract.get_document_analysis(JobId=jobId,</span><br><span class="line">                                                                   MaxResults=maxResults,</span><br><span class="line">                                                                   NextToken=paginationToken)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.processType == ProcessType.DETECTION:</span><br><span class="line">                <span class="keyword">if</span> paginationToken == <span class="literal">None</span>:</span><br><span class="line">                    response = self.textract.get_document_text_detection(JobId=jobId,</span><br><span class="line">                                                                         MaxResults=maxResults)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    response = self.textract.get_document_text_detection(JobId=jobId,</span><br><span class="line">                                                                         MaxResults=maxResults,</span><br><span class="line">                                                                         NextToken=paginationToken)</span><br><span class="line"></span><br><span class="line">            blocks = response[<span class="string">&#x27;Blocks&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Detected Document Text&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Pages: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(response[<span class="string">&#x27;DocumentMetadata&#x27;</span>][<span class="string">&#x27;Pages&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Display block information</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">                self.DisplayBlockInfo(block)</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;NextToken&#x27;</span> <span class="keyword">in</span> response:</span><br><span class="line">                paginationToken = response[<span class="string">&#x27;NextToken&#x27;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                finished = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GetResultsDocumentAnalysis</span>(<span class="params">self, jobId</span>):</span><br><span class="line">        maxResults = <span class="number">1000</span></span><br><span class="line">        paginationToken = <span class="literal">None</span></span><br><span class="line">        finished = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> finished == <span class="literal">False</span>:</span><br><span class="line"></span><br><span class="line">            response = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> paginationToken == <span class="literal">None</span>:</span><br><span class="line">                response = self.textract.get_document_analysis(JobId=jobId,</span><br><span class="line">                                                               MaxResults=maxResults)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                response = self.textract.get_document_analysis(JobId=jobId,</span><br><span class="line">                                                               MaxResults=maxResults,</span><br><span class="line">                                                               NextToken=paginationToken)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Get the text blocks</span></span><br><span class="line">            blocks = response[<span class="string">&#x27;Blocks&#x27;</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Analyzed Document Text&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Pages: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(response[<span class="string">&#x27;DocumentMetadata&#x27;</span>][<span class="string">&#x27;Pages&#x27;</span>]))</span><br><span class="line">            <span class="comment"># Display block information</span></span><br><span class="line">            <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">                self.DisplayBlockInfo(block)</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;NextToken&#x27;</span> <span class="keyword">in</span> response:</span><br><span class="line">                    paginationToken = response[<span class="string">&#x27;NextToken&#x27;</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    finished = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    roleArn = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    bucket = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    document = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    region_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    analyzer = DocumentProcessor(roleArn, bucket, document, region_name)</span><br><span class="line">    analyzer.CreateTopicandQueue()</span><br><span class="line">    analyzer.ProcessDocument(ProcessType.DETECTION)</span><br><span class="line">    analyzer.DeleteTopicandQueue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="Textract-同步處理">Textract 同步處理</h1><ul><li>Ref: AWS Textract API 規格書：<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/API_DetectDocumentText.html">https://docs.aws.amazon.com/zh_tw/textract/latest/dg/API_DetectDocumentText.html</a></li></ul><p>DetectDocumentText 是可以分析文件中的 line 或是 word 字段和位置。AWS Textract 可以選擇要透過S3 或是<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/API_Document.html">傳送 base64 編碼</a>的bytes來進行分析。根據官方對<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/how-it-works-detecting.html">偵測文字</a>的說法，回應返回文檔中檢操到的：</p><ul><li>文本的line和word</li><li>文本中line裡面和word之間的關係</li><li>檢測到的文本顯示在圖片上哪一個位置</li></ul><p>在這裏，我們是使用同步檢測（一個做完才做下一個），如果要使用異步檢測可以參考<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/API_StartDocumentTextDetection.html">StartDocumentTextDetection</a>，並且透過<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/API_GetDocumentTextDetection.html">GetDocumentTextDetection</a>來取得結果。如需詳細資訊和範例，請參閱 <a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/async.html">使用異步操作處理文檔</a>。</p><h2 id="建立client">建立client</h2><p>我們要先建立一個client，然後使用 <code>detect_document_text</code> 來進行分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># AWS </span></span><br><span class="line"><span class="keyword">import</span> boto3 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 圖片處理</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> pdf2image <span class="keyword">import</span> convert_from_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取pdf </span></span><br><span class="line">pdf_file = <span class="string">&#x27;test.pdf&#x27;</span> <span class="comment"># 設定想要處理的檔案</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(pdf_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file: </span><br><span class="line">    pdf_binary = file.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># aws client </span></span><br><span class="line">client = boto3.client(<span class="string">&#x27;textract&#x27;</span>, region_name=<span class="string">&#x27;us-east-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># textract </span></span><br><span class="line">response = client.detect_document_text(Document=&#123;<span class="string">&#x27;Bytes&#x27;</span>: pdf_binary&#125;)</span><br></pre></td></tr></table></figure><h2 id="處理回傳的資料">處理回傳的資料</h2><p>以下程式碼是<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/detecting-document-text.html">官方提供</a>的範例程式，主要可以看到如何處理回傳的資料，並且在圖片上畫出文字的位置。他的Bounding Box是一個比例，所以要乘上圖片的寬高才能得到正確的位置。</p><p><em>檢測到的文本將在Text欄位Block物件</em>。所以此BlockType字段確定文本是一行文本 (LINE) 還是單詞 (WORD)。一個字是一或多個 ISO 基本拉丁腳本字符，不以空格分隔。一個線是製表符分隔和連續單詞的字符串。</p><p>最後bounding box的位置由以下組成：用來定義邊界框的四個點。[(x0, y0), (x1, y1)] 或 [x0, y0, x1, y1] 的數列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_text_detection</span>():</span><br><span class="line">    images = convert_from_bytes(pdf_binary)</span><br><span class="line">    image = images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Get the text blocks</span></span><br><span class="line">    blocks=response[<span class="string">&#x27;Blocks&#x27;</span>]</span><br><span class="line">    width, height =image.size  </span><br><span class="line">    draw = ImageDraw.Draw(image)  </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Detected Document Text&#x27;</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Create image showing bounding box/polygon the detected lines/text</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Type: &#x27;</span> + block[<span class="string">&#x27;BlockType&#x27;</span>])</span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">&#x27;BlockType&#x27;</span>] != <span class="string">&#x27;PAGE&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Detected: &#x27;</span> + block[<span class="string">&#x27;Text&#x27;</span>])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Confidence: &#x27;</span> + <span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Confidence&#x27;</span>]) + <span class="string">&quot;%&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Id: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Id&#x27;</span>]))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;Relationships&#x27;</span> <span class="keyword">in</span> block:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Relationships: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Relationships&#x27;</span>]))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Bounding Box: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;BoundingBox&#x27;</span>]))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Polygon: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>]))</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            draw=ImageDraw.Draw(image)</span><br><span class="line">            <span class="comment"># Draw WORD - Green -  start of word, red - end of word</span></span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">&#x27;BlockType&#x27;</span>] == <span class="string">&quot;WORD&quot;</span>:</span><br><span class="line">                draw.line([(width * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;X&#x27;</span>],</span><br><span class="line">                height * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;Y&#x27;</span>]),</span><br><span class="line">                (width * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">3</span>][<span class="string">&#x27;X&#x27;</span>],</span><br><span class="line">                height * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">3</span>][<span class="string">&#x27;Y&#x27;</span>])],fill=<span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">                width=<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">                draw.line([(width * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">1</span>][<span class="string">&#x27;X&#x27;</span>],</span><br><span class="line">                height * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">1</span>][<span class="string">&#x27;Y&#x27;</span>]),</span><br><span class="line">                (width * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">2</span>][<span class="string">&#x27;X&#x27;</span>],</span><br><span class="line">                height * block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>][<span class="number">2</span>][<span class="string">&#x27;Y&#x27;</span>])],</span><br><span class="line">                fill=<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">                width=<span class="number">2</span>)    </span><br><span class="line"></span><br><span class="line">                 </span><br><span class="line">            <span class="comment"># Draw box around entire LINE  </span></span><br><span class="line">            <span class="keyword">if</span> block[<span class="string">&#x27;BlockType&#x27;</span>] == <span class="string">&quot;LINE&quot;</span>:</span><br><span class="line">                points=[]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> polygon <span class="keyword">in</span> block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;Polygon&#x27;</span>]:</span><br><span class="line">                    points.append((width * polygon[<span class="string">&#x27;X&#x27;</span>], height * polygon[<span class="string">&#x27;Y&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">                draw.polygon((points), outline=<span class="string">&#x27;black&#x27;</span>)    </span><br><span class="line">  </span><br><span class="line">                <span class="comment"># Uncomment to draw bounding box</span></span><br><span class="line">                box=block[<span class="string">&#x27;Geometry&#x27;</span>][<span class="string">&#x27;BoundingBox&#x27;</span>]                    </span><br><span class="line">                left = width * box[<span class="string">&#x27;Left&#x27;</span>]</span><br><span class="line">                top = height * box[<span class="string">&#x27;Top&#x27;</span>]           </span><br><span class="line">                draw.rectangle([left,top, left + (width * box[<span class="string">&#x27;Width&#x27;</span>]), top +(height * box[<span class="string">&#x27;Height&#x27;</span>])],outline=<span class="string">&#x27;yellow&#x27;</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display the image</span></span><br><span class="line">    image.show()</span><br><span class="line">    <span class="comment"># display image for 10 seconds</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(blocks)</span><br></pre></td></tr></table></figure><blockquote><p>結果<br><img src="https://i.imgur.com/jk7Sz5G.png" alt=""></p></blockquote><p>詳細規格可以餐考<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/how-it-works-document-layout.html">文本檢測和文檔分析響應對象</a>）</p><div class="note danger flat"><p>但是你會發現一個叫做confidence的欄位，從上圖跟下面的json可以看到，<code>#Get x the * document IN from IN S3</code>這段<code>x</code>跟<code>*</code>還有<code>IN</code>都不應該出現，而他們的confidence也很低，分別都是25。應該要<strong>進行filter掉信心不高的內容</strong>。根據不同的場景，可信度低的檢測可能需要人類的視覺確認。</p></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;DocumentMetadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;Pages&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Blocks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;BlockType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PAGE&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;BoundingBox&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">0.9976544976234436</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Left&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Top&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Polygon&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">2.8319884677330265e-6</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">1.0</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.9966249465942383</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.0</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.9976544976234436</span> <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;964301ea-606d-4842-b329-e935cdd1ccac&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Relationships&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CHILD&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;f4e39047-43f0-468b-a10b-d8718af58a9a&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;d4d91acf-da43-4c51-828d-a99528296d76&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;e02398d3-94f9-4dc6-9d5a-9259fa6fbe1d&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;d331852e-b1e7-474a-9906-200fea91a887&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;6299c37e-3586-49bf-8804-a7660e998acc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;cc4dda56-bff8-4c37-962b-6f9112680dc7&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;BlockType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LINE&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Confidence&quot;</span><span class="punctuation">:</span> <span class="number">70.04537200927734</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#Get x the * document IN from IN S3&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;BoundingBox&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span> <span class="number">0.30295300483703613</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">0.014886284247040749</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Left&quot;</span><span class="punctuation">:</span> <span class="number">0.15722371637821198</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Top&quot;</span><span class="punctuation">:</span> <span class="number">0.11024140566587448</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Polygon&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.15722371637821198</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.11024140566587448</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.4601767361164093</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.11063025891780853</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.46017175912857056</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.12512768805027008</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.15722690522670746</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.12475030869245529</span> <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;f4e39047-43f0-468b-a10b-d8718af58a9a&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Relationships&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CHILD&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Ids&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;005d8051-a3e8-414f-b509-3e3f70dce56c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;2e14dc51-9d9d-4740-82fb-2f6710febacf&quot;</span><span class="punctuation">,</span> # 這裡要注意</span><br><span class="line">            <span class="string">&quot;d6ef827c-d9fa-488c-b295-8d8a0b20ee86&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;5224fd43-c247-4f96-aa67-ae4e9d63b3f1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;c78aca25-1f8d-4d29-9b27-5f06fb32561e&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;c0bdce47-96af-4b3e-aacd-672deec8c2d2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;e1f3f661-3f2a-4ad6-9875-835d05e18132&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;88b396a3-1f7c-455b-b73f-4ed5e2ef300a&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;6d9b7d1d-0a22-4a53-a141-12ce50157b64&quot;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;BlockType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WORD&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Confidence&quot;</span><span class="punctuation">:</span> <span class="number">25.193822860717773</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x&quot;</span><span class="punctuation">,</span> # 圖片這個根本不是x，因死這個confidence也很低，應該要filter掉</span><br><span class="line">      <span class="attr">&quot;TextType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRINTED&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;BoundingBox&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span> <span class="number">0.004908399190753698</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">0.0033209826797246933</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Left&quot;</span><span class="punctuation">:</span> <span class="number">0.20951908826828003</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;Top&quot;</span><span class="punctuation">:</span> <span class="number">0.1167941763997078</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Polygon&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.20951908826828003</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.1167941763997078</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.21442709863185883</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.11680039763450623</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.21442748606204987</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.12011516094207764</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span> <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.20951949059963226</span><span class="punctuation">,</span> <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.12010898441076279</span> <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2e14dc51-9d9d-4740-82fb-2f6710febacf&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h1 id="補充內容">補充內容</h1><h2 id="關於文字的位置">關於文字的位置</h2><ul><li>ref: <a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/text-location.html">https://docs.aws.amazon.com/zh_tw/textract/latest/dg/text-location.html</a></li></ul><p>若要確定項目在文件頁面上的位置，請使用週框(Geometry)由 Amazon Textract 操作返回的信息Block物件。所以此Geometry物件包含兩類檢測到的項目的位置和幾何資訊：</p><ul><li>軸對齊BoundingBox物件，該物件包含左上方座標以及項目的寬度和高度。</li><li>描述項目輪廓的多邊形對象，指定為Point對象包含X(水平軸) 和Y（垂直軸）每個點的文檔頁面座標。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Geometry&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;BoundingBox&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span> <span class="number">0.053907789289951324</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;Top&quot;</span><span class="punctuation">:</span> <span class="number">0.08913730084896088</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;Left&quot;</span><span class="punctuation">:</span> <span class="number">0.11085548996925354</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">0.013171200640499592</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;Polygon&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span># 起點的線</span><br><span class="line">                <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.08985357731580734</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.11085548996925354</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.08913730084896088</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.16447919607162476</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.10159222036600113</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.16476328670978546</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">            <span class="punctuation">&#123;</span># 終點的線</span><br><span class="line">                <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">0.10230850428342819</span><span class="punctuation">,</span> </span><br><span class="line">                <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">0.11113958805799484</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Name:&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;TextType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PRINTED&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;BlockType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WORD&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Confidence&quot;</span><span class="punctuation">:</span> <span class="number">99.56285858154297</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c734fca6-c4c4-415c-b6c1-30f7510b72ee&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2HdZDBj.png" alt=""><br><img src="https://i.imgur.com/VO5Mrga.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> OCR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aws </tag>
            
            <tag> textract </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Amazon Textract 如何處理多欄位(Multi-Column)的文字排序</title>
      <link href="/posts/textract-multi-column/"/>
      <url>/posts/textract-multi-column/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>AWS Textract 是用於從 pdf（或圖片）中擷取文字的 AWS 工具。最好的情況是您的原始文件只有一欄，例如一本書。當您有多個專欄（例如報紙文章）時，事情處理起來會更加複雜。所以這次來分享一下如何使用 Amazon Textract 來處理多欄位的文字排序。有參考這篇<a href="https://medium.com/claranet-ch/aws-textract-how-to-detect-and-sort-text-from-a-multi-column-document-61e411f3e259">AWS Textract: how to detect and sort text from a multi-column document</a>做一些改良。</p><p>我的來源是一篇報紙文章，版面如下：<br><img src="https://i.imgur.com/XOevNWt.png" alt=""></p><h1 id="Textract-Response-format">Textract Response format</h1><p>Textract 輸出是由各種 BlockType 分層排列形成的 JSON。一個BlockType的「Page」由多個「Line」組成，而「Line」又由多個「Word」組成。在這些回應中，您看不到任何結構資訊，無法將多列文字僅排序為一列。但是可以知道的是，Textract在解析文字時，是由上到下，且一排排的解析，可以參考下圖中的編號的第27~48，您可以發現儘管是在不同的Column，但是Textract解析的順序是由左到右依序往下解析。<br><img src="https://i.imgur.com/kWd9zkK.png" alt=""></p><h1 id="Solution">Solution</h1><p>我們所採用的想法是使用 Textract 所提供繪製出邊界框座標。把相近的Line形成一個Block，來找出同一Column的Line。最終結果會如下圖：<br><img src="https://i.imgur.com/szs2EFK.png" alt=""></p><p>從上圖中可以得知以下訊息：</p><ul><li>最長的Block可能是Title</li><li>其他Block可以由上而下，由左至右排序，這樣就可以組合出閱讀順序，並得知Column的分佈</li></ul><h2 id="Step-1-Define-the-Class">Step 1: Define the Class</h2><p>從官網中有說明<a href="https://docs.aws.amazon.com/zh_tw/textract/latest/dg/text-location.html">文檔上的目標位置怎麼看</a>，簡單來說會長以下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;BoundingBox&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;Width&quot;</span><span class="punctuation">:</span> <span class="number">0.007353090215474367</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Height&quot;</span><span class="punctuation">:</span> <span class="number">0.0288887619972229</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Left&quot;</span><span class="punctuation">:</span> <span class="number">0.08638829737901688</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;Top&quot;</span><span class="punctuation">:</span> <span class="number">0.03477252274751663</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>取自官方網站<br><img src="https://i.imgur.com/VSHrpN5.png" alt=""><br><img src="https://i.imgur.com/wjdj6r2.png" alt=""></p></blockquote><p>在理解格式之後我們可以先定義Class來處理這些資料:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, page_number, lines</span>):</span><br><span class="line">        self.lines = lines</span><br><span class="line">        self.page = page_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.lines:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;line: <span class="subst">&#123;line.__str__()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Page: <span class="subst">&#123;self.page&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> src.models.line <span class="keyword">import</span> Line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.lines: <span class="type">List</span>[Line] = []</span><br><span class="line">        self.page: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.reason: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">id</span>: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.left: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.top: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.height: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.width: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Block: page=<span class="subst">&#123;self.page&#125;</span>, id=<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>, (x1,y1)=(<span class="subst">&#123;self.left&#125;</span>, <span class="subst">&#123;self.top&#125;</span>), (x2,y2)=(<span class="subst">&#123;self.left + self.width&#125;</span>,<span class="subst">&#123;self.top + self.height&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_line</span>(<span class="params">self, line</span>):</span><br><span class="line">        self.lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, id_: <span class="built_in">str</span>, page: <span class="built_in">int</span>, text: <span class="built_in">str</span>, top: <span class="built_in">int</span>, left: <span class="built_in">int</span>, width: <span class="built_in">int</span>, height: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.top: <span class="built_in">int</span> = top</span><br><span class="line">        self.left: <span class="built_in">int</span> = left</span><br><span class="line">        self.width: <span class="built_in">int</span> = width</span><br><span class="line">        self.height: <span class="built_in">int</span> = height</span><br><span class="line"></span><br><span class="line">        self.page: <span class="built_in">int</span> = page</span><br><span class="line">        self.id_: <span class="built_in">str</span> = id_</span><br><span class="line">        self.text: <span class="built_in">str</span> = text</span><br><span class="line">        self.center: <span class="built_in">list</span> = self.get_center()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&quot;Line: \t page=<span class="subst">&#123;self.page&#125;</span>, &quot;</span></span><br><span class="line">                <span class="string">f&quot;Id=<span class="subst">&#123;self.id_&#125;</span>, &quot;</span></span><br><span class="line">                <span class="string">f&quot;Text=<span class="subst">&#123;self.text&#125;</span>, \n&quot;</span></span><br><span class="line">                <span class="string">f&quot;left=<span class="subst">&#123;self.left&#125;</span>, top=<span class="subst">&#123;self.top&#125;</span>); &quot;</span></span><br><span class="line">                <span class="string">f&quot;width=<span class="subst">&#123;self.width&#125;</span>, height=<span class="subst">&#123;self.height&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_center</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        x = self.left</span><br><span class="line">        y = self.top</span><br><span class="line">        x1 = self.left + self.width</span><br><span class="line">        y1 = self.top + self.height</span><br><span class="line">        x_center = (x + x1) / <span class="number">2</span></span><br><span class="line">        y_center = (y + y1) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> [x_center, y_center]</span><br></pre></td></tr></table></figure><h2 id="Step-2-General-Function">Step 2: General Function</h2><p>接下來我們需要一些通用的Function來處理資料，這邊我們會需要以下幾個Function</p><ul><li><code>read_json_file</code>: 讀取Textract回傳的JSON檔案</li><li><code>read_file_to_bytes</code>: 主要讀取PDF檔案呈現結果使用</li><li><code>print_blocks</code>: 用來印出Block的資訊</li><li><code>get_lines_from_json</code>: 從Textract回傳的JSON中取得Line的資訊</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># response</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pdf2image <span class="keyword">import</span> convert_from_bytes</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_json_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">return</span> json.load(file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file_to_bytes</span>(<span class="params">file_path: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[Image.Image]:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        pdf_binary = file.read()</span><br><span class="line">    <span class="keyword">return</span> convert_from_bytes(pdf_binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_lines_from_json</span>(<span class="params">file_path: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[Line]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get all type &quot;LINE&quot; from json file generated by textract.</span></span><br><span class="line"><span class="string">    :param file_path: json file generated by textract.</span></span><br><span class="line"><span class="string">    :return: list of Line.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines: <span class="type">List</span>[Line] = []</span><br><span class="line">    json_res = read_json_file(file_path)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> json_res[<span class="string">&quot;Blocks&quot;</span>]:</span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">&quot;BlockType&quot;</span>] == <span class="string">&quot;LINE&quot;</span>:</span><br><span class="line">            box = item[<span class="string">&quot;Geometry&quot;</span>][<span class="string">&quot;BoundingBox&quot;</span>]</span><br><span class="line">            lines.append(</span><br><span class="line">                Line(</span><br><span class="line">                    item[<span class="string">&quot;Id&quot;</span>],</span><br><span class="line">                    item[<span class="string">&quot;Page&quot;</span>],</span><br><span class="line">                    item[<span class="string">&quot;Text&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Top&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Left&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Width&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Height&quot;</span>]))</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_blocks</span>(<span class="params">blocks: <span class="type">List</span>[Block]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    print block and line information</span></span><br><span class="line"><span class="string">    :param blocks: blocks to print</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;block.__str__()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> block.lines:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;line.__str__()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，因為我們判斷兩個Line是否要合併成一個Block很大的要素就是看他們是否相近，因此我們可以定義一個Class負責做這件事情：</p><ul><li><code>two_point_distance</code> 計算兩點之間的距離，這個會被用來計算Lines之間的中心距離是否太遠: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>d</mtext><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\text{d} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">d</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.305em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span></span></span></span></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineSimilarityChecker</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This class is used to check the similarity between two lines.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, column_type: ColumnType,</span></span><br><span class="line"><span class="params">                 distance_tolerance: <span class="built_in">float</span> = <span class="number">0.03</span>,</span></span><br><span class="line"><span class="params">                 width_tolerance: <span class="built_in">float</span> = <span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                 left_tolerance: <span class="built_in">float</span> = <span class="number">0.02</span>,</span></span><br><span class="line"><span class="params">                 height_tolerance: <span class="built_in">float</span> = <span class="number">0.02</span>,</span></span><br><span class="line"><span class="params">                 same_line_tolerance: <span class="built_in">float</span> = <span class="number">0.005</span></span></span><br><span class="line"><span class="params">                 </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.column_type = column_type</span><br><span class="line"></span><br><span class="line">        self.distance_tolerance = distance_tolerance</span><br><span class="line">        self.width_tolerance = width_tolerance</span><br><span class="line">        self.left_tolerance = left_tolerance</span><br><span class="line">        self.height_tolerance = height_tolerance</span><br><span class="line">        self.same_line_tolerance = same_line_tolerance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_left_similar</span>(<span class="params">self, line1, line2, tolerance=<span class="literal">None</span></span>):</span><br><span class="line">        tolerance = tolerance <span class="keyword">or</span> self.left_tolerance</span><br><span class="line">        <span class="keyword">return</span> self.pretty_similar(line1.left, line2.left, tolerance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_width_similar</span>(<span class="params">self, line1, line2, tolerance=<span class="literal">None</span></span>):</span><br><span class="line">        tolerance = tolerance <span class="keyword">or</span> self.width_tolerance</span><br><span class="line">        <span class="keyword">return</span> self.pretty_similar(line1.width, line2.width, tolerance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_height_similar</span>(<span class="params">self, line1, line2, tolerance=<span class="literal">None</span></span>):</span><br><span class="line">        tolerance = tolerance <span class="keyword">or</span> self.height_tolerance</span><br><span class="line">        <span class="keyword">return</span> self.two_point_height(line1.top, line2.top) &lt; tolerance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_center_close</span>(<span class="params">self, line1: Line, line2: Line</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.two_point_distance(</span><br><span class="line">            line1.center[<span class="number">0</span>],</span><br><span class="line">            line1.center[<span class="number">1</span>],</span><br><span class="line">            line2.center[<span class="number">0</span>],</span><br><span class="line">            line2.center[<span class="number">1</span>]) &lt; self.distance_tolerance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pretty_similar</span>(<span class="params">x: <span class="built_in">float</span>, x1: <span class="built_in">float</span>, tolerance: <span class="built_in">float</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x - x1) &lt; tolerance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">two_point_distance</span>(<span class="params">x: <span class="built_in">float</span>, y: <span class="built_in">float</span>, x1: <span class="built_in">float</span>, y1: <span class="built_in">float</span></span>):</span><br><span class="line">        distance = math.sqrt((x - x1) ** <span class="number">2</span> + (y - y1) ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">two_point_height</span>(<span class="params">y: <span class="built_in">float</span>, y1: <span class="built_in">float</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(y - y1)</span><br></pre></td></tr></table></figure><h2 id="Step-3-Define-Rule-of-Block">Step 3: Define Rule of Block</h2><p>現在我們要設計，在什麼樣的條件滿足下可以形成一個Block，這邊我們設計的規則如下：<br><img src="https://i.imgur.com/iyxK62j.png" alt=""></p><p>定義規則的程式碼如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_two_line_close</span>(<span class="params">block, target_line, cur_line</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Check if two lines are close enough, so we can merge them into a block</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    left_tolerance = <span class="number">0.02</span></span><br><span class="line">    width_tolerance =  <span class="number">0.01</span> <span class="comment"># [left_tolerance, (target_line.width - cur_line.width).abs / 2].max</span></span><br><span class="line">    distance_tolerance = <span class="number">0.04</span></span><br><span class="line">    height_tolerance = <span class="number">0.03</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_left_similar</span>(<span class="params">line1, line2, tolerance = left_tolerance</span>):</span><br><span class="line">        <span class="keyword">return</span> pretty_similar(line1.left, line2.left, tolerance)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_width_similar</span>(<span class="params">line1, line2, tolerance = width_tolerance</span>): </span><br><span class="line">        <span class="keyword">return</span>  pretty_similar(line1.width, line2.width, tolerance)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_height_similar</span>(<span class="params">line1, line2, tolerance = height_tolerance</span>):</span><br><span class="line">        <span class="keyword">return</span> two_point_hight(line1.top, line2.top) &lt; tolerance </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_on_same_page</span>(<span class="params">line1, line2</span>):</span><br><span class="line">        <span class="keyword">return</span> line1.page == line2.page</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_center_close</span>(<span class="params">line1, line2</span>):</span><br><span class="line">        <span class="keyword">return</span> two_point_distance(line1.center[<span class="number">0</span>], line1.center[<span class="number">1</span>], line2.center[<span class="number">0</span>], line2.center[<span class="number">1</span>]) &lt; distance_tolerance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_same_paragraph</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        用來處理相同的Paragraph</span></span><br><span class="line"><span class="string">        如果左邊起點相同 且 高度相近 那他們就是在同一個Block</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (is_left_similar(target_line, cur_line) <span class="keyword">and</span> </span><br><span class="line">            is_height_similar(block.lines[-<span class="number">1</span>], cur_line)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_text_center_context</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        用來處理置中的文字</span></span><br><span class="line"><span class="string">        如果中心點相近 且 高度相近 那他們就是在同一個Block</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (is_center_close(target_line, cur_line) <span class="keyword">and</span> is_height_similar(block.lines[-<span class="number">1</span>], cur_line))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 首先檢查是否在同一頁 因為不能讓Block跨頁</span></span><br><span class="line">    <span class="keyword">if</span> is_on_same_page(target_line, cur_line): </span><br><span class="line">        <span class="comment"># 把相同的paragraph 或是 內容置中的 匡選起來</span></span><br><span class="line">        <span class="keyword">if</span> is_same_paragraph() <span class="keyword">or</span> is_text_center_context():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="Step-4-Iterate-Line-to-Form-Block">Step 4: Iterate Line to Form Block</h2><p>接下來我們就可以開始遞迴所有的Line來找出Block</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_lines_to_block</span>(<span class="params">lines</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    把Line合併成Block</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ready_blocks = [] <span class="comment"># 準備一個空的Block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 只要lines還有東西就繼續組成Block</span></span><br><span class="line">    <span class="keyword">while</span> lines: </span><br><span class="line">        block = Block()</span><br><span class="line">        target_line = lines[<span class="number">0</span>] <span class="comment"># 取出第一個Line作為組成Block的第一個被比較的對象</span></span><br><span class="line">        block.add_line(lines[<span class="number">0</span>]) <span class="comment"># 把target_line加入Block</span></span><br><span class="line">        block.page = target_line.page <span class="comment"># 設定Block的Page</span></span><br><span class="line">        lines.pop(<span class="number">0</span>) <span class="comment"># 把target_line從lines中移除</span></span><br><span class="line">        index = <span class="number">0</span>  <span class="comment"># 重新設置 index 為 0，因為pop會影響到index順序</span></span><br><span class="line">        <span class="comment"># 遞迴所有的Line直到沒有lines可以比較了</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">            cur_line = lines[index]</span><br><span class="line">            <span class="keyword">if</span> target_line.page == cur_line.page: </span><br><span class="line">                <span class="comment"># 寬度一樣 那中心不能差太遠 </span></span><br><span class="line">                <span class="keyword">if</span> is_two_line_close(block, target_line, cur_line):</span><br><span class="line">                    block.add_line(cur_line)</span><br><span class="line">                    lines.pop(index) <span class="comment"># pop完之後cur_line要從index 0開始</span></span><br><span class="line">                    index = <span class="number">0</span>  <span class="comment"># 重新設置 index 為 0</span></span><br><span class="line">                    <span class="keyword">continue</span>  <span class="comment"># 繼續下一輪循環</span></span><br><span class="line">            index += <span class="number">1</span>  <span class="comment"># 檢查下一個元素</span></span><br><span class="line"></span><br><span class="line">        ready_blocks.append(block) <span class="comment"># 把整理好的Block加入清單</span></span><br><span class="line">    <span class="keyword">return</span> blocks</span><br></pre></td></tr></table></figure><h2 id="Step5-Execute">Step5: Execute</h2><p>最後我們就可以執行程式碼了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">json_path = <span class="string">&quot;./result/test.json&quot;</span> <span class="comment"># 從Textract回傳的JSON檔案</span></span><br><span class="line">pdf_path = <span class="string">&quot;../../src/test.pdf&quot;</span></span><br><span class="line"></span><br><span class="line">lines = get_lines_from_json(json_path) <span class="comment"># 從Textract回傳的JSON中取得Line的資訊</span></span><br><span class="line">blocks = merge_lines_to_block(lines) <span class="comment"># 把Line合併成Block </span></span><br><span class="line">blocks = find_block_corners(blocks) <span class="comment"># 找出Block的四個角落座標，以可以包圍所有的Line</span></span><br><span class="line">show_image_bbox(pdf_path, blocks)</span><br><span class="line"><span class="comment">#print_blocks(blocks) # 可以印出Block的資訊</span></span><br></pre></td></tr></table></figure><p>結果如下圖：<br><img src="https://i.imgur.com/szs2EFK.png" alt=""></p><h1 id="Advance-Clean-Code-Single-Page">Advance: Clean Code + Single Page</h1><p>但是上述的結果並不適合Single Page，因此我們可以多做一些額外的設定。為了方便管理，我把各個服務拆分變成模組，以下是檔案結構</p><details class="toggle" ><summary class="toggle-button" style="">檔案結構</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── resource</span><br><span class="line">│   ├── pdf <span class="comment"># 放pdf檔案</span></span><br><span class="line">│   │   ├── single-column.pdf</span><br><span class="line">│   │   └── multi-column.pdf</span><br><span class="line">│   └── result <span class="comment"># 放textract解析後的json檔案</span></span><br><span class="line">│       ├── single-column</span><br><span class="line">│       │   └── final-result.json</span><br><span class="line">│       └── multi-column</span><br><span class="line">│           ├── final-result.json</span><br><span class="line">│           ├── result_0.json</span><br><span class="line">│           └── result_1.json</span><br><span class="line">├── src <span class="comment"># 放程式碼</span></span><br><span class="line">│   ├── models <span class="comment"># 放Class</span></span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── block.py</span><br><span class="line">│   │   ├── line.py</span><br><span class="line">│   │   ├── page.py</span><br><span class="line">│   │   └── process_type.py</span><br><span class="line">│   ├── ocr <span class="comment"># 放處理OCR相關的服務</span></span><br><span class="line">│   │   ├── util</span><br><span class="line">│   │   │   ├── __init__.py</span><br><span class="line">│   │   │   ├── bbox_merger.py</span><br><span class="line">│   │   │   └── functions.py</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">├── tests</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── test_block_merge.ipynb</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure></div></details><p>經過整理的程式碼可以參考如下：</p><details class="toggle" ><summary class="toggle-button" style="">各種class檔案</summary><div class="toggle-content"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">│   ├── models</span><br><span class="line">│   │   ├── __pycache__</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── block.py</span><br><span class="line">│   │   ├── line.py</span><br><span class="line">│   │   ├── page.py</span><br><span class="line">│   │   └── process_type.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> src.models.line <span class="keyword">import</span> Line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.lines: <span class="type">List</span>[Line] = []</span><br><span class="line">        self.page: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.reason: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">id</span>: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.left: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.top: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.height: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line">        self.width: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Block: page=<span class="subst">&#123;self.page&#125;</span>, id=<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>, (x1,y1)=(<span class="subst">&#123;self.left&#125;</span>, <span class="subst">&#123;self.top&#125;</span>), (x2,y2)=(<span class="subst">&#123;self.left + self.width&#125;</span>,<span class="subst">&#123;self.top + self.height&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_line</span>(<span class="params">self, line</span>):</span><br><span class="line">        self.lines.append(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, id_: <span class="built_in">str</span>, page: <span class="built_in">int</span>, text: <span class="built_in">str</span>, top: <span class="built_in">int</span>, left: <span class="built_in">int</span>, width: <span class="built_in">int</span>, height: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.top: <span class="built_in">int</span> = top</span><br><span class="line">        self.left: <span class="built_in">int</span> = left</span><br><span class="line">        self.width: <span class="built_in">int</span> = width</span><br><span class="line">        self.height: <span class="built_in">int</span> = height</span><br><span class="line"></span><br><span class="line">        self.page: <span class="built_in">int</span> = page</span><br><span class="line">        self.id_: <span class="built_in">str</span> = id_</span><br><span class="line">        self.text: <span class="built_in">str</span> = text</span><br><span class="line">        self.center: <span class="built_in">list</span> = self.get_center()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f&quot;Line: \t page=<span class="subst">&#123;self.page&#125;</span>, &quot;</span></span><br><span class="line">                <span class="string">f&quot;Id=<span class="subst">&#123;self.id_&#125;</span>, &quot;</span></span><br><span class="line">                <span class="string">f&quot;Text=<span class="subst">&#123;self.text&#125;</span>, \n&quot;</span></span><br><span class="line">                <span class="string">f&quot;left=<span class="subst">&#123;self.left&#125;</span>, top=<span class="subst">&#123;self.top&#125;</span>); &quot;</span></span><br><span class="line">                <span class="string">f&quot;width=<span class="subst">&#123;self.width&#125;</span>, height=<span class="subst">&#123;self.height&#125;</span> \n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_center</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>:</span><br><span class="line">        x = self.left</span><br><span class="line">        y = self.top</span><br><span class="line">        x1 = self.left + self.width</span><br><span class="line">        y1 = self.top + self.height</span><br><span class="line">        x_center = (x + x1) / <span class="number">2</span></span><br><span class="line">        y_center = (y + y1) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> [x_center, y_center]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, page_number, lines</span>):</span><br><span class="line">        self.lines = lines</span><br><span class="line">        self.page = page_number</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> self.lines:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;line: <span class="subst">&#123;line.__str__()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Page: <span class="subst">&#123;self.page&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProcessType</span>:</span><br><span class="line">    LINE = <span class="string">&quot;LINE&quot;</span></span><br><span class="line">    WORD = <span class="string">&quot;WORD&quot;</span></span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">通用Function</summary><div class="toggle-content"><p><strong>src/ocr/util/functions.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># response</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pdf2image <span class="keyword">import</span> convert_from_bytes</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_json_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">return</span> json.load(file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file_to_bytes</span>(<span class="params">file_path: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[Image.Image]:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        pdf_binary = file.read()</span><br><span class="line">    <span class="keyword">return</span> convert_from_bytes(pdf_binary)</span><br></pre></td></tr></table></figure></div></details><details class="toggle" ><summary class="toggle-button" style="">bbox_merger.py 負責把lines變成blocks</summary><div class="toggle-content"><p><strong>src/ocr/util/bbox_merger.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pdf2image <span class="keyword">import</span> convert_from_bytes</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> src.models.block <span class="keyword">import</span> Block</span><br><span class="line"><span class="keyword">from</span> src.models.line <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> src.ocr.util.functions <span class="keyword">import</span> read_json_file</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColumnType</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Column type, based on the column type of pdf.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    SINGLE = <span class="string">&quot;SINGLE&quot;</span></span><br><span class="line">    MULTI = <span class="string">&quot;MULTI&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_lines_from_json</span>(<span class="params">file_path: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[Line]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Get all type &quot;LINE&quot; from json file generated by textract.</span></span><br><span class="line"><span class="string">    :param file_path: json file generated by textract.</span></span><br><span class="line"><span class="string">    :return: list of Line.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines: <span class="type">List</span>[Line] = []</span><br><span class="line">    json_res = read_json_file(file_path)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> json_res[<span class="string">&quot;Blocks&quot;</span>]:</span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">&quot;BlockType&quot;</span>] == <span class="string">&quot;LINE&quot;</span>:</span><br><span class="line">            box = item[<span class="string">&quot;Geometry&quot;</span>][<span class="string">&quot;BoundingBox&quot;</span>]</span><br><span class="line">            lines.append(</span><br><span class="line">                Line(</span><br><span class="line">                    item[<span class="string">&quot;Id&quot;</span>],</span><br><span class="line">                    item[<span class="string">&quot;Page&quot;</span>],</span><br><span class="line">                    item[<span class="string">&quot;Text&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Top&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Left&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Width&quot;</span>],</span><br><span class="line">                    box[<span class="string">&quot;Height&quot;</span>]))</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_blocks</span>(<span class="params">blocks: <span class="type">List</span>[Block]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    print block and line information</span></span><br><span class="line"><span class="string">    :param blocks: blocks to print</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;block.__str__()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> block.lines:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;line.__str__()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineSimilarityChecker</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This class is used to check the similarity between two lines.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, column_type: ColumnType,</span></span><br><span class="line"><span class="params">                 distance_tolerance: <span class="built_in">float</span> = <span class="number">0.03</span>,</span></span><br><span class="line"><span class="params">                 width_tolerance: <span class="built_in">float</span> = <span class="number">0.01</span>,</span></span><br><span class="line"><span class="params">                 left_tolerance: <span class="built_in">float</span> = <span class="number">0.02</span>,</span></span><br><span class="line"><span class="params">                 height_tolerance: <span class="built_in">float</span> = <span class="number">0.02</span>,</span></span><br><span class="line"><span class="params">                 same_line_tolerance: <span class="built_in">float</span> = <span class="number">0.005</span></span></span><br><span class="line"><span class="params">                 </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.column_type = column_type</span><br><span class="line"></span><br><span class="line">        self.distance_tolerance = distance_tolerance</span><br><span class="line">        self.width_tolerance = width_tolerance</span><br><span class="line">        self.left_tolerance = left_tolerance</span><br><span class="line">        self.height_tolerance = height_tolerance</span><br><span class="line">        self.same_line_tolerance = same_line_tolerance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_left_similar</span>(<span class="params">self, line1, line2, tolerance=<span class="literal">None</span></span>):</span><br><span class="line">        tolerance = tolerance <span class="keyword">or</span> self.left_tolerance</span><br><span class="line">        <span class="keyword">return</span> self.pretty_similar(line1.left, line2.left, tolerance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_width_similar</span>(<span class="params">self, line1, line2, tolerance=<span class="literal">None</span></span>):</span><br><span class="line">        tolerance = tolerance <span class="keyword">or</span> self.width_tolerance</span><br><span class="line">        <span class="keyword">return</span> self.pretty_similar(line1.width, line2.width, tolerance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_height_similar</span>(<span class="params">self, line1, line2, tolerance=<span class="literal">None</span></span>):</span><br><span class="line">        tolerance = tolerance <span class="keyword">or</span> self.height_tolerance</span><br><span class="line">        <span class="keyword">return</span> self.two_point_height(line1.top, line2.top) &lt; tolerance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_center_close</span>(<span class="params">self, line1: Line, line2: Line</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.two_point_distance(</span><br><span class="line">            line1.center[<span class="number">0</span>],</span><br><span class="line">            line1.center[<span class="number">1</span>],</span><br><span class="line">            line2.center[<span class="number">0</span>],</span><br><span class="line">            line2.center[<span class="number">1</span>]) &lt; self.distance_tolerance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pretty_similar</span>(<span class="params">x: <span class="built_in">float</span>, x1: <span class="built_in">float</span>, tolerance: <span class="built_in">float</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x - x1) &lt; tolerance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">two_point_distance</span>(<span class="params">x: <span class="built_in">float</span>, y: <span class="built_in">float</span>, x1: <span class="built_in">float</span>, y1: <span class="built_in">float</span></span>):</span><br><span class="line">        distance = math.sqrt((x - x1) ** <span class="number">2</span> + (y - y1) ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">two_point_height</span>(<span class="params">y: <span class="built_in">float</span>, y1: <span class="built_in">float</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(y - y1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineMerger</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    This class is used to turn lines to blocks by compare each line&#x27;s similarity.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lines, column_type: ColumnType = ColumnType.SINGLE</span>):</span><br><span class="line">        self.column_type = column_type</span><br><span class="line">        self.line_check = LineSimilarityChecker(self.column_type)</span><br><span class="line">        self.lines: <span class="type">List</span>[Line] = lines</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_blocks</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[Block]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get all blocks after turning lines into blocks.</span></span><br><span class="line"><span class="string">        :param column_type: column is SINGLE or MULTI default is SINGLE</span></span><br><span class="line"><span class="string">        :return: blocks</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        blocks = self.merge_lines_to_block(self.lines)</span><br><span class="line">        <span class="keyword">return</span> self.find_block_corners(blocks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_lines_to_block</span>(<span class="params">self, lines</span>) -&gt; <span class="type">List</span>[Block]:</span><br><span class="line">        blocks: <span class="type">List</span>[Block] = []</span><br><span class="line">        <span class="keyword">while</span> lines:</span><br><span class="line">            block = Block()</span><br><span class="line">            block.add_line(lines.pop(<span class="number">0</span>))</span><br><span class="line">            block.page = block.lines[<span class="number">0</span>].page</span><br><span class="line">            target_line = block.lines[<span class="number">0</span>]</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(lines):</span><br><span class="line">                cur_line = lines[index]</span><br><span class="line">                <span class="keyword">if</span> target_line.page == cur_line.page:</span><br><span class="line">                    <span class="comment"># for single column, when encounter number point, make a</span></span><br><span class="line">                    <span class="comment"># new a block</span></span><br><span class="line">                    <span class="keyword">if</span> self.column_type == ColumnType.SINGLE <span class="keyword">and</span> self.is_start_special_word(</span><br><span class="line">                            cur_line):</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;---Found special word---&quot;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(cur_line.text)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;---End special word: Jump to next block---&quot;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="comment"># other case, all need to compare the lines are close or</span></span><br><span class="line">                    <span class="comment"># not.</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> self.is_two_line_close(block, cur_line):</span><br><span class="line">                            block.add_line(cur_line)</span><br><span class="line">                            lines.pop(index)</span><br><span class="line">                            index = <span class="number">0</span></span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            blocks.append(block)</span><br><span class="line">        <span class="keyword">return</span> blocks</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_start_special_word</span>(<span class="params">self, cur_line: Line</span>):</span><br><span class="line">        <span class="comment"># 先去字串前後空白 根據空白進行split，取第一個字串</span></span><br><span class="line">        curStart = cur_line.text.strip().split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        pattern = self._regex_pattern()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> re.<span class="keyword">match</span>(pattern, curStart):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_regex_pattern</span>() -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># general word or number + &quot;.&quot;  + any words (e.g. 1.Hello my friend)</span></span><br><span class="line">        GENERAL_WORD_DOT_PATTERN = <span class="string">r&#x27;^[a-zA-Z0-9]\..*&#x27;</span></span><br><span class="line">        <span class="comment"># non-general one word or number + general one word or num + any word (e.g (1) This is ...)</span></span><br><span class="line">        NON_ALPHANUMERIC_WORD_PATTERN = <span class="string">r&#x27;[^a-zA-Z0-9][a-zA-Z0-9][^a-zA-Z0-9].*&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;|&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            GENERAL_WORD_DOT_PATTERN,</span><br><span class="line">            NON_ALPHANUMERIC_WORD_PATTERN)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_two_line_close</span>(<span class="params">self, block, cur_line</span>):</span><br><span class="line">        last_line: Line = block.lines[-<span class="number">1</span>]</span><br><span class="line">        target_line: Line = block.lines[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.is_on_same_page(target_line, cur_line):</span><br><span class="line">            <span class="comment"># multi column: center text &amp; paragraph block</span></span><br><span class="line">            <span class="keyword">if</span> self.column_type == ColumnType.MULTI:</span><br><span class="line">                <span class="keyword">if</span> (self.is_same_paragraph(last_line, cur_line) <span class="keyword">or</span></span><br><span class="line">                        self.is_text_center_context(last_line, cur_line)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># single column: same line</span></span><br><span class="line">            <span class="keyword">elif</span> self.column_type == ColumnType.SINGLE:</span><br><span class="line">                <span class="keyword">if</span> (self.is_on_same_line(last_line, cur_line) <span class="keyword">or</span></span><br><span class="line">                        self.is_same_paragraph(last_line, cur_line)):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_on_same_page</span>(<span class="params">line1, line2</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> line1.page == line2.page</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_on_same_line</span>(<span class="params">self, last_line, cur_line</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> self.line_check.is_height_similar(last_line, cur_line)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_same_paragraph</span>(<span class="params"></span></span><br><span class="line"><span class="params">            self,</span></span><br><span class="line"><span class="params">            last_line: Line,</span></span><br><span class="line"><span class="params">            cur_line: Line</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> (self.line_check.is_left_similar(last_line, cur_line)</span><br><span class="line">                <span class="keyword">and</span> self.line_check.is_height_similar(last_line, cur_line)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_text_center_context</span>(<span class="params">self, last_line: Line, cur_line: Line</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> (self.line_check.is_center_close(last_line, cur_line) <span class="keyword">and</span></span><br><span class="line">                self.line_check.is_height_similar(last_line, cur_line))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_block_corners</span>(<span class="params">blocks: <span class="type">List</span>[Block]</span>) -&gt; <span class="type">List</span>[Block]:</span><br><span class="line">        <span class="keyword">for</span> index, block <span class="keyword">in</span> <span class="built_in">enumerate</span>(blocks):</span><br><span class="line">            min_top = <span class="built_in">min</span>(line.top <span class="keyword">for</span> line <span class="keyword">in</span> block.lines)</span><br><span class="line">            min_left = <span class="built_in">min</span>(line.left <span class="keyword">for</span> line <span class="keyword">in</span> block.lines)</span><br><span class="line">            max_bottom = <span class="built_in">max</span>(line.top + line.height <span class="keyword">for</span> line <span class="keyword">in</span> block.lines)</span><br><span class="line">            max_right = <span class="built_in">max</span>(line.left + line.width <span class="keyword">for</span> line <span class="keyword">in</span> block.lines)</span><br><span class="line"></span><br><span class="line">            block.height = max_bottom - min_top</span><br><span class="line">            block.width = max_right - min_left</span><br><span class="line">            block.top = min_top</span><br><span class="line">            block.left = min_left</span><br><span class="line">            block.<span class="built_in">id</span> = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> blocks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_image_bbox</span>(<span class="params">pdf_file, blocks</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    show image bounding box</span></span><br><span class="line"><span class="string">    :param pdf_file: the pdf file location</span></span><br><span class="line"><span class="string">    :param blocks: the list of blocks we want to draw</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(pdf_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        images = convert_from_bytes(file.read())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, image <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        width, height = image.size</span><br><span class="line">        page = index + <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Process Page Index: <span class="subst">&#123;page&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        plt.figure(figsize=(<span class="number">20</span>, <span class="number">16</span>))</span><br><span class="line">        plt.imshow(image)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># iterate over the blocks</span></span><br><span class="line">        <span class="keyword">for</span> i, block <span class="keyword">in</span> <span class="built_in">enumerate</span>(blocks):</span><br><span class="line">            <span class="keyword">if</span> block.page == page:</span><br><span class="line">                rect = Rectangle(</span><br><span class="line">                    (width * block.left,</span><br><span class="line">                     height * block.top),</span><br><span class="line">                    block.width * width,</span><br><span class="line">                    block.height * height,</span><br><span class="line">                    edgecolor=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">                    facecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">                plt.text(</span><br><span class="line">                    width * block.left,</span><br><span class="line">                    height * block.top,</span><br><span class="line">                    block.<span class="built_in">id</span>,</span><br><span class="line">                    fontsize=<span class="number">12</span>,</span><br><span class="line">                    color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">                plt.gca().add_patch(rect)</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure></div></details><p>接下來就可以直接呼叫了<br><strong>tests/test_block_merge.ipynb</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> src.ocr.util.bbox_merger <span class="keyword">import</span> (</span><br><span class="line">    show_image_bbox, </span><br><span class="line">    get_lines_from_json, </span><br><span class="line">    LineMerger, </span><br><span class="line">    print_blocks, </span><br><span class="line">    ColumnType</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, is_multi_column: <span class="built_in">bool</span></span>):</span><br><span class="line">        <span class="keyword">if</span> is_multi_column:</span><br><span class="line">            self.topic = <span class="string">&quot;multi-column&quot;</span></span><br><span class="line">            self.column_type = ColumnType.MULTI</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.topic = <span class="string">&quot;single-column&quot;</span></span><br><span class="line">            self.column_type = ColumnType.SINGLE</span><br><span class="line">            </span><br><span class="line">        self.json_path = <span class="string">&#x27;../resource/result/&#123;&#125;/final-result.json&#x27;</span>.<span class="built_in">format</span>(self.topic)</span><br><span class="line">        self.pdf_path = <span class="string">&#x27;../resource/pdf/&#123;&#125;.pdf&#x27;</span>.<span class="built_in">format</span>(self.topic)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">is_multi_column: <span class="built_in">bool</span></span>):</span><br><span class="line">    v = Value(is_multi_column = is_multi_column)</span><br><span class="line">    lines = get_lines_from_json(v.json_path)</span><br><span class="line">    blocks = LineMerger(lines, v.column_type).get_blocks()</span><br><span class="line">    print_blocks(blocks)</span><br><span class="line">    show_image_bbox(pdf_file=v.pdf_path, blocks=blocks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main(is_multi_column = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> OCR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aws </tag>
            
            <tag> textract </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰島自由行2024冬天旅遊指南: 行程規劃/保險/自駕注意</title>
      <link href="/posts/iceland-ultimate-travel-guide/"/>
      <url>/posts/iceland-ultimate-travel-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在德國讀雙聯終於考完期末考時，那時是二月初。我們想著要怎麼規劃一個月的寒假，剛好小夥伴們在我家討論想去的國家時，大家都有相同的願望就是去冰島看極光，剛好極光最適合觀賞的月份是10月~3月，因此我們就開啟了Flyscanner搜尋哪一天的機票最便宜，看了看發現2/26的去程跟3/7回程最便宜，二話不說就訂機票了，訂完機票我們就會有動力來<em>開始計劃11天10夜的行程</em>！</p><p>那這篇文章主要記錄了當時我們的行程規劃、預算規劃、自駕注意事項、保險、意外事件等等，希望對大家有幫助！</p><div class="note danger flat"><p>因為文章很長，<strong>建議根據旁邊的目錄來找你想要了解的章節…跳過去直接看比較快</strong>。</p></div><div class="note info flat"><p><strong>如果你滿足以下情境，那麼這篇文章對你來說就是一個很好的參考</strong>：</p><ul><li>我想要環島，但是不知道該怎麼規劃行程？ <em>查看：<a href="#01-%E8%A1%8C%E7%A8%8B%E5%AE%89%E6%8E%92">01-行程安排</a></em></li><li>必須下載的App和網站有哪些？ <em>查看：<a href="#02-%E5%BF%85%E5%82%99App%E5%92%8C%E7%B6%B2%E7%AB%99">02-必備App和網站</a></em></li><li>我是來歐洲交換的窮學生，希望可以省錢又可以玩得開心（預算在5萬內含機票）<em>查看：<a href="#03-%E9%96%8B%E9%8A%B7%E8%8A%B1%E8%B2%BB">03-開銷花費</a></em></li><li>雪地自駕跟租車有什麼需要注意的？ <em>查看：<a href="#04-%E8%87%AA%E9%A7%95%E5%92%8C%E7%A7%9F%E8%BB%8A">04-自駕注意事項</a></em></li><li>汽車的保險該怎麼買？ <em>查看：<a href="#05-%E4%BF%9D%E9%9A%AA">05-保險</a></em></li><li>如果自駕發生意外該怎麼辦？ <em>查看：<a href="#06-%E6%84%8F%E5%A4%96%E4%BA%8B%E4%BB%B6">06-意外事件</a></em></li><li>冰川健行和藍冰洞有推薦的跟團行程嗎？<em>查看：<a href="/posts/iceland-ultimate-travel-guide/#Day05-%E8%B7%9F%E5%9C%98%EF%BC%9A%E5%86%B0%E5%B7%9D%E5%81%A5%E8%A1%8C-%E8%97%8D%E5%86%B0%E6%B4%9E">Day05 跟團：冰川健行 + 藍冰洞</a></em></li><li>我應該怎麼拍攝極光？ <em>查看：<a href="#07-%E6%A5%B5%E5%85%89%E6%8B%8D%E6%94%9D">07-極光拍攝</a></em></li><li>我應該要帶什麼行李（冬天適用）？ <em>查看：<a href="#08-%E8%A1%8C%E6%9D%8E%E6%BA%96%E5%82%99">08-行李準備</a></em></li></ul></div><div class="note warning flat"><p>我先來說一下結論，冰島整趟旅遊最值得的部分：</p><ol><li><strong>自駕環島</strong>，從離開城市開始，進入彷彿另一個星球的世界，沿途的風景令人不勝讚嘆</li><li><strong>極光</strong>（一定要先做好拍攝功課，因為極光不等人）</li><li>參加<strong>冰川健行與藍冰洞</strong>的跟團（藍冰洞只有冬天才有）</li><li><strong>雪地遇難</strong>的經驗（這是最印象深刻的，但當然以安全為前提，要做好雪地自駕的功課還有遇難的應對措施和保險）</li></ol></div><h1 id="01-行程安排">01-行程安排</h1><iframe class="center" src="https://www.google.com/maps/d/u/1/embed?mid=1glN0nMrmKrdjA-eaVhsKTV9b7lDV8vg&ehbc=2E312F" width="100%" height="480"></iframe><p>我們是四人行，在交通方面非常推薦自駕冰島，但是<em>一定要四輪驅動，因為有很多地方是只有四驅車才能進入</em>，否則非四驅車進入保險會失效。行程安排大概如上圖，按照紅橙黃綠藍紫的顏色代表不同天的行程。</p><h2 id="Day01-取車-小豬超市準備食物">Day01 取車+小豬超市準備食物</h2><div class="note info flat"><p>這天因為飛機下午才抵達冰島，因此我們主要就是取車、買食物、住宿。</p></div><p><img src="https://i.imgur.com/O4qf0ZA.png" alt=""></p><table><thead><tr><th>時間</th><th>地點</th><th>備註</th></tr></thead><tbody><tr><td>11:40-14:30</td><td>雷克雅維克機場</td><td></td></tr><tr><td>15:30</td><td>取車</td><td>問有沒有車wifi</td></tr><tr><td>16:30</td><td><a href="https://maps.app.goo.gl/s33pVyxFFcHr4d6p8">小豬超市</a></td><td>多買水、麵包、糧食、提神飲料！！</td></tr><tr><td>住宿</td><td><a href="https://maps.app.goo.gl/ih2cpLXWZGtGi62o6">Hostel B47</a></td><td>有廚房，市區停車有的會收費，先看hotel有沒有停車場</td></tr></tbody></table><h2 id="Day02-火口湖-間歇泉-斯里蘭卡瀑布">Day02 火口湖 + 間歇泉 + 斯里蘭卡瀑布</h2><div class="note info flat"><p>我就總結一下，這個行程最印象深刻最美好的：</p><ul><li>我最印象深刻的是<strong>賽裡雅蘭卡瀑布</strong>，因為我們把它放在最後一個行程，<em>天氣好加上遇到夕陽落下時刻，當夕陽打在瀑布上和黃綠色的草地</em>上，真的是太美了！</li><li>第二個<strong>很推的是飯店Guesthouse Hateigi，他是我在冰島住到最棒的民宿</strong>，浴室跟廚房都在房間內，非常方便不需要跟別人搶，同時他還在浴室附上了洗衣機，還有洗碗機！真的是什麼都有！</li></ul></div><p><img src="https://i.imgur.com/W4Yo4Nc.png" alt=""></p><table><thead><tr><th><div style="width:90px">時間</div></th><th><div style="width:150px">地點</div></th><th>備註</th></tr></thead><tbody><tr><td>9:00 前出門</td><td>飯店Checkout + 早餐</td><td></td></tr><tr><td>-</td><td>開車</td><td><code>飯店</code> to <code>火口湖</code> 56min</td></tr><tr><td>10:30 前抵達</td><td><a href="https://maps.app.goo.gl/LrVbVHe3uWtcq9VJ9">Kerið 火口湖</a></td><td><em>免費停車，沒有廁所，要門票費 2.7 歐</em> 這座優美湖泊位於火山口，大約於西元前 4,000 年形成，可經由步行抵達。</td></tr><tr><td>-</td><td>開車</td><td>開車從<code>火口湖</code>到<code>間歇泉</code> 40min</td></tr><tr><td>12:00 前抵達</td><td><a href="https://maps.app.goo.gl/6SdcEqrvP9paf71T8">間歇泉</a></td><td>約6~10分鐘噴發一次，旁邊紀念品店可買兔毛帽</td></tr><tr><td>-</td><td>開車</td><td>從<code>間歇泉</code>to<code>黃金瀑布</code> 10min</td></tr><tr><td>14:30 前抵達</td><td><a href="https://maps.app.goo.gl/8kBZE86Tv3xXsHSQ7">黃金瀑布-Gullfoss瀑布</a></td><td>旁邊紀念品店好逛、有廁所; 是金圈三環之一，外形特別，澎湃洶湧的水量與同時歷經兩座斷層壯觀景色，是冰島第二大瀑布</td></tr><tr><td>-</td><td>開車</td><td>從<code>黃金瀑布</code>到<code>賽里蘭雅瀑布</code> 1hr 40min</td></tr><tr><td>16:00 前抵達</td><td><a href="https://maps.app.goo.gl/LirrcgsZpmn6teuD6">Seljalandsfoss 塞里雅蘭瀑布</a></td><td>後方有座被瀑布沖刷而成的岩洞可以走進去，如水簾洞故又稱為「水簾洞瀑布」（但是冬天不開放去瀑布後面）</td></tr><tr><td>-</td><td>開車</td><td>從<code>賽里蘭雅瀑布</code>到<code>飯店</code> 45min</td></tr><tr><td>18:00 前抵達</td><td><a href="https://maps.app.goo.gl/RZ9LJJBejZX6qSUm6">Guesthouse Hateigi</a></td><td>飯店check in  有廚房</td></tr></tbody></table><h2 id="Day03-彩虹瀑布-迪拉半島-黑沙灘-紅頂教堂-羽毛河峽谷">Day03 彩虹瀑布 + 迪拉半島 + 黑沙灘 + 紅頂教堂 + 羽毛河峽谷</h2><div class="note info flat"><p>這裡就先不提供時間，因為時間有限所以不是google map上的景點都有去，但是主要下面表格是我們最後有去的地點。</p><ul><li>最印象深刻的應該是<strong>彩虹瀑布</strong>，非常<em>推薦走旁邊的步道上瀑布上面</em>，景觀很壯觀！然後瀑布真的很容易看到彩虹，<em>建議早上去</em>，因為陽光剛好可以照到瀑布才會有彩虹。</li><li>第二名是<strong>迪拉半島</strong>，會先開車抖上到一個坡度，沿途也很壯觀，<em>從這裡看黑沙灘很漂亮</em>！但是黑沙灘真的太多人了，加上玄武岩小小的，所以印象不太好。</li><li>第三名是<strong>羽毛和峽谷</strong>，一次<em>身處在一整片的草原跟山谷還是很壯觀</em>！有時候還會不小心看到野生的鹿群在遠方奔跑！</li></ul></div><p><img src="https://i.imgur.com/p7chd9s.png" alt=""></p><table><thead><tr><th>地點</th><th>備註</th></tr></thead><tbody><tr><td>開車</td><td>從<code>飯店</code> to <code>斯科加爾瀑布</code> 1hr 7min</td></tr><tr><td><a href="https://maps.google.com/?cid=1108104447747062088">Skógafoss 斯科加爾瀑布</a></td><td><code>停車場不用付錢</code><br/>Skogafoss，有陽光看到彩虹🌈的機率很高又被稱為彩虹瀑布，是極受歡迎的《白日夢冒險王》拍攝場景之一。瀑布高62米，寬25米，水勢強大，是全冰島最壯觀的瀑布之一。</td></tr><tr><td>開車</td><td><code>瀑布</code> to <code>迪拉半島</code> 25min</td></tr><tr><td><a href="https://maps.app.goo.gl/MZZghADmSQgxAgtn9">Dyrhólaey迪拉半島</a></td><td><code>停車場不用付錢</code> <br/> 這座小型半島風景如畫，有燈塔與一座橫跨在海面上的巨型火成岩拱橋。從這裡看黑沙灘很讚。</td></tr><tr><td><a href="https://maps.app.goo.gl/Uf6JMKPeEGEDXkB56">雷尼斯黑沙灘</a></td><td>黑沙灘結束可以去超市<br/>不要靠海太近，會捲人很危險！！！玄武岩地景的黑色沙灘，一旁有從海中突起的嶙峋岩石。但聽說澎湖的玄武岩比較厲害。</td></tr><tr><td><a href="https://maps.app.goo.gl/e86Qw3MqUXsWeGjP7?g_st=ic">紅頂教堂</a></td><td>還行，是明信片場景</td></tr><tr><td>開車</td><td><code>黑沙灘</code> to <code>羽毛河峽谷</code> 1hr 6min</td></tr><tr><td><a href="https://maps.app.goo.gl/dsMVNvUziveMNGq8A">Fjaðrárgljúfur 羽毛河峽谷</a></td><td><code>停車場有收費，冬天廁所不開放</code><br/>深而蜿蜒的河谷，小賈斯汀I’ll show you的拍攝地，約於2百萬年前形成，設有步道，可一覽遼闊全景。 但是冬天走那個步道一定要穿釘鞋…上面全都是滑冰不可能走，可以走旁邊的草地。因為是峽谷，所以風挺大的。</td></tr><tr><td>開車</td><td><code>羽毛</code> to <code>飯店</code> 2hr 39min</td></tr><tr><td><a href="https://maps.app.goo.gl/xw6CdFRFCjosn8j59">霍芬旅館</a></td><td>有廚房，住兩晚，有吹風機</td></tr></tbody></table><h2 id="Day04-杰古沙龍冰河湖-鑽石沙灘-羊排晚餐">Day04 杰古沙龍冰河湖 + 鑽石沙灘 + 羊排晚餐</h2><div class="note info flat"><p>這天的行程是最Chill的一天，最印象深刻的應該就是吃羊排跟看鑽石沙灘，還有看極光</p><ul><li><strong>鑽石冰沙灘</strong> 真的很美，沒有看過<em>冰塊在沙攤上，很建議盡量走到裡面靠近岩牆的地方</em>，因為那裡人比較少，記得撿一塊冰塊跟海合照一張。</li><li><strong>Pakkhus Restaurant</strong> 這間餐廳的<em>羊排跟奶油龍蝦還不錯</em>，但價位偏高，羊排吃不出來羊味，奶油龍蝦很新鮮，沒有到說非常好吃到難忘，但是是一個很好的體驗。</li><li><strong>霍芬旅館</strong> 這間飯店很乾淨，廚具應有盡有，最棒的是霍芬小鎮是很適合看到極光的地方，<em>這個旅館後面就有一個小山丘，超級適合看極光</em>！但是晚上爬上去完全沒有燈，要記得帶手電筒，盡量走靠柵欄的地方比較不那麼陡峭。</li></ul></div><p><img src="https://i.imgur.com/CeoBk4C.png" alt=""></p><table><thead><tr><th>地點</th><th>備註</th></tr></thead><tbody><tr><td>開車</td><td><code>飯店</code> to <code>鑽石沙灘</code> 1hr</td></tr><tr><td><a href="https://maps.app.goo.gl/E7rAYRmPCVmDFPbZ6">鑽石冰沙灘</a></td><td><code>注意：盡量往裡面走，才不會很多人</code>，以漂流至岸上的大型閃爍冰山碎片聞名。</td></tr><tr><td><a href="https://maps.app.goo.gl/TQcr86k8y4ktQLmF8">杰古沙龍冰河湖</a></td><td><code>注意：盡量往裡面走，才不會很多人。</code> 傑古沙龍冰河湖是冰島的一個重要景點。由於湖口狹窄，使得從冰河崩解的冰塊在湖面停留，形成大量美麗的藍色漂浮冰塊，這些冰塊緩緩流入海洋，營造出獨特的美景。</td></tr><tr><td>開車</td><td><code>冰河湖</code> to <code>瀑布</code> 1hr 19min</td></tr><tr><td><a href="https://maps.app.goo.gl/t9TgJ9eib9WP3p8J6">stutafoss瀑布</a></td><td>看過很多大瀑布，所以這個後來的感覺還好</td></tr><tr><td>開車</td><td><code>瀑布</code> to <code>餐廳</code> 22min</td></tr><tr><td><a href="https://maps.app.goo.gl/1cuJxhB5aeFQFPeX9">Pakkhus Restaurant</a></td><td>必吃羊肉、龍蝦，營業時間17:00~21:00，飯店開車5min</td></tr><tr><td><a href="https://maps.app.goo.gl/xw6CdFRFCjosn8j59">霍芬旅館</a></td><td>有廚房</td></tr></tbody></table><h2 id="Day05-跟團：冰川健行-藍冰洞">Day05 跟團：冰川健行 + 藍冰洞</h2><div class="note info flat"><p>今天的行程是最棒最難忘的因為3:30結束了冰川行程，我們原本住的飯店是<a href="https://maps.app.goo.gl/moDUpP49vW1TFxtB6">Studio Apartments</a>他是在93號公路的底端，路途夾在兩座山脈之間，剛好那天暴風雪…我們卡在93號公路的前端，所以無法順利抵達飯店，只好臨時改住<a href="https://maps.app.goo.gl/ccWSpUTtsZKprgd6A">新旅館</a>。硬要說的話，這天最印象深刻的是：</p><ul><li><strong>冰川與藍冰洞健行</strong>，我們做了非常多功課，因為難得冬天自駕，所以當然要看<em>只有冬天才看得到的藍冰洞！<em>夥伴多方的比價後，最後選擇了<a href="https://glacieradventure.is/tour/blue-ice-cave-adventure/">這個跟團</a>，他們</em>不僅會有冰川健行，還會去最大的藍冰洞，價位在萬元內是可以負擔的</em>！這個行程導遊也說是他最喜歡的行程！</li><li><strong>雪地自駕遇難</strong>，這個真的很令人印象深刻，所以為此我會為這個部分特別寫應該怎麼應對的方法。</li></ul></div><p><img src="https://i.imgur.com/liJ2HVd.png" alt=""></p><table><thead><tr><th>時間</th><th><div style="width:180px">地點</div></th><th>備註</th></tr></thead><tbody><tr><td>7:45</td><td>出發</td><td>飯店checkout+早餐</td></tr><tr><td>-</td><td>開車</td><td><code>飯店</code> to <code>Glacier Adventer集合地</code> 54min</td></tr><tr><td>9:30-15:30</td><td><a href="https://maps.app.goo.gl/AKUVfxUYLPmZZMveA">冰川＋藍冰洞集合地</a></td><td>總時間在5至6小時之間，其中在冰洞內為40-60分鐘，在冰川上為2小時。難度適中<code>提前30分鐘集合</code></td></tr><tr><td>-</td><td>開車</td><td><code>冰川</code> to <code>舊旅館</code> 54min</td></tr><tr><td>16:30</td><td>舊旅館</td><td>回飯店領行李和接夥伴</td></tr><tr><td>-</td><td>開車</td><td><code>舊旅館</code> to <code>新旅館</code> 3hr 50min</td></tr><tr><td>20:30</td><td><a href="https://maps.app.goo.gl/ccWSpUTtsZKprgd6A">新旅館</a></td><td>普通的旅館，只是因為暴風雪臨無法抵達原本預定的旅館</td></tr></tbody></table><h2 id="Day06-米湖-惠爾山">Day06 米湖 + 惠爾山</h2><div class="note info flat"><p>經歷了昨天的暴風雪，今天的行程就特別注意不要拉車到傍晚才回去，所以今天主要只去一個景點，而其他景點像是<a href="https://maps.app.goo.gl/jscMrpqmph48ruR77">玄武岩走廊</a>因為太遠所以不去、<a href="https://maps.app.goo.gl/7o8Nexbo9LcQrZBC7">賽爾佛斯瀑布</a>和<a href="https://maps.app.goo.gl/3ZMiL58p9Apgaxin8">Krafla火山口</a>＋<a href="https://maps.app.goo.gl/fYfd4pQYotK22MQx5">Víti火山湖</a>則是因為前一天的暴風雪無法通行所以也取消不去。而<a href="https://maps.app.goo.gl/e9wWckNYfKPuRPkBA">米湖</a>也因為前一天的暴風雪，覆蓋一層雪，根本看不出來是湖…</p><p>最印象深刻的是：</p><ul><li>超級棒的飯店，大推<a href="https://maps.app.goo.gl/1S6zsD58aGrbKfqP7"><strong>Myvatn Berjaya Iceland Hotels</strong></a>，<em>窗戶看出去的景色非常好看</em>！後面也很適合拍極光（但是教堂有點太亮而已），<em>飯店提供的洗髮乳跟沐浴乳都很頂級、還提供雪鏟跟刮除冰的工具</em>。</li><li><strong>惠爾山</strong>也很不錯，爬山山頂不會很久，但是因為前一天暴風雪的緣故，導致上山跟下山都有冰跟雪，容易滑倒…，但是<em>山上看出去一望無際的景色還是令人讚嘆</em>！</li><li><strong>極光大爆發</strong>，晚上的溫度低到-16度，但是天氣極好，並且極光大爆發！</li></ul></div><p><img src="https://i.imgur.com/TheT745.png" alt=""></p><table><thead><tr><th>地點</th><th>備註</th></tr></thead><tbody><tr><td><a href="https://maps.app.goo.gl/e9wWckNYfKPuRPkBA">米湖</a></td><td>想去維提火山（viti）火山湖！就在米湖附近 停車場就看得到火山湖，米湖-火山湖泊，以利用天然地熱加溫的潟湖、野生鳥類和北極光景觀聞名。</td></tr><tr><td><a href="https://maps.app.goo.gl/kEkUBecysuMNEqET9">惠爾山-石灰死火山</a></td><td><code>爬上山頂大約15分鐘路有點陡; 要付停車費; 付費廁所</code> <br/> Hverfjall 大約形成於約2500年前。當時，火山爆發後，熔岩覆蓋了周圍的湖水。湖水底下的悶燒池水在密閉空間裡積聚了大量水蒸氣，最終爆發形成了這樣的地形。</td></tr><tr><td><a href="https://maps.app.goo.gl/1S6zsD58aGrbKfqP7">Myvatn Berjaya Iceland Hotels旅館</a></td><td>沒廚房，但是設備和景色一級棒，房間內提供不錯的膠囊咖啡、沐浴乳、洗髮乳和潤髮乳等，非常好的室內設計！</td></tr></tbody></table><h2 id="Day07-眾神瀑布">Day07 眾神瀑布</h2><div class="note warning flat"><p>接下來這天的行程，從眾神瀑布到阿克雷里，會經過<strong>全境唯一收費的隧道</strong>，他沒有收費站、沒有柵欄只有一塊提示牌，看其他攻略說3小時內繳費就可以了，<em>這條隧道的收費是Kr.1650，但是我們沒有走收費隧道，有免費公路83號84號可以走</em>，繞開風景很漂亮，大概多開16公里，但是可能會因為天氣惡劣而導致關閉，風挺強的，當時開的時候雪在公路上飄，所以看不太清楚地面的樣子。</p><details class="toggle" ><summary class="toggle-button" style="">隧道位置圖片示意圖</summary><div class="toggle-content"><p><img src="https://i.imgur.com/xQZeoXY.png" alt=""><br><img src="https://i.imgur.com/sXMYTZ7.png" alt=""></p></div></details></div><div class="note info flat"><p>當天印象比較深刻的部分是<strong>旅館</strong>，這間旅館身處在有點像沖積平原的地方，可以看到很多河流把河床沖刷成三角狀，而<em>飯店處在一個偏遠的地方，附近完全沒有光害</em>！可惜那天的天氣雲層多，否則那天是我們來旅行極光KP值最高的一天！如果有機會，天氣好一定要來住住看！風景也很好，<em>廚房跟公共空間給人一種溫馨的感覺</em>。</p></div><p><img src="https://i.imgur.com/biB4SS7.png" alt=""></p><table><thead><tr><th>地點</th><th>備註</th></tr></thead><tbody><tr><td><a href="https://maps.app.goo.gl/q4q8RY8wp4WYHHwi7">眾神瀑布</a></td><td>開車會經過收費隧道，看能否繞路；不知道怎麼付費會罰款。</td></tr><tr><td>開車</td><td><code>眾神瀑布</code> to <code>小豬超市</code> 36 分鐘</td></tr><tr><td><a href="https://maps.app.goo.gl/C7CYzhdTgvvPDqog6">小豬超市</a></td><td>冰島唯二的小豬超市。請補貨，小紅書說有賣即食飯！！！</td></tr><tr><td>開車</td><td><code>小豬超市</code> to <code>住宿</code> 1 小時 33 分鐘</td></tr><tr><td><a href="https://maps.app.goo.gl/DdHH8gVeL19wCizE8">Helluland Guesthouse旅館</a></td><td>有廚房、有吹風機，偏郊區，但是如果天氣很好真的完全沒有光害，肯定會是看極光最佳之地。</td></tr></tbody></table><h2 id="Day08-草帽山-看海豹-回雷克雅維克">Day08 草帽山 + 看海豹 + 回雷克雅維克</h2><div class="note info flat"><p>這天的行程可以說是環島的最後一天，因為開車時間長達6小時，為了不要太晚回到雷克雅維克，所以我們只去了幾個簡單的景點，順路的草帽山跟看海豹。</p></div><p><img src="https://i.imgur.com/UyW5TrM.png" alt=""></p><table><thead><tr><th>時間</th><th><div style="width:150px">地點</div></th><th>備註</th></tr></thead><tbody><tr><td></td><td>開車</td><td><code>飯店</code> to <code>草帽山</code> 3hr 51min</td></tr><tr><td>15:00離開</td><td><a href="https://maps.app.goo.gl/e1maVSAWs64tb3tMA">草帽山</a></td><td>最佳拍攝地是一個瀑布，但是因為<em>冬天所以無法去前往瀑布的路線</em>，只能在停車場看看就走了（<code>停車場要付費，所以我們隨便找個路邊停一下</code>），山形在某些特定的角度還不錯。</td></tr><tr><td></td><td>開車</td><td><code>草帽山</code> to <code>看海豹</code> 42min</td></tr><tr><td>17:00離開</td><td><a href="https://maps.app.goo.gl/rYiNCUVBR2S6MWYYA">Ytri Tunga看海豹</a></td><td>只能遠遠的看，但是<em>看到海豹的機率非常高</em>，一過去就看到了，看到幾隻躺在岩石上懶懶的晒太陽，有的海面上還會稍微探出頭一下，挺可愛。</td></tr><tr><td></td><td>開車</td><td><code>看海豹</code> to <code>住宿</code> 2hr 3min</td></tr><tr><td>19:00抵達</td><td><a href="https://maps.app.goo.gl/ih2cpLXWZGtGi62o6">Hostel B47</a></td><td>有廚房，住兩晚</td></tr></tbody></table><h2 id="Day09-藍湖溫泉-市區燈塔追光">Day09 藍湖溫泉 + 市區燈塔追光</h2><div class="note info flat"><p>藍湖溫泉真的很棒！應該是人生中難忘的溫泉泡湯經驗吧…，雖然台灣的溫泉也不錯，但是<em>這裡的溫泉可以在泡湯的同時欣賞風景、喝飲品、敷面膜的體驗還是第一次</em>。我認為如果你要去泡藍湖溫泉有幾個建議：</p><ul><li><strong>不需要帶毛巾、洗澡用品</strong>，他們會提供。</li><li>可以<strong>不用買到Prime的票，買基本票就好</strong>，Prime多了一杯飲料跟比較好的面膜，但是基本的票也是有三溫暖跟桑拿可以使用，他們三溫暖不需要驗證就可以進去！</li></ul><p>那天我們很幸運的遇到來自香港的朋友，他們免費送我們他們的手環可以用來兌換飲料，很幸運。</p></div><p><img src="https://i.imgur.com/7aXtgNz.png" alt=""></p><table><thead><tr><th>地點</th><th>備註</th></tr></thead><tbody><tr><td>開車</td><td><code>飯店</code> to <code>藍湖</code> 42min</td></tr><tr><td><a href="https://maps.app.goo.gl/zo8uN6iJJAPnQLqZA">藍湖</a></td><td>需預約</td></tr><tr><td>開車</td><td><code>藍湖</code> to <code>市區</code> 45min</td></tr><tr><td><a href="https://maps.app.goo.gl/yyWPfqFdyyNMqjgh6">市區燈塔</a></td><td>市區追極光最佳地點，但是我得說，人太多了！<em>建議去找市區偏遠的地方</em>，看極光還比較好…，蠻推薦<a href="https://maps.app.goo.gl/G3QiumncWNPSzZZ96">這裡</a>沒有光害。如果硬要在燈塔，只有一個<em>意見那就是等到過12點，像是1~2點人少點再過去比較好</em>，不然所有車子都卡在燈塔附近，車子很難出來就算了，<em>車子的遠光燈都會影響觀賞體驗…還有一堆遊客會開閃光燈…</em></td></tr><tr><td><a href="https://maps.app.goo.gl/ih2cpLXWZGtGi62o6">Hostel B47</a></td><td>有廚房，睡飽點 明天睡機場</td></tr></tbody></table><h2 id="Day10-寄明信片-市區採買">Day10 寄明信片 + 市區採買</h2><div class="note info flat"><p>這天是我們最後一天，所以就是把一些小事情做完，<em>像是寄明信片、採買一些冰島的特產</em>，然後就是回家了。如果你預算不高，大概2000內可以買以下東西：</p><ul><li>明信片（去郵局買郵票寄信，寄回台灣大概100台幣內）</li><li>羊毛磁鐵（本店大概一個300台幣左右）</li><li>羊毛帽（大概一個1500台幣左右）</li><li>去機場再買冰島巧克力，買Salt口味！超級好吃！</li></ul></div><table><thead><tr><th>地點</th><th>備註</th></tr></thead><tbody><tr><td><a href="https://maps.app.goo.gl/WGFUDABZSLjWw7227">iceland memories</a></td><td>最推紀念品店，必買手工羊毛磁鐵</td></tr><tr><td><a href="https://maps.app.goo.gl/jYNRfuevyncDkFHK9">MJUK</a></td><td>必買羊毛帽</td></tr><tr><td><a href="https://maps.app.goo.gl/aXkitjeGoBgYEkLM6">Feldur</a></td><td>必買兔毛帽、兔毛圍脖</td></tr><tr><td><a href="https://maps.app.goo.gl/4bMnXKbQKw3juLTH6">哈爾格林姆教堂</a></td><td>應該是基督教堂，蠻新鮮的，畢竟歐洲都是天主教堂居多</td></tr><tr><td><a href="https://maps.app.goo.gl/KpSNM5SWS9xia3Qz8">icemart</a></td><td>紀念品</td></tr><tr><td><a href="https://maps.app.goo.gl/Hr8J88ei5HGWaXDB7">eymundsson</a></td><td>紀念品</td></tr></tbody></table><div class="note warning flat"><p><strong><a href="https://maps.app.goo.gl/LWbUgSuz7Q5WRwsK8?g_st=il">Hertz還車的地點</a>挺特別的</strong>，我們迷路了一下，後來發現他當初給我們鑰匙的信封袋背面有寫。然後他們的還車方式是，你把車停在還車場，然後<em>把wifi機器留在車上，鑰匙放在還車場旁邊入口建築物門口的信箱口</em>，那個信箱口的設計真的很白痴，他們是在牆上挖洞…你要把鑰匙投入洞裡，然後那個洞被信箱盒蓋住…。</p></div><h2 id="Day11-回家">Day11 回家</h2><p>這天回家的時候，剛好遇到德國法蘭克福機場罷工+德鐵罷工…又是另一個故事了(´･ω･`)。 但是我們很幸運的，飛機沒有取消，改搭公車回Karlsruhe。</p><h1 id="02-必須知道的App和網站">02-必須知道的App和網站</h1><div class="note info flat"><p>一定要開的網站：</p><ul><li>路況：<a href="https://umferdin.is/en/road/913080027">https://umferdin.is/en/road/913080027</a></li><li>極光：<a href="https://en.vedur.is/weather/forecasts/areas/">https://en.vedur.is/weather/forecasts/areas/</a></li></ul><p>手機的app推薦有以下幾個：</p></div><p><img src="https://i.imgur.com/1WadFLY.png" alt=""></p><h2 id="怎麼看極光">怎麼看極光</h2><p>點擊進入Aurora的App，主要會看的頁面有以下，我認為綠色蓋到的地方非常準，以我的經驗<em>只要天晴，綠色蓋到的地方就會看到極光</em>。<br><img src="https://i.imgur.com/EjkH1Zz.png" alt=""></p><p>雲層覆蓋的地方我認為看官方的比較準，可以點擊<a href="https://en.vedur.is/weather/forecasts/aurora/">極光預報</a>查看目前雲層覆蓋如下：<br><img src="https://i.imgur.com/0Hix6Eh.png" alt=""></p><h2 id="怎麼看路況">怎麼看路況</h2><div class="note warning flat"><p>這是最常看也是最重要的，<em>只要你有自駕，每次往下一個點就要看一次（如果天氣不好更是要不斷刷新，尤其夜晚天氣多變的時候）</em>。<strong>這是會救你一命的網站，一定要把它加到最愛！！！！</strong><br>網站：<a href="https://umferdin.is/en/road/913080027">https://umferdin.is/en/road/913080027</a></p></div><p><img src="https://i.imgur.com/yAxJ2vw.png" alt=""></p><h1 id="03-開銷花費">03-開銷花費</h1><p>廢話不多說，先給結論，含來回機票、冰川健行等，<strong>所有的費用大概是1451歐元</strong>（這裡還涵蓋一些意外的費用，像是臨時住的旅館和救援費用的差額），整體11天10夜的開銷大概會需要抓45000台幣。</p><p>以下圖片的表格是個人花費喔！旁邊的細節總額是四個人的開銷。<br><img src="https://i.imgur.com/wFXG3VJ.png" alt=""></p><p><strong>吃的部分</strong><br><em>我覺得我們自己煮的挺好的，平均一餐不到5歐元</em>：</p><ul><li><code>早午餐</code>：<ul><li>早上會把午餐一起做好，主要吃吐司、火腿、nutella巧克力醬、起司、水煮蛋，有時候可以配冰島的巧克力牛奶、或是燕麥奶（不用冰）。</li><li>建議把夾鏈袋帶上，可以把吐司放在裡面</li></ul></li><li><code>晚餐</code><ul><li>有時候買超大條鮭魚吃，冰島一定要去小豬超市買大鮭魚超級划算又好吃！</li><li>主要還有吃自己帶的泡麵</li><li>如果沒有泡麵就吃義大利麵也不錯</li></ul></li></ul><p><em>去小豬超市採購的時候，主要必買的東西有：</em></p><ul><li>雞蛋：因為我們有四個人，所以都會確保車上會有兩盒雞蛋</li><li>吐司、起司：做早午餐用</li><li>玉米罐頭：因為我們會帶康寶濃湯</li><li>蔬菜：大白菜真是可以久放的好蔬菜</li><li>蘋果：不要忘了補充水果</li><li>有時候想奢侈點時：<ul><li>燕麥奶</li><li>豬肉片</li><li>優格</li></ul></li></ul><p><strong>住宿的部分</strong><br><em>住宿主要會有幾點注意：</em></p><ul><li>可以先透過booking.com用地圖在你的行程附近找便宜的住宿有哪些</li><li>然後記得透過google map查一下是否有更便宜的價位（有時候google會列出不同平台的價格），甚至可以找一下旅館是否有官網，有時候官網更便宜…</li><li>接著要注意，如果你是冬天自駕，準備預定北部的飯店，如果不是大城市的話…<ul><li><code>注意飯店是否偏僻、遠離1號公路、夾帶山脈中間、或是查看路況的網站看一下通往該旅館的路是否可以通行...</code></li><li>這點很重要，因為我們就遇到了暴風雪，我們的飯店就在93號公路的底端，路途夾在兩座山脈之間，無法順利抵達飯店，只好臨時改住新旅館。</li><li><code>你也可以不訂旅館，當天看天氣狀況決定，因為冬天的旅館一定預定的到...</code></li></ul></li><li>建議選有廚房的飯店，才可以省錢自己煮（自己煮也比較好吃）</li></ul><p><strong>最大的開銷</strong><br>最大個開銷主要有以下幾項：</p><ul><li><code>機票</code>：如果是留學生，建議直接去Skyscanner選最便宜的日子去。<ul><li>啊！記得<em>有時候直接去官網買比SkyScanner便宜超多</em>！</li></ul></li><li><code>租車</code>：可以查看<a href="#04-%E8%87%AA%E9%A7%95%E5%92%8C%E7%A7%9F%E8%BB%8A">04-自駕和租車</a>的部分</li><li><code>冰川健行</code>：超級推薦<a href="https://glacieradventure.is/tour/blue-ice-cave-adventure/">這個跟團</a>!冰川冰洞一次滿足！</li><li><code>汽油費</code>：通常租車公司會給加油卡，去合作的加油站比較便宜，然後不要使用台灣的信用卡刷…否則非N1的加油站每次會先預扣6000台幣手續費，很傷。但是如果你是使用歐洲的銀行帳戶像是Revolut，刷完就會立刻退回了。N1會比其他加油站還要貴…。</li></ul><h1 id="04-自駕和租車">04-自駕和租車</h1><ul><li>先查好太陽下山的時間</li></ul><h2 id="租車公司">租車公司</h2><ul><li>Eurpocar 德國體驗不好</li><li>Hertz 推薦</li><li>一定要租wifi</li></ul><h2 id="雪地自駕注意">雪地自駕注意</h2><h1 id="05-保險">05-保險</h1><ul><li>Rental Car</li></ul><h1 id="06-意外事件">06-意外事件</h1><h2 id="理賠教學">理賠教學</h2><ul><li>推薦網站</li></ul><h1 id="07-極光拍攝">07-極光拍攝</h1><h1 id="08-行李準備">08-行李準備</h1><ul><li>暖暖包</li><li>衣服三套</li><li>腳架</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 旅遊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Iceland </tag>
            
            <tag> Travel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IT Project Management 重點整理</title>
      <link href="/posts/agile-and-waterfall/"/>
      <url>/posts/agile-and-waterfall/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>這是為了準備IT Project Management的期末考而整理的重點。</p><h1 id="Agile-vs-Waterfall">Agile vs Waterfall</h1><h2 id="Agile-Methodology">Agile Methodology</h2><ul><li>Ref: <a href="https://medium.com/uxeastmeetswest/%E6%95%8F%E6%8D%B7%E5%BC%8F%E9%96%8B%E7%99%BC-agile-%E7%80%91%E5%B8%83%E5%BC%8F%E9%96%8B%E7%99%BC-waterfall-%E6%95%8F%E6%8D%B7%E5%BC%8Fux-lean-ux-%E5%85%9C%E5%B9%BE-7f510cdd5fae">敏捷式開發(Agile)、瀑布式開發(Waterfall) 、敏捷式UX、Lean UX。兜幾？</a></li></ul><div class="note info flat"><p>敏捷的原則：減少浪費、快速產出、不斷循環、快速學習</p></div><p>敏捷是目前在軟體開發的趨勢，因為軟體開發的需求會隨著時間改變，所以需要一個可以快速產出並且可以快速改變的開發方法。</p><p><strong>Positive Side of Agile</strong></p><ul><li>客戶會需要與團隊緊密合作，客戶獲得了strong sense of ownership。</li><li>如果有上市時間更重要，敏捷可以更快的上市產出基本版本。</li></ul><p><strong>Negative Side of Agile</strong></p><ul><li>有時候會因為<em>衝刺到後面跟一開始的目標偏離</em>，讓產品缺乏一致性，<em>硬體產品也較不適用於此方法</em>，畢竟硬體做出來就不能一直更改。</li><li>客戶可能<em>沒這麼多時間</em></li><li>因為Agile專注在time-boxes交付和頻繁的重新確定優先順序，某些準備交付的項目可能無法在規定的時間內完成。可能<em>需要額外的衝刺Spring</em>（超出最初計劃的衝刺），從而增加專案成本。</li><li>如果在<em>初始架構和設計中沒有考慮系統的全部範圍</em>，敏捷開發的迭代性質可能會<em>導致頻繁的重構</em>。</li></ul><h2 id="Waterfall-Methodology">Waterfall Methodology</h2><ul><li>Ref: <a href="https://www.seguetech.com/waterfall-vs-agile-methodology/">Waterfall vs. Agile: Which is the Right Development Methodology for Your Project?</a></li></ul><div class="note info flat"><p>瀑布式就比較<strong>不迭代式(Iteratvie)</strong>，像瀑布般從上往下的線性流程：產品需求 &gt; 設計 &gt; 開發 &gt; 測試 &gt; 保養更新<br>開發時一般不會回去上一步驟，若有需要更改或是修正時較為困難，所以每一步驟都會非常小心仔細的產出。</p></div><p>對於比較大需求明確的專案，瀑布式開發是一個很好的選擇，因為需求明確，透過線性流程可以很好的控制進度，同時透過合約中的某些限制，計劃驅動可以降低風險。</p><p><strong>Positive Side of Waterfall</strong></p><ul><li>開發人員和客戶會在<em>開發生命週期早期就確定需求</em>，這讓規劃和設計更加直觀(straightforward)。</li><li>由於提前了解工作的全部範圍，因此更<em>容易衡量進度</em>。</li><li>除了審查、批准、狀態會議討論之外，在需求階段釐清後<em>客戶不需要嚴格在場</em>。</li><li>有時<em>適用同時開發多個專案的元件</em>，因為設計在開發生命週期早期就完成。</li></ul><p><strong>Negative Side of Waterfall</strong></p><ul><li><em>收集客戶需求是最難的部分</em>，客戶有時會被細節嚇倒，這種方法需要在專案早期提供的具體細節。</li><li>客戶並<em>不總是能夠從需求文件中視覺化應用程式</em>，線框和模型可以提供幫助，但是作為書面在理解內容上會遇到困難。</li><li>客戶可能<em>對其交付的軟體產品不滿意</em>，由於所有可交付成果均基於書面要求，因此客戶可能直到快要完成時才看到將交付的內容。到那時，實施變革可能會很困難（而且成本高昂）。</li></ul><h2 id="When-to-use-Agile-vs-Waterfall">When to use Agile vs Waterfall</h2><ul><li>Ref: <a href="https://www.seguetech.com/waterfall-vs-agile-methodology/">Waterfall vs. Agile: Which is the Right Development Methodology for Your Project?</a></li></ul><table><thead><tr><th>Project factor</th><th>Agile</th><th>Waterfall</th></tr></thead><tbody><tr><td>Customere Availability</td><td>客護需要頻繁參與討論</td><td>客戶只需要在前期參與</td></tr><tr><td>Features</td><td><em>頻繁改變</em>，對於scope不確定時適用</td><td>如當<em>事先知道範圍或合約條款</em>限制變更時效果很好</td></tr><tr><td>Propritization</td><td><em>最有價值的功能要先完成</em>，有效既低做出無用產品的風險，透過允許部分成功來降低完全失敗的風險</td><td><em>只做大家都同意的事情</em>，一開始就談清楚</td></tr><tr><td>Team</td><td>比較小、需要高度互動的團隊</td><td>團隊的互動有限</td></tr><tr><td>Funding</td><td>不確定性高的預算上適合，但是在<em>固定價格上不吃香</em></td><td>透過<em>固定價格談好來降低風險</em></td></tr><tr><td>Summary</td><td>Agile 在彈性高時適用</td><td>面對供應商與外部客戶之間的合約中的某些限制，計劃驅動可以降低風險</td></tr></tbody></table><h1 id="CRISP-DM">CRISP-DM</h1><p>在數據科學領域中，有效地處理和分析數據是取得成功的關鍵。然而，面對不斷增長的數據量和複雜性，我們需要一個結構化、可靠的方法來引導我們完成數據專案。CRISP-DM（Cross Industry Standard Process for Data Mining）作為一個廣泛應用的標準流程模型，應運而生，為數據科學家和分析師提供了一個清晰而靈活的框架，協助他們成功地應對各種數據挖掘項目。</p><p>在這篇文章中，我們將探討CRISP-DM的流程還有問題。</p><h2 id="Process">Process</h2><p><img src="https://i.imgur.com/Ee2azMG.png" alt=""><br><img src="https://i.imgur.com/rwKc5DO.png" alt=""></p><h2 id="Weakness">Weakness</h2><p><img src="https://i.imgur.com/BmEpD0S.png" alt=""></p><ul><li>Business Understanding 與其他步驟不依該獨立，並且缺少如何理解、驗證、細節化需求等活動。</li><li>沒有考慮到其他階段也需要backtrack<ul><li>Data Preparation 到 Business Understanding,或是Data Understanding, Data Preparation, Business Understanding 之間應該也要有循環。</li></ul></li></ul><p><img src="https://i.imgur.com/EwsRUJy.png" alt=""></p><ul><li><em>modeling 通常是需要與其他phases iterate的</em><ul><li>尤其是在 Data Preparation, Data Understanding, Business nderstanding, 和Deployment，modeling與這些phases進行iterate的目的是在improve models。</li><li>同時，應該要明確地<em>將agile的流程整合進去</em> Modeling 與其他 phases 的流程中，我認為是因為結果如果沒有達到客戶需求，就需要隨時做調整。</li></ul></li></ul><p><img src="https://i.imgur.com/Tm7ThOe.png" alt=""></p><ul><li>CRISP-DM <em>不支援某些資料探勘專案所需的敏捷性</em>。</li></ul><h1 id="Stacey">Stacey</h1><ul><li>ref: <a href="https://www.praxisframework.org/en/library/stacey-matrix">Stacey matrix</a></li></ul><p>Stacey Landscape Diagram是一個工具，可以<em>幫助您分析項目的複雜度，並選擇最合適的管理方法</em>。它是由管理學教授Ralph Douglas Stacey開發和發表的。</p><p>Stacey Landscape Diagram有兩個維度：</p><ul><li><strong>協議 Agreement</strong>: 協議是指項目的<em>目標和方法是否有共同的理解和支持</em>。</li><li><strong>確定性 Certainty</strong>: 確定性是指項目的<em>結果和影響是否可以預測和控制</em>。通常可以根據過去的經驗推斷新項目的結果。<ul><li>Far from certainty: 通常情況獨特新穎的項目，通常，因果關係是不清楚的。在<em>嘗試制定計劃時，過去的經驗幾乎沒有什麼幫助</em>。</li><li>Close from certainty: 人可以非常確定從過去推斷和預測行動的結果。</li></ul></li></ul><p><img src="https://i.imgur.com/hnIkqCV.png" alt=""><br><img src="https://i.imgur.com/7Eb8Ipr.png" alt=""><br>Stacey identified five areas：</p><ol><li><strong>Close to agreement, close to certainty:</strong><ul><li>close to certainty 表示可以從過去收集數據，用於預測未來。<ul><li>e.g. 建築和工程專案通常擁有豐富的技術數據。</li></ul></li><li>close to agreement 舉例來說，在交付工作開始前，就有詳細的說明和安排專案或計劃工作內容。<ul><li>e.g 可以在交付工作開始之前詳細說明和安排。透過監控詳細計劃來控制工作</li></ul></li><li>適合的專案管理：這個區域的項目可以使用傳統的項目管理方法，像是waterfall，因為這些<em>方法適用於詳細的規劃和控制，以及對於需求和目標的清晰定義</em>。</li></ul></li><li><strong>Far from agreement, close to certainty</strong><ul><li>Close to certainty 有些專案對於哪些目標是可能的以及如何實現這些<em>目標非常確定</em></li><li>Far from agreement 但對於<em>哪些目標具有『最大價值』卻缺乏共識</em>。<ul><li>e.g. 專案經理很難開發出可以<em>被對價值有不同看法的多個利害關係人接受的商業案例</em>。</li></ul></li><li>採取措施：在這一領域，談判、<em>達成妥協和發展聯盟等技能非常重要</em>。決策變得政治化而不是技術化。</li><li>適合的專案管理：可以使用看板方法，因為它<em>強調了透明度和可視性</em>，<em>以在不同的利害關係人之間協調、溝通建立共識</em>。</li></ul></li><li><strong>Close to agreement, far from certainty</strong><ul><li>Close to agreement 項目可能對預期目標高度一致。</li><li>Far from certainty 但對實現預期目標的因果關係卻不太確定。<ul><li>e.g. 當假設產出將如何帶來效益時，產出、成果和效益之間的關係通常可以屬於這一類。</li></ul></li><li>採取措施：在這種情況下，利害關係人之間<em>必須有強烈的共同願景</em>，並且需要<em>採取靈活、現實的規劃方法</em>。即使具體路徑尚未完全預先確定，專案經理和發起人也必須明顯地朝著商定的未來狀態（藍圖）前進。</li><li>適合的專案管理：可以使用敏捷方法，像是Scrum。因為這個方法可以讓<em>團隊在不確定的情況下快速反應</em>。</li></ul></li><li><strong>The zone of complexity</strong><ul><li>猶如垃圾桶決策模式，需要集思廣益、探索錯誤，在該區域所涵蓋的區域中，低水準的協議或低水準的確定性使專案成為一個<em>複雜的管理問題</em>。這個領域<em>經常引發糟糕的決策實踐</em></li><li>採取措施：而它真正<em>需要的是高水準的創造力、創新性和擺脫過去限制的自由來創造新的解決方案</em>。</li><li>適合的專案管理：這個可以使用eXtreme Programming (XP)或其他敏捷方法的變體。目的在促進團隊的創新和協作，透過頻繁的反饋和測試提高質量和效率。</li></ul></li><li><strong>The zone of chaos</strong><ul><li>分裂、無秩序，需要避免。在缺乏共識和確定性的地方，無政府狀態就會盛行。個人和組織有時會採取迴避措施，但這種情況並不總是可以避免。如果發生這些情況，需要採取策略來解決。</li><li>採取措施：而它真正<em>需要的是高水準的創造力、創新性和擺脫過去限制的自由來創造新的解決方案</em>。</li><li>適合的專案管理：如果到了這個區域就很難使用任何管理方法，因為缺乏明確的目標、也無法預測和控制，反而應該要進行危機管理、或是尋求專業協助。</li></ul></li></ol><h1 id="Design-Thinking">Design Thinking</h1><div class="note info flat"><p>Design Thinking 結合 Diverse <strong>People</strong> + Creative <strong>Space</strong> + Iterative <strong>Approach</strong> 來解決問題。<br><strong>是發散性思考階段和聚合思考階段</strong></p></div><p><img src="https://i.imgur.com/lLcgKXI.png" alt=""></p><ul><li>The Design Thinking Process is <em>characterized by divergent and convergent thinking stages</em>.<ul><li>設計思考過程的特徵<em>是發散性思考階段和聚合思考階段</em>。</li></ul></li><li>Design Thinking 重點：<ul><li>保持好奇心 open mind、建設性回饋文化（Constructive feedback culture）</li><li>允許失敗，失敗是學習的一部分</li></ul></li><li>每個Step的說明：<ul><li><code>Scoping</code>: 開始提出一些ㄒtopic, questions, thoughts, ideas，先<em>專注在思考自己的想法</em>。</li><li><code>360 Research</code>: <em>詢問跟傾聽</em>，詢問使用者/客戶，收集回饋，了解利害關係人的動機、目標。</li><li><code>Synthesis</code>:  把目前為止收到的意見回饋、想到的問題，進行<em>綜合</em>。</li><li><code>Ideate</code>: 理解問題後，開始<em>腦力激盪想解決方法</em>。</li><li><code>Prototype</code>: <em>做出最初的模型</em>，用來展示解決方案的感覺、外觀、和工作原理，使其變得有型。可以透過prototype獲得即時回饋</li><li><code>Validate</code>: 您要將您的原型進行測試，並<em>根據用戶的反饋進行改進和迭代</em>。</li></ul></li></ul><p><strong>People + Space + Approach</strong></p><ul><li><code>People</code>: 團隊合作、跨領域、定義規則並遵守。最好由 T 型人員組成的團隊，這裡的T是包含縱軸跟橫軸，橫軸是知識廣度、縱軸是專業知識。</li><li><code>Space</code>: 彈性, adapted 的工作環境可以創造出更好的想法。</li><li><code>Approach</code>: 思考問題、腦力激盪、規劃Project</li></ul><p><strong>Design和Stacey之間的關聯與合作</strong></p><ul><li>簡單介紹兩者<ul><li>Stacey Landscape Diagram 可以用來分析問題複雜度的工具。</li><li>Design Thinking是一種解決複雜問題的創新方法。</li></ul></li><li>關聯性：<ul><li>Stacey Landscape Diagram 可以協助設計者識別問題所處的區域，選擇合適的Design Thinking 方法，將Agreement跟Certainty更清楚和一致性。</li><li>舉例來說，如果目前問題處於Far from certainty，表示目前的狀況無法透過經驗來獲得解決，那麼設計者需要透過<em>創新和擺脫過去限制的自由來創造新的解決方案</em>。因此於Design Thinking中，可以採用迭代不斷測試和改進，從Complex往Complicated 和 Simple 的區域移動。</li><li>如果目前處於Far from agreement的狀態，表示目前團隊的共識不足，因此在Design Thinking的階段中，360 Research, Ideate 的階段需要做調整。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Agile, Waterfall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> agile </tag>
            
            <tag> waterfall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark UI 觀察日誌</title>
      <link href="/posts/pyspark-monitoring-ui/"/>
      <url>/posts/pyspark-monitoring-ui/</url>
      
        <content type="html"><![CDATA[<h1 id="Job-Stage-Task">Job, Stage, Task</h1><ul><li>Ref: <a href="https://zhuanlan.zhihu.com/p/59461521">[看图说话] 基于Spark UI性能优化与调试——初级篇</a></li><li>Ref: <a href="https://zhuanlan.zhihu.com/p/50752866">理解spark中的job、stage、task</a></li></ul><div class="note info flat"><p>本篇主要會記錄使用Spark的一些觀察日誌，希望可以了解以下問題：</p><ul><li><strong>Q: stage, task, job, partition 之間的關係？</strong></li><li><strong>Q: 何時會需要 Shuffle? Shuffle 是如何運作的？</strong></li></ul></div><p>簡單來說，一個 Spark Application 被提交之後，會<em>根據 Action 的觸發產生 Job，每個 Job 根據 Shuffle 的分界點，又會被分成多個 Stage，而每個 Stage 預設會根據核心大小、資料大小，包含多個 Partition</em>，也就是Task，以加快運算。大概是以下這種感覺：<br><img src="https://i.imgur.com/bcimzba.png" alt=""></p><h2 id="Job">Job</h2><p>首先，Spark 中的數據都是由 RDD 組成的，而 RDD 是由 partition 組成的，每個 partition 代表一個數據塊。RDD 支援兩種操作分別是 Transformation 和 Action，<em>Transformation 並不會讓程式馬上執行，而是會返回一個新的 RDD，而 Action 則會讓程式馬上執行，並返回一個結果</em>。</p><ul><li>常見的Transformation如：map、mapPartitions、flatMap、filter、union、groupByKey、repartition、cache等。</li><li>常見的Action如：reduce、collect、show、count、foreach、saveAsTextFile等。</li></ul><p>因此，<em>一個 Job 需要由 Action 執行所觸發</em>，而一個 Action 會觸發一個或多個 Transformation，也就代表 <em>一個 Job 會有多個運算子操作（Tansformation）</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 舉例來說，當執行以下程式時，UI才會顯示出一個Job，因為他使用read這個action</span></span><br><span class="line">ecommerce = spark.read\</span><br><span class="line">    .option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .csv(root)</span><br></pre></td></tr></table></figure><p>每個 Job 都是一系列的運算子操作，但是這些運算會有兩種情況：</p><ol><li><strong>窄依賴（Narrow Dependency）</strong>：簡單來說就是<em>下一個RDD所需要的數據來源</em>是某個特定Partition，<em>不需要跨越Partition</em>。</li><li><strong>寬依賴（Wide Dependency</strong>）：簡單來說就是<em>下一個 RDD 的執行，需要來自多個不同 Partition 的資料</em>。</li></ol><p><img src="https://i.imgur.com/irD8tgY.png" alt=""></p><p>你會發現，因為<em>Shuffle writing 變多了，這也會導致 gc 頻率提高更花時間</em>，畢竟很多資料都要 Buffer，儘管沒有 memory 也會透過寫進磁碟的方式紀錄資料。（這也意味著gc頻率變多，所以時間也較長）。<br><img src="https://i.imgur.com/MdmTT8p.png" alt=""></p><div class="note danger flat"><p>需要注意的是如果使用cache，在下一個Action這個cache的內容被釋放掉的話，該數據並沒有被緩存，而是需要重新計算。</p></div><h2 id="Task">Task</h2><p>Task是Spark最細的執行單元，<em>Task的數量就是Stage的併行度</em>，Task的數量由SparkContext的spark.default.parallelism設定，默認值是CPU核數。以Mac為例，透過輸入<code>sysctl hw.physicalcpu</code>可以得到CPU核數，而該CPU數量是一次Task可以執行的量。舉例來說，<em>我的核心如果是10，因此從下圖可以看到一次執行10個Parallel Task</em>。</p><p><img src="https://i.imgur.com/5Qv8Agx.png" alt=""></p><p>RDD 在計算的過程中，可能會分成多個 Partition，而每個 Partition 會被一個 Task 執行，<em>一個 Task 只會執行一個 Partition</em>。因此 <em>RDD 的 Partition 數量決定了所有的 Task 數量總數</em>。</p><div class="note warning flat"><p>需要注意的是，如果使用 map 不會影響 Partition 數量，但是在 Reduce RDD的聚合階段（將數據減少為一個單一的結果），因為 Reduce 操作會在 Cluster 的 Parition 上執行，將各 Partition 的結果匯總起來，導致會觸發Shuffle操作，</p><p>聚合後的RDD其Partition數量跟操作有關，如果使用 <code>repartition()</code> 就會聚合成指定的 Partition 數量。但如果使用 <code>coalesce</code> 同樣可以改變 Partition 數量，但是他不會觸發 Shuffle，而是會將 Partition 數量減少到指定的數量，因此會導致資料不均勻，而且會導致資料移動，因此效率較差。</p></div><h2 id="Stage">Stage</h2><div class="note primary flat"><p><strong>一個 Job 可能會包含多個 Stage，通常一個 Job 觸發多個 Stage ，而這些 Stage 的劃分是根據 Shuffle 所產生的，Shuffle依賴於兩個 Stage 的分界點</strong>。</p></div><p><strong>這句話什麼意思？</strong><br>關於Shuffle的操作通常會導致一個Stage的結束，因為Shuffle涉及到數據的重新分發和組織，需要將數據從不同的Partition重新組合到不同的節點上。*這個重新分發的過程會引入Network和I/O的開銷（磁碟寫入和讀取），因此Spark通常會將Shuffle操作作為一個Stage的邊界。*也因此 Shuffle 也是任務中最消耗資源的部分，因為數據可能保存在不同的節點，所以下一個 Stage (也就是下一個 shuffle) 要執行前，需要先等待上一個 Stage 的 shuffle 完成，然後把上一個 Stage 的結果從不同節點上拉取過來，這會增加Network和I/O。</p><h1 id="Shuffle">Shuffle</h1><ul><li>Ref: <a href="https://www.bing.com/ck/a?!&amp;&amp;p=3e87c923202af04fJmltdHM9MTcwNDc1ODQwMCZpZ3VpZD0zMWM5MGY5NS0yMTg3LTY0YzEtMmFjMy0xYzc5MjA5NzY1NjAmaW5zaWQ9NTUxMg&amp;ptn=3&amp;ver=2&amp;hsh=3&amp;fclid=31c90f95-2187-64c1-2ac3-1c7920976560&amp;psq=spark+shuffle+%e5%8e%9f%e7%90%86&amp;u=a1aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDA3NjYyMjkjOn46dGV4dD0lRTUlOUMlQThzaHVmZmxlJUU3JTlBJTg0JUU2JTk3JUI2JUU1JTgwJTk5JUU0JUJDJTlBJUU2JTlDJTg5JUU0JUI4JTgwJUU0JUI4JUFBJUU1JUFFJTlBJUU2JTk3JUI2JUU1JTk5JUE4JUVGJUJDJThDJUU0JUI4JThEJUU1JUFFJTlBJUU2JTlDJTlGJUU3JTlBJTg0JUU1JThFJUJCJUU0JUJDJUIwJUU3JUFFJTk3JUU4JUJGJTk5JUU0JUI4JUFBJUU1JTg2JTg1JUU1JUFEJTk4JUU3JUJCJTkzJUU2JTlFJTg0JUU3JTlBJTg0JUU1JUE0JUE3JUU1JUIwJThGJUVGJUJDJThDJUU1JUJEJTkzJUU1JTg2JTg1JUU1JUFEJTk4JUU3JUJCJTkzJUU2JTlFJTg0JUU0JUI4JUFEJUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU4JUI2JTg1JUU4JUJGJTg3NU0lRTYlOTclQjYlRUYlQkMlOEMlRTYlQUYlOTQlRTUlQTYlODIlRTclOEUlQjAlRTUlOUMlQTglRTUlODYlODUlRTUlQUQlOTglRTclQkIlOTMlRTYlOUUlODQlRTQlQjglQUQlRTclOUElODQlRTYlOTUlQjAlRTYlOEQlQUUlRTQlQjglQkE1LjAxTSVFRiVCQyU4QyVFOSU4MiVBMyVFNCVCOSU4OCVFNCVCQiU5NiVFNCVCQyU5QSVFNyU5NCVCMyVFOCVBRiVCNzUuMDElMkEyLTUlM0Q1LjAyTSVFNSU4NiU4NSVFNSVBRCU5OCVFNyVCQiU5OSVFNSU4NiU4NSVFNSVBRCU5OCVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCQiU5MyVFNiU5RSU4NCVFMyU4MCU4MiwlRTUlQTYlODIlRTYlOUUlOUMlRTclOTQlQjMlRTglQUYlQjclRTYlODglOTAlRTUlOEElOUYlRTQlQjglOEQlRTQlQkMlOUElRTglQkYlOUIlRTglQTElOEMlRTYlQkElQTIlRTUlODYlOTklRUYlQkMlOEMlRTUlQTYlODIlRTYlOUUlOUMlRTclOTQlQjMlRTglQUYlQjclRTQlQjglOEQlRTYlODglOTAlRTUlOEElOUYlRUYlQkMlOEMlRTglQkYlOTklRTYlOTclQjYlRTUlODAlOTklRTQlQkMlOUElRTUlOEYlOTElRTclOTQlOUYlRTYlQkElQTIlRTUlODYlOTklRTclQTMlODElRTclOUIlOTglRTMlODAlODI&amp;ntb=1">詳細的Shuffle機制</a></li></ul><h2 id="Working-Process">Working Process</h2><p><strong>Q: 何時會需要 Shuffle? Shuffle 是如何運作的？</strong><br>Shuffle 是 Spark 中最耗資源的操作，這個過程會涉及到磁盤的讀寫，以及網路的傳輸(Network bound)，因此會消耗大量的資源。以 <code>reduceByKey()</code> 為例，他會將上一個RDD 中的每個 Key 對應的所有 Value 聚合成一個 Value，然後生成一個新的 RDD，類似 <code>&lt;key, value&gt;</code>的形式。但是問題來了，<em>當我們準備把上一個 RDD 中的 Key 其 Value 進行聚合的時候，這些 Key 不見得都在同一個 Partition 中（可能在別的 Node），這時候就需要進行 Shuffle</em>。</p><p><strong>Q: 如何聚合？（這裡的聚合就是Shuffle）</strong><br>聚合的過程中會牽涉到兩種操作：</p><ul><li><em>Shuffle Write</em>: 把上一個 RDD <em>執行玩的內容（但是不同Partition）其 Key 寫到 Parition File</em>，這個 File 會被存在硬碟中（暫時的之後會gc處理掉），這麼做的目的是為了下一個 RDD 執行工作時，可以根據 Partition File 去不同的 Partition 獲取自己所需的 Value。</li><li><em>Shuffle Read</em>：這個步驟就是下*一個 RDD 去讀取上一個 RDD 的 Partition File，*然後根據自己的 Key 去獲取 Value。</li></ul><p><strong>Q: 具體是怎麼執行 Shuffle Write 跟 Shuffle Read 的？</strong><br>因為 Spark 有兩種不同的 Shuffle 類型，分別是 HashShuffle 和 SortShuffle，而這兩種 Shuffle 的差別在於 Shuffle Write 的時候，<em>HashShuffle 會把 Key 進行 Hash 後，根據 Hash 後的值去決定寫到哪個 Partition File，而 SortShuffle 則是根據 Key 的值去決定寫到哪個 Partition File</em>。而 Shuffle Read 的時候，<em>HashShuffle 會根據 Key 的 Hash 值去決定從哪個 Partition File 讀取，而 SortShuffle 則是根據 Key 的值去決定從哪個 Partition File 讀取</em>。</p><p>而一般進行HashShuffle的機制是，Map Task 有獨立自己的 Buffer，如下:<br><img src="https://i.imgur.com/6qqixGD.png" alt=""></p><ol><li>每一個 map task 執行完後將 value 寫到 buffer 中，下一個 Stage 有多少個 Task 就會有多少個 Butter (=多少個 block file)，buffer 的大小可以通過 <code>spark.shuffle.file.buffer</code> 設定，默認為32KB。</li><li>每個 buffer 會對應到一個磁碟小文件（也就是shuffle write的過程）。</li><li>最後，在執行 reduce task 時，會根據 map task 的數量，來決定 reduce task 要拉取多少個 map task 的輸出文件（也就是shuffle read的過程）。</li></ol><p>產生的Block File(磁碟檔案)數量是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>×</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">M \times R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span><br>where R is the number of reduce tasks and M is the number of map task</p><h2 id="Example-Cause-Shuffle">Example Cause Shuffle</h2><p>讓我們來舉例，Shuffle 發生的情況：</p><div class="note info flat"><p><strong>前提概要</strong>：比較一下兩段不一樣的程式，我們讀取了一份GB級別的csv檔案，因為檔案很大，所以會需要進行Partition，總共一個 Stage 執行 68 個 Task。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ecommerce = spark.read\</span><br><span class="line">    .option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .csv(root)</span><br></pre></td></tr></table></figure></div><p>以下這段程式，ecommerce是GB級別的資料，但是因為我們只顯示 5 筆，<em>加上 filter 是 Narrow Dependency 所以不會觸發 Shuffl</em>e，因此執行速度非常快，甚至一個 Task 就可以搞定，我們也可以在 UI 中看到只有一個 Task。scaling 的方式會根據 action 執行的內容決定，舉例來說 show(5) 因為只需要 5 筆資料，所以當執行的queries滿足request時就會停止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ecommerce = ecommerce.<span class="built_in">filter</span>(col(<span class="string">&quot;event_type&quot;</span>) == <span class="string">&quot;purchase&quot;</span>)</span><br><span class="line">ecommerce.show(<span class="number">5</span>) <span class="comment"># job id 3, this is no shuffle due to the RDD is narrow dependency (filter) </span></span><br></pre></td></tr></table></figure><p>但是當我們<em>使用Wide Dependency時，就會觸發 Shuffle</em>，因此會產生很多個 Task，而且執行速度也會變慢，因為需要等待 Shuffle Write 跟 Shuffle Read 的過程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = ecommerce.groupBy(<span class="string">&#x27;user_session&#x27;</span>).agg(</span><br><span class="line">    spark_max(<span class="string">&#x27;event_time&#x27;</span>).alias(<span class="string">&#x27;Date_order&#x27;</span>),  <span class="comment"># alias is rename function</span></span><br><span class="line">    spark_max(<span class="string">&#x27;user_id&#x27;</span>).alias(<span class="string">&#x27;user_id&#x27;</span>), </span><br><span class="line">    count(<span class="string">&#x27;user_session&#x27;</span>).alias(<span class="string">&#x27;order_count&#x27;</span>), </span><br><span class="line">    spark_sum(<span class="string">&#x27;price&#x27;</span>).alias(<span class="string">&#x27;price&#x27;</span>)  </span><br><span class="line">)</span><br><span class="line">result.show(<span class="number">5</span>) <span class="comment"># job id 4, this accure shuffle due to the RDD is wide dependency (groupBy)</span></span><br></pre></td></tr></table></figure><p>因此你也可以透過 Job id 3, 4 發現這兩者執行的任務會產生不一樣的 Task 數量與處理時間。<br><img src="https://i.imgur.com/s1yP0Pa.png" alt=""></p><p>下圖中，你會發現在資料量大的情況下，每個Partition所負責的資料很多，default是200個Partition，每個<br><img src="https://i.imgur.com/DheCwZ0.png" alt=""></p><div class="note warning flat"><p>你會發現，在不同size 資料讀取間，造成的明顯影響有以下：</p><ul><li>GC Time: 因為把 Shuffle 時執行的 Buffer 進行 GC。</li><li>Getting Result Time</li><li>Peak Execution Meemory</li><li>Shuffle Write Time</li></ul></div><blockquote><p>1BM file<br><img src="https://i.imgur.com/puwACLy.png" alt=""></p></blockquote><blockquote><p>1000 data raw<br><img src="https://i.imgur.com/mF7PTuV.png" alt=""></p></blockquote><h2 id="Problem">Problem</h2><p><strong>Q: Shuffle 可能會導致的問題？</strong><br>你可以從上面的問題發現，執行Shuffle Writing 會產生很多磁碟小文件（Block File）當磁碟小文件過多時可能會導致以下問題：</p><ol><li>Shuffle Read 的故城中會需要讀取很多 Block File (磁碟小文件)對象。因此在 JVM 堆內存中對象過多會<em>造成頻繁的 gc</em>，當gc因為內存不夠時，會導致 OOM （Out Of Memory）。</li><li>在數據傳輸過程中會需要平凡的 Network Bound，這可能會提高通信故障的可能性，一旦通信故障，就會導致 Task 失敗發生 <code>Shuffle file cannot find</code>這個錯誤，TaskScheduler 不負責重試，由DAGScheduler負責重試 Stage。</li></ol><h1 id="Partition">Partition</h1><ul><li><p>Ref: <a href="https://zhuanlan.zhihu.com/p/528649631">關於Repartition() vs Coalesce()之間的差異？</a></p></li><li><p>通常一個RDD的DD(Distributed dataset)，是由數個不同的Partition所組成，而Partition會分散在cluster不同node上。</p></li><li><p>partition數量太小可能導致cluster使用率降低，或是單一partition太大無法放入單機的記憶體中</p></li><li><p>partition數量太多可能導致較多的跨節點溝通，造成太多無謂的網路IO</p><ul><li>Spark官方與DataBricks都建議partition數量為叢集中可用核心數的3~4倍為一個參考值</li></ul></li></ul><div class="note warning flat"><p><strong>To be continue…</strong></p></div><h1 id="Fault-Tolerance">Fault Tolerance</h1><p>If we want our system to be fault tolerant, it should be redundant because we ==require a redundant component to obtain the lost data==. The faulty data recovers by redundant data.</p><h2 id="Cluster-容錯">Cluster 容錯</h2><h3 id="Worker-異常">Worker 異常</h3><div class="note info flat"><p>當 Worker 異常，Master 會透過心跳機制發現，並且移除異常的 Worker，然後重新啟動 Executor。</p></div><ul><li>Spark Worker會保持和Master的心跳，當Worker出現逾時時，Master呼叫timeOutDeadWorkers()方法進行處理，<em>移除逾時的Worker</em>。</li><li>移除時會通知Driver Executor已經移除(Executor異常處理詳見下文)，然後設定運行在目前Worker上的Driver重啟或直接刪除：</li></ul><h3 id="Executor-異常">Executor 異常</h3><div class="note info flat"><p>當 Executor 異常，會會重試三次，若仍是無法則嘗試取得可用的 Worker 節點並重新啟動 Executor。</p></div><ul><li>Executor發生異常時，外部的包裝類別ExecutorRunner會<em>把異常訊息傳送給Worker</em></li><li>然後Worker會<em>傳訊息給Master</em>。</li><li>Master 接收 Executor 狀態變更訊息後，如果發現 Executor 出現異常退出，則呼叫 Master.schedule 方法，<em>嘗試取得可用的 Worker 節點</em>並重新啟動 Executor。</li></ul><p>簡單來說，如果因為Worker異常而導致Stage失敗，就會觸發RDD容錯機制，會對運行失敗的Stage進行重試，預設三次。</p><p>我們可以透過點擊Executors Tab來觀察，有關為應用程式創建的執行程序的摘要信息，包括內存和磁碟使用情況以及任務和shuffle信息。</p><h2 id="Job-Task-容錯">Job Task 容錯</h2><p>RDD Lineage：</p><ul><li>基於RDD的各項transformation構成compute chain，這樣在計算結果丟失時可以根據lineage重新計算。</li><li>在<em>窄依賴</em>的情況下，因為每個父RDD Partition依賴於特定的子RDD Partition，<em>重新計算時可以直接使用這個子RDD Partition的數據</em>，沒有Redundant Computation（冗餘計算）。</li><li>在<em>寬依賴</em>的情況下，當丟失整一個子RDD Partition時，因為<em>多個父RDD Partition可能會依賴於這個子RDD Partition，因此Spark必須將與該子RDD相關的所有父RDD都重新計算</em>。<ul><li>因此如果compute chain很長的寬依賴情況下，建議做一次Checkpoint或是cache來先做緩存，減少執行開銷。</li></ul></li></ul><div class="note warning flat"><p><strong>Q: 什麼是Redundant Computation（冗餘計算）？</strong><br>主要常發生在寬依賴的情況下，因為每個父RDD Partition依賴多個子RDD Partition，重新計算時需要重新計算所有子RDD Partition，這樣就會造成Redundant Computation（冗餘計算）。</p></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> Debugging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo - Butterfly 版本的語言切換功能設置</title>
      <link href="/posts/hexo-butterfly-lang-switch/"/>
      <url>/posts/hexo-butterfly-lang-switch/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因為求職需求，需要把網站轉換成英文，但是也想保留中文，開始尋找方法可以做中英文切換。<br>剛好看到 <a href="https://butterfly.js.org/">Hexo - Butterfly 官方網站</a>，發現他們的網站就有中英文切換的功能，但是找遍了各個網站都沒有人說明。<br>所以只好看source code來了解是怎麼做的。</p><p>奮鬥了 2 天，終於找到方法了，以下是我整理的方法。</p><h1 id="Step-1-開設一個-private-en-repository">Step 1. 開設一個 private en repository</h1><ul><li>參考：<a href="https://www.igerm.ee/experience/%E5%AE%8C%E7%BE%8E%E7%9A%84Hexo%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">完美的Hexo多语言解决方案</a></li></ul><p>靈感主要參考上述連結，主要運作原理就是透過<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#">建立多個 GitHub Pages</a>，基本上會有一個專門運行中文的 repository，另外再開設一個專門運行英文的 repository，透過設定不同的 <code>config.yml</code> 和 <code>_config.butterfly.yml</code>來達到中英文切換的效果。</p><blockquote><p>以下是我建立的兩個 repository<br><img src="https://i.imgur.com/2D3inpr.png" alt=""></p></blockquote><blockquote><p>建立特定語言的 GitHub Pages<br><img src="https://i.imgur.com/6Q2AQkO.png" alt=""></p></blockquote><h1 id="Step-2-設置-en-zh-config">Step 2. 設置 [en/zh] config</h1><p>先用<code>_config.yml</code>複製出兩個檔案分別是 <code>config-en.yml</code>跟<code>config-zh.yml</code>檔案，並且做以下設定。</p><blockquote><p>config-en.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定成英文</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 en </span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://&lt;url-url&gt;/en</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/en/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定啟動的路徑</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source-en</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public-en</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把中文的 source 進行排除</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">source/</span></span><br></pre></td></tr></table></figure><blockquote><p>config-zh.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定成中文 </span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-TW</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用原本的url</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://shannonhung.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定啟動的路徑</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把英文的 source 進行排除</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">source-en/</span></span><br></pre></td></tr></table></figure><h1 id="Step-3-設定-切換語言的-js">Step 3. 設定 切換語言的 js</h1><ul><li>參考：<a href="https://github.com/jerryc127/butterfly.js.org/blob/main/source/self/btf.js">https://github.com/jerryc127/butterfly.js.org/blob/main/source/self/btf.js</a></li></ul><p>我是在這個<a href="https://github.com/jerryc127/butterfly.js.org/blob/main/source/self/btf.js">btf.js</a>看到的，你可以在 <code>source/self</code> 中建立這個 <code>btf.js</code>，內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判斷是否為英文</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isIncludeEN</span> = item =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">&#x27;/en/&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">includes</span>(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立 重新導向到不同語言的 url </span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">loadFullPage</span> = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = url</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新導向 </span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">eventFn</span> = (<span class="params">elements, includeEN</span>) =&gt; &#123;</span><br><span class="line">    elements.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!includeEN || !<span class="title function_">isIncludeEN</span>(item.<span class="property">href</span>)) &#123;</span><br><span class="line">        item.<span class="property">href</span> = <span class="string">`javascript:loadFullPage(&#x27;<span class="subst">$&#123;item.href&#125;</span>&#x27;);`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判斷目前是否為英文</span></span><br><span class="line">  <span class="keyword">const</span> nowIncludeEN = <span class="title function_">isIncludeEN</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 這邊記得改成你的 url</span></span><br><span class="line">  <span class="keyword">const</span> selector = nowIncludeEN</span><br><span class="line">    ? <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a[href^=&quot;https://&lt;your-url&gt;&quot;]&#x27;</span>)</span><br><span class="line">    : <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a[href^=&quot;/en/&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eventFn</span>(selector, nowIncludeEN)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h1 id="Step-4-建立-source-en-資料夾">Step 4. 建立 source-en 資料夾</h1><p>接下來很重要的一步，那就是把整個 <code>source</code> 資料夾複製，並且重新命名為 <code>source-en</code>，並確認 <code>btf.js</code> 有在 <code>source-en/self</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">├── source-en <span class="comment"># &lt;== here </span></span><br><span class="line">├── themes</span><br><span class="line">├── _config.butterfly.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── config-butterfly-en.yml </span><br><span class="line">├── config-en.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><h1 id="Step-5-建立-en-zh-Butterfly-config">Step 5. 建立 [en/zh] Butterfly config</h1><p>請先複製你自己的 <code>_config.butterfly.yml</code>，並且重新命名為 <code>config-butterfly-en.yml</code>跟<code>config-butterfly-zh.yml</code>，主要改動以下部分：</p><ol><li>並設定 Butterfly config 需要引入剛剛建立的 <code>btf.js</code>至不同的檔案</li><li>還有網站的目錄，你可以改成相對的語言目錄</li></ol><blockquote><p>config-butterfly-zh.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把目錄改成中文</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">找文章||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="string">目錄:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">    <span class="string">標籤:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">文章:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">首頁:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">關於我:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="string">相關連結:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="comment"># 添加以下內容 注意： English 請使用 /en/ 來導入，中文則是 /</span></span><br><span class="line">  <span class="string">語言||fas</span> <span class="attr">fa-language:</span> </span><br><span class="line">    <span class="attr">English:</span> <span class="string">/en/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-e</span></span><br><span class="line">    <span class="string">中文:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inject 剛剛建立好的 js </span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/btf.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>config-butterfly-en.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 英文描述你的目錄 </span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Archives: /archives/ || fas fa-archive</span></span><br><span class="line">  <span class="attr">Categroies:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">Find</span> <span class="string">Posts</span> <span class="string">||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="attr">By Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="attr">By Posts:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">Home Page:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">About Me:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="attr">Links:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="comment"># 以下網址記得修改成你的 但是這裡又不太一樣，</span></span><br><span class="line">  <span class="comment"># English 請使用 / 來導入，中文則是 https://ShannonHung.github.io/ 你的網址</span></span><br><span class="line">  <span class="string">Language||fas</span> <span class="attr">fa-language:</span></span><br><span class="line">    <span class="attr">English:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-e</span></span><br><span class="line">    <span class="string">中文:</span>  <span class="string">https://ShannonHung.github.io/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># inject 剛剛建立好的 js </span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/en/self/btf.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><div class="note danger flat"><p>注意！！<br><code>config-butterfly-en.yml</code> 中任何 <code>/img/</code> 圖片 或是 <code>/self/</code> 的 js 檔案，都要改成 <code>/en/img/</code> 或是 <code>/en/self/</code>，這樣才能正確顯示圖片或是引入 js 檔案。</p></div><h1 id="Step-6-於-package-json-建立腳本">Step 6. 於 package.json 建立腳本</h1><p>最後一步，就是更新 <code>package.json</code>，讓他可以產生<code>public-en</code>的資料夾，以便後續推到 repository en 中。</p><blockquote><p>pcakage.json</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;push&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo douban &amp;&amp; gulp &amp;&amp; hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git init &amp;&amp; git add . &amp;&amp; git commit -m &#x27;backup&#x27; &amp;&amp; git push origin main&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kk&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g --config config-en.yml &amp;&amp; hexo s --config config-en.yml&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Finally：腳本部署">Finally：腳本部署</h1><p>現在我們準備建立腳本做部署，請先確認你有以下檔案：</p><ul><li><code>config-butterfly-en.yml</code></li><li><code>config-butterfly-zh.yml</code></li><li><code>config-en.yml</code></li><li><code>config-zh.yml</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">├── public-en</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">├── source-en</span><br><span class="line">├── themes</span><br><span class="line">├── _config.butterfly.yml <span class="comment"># 沒有沒關係，腳本會自動建立 </span></span><br><span class="line">├── _config.yml <span class="comment"># &lt;== 沒有沒關係，腳本會自動建立 </span></span><br><span class="line">├── config-butterfly-en.yml <span class="comment"># &lt;== 這裡 en 的 butterfly config </span></span><br><span class="line">├── config-butterfly-zh.yml <span class="comment"># &lt;== 這裡 zh 的 butterfly config</span></span><br><span class="line">├── config-en.yml <span class="comment"># &lt;== 這裡 en 的 config</span></span><br><span class="line">├── config-zh.yml <span class="comment"># &lt;== 這裡 zh 的 config </span></span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>然後於跟目錄中建立一個 <code>deploy.sh</code>，內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        -h|--<span class="built_in">help</span>) </span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Usage: bash.sh [en|zh|all|show &lt;en|zh&gt;|-h]&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Options:&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [deploy|d] en   Deploy English configuration to GitHub Pages&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [deploy|d] zh   Deploy Chinese configuration to GitHub Pages&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [deploy|d] all  Deploy both English and Chinese configurations to GitHub Pages&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [show|s] en     Execute npm run show for English configuration&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [show|s] zh     Execute npm run show for Chinese configuration&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  -h, --help      Display this help message&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        d | deploy)</span><br><span class="line">            lang=<span class="variable">$2</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;en&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;zh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-<span class="variable">$lang</span>.yml&quot;</span> _config.yml</span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-butterfly-<span class="variable">$lang</span>.yml&quot;</span> <span class="string">&quot;_config.butterfly.yml&quot;</span></span><br><span class="line">                npm run kk</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Deploy <span class="variable">$1</span> success!&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;all&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">for</span> lang_choice <span class="keyword">in</span> <span class="string">&quot;zh&quot;</span> <span class="string">&quot;en&quot;</span>; <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">cp</span> <span class="string">&quot;config-<span class="variable">$lang_choice</span>.yml&quot;</span> _config.yml</span><br><span class="line">                    <span class="built_in">cp</span> <span class="string">&quot;config-butterfly-<span class="variable">$lang_choice</span>.yml&quot;</span> <span class="string">&quot;_config.butterfly.yml&quot;</span></span><br><span class="line">                    npm run kk</span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">&quot;Deploy <span class="variable">$lang_choice</span> success!&quot;</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Error! Please input &#x27;en&#x27; or &#x27;zh&#x27; or &#x27;all&#x27;!&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            ;;</span><br><span class="line">        s | show)</span><br><span class="line">            lang=<span class="variable">$2</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;en&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;zh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-<span class="variable">$lang</span>.yml&quot;</span> _config.yml</span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-butterfly-<span class="variable">$lang</span>.yml&quot;</span> <span class="string">&quot;_config.butterfly.yml&quot;</span></span><br><span class="line">                npm run show</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Running npm show!&quot;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Error! Please use &#x27;./bash.sh show en&#x27; or &#x27;./bash.sh show zh&#x27;!&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            <span class="built_in">shift</span> <span class="comment"># Move to the next argument after &#x27;show&#x27;</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Error! Please input deploy &lt;en|zh|all&gt; or &#x27;show &lt;en|zh&gt;&#x27; or &#x27;-h&#x27; for help!&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>記得把它改成可執行檔，然後可以透過以下指令進行部署囉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x deploy.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尋求幫助</span></span><br><span class="line">./deploy.sh -h</span><br><span class="line">./deploy.sh --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送英文 到 en repository  </span></span><br><span class="line">./deploy.sh deploy en </span><br><span class="line">./deploy.sh d en </span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送中文 到 zh repository </span></span><br><span class="line">./deploy.sh deploy zh</span><br><span class="line">./deploy.sh d zh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地運行英文 </span></span><br><span class="line">./deploy.sh show en</span><br><span class="line">./deploy.sh s en</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地運行中文</span></span><br><span class="line">./deploy.sh show zh</span><br><span class="line">./deploy.sh s z</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="進階：不同文章切換中英文">進階：不同文章切換中英文</h1><p>如果你希望可以透過點擊 bottom 來達到中英文切換的效果如下：<br><img src="https://i.imgur.com/p9KnWUd.png" alt=""></p><p>那就繼續看下去吧！</p><h2 id="Step1-改寫-config-butterfly-lang-yml">Step1: 改寫 <code>config-butterfly-&lt;lang&gt;.yml</code></h2><blockquote><p>config-butterfly-zh.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="comment"># 開啟簡繁轉換 button </span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 預設繁體 </span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">繁</span></span><br><span class="line">  <span class="comment"># 如果是 `1` 就是中文 `3` 則是英文 </span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）/ 3 - English</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>config-butterfly-.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (簡繁轉換)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="comment"># 開啟簡繁轉換 button </span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 預設英文 </span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">En</span></span><br><span class="line">  <span class="comment"># 如果是 `1` 就是中文 `3` 則是英文 </span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="Step2-撰寫-tw-en-js-檔案">Step2. 撰寫 <code>tw_en.js</code> 檔案</h2><p>接下來我們要寫一個 js 檔案，在任意一個頁面時，點擊 bottom 就可以切換中英文，邏輯是：</p><ul><li>如果目前網站是：<code>https://&lt;rul&gt;/en/posts/&lt;post1&gt;</code><ul><li>當點擊 EN bottom 時，就會導向 <code>https://&lt;rul&gt;/posts/&lt;post1&gt; </code></li><li>簡單來說就是把 <code>/en</code> 移除</li></ul></li><li>如果目前網站是：<code>https://&lt;rul&gt;/posts/&lt;post1&gt;</code><ul><li>當點擊 EN bottom 時，就會導向 <code>https://&lt;rul&gt;/en/posts/&lt;post1&gt;</code></li><li>簡單來說就是在第一個 <code>/</code> 後面加上 <code>/en</code></li></ul></li></ul><p>因此我們把邏輯撰寫於 <code>source/self/tw_en.js</code> 與 <code>source-en/self/tw_en.js</code> 如下程式碼：</p><blockquote><p>tw_en.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; defaultEncoding, translateDelay, msgToTraditionalChinese &#125; =</span><br><span class="line">    <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">translate</span>;</span><br><span class="line">  <span class="keyword">const</span> msgToEnglish = <span class="string">&quot;EN&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> snackbarData = <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span>;</span><br><span class="line">  <span class="keyword">let</span> currentEncoding = defaultEncoding;</span><br><span class="line">  <span class="keyword">const</span> targetEncodingCookie = <span class="string">&quot;translate-en-cht&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> targetEncoding =</span><br><span class="line">    saveToLocal.<span class="title function_">get</span>(targetEncodingCookie) === <span class="literal">undefined</span></span><br><span class="line">      ? defaultEncoding</span><br><span class="line">      : <span class="title class_">Number</span>(saveToLocal.<span class="title function_">get</span>(<span class="string">&quot;translate-en-cht&quot;</span>));</span><br><span class="line">  <span class="keyword">let</span> translateButtonObject;</span><br><span class="line">  <span class="keyword">const</span> isSnackbar = snackbarData !== <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isIncludeEN</span> = (<span class="params">item</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">&quot;/en/&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">includes</span>(key);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nowIncludeEN = <span class="title function_">isIncludeEN</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">translatePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentUrl = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nowIncludeEN) &#123;</span><br><span class="line">      <span class="comment">// 把文字顯示成繁體中文</span></span><br><span class="line">      translateButtonObject.<span class="property">textContent</span> = msgToTraditionalChinese;</span><br><span class="line">      <span class="comment">// 然後導向繁體中文的網址 目前網址 /en/... =&gt; /...</span></span><br><span class="line">      <span class="keyword">let</span> newUrl = currentUrl.<span class="title function_">replace</span>(<span class="string">&quot;/en/&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Redirect to <span class="subst">$&#123;newUrl&#125;</span>`</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = newUrl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 把文字顯示成英文</span></span><br><span class="line">      translateButtonObject.<span class="property">textContent</span> = msgToEnglish;</span><br><span class="line">      <span class="comment">// 然後導向英文的網址 目前網址 /... =&gt; /en/...</span></span><br><span class="line">      <span class="keyword">let</span> newUrl = currentUrl.<span class="title function_">replace</span>(<span class="regexp">/^(https?:\/\/[^\/]+)(\/)?/</span>, <span class="string">&quot;$1/en/&quot;</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = newUrl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">translateInitialization</span>(<span class="params"></span>) &#123;</span><br><span class="line">    translateButtonObject = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;translateLink&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (translateButtonObject) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nowIncludeEN) &#123;</span><br><span class="line">        translateButtonObject.<span class="property">textContent</span> = msgToTraditionalChinese;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        translateButtonObject.<span class="property">textContent</span> = msgToEnglish;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pjax:complete&quot;</span>, translateInitialization);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">translateFn</span> = &#123;</span><br><span class="line">    translatePage,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">translateInitialization</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Step3-設定-js-於-config-中">Step3. 設定 js 於 config 中</h2><p>打開 <code>config-butterfly-&lt;lang&gt;.yml</code>，並且設定 <code>inject</code> 如下：</p><blockquote><p>config-butterfly-en.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/en/self/btf.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/en/self/tw_en.js&quot;&gt;&lt;/script&gt;</span> <span class="comment"># &lt;== 這裡</span></span><br></pre></td></tr></table></figure><blockquote><p>config-butterfly-zh.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/btf.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/tw_en.js&quot;&gt;&lt;/script&gt;</span> <span class="comment"># &lt;== 這裡</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark and Pyspark Local Mode &amp; Cluster on Mac</title>
      <link href="/posts/pyspark-install-notebook/"/>
      <url>/posts/pyspark-install-notebook/</url>
      
        <content type="html"><![CDATA[<h1 id="Install-Java">Install Java</h1><p>Open a terminal and execute java. It should redirect you to a download site (if you haven’t installed it already)</p><p><img src="https://i.imgur.com/ZlLffKo.png" alt=""></p><h1 id="Python-3">Python 3</h1><div class="note warning flat"><p>如果你透過 homebrew 安裝，或 conda 可以跳過此步驟。</p></div><p>Browse to <a href="https://python.org/downloads">https://python.org/downloads</a>, get a 3.x version (latest is 3.12.0.). Install the pkg.</p><p><img src="https://i.imgur.com/tNa5lHd.png" alt=""></p><h1 id="Spark-Pyspark">Spark/Pyspark</h1><p>Go to <a href="https://spark.apache.org/downloads.html">https://spark.apache.org/downloads.html</a> and download Spark. Use Spark 3.5.0 for Hadoop 3.3</p><p><img src="https://i.imgur.com/zUkILNQ.png" alt=""></p><p>執行以下指令，我們把 spark 移動到 <code>/usr/local</code> 底下，通常 <code>/usr/local</code> 是使用者自己手動下載的非系統預設軟體，這個folder由用戶自己管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Untar Archive with: </span></span><br><span class="line">tar xfz Downloads/spark-3.5.0-bin-hadoop3.tar.gz </span><br><span class="line">sudo <span class="built_in">mv</span> spark-3.5.0-bin-hadoop3 /usr/local</span><br></pre></td></tr></table></figure><p>然後設定環境變數，因為我是使用zsh作為shell，所以我們要設定 <code>~/.zshenv</code>，如果你是使用bash，請設定 <code>~/.bash_profile</code>。</p><div class="note danger flat"><p>注意的是，如果你是使用 conda 要把 python3 改成 python 因為你要使用 conda 的 python，而不是系統預設的 python。如下：<br><code>echo 'export PYSPARK_DRIVER_PYTHON=python' &gt;&gt; ~/.zshenv</code><br>會這樣改是因為，homebrew 的 python 指令是 python3 而不是 python。但是 conda 的 python 指令是 python，你可以透過 conda activate 來自由切換 python 版本。因此如果輸入pyspark的時候，就會根據 <code>PYSPARK_DRIVER_PYTHON</code> 所指定的指令進行啟動。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (zsh Version; for bash, use ~/.bash_profile instead of ~/.zshenv) </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYSPARK_DRIVER_PYTHON=python3&#x27;</span> &gt;&gt; ~/.zshenv </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export SPARK_HOME=/usr/local/spark-3.5.0-bin-hadoop3&#x27;</span> &gt;&gt; ~/.zshenv </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshenv</span><br></pre></td></tr></table></figure><p>最後嘗試啟動 Pyspark 看看<br><img src="https://i.imgur.com/VR4zKpu.png" alt=""></p><h1 id="安裝必要套件">安裝必要套件</h1><p>請根據你所使用的套件管理工具進行安裝，以下是兩種常見的套件管理工具。</p><blockquote><p>pip</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook </span><br><span class="line">pip install findspark </span><br></pre></td></tr></table></figure><blockquote><p>conda</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge notebook</span><br><span class="line">conda install -c conda-forge findspark</span><br></pre></td></tr></table></figure><h1 id="測試Pyspark-on-notebook">測試Pyspark on notebook</h1><p>輸入以下指令，如果成功會看到以下畫面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> findspark </span><br><span class="line">findspark.init() </span><br><span class="line"><span class="keyword">import</span> pyspark <span class="comment"># only run after findspark.init() </span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession </span><br><span class="line">spark = SparkSession.builder.getOrCreate() </span><br><span class="line">df = spark.sql(<span class="string">&#x27;&#x27;&#x27;select &#x27;spark&#x27; as hello &#x27;&#x27;&#x27;</span>) </span><br><span class="line">df.show() </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fa56EZO.png" alt=""></p><h1 id="建立Spark-Cluster">建立Spark Cluster</h1><p>你也可以透過spark-3.5.0-bin-hadoop3裡面的spark-class來建立自己的cluster在本機上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先啟動 master node，可以指定要啟動的IP 或是不指定也可以</span></span><br><span class="line"><span class="comment"># The host flag ( --host) is optional. </span></span><br><span class="line">spark-class org.apache.spark.deploy.master.Master --host &lt;IP_Addr&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup Slave Nodes </span></span><br><span class="line">spark-class org.apache.spark.deploy.worker.Worker spark://&lt;master_ip&gt;:7077 --host &lt;IP_ADDR&gt;</span><br></pre></td></tr></table></figure><p>Access the Spark UI through the master URL on port 8080 http://&lt;MASTER_IP&gt;:8080</p><p>然後在Jypyter Notebook就可以透過以下指令連接到你的cluster</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> findspark </span><br><span class="line">findspark.init()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyspark </span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line">spark = SparkSession.builder.master(<span class="string">&quot;spark://&lt;master_ip&gt;:7077&quot;</span>).appName(<span class="string">&quot;APP-Name&quot;</span>).getOrCreate()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyspark 的基本概念</title>
      <link href="/posts/pyspark-basic/"/>
      <url>/posts/pyspark-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本篇文章主要的目的是在整理 Spark: The Definitive Guide 這本書的內容，並且加上自己的理解，讓自己更加熟悉 Spark 的基本概念。</p><h1 id="Spark-Application">Spark Application</h1><p>取自：Spark: The Definitive Guide<br><img src="https://i.imgur.com/zVujAB9.png" alt=""></p><p>Spark Application mainly consist of two processes:</p><ol><li><strong>Driver process</strong>：<ul><li>executing main() function, sits on a node in the cluster</li><li>maintaining information about the Spark Application</li><li>responding to a user’s program or input</li><li>analyzing, distributing, and scheduling work across the executors</li></ul></li><li><strong>Executor process</strong>：<ul><li>executing code assigned to it by the driver</li><li>reporting the state of the computation on that executor back to the driver node</li></ul></li></ol><h1 id="Spark’s-APIs">Spark’s APIs</h1><p><img src="https://i.imgur.com/BAHyroO.png" alt=""></p><p>Spark’s language APIs 提供其他程式語言像是Python或是R等，執行Spark code的能力。有一個 SparkSession object 會被建立，SparkSession 你可以想像他是執行 Spark code 的入口，如果使用其他語言像是Python時，不需要撰寫JVM指令，可以<strong>透過 Spark’s Language API 將 Python code 轉換成可以在 JVMs 上面執行的程式</strong>。</p><h1 id="SparkSession">SparkSession</h1><div class="note info flat"><p>SparkSesion：透過 driver process 控制 Spark Application。</p></div><p><img src="https://i.imgur.com/Q3ttftn.png" alt=""></p><p>透過 PySpark （Spark API）來建立 SparkSession：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> findspark </span><br><span class="line">findspark.init() </span><br><span class="line"><span class="keyword">import</span> pyspark <span class="comment"># only run after findspark.init() </span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession </span><br><span class="line">spark = SparkSession.builder.getOrCreate() </span><br><span class="line">df = spark.<span class="built_in">range</span>(<span class="number">1000</span>).toDF(<span class="string">&quot;number&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Structured-API">Structured API</h1><p><img src="https://i.imgur.com/DbwJUEd.png" alt=""></p><h2 id="Datasets">Datasets</h2><ul><li><strong>差異</strong>：<ul><li>Datasets 是 Spark 中的類型安全 API，在 Java 和 Scala 中提供了靜態類型的支持。（也就是在編譯前就知道數據類型）</li><li>它允許將 Java/Scala 類型分配給 DataFrame 中的記錄，並以類似 Java ArrayList 或 Scala Seq 的方式操作它們。</li></ul></li><li><strong>使用時機</strong>：<ul><li>Datasets 適合於需要靜態類型支持的情況，特別是大型應用程序中，多個工程師通過明確定義的接口進行交互時。</li><li>就像Java中的Class，你會定義好他的屬性、名稱、函式等。</li></ul></li><li><strong>例子</strong>：<ul><li>如果你需要對數據進行較為複雜的操作，而且<code>需要保證類型安全</code>，那麼使用 Dataset 是個不錯的選擇。</li><li>例如，進行較複雜的業務邏輯，同時需要在數據處理中保持靜態類型檢查。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 先定義好class 型別 </span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title class_">Flight</span>(<span class="attr">DEST_COUNTRY_NAME</span>: <span class="title class_">String</span>,</span><br><span class="line">                  <span class="attr">ORIGIN_COUNTRY_NAME</span>: <span class="title class_">String</span>,</span><br><span class="line">                  <span class="attr">count</span>: <span class="title class_">BigInt</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 讀取資料</span></span><br><span class="line">val flightsDF = spark.<span class="property">read</span></span><br><span class="line">  .<span class="title function_">parquet</span>(<span class="string">&quot;/data/flight-data/parquet/2010-summary.parquet/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轉換資料對應至型別中</span></span><br><span class="line">val flights = flightsDF.<span class="property">as</span>[<span class="title class_">Flight</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">flights</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">flight_row</span> =&gt;</span> flight_row.<span class="property">ORIGIN_COUNTRY_NAME</span> != <span class="string">&quot;Canada&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">flight_row</span> =&gt;</span> flight_row)</span><br><span class="line">  .<span class="title function_">take</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">flights</span><br><span class="line">  .<span class="title function_">take</span>(<span class="number">5</span>)</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">flight_row</span> =&gt;</span> flight_row.<span class="property">ORIGIN_COUNTRY_NAME</span> != <span class="string">&quot;Canada&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">fr</span> =&gt;</span> <span class="title class_">Flight</span>(fr.<span class="property">DEST_COUNTRY_NAME</span>, fr.<span class="property">ORIGIN_COUNTRY_NAME</span>, fr.<span class="property">count</span> + <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="DataFrames">DataFrames</h2><ul><li><strong>差異</strong>：<ul><li>DataFrames 是分佈式的 Row 對象集合，用於處理各種類型的表格數據。</li><li>它提供了一個<code>更接近 SQL 操作的界面</code>(只是是透過函示呼叫)，並且是 Python、R 和 Scala 中使用最廣泛的 API。</li></ul></li><li><strong>使用時機</strong>：<ul><li>當你需要以類似於 SQL 的方式操作和轉換數據時，DataFrames 是一個很好的選擇。它的彈性和簡潔性使得能夠快速進行數據操作和轉換。</li></ul></li><li><strong>例子</strong>：<ul><li>例如，進行數據過濾、聚合、連接和簡單的轉換等操作時，DataFrames 是一個非常方便的選擇。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先讀取資料</span></span><br><span class="line">flight = spark.read\</span><br><span class="line">    .option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .csv(os.path.join(root, <span class="string">&quot;flight-data/csv/2015-summary.csv&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接近SQL操作介面，但是使用起來更加方便</span></span><br><span class="line">dataframeway = flight.groupBy(<span class="string">&quot;DEST_COUNTRY_NAME&quot;</span>).count()  </span><br></pre></td></tr></table></figure><h2 id="SQL">SQL</h2><ul><li><strong>差異</strong>：<ul><li>SQL 是一種結構化查詢語言，允許使用<code>類 SQL 的語法進行數據操作</code>。(可以直接寫SQL)</li><li>在 Spark 中，你可以使用 SQL 像操作關聯式數據庫一樣操作 DataFrame 和 TempView。</li></ul></li><li><strong>使用時機</strong>：<ul><li>當你更擅長於 SQL 語法，或者希望使用標準 SQL 操作數據時，SQL 是一個很好的選擇。它也能提供可讀性強、易於維護的優勢。</li></ul></li><li><strong>例子</strong>：<ul><li>如果你有大量的 SQL 經驗，或者希望通過使用 SQL 來表達數據操作，那麼在 Spark 中使用 SQL 是很直觀的。</li><li>舉例來說，對於熟悉 SQL 語法的用戶，將一些較複雜的數據操作轉化為 SQL 可能更為自然和高效。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先讀取資料</span></span><br><span class="line">flight = spark.read\</span><br><span class="line">    .option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .csv(os.path.join(root, <span class="string">&quot;flight-data/csv/2015-summary.csv&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 註冊為一個名為 &quot;flight_data_2015&quot; 的暫時性視圖。</span></span><br><span class="line"><span class="comment"># 這意味著你可以使用 SQL 語法或 Spark 的 DataFrame API 在程式中直接查詢這個名為 &quot;flight_data_2015&quot; 的視圖。</span></span><br><span class="line">flight.createOrReplaceTempView(<span class="string">&quot;flight_data_2015&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這樣就可以透過 SQL 語法進行查詢</span></span><br><span class="line">sqlway = spark.sql(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT DEST_COUNTRY_NAME, count(1) </span></span><br><span class="line"><span class="string">                   FROM flight_data_2015 </span></span><br><span class="line"><span class="string">                   GROUP BY DEST_COUNTRY_NAME</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三者比較">三者比較</h2><ul><li><strong>效率</strong>：DataFrames 和 SQL 提供了簡潔、易讀且高效的數據操作方式，適用於快速開發和簡單轉換。</li><li><strong>類型安全</strong>：Datasets 提供了靜態類型支持，適用於對類型安全性要求較高的情況。</li></ul><h1 id="Structured-Streaming">Structured Streaming</h1><p>StreamingDataFrame 跟 staticDataFrame 有什麼差異呢？</p><h2 id="差異">差異</h2><ul><li><strong>StreamingDataFrame</strong>:<ul><li>用於處理流式數據，是基於連續到達的數據流進行操作。</li><li>使用 readStream 方法讀取流式數據。</li><li>可以通過在流式數據上應用操作和轉換來進行實時處理。</li></ul></li><li><strong>staticDataFrame</strong>:<ul><li>用於處理靜態、固定的數據集，是一次性加載整個數據集進行操作。</li><li>使用 read 方法從靜態數據源（如文件、資料庫等）讀取數據。</li><li>適用於批處理作業，對於靜態且不會變動的數據進行操作和分析。</li></ul></li></ul><p><strong>流式操作</strong></p><ul><li>它的目的是將數據寫入某個地方，而不僅僅是對數據進行計算或統計（例如 count 操作在流式上是沒有意義的）。</li><li>流式操作會將結果輸出到內存表，並在每次觸發（trigger）後更新該表。</li><li>在啟動了流式處理之後，可以使用透過儲存的內存 Table 使用 SQL 查詢來檢視內存表中的結果。</li><li>好處：這樣的操作讓你可以在將數據寫入最終目的地之前，先對計算結果進行預覽和檢查，以確保數據處理和計算的準確性和一致性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 讀取資料適用 load 而不是 read </span></span><br><span class="line"><span class="comment"># 2. maxFilesPerTrigger 代表每次觸發的檔案數量 也就是新的檔案進來時，會觸發一次</span></span><br><span class="line">streamingDataFrame = spark.readStream\</span><br><span class="line">    .schema(staticSchema)\</span><br><span class="line">    .option(<span class="string">&quot;maxFilesPerTrigger&quot;</span>, <span class="number">1</span>)\</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;csv&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .load(<span class="string">&quot;/data/retail-data/by-day/*.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 當trigger發生時，會將結果輸出到內存表中，但是以下是lazy evaluation，所以不會真的執行</span></span><br><span class="line"><span class="comment"># 要透過 writeStream 來啟動</span></span><br><span class="line">purchaseByCustomerPerHour = streamingDataFrame\</span><br><span class="line">  .selectExpr(</span><br><span class="line">    <span class="string">&quot;CustomerId&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(UnitPrice * Quantity) as total_cost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;InvoiceDate&quot;</span>)\</span><br><span class="line">  .groupBy(</span><br><span class="line">    col(<span class="string">&quot;CustomerId&quot;</span>), window(col(<span class="string">&quot;InvoiceDate&quot;</span>), <span class="string">&quot;1 day&quot;</span>))\</span><br><span class="line">  .<span class="built_in">sum</span>(<span class="string">&quot;total_cost&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># writeStream 當每次 trigger 觸發的時候，會將結果輸出到內存表中</span></span><br><span class="line">purchaseByCustomerPerHour.writeStream\</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;memory&quot;</span>)\</span><br><span class="line">    .queryName(<span class="string">&quot;customer_purchases&quot;</span>)\</span><br><span class="line">    .outputMode(<span class="string">&quot;complete&quot;</span>)\</span><br><span class="line">    .start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過儲存的內存 Table 使用 SQL 查詢來檢視內存表中的結果</span></span><br><span class="line"><span class="comment"># 可以查看目前處理的狀況 </span></span><br><span class="line">spark.sql(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  SELECT *</span></span><br><span class="line"><span class="string">  FROM customer_purchases</span></span><br><span class="line"><span class="string">  ORDER BY `sum(total_cost)` DESC</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span>)\</span><br><span class="line">  .show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通過使用 writeStream 方法，將結果輸出到控制台，這樣你可以在控制台上看到實時的結果變化。</span></span><br><span class="line">purchaseByCustomerPerHour.writeStream</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;console&quot;</span>)</span><br><span class="line">    .queryName(<span class="string">&quot;customer_purchases_2&quot;</span>)</span><br><span class="line">    .outputMode(<span class="string">&quot;complete&quot;</span>)</span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure><p>他就會不斷跳出結果，只要讀取了新的檔案就會觸發一次，然後你就可以查看檔案的變化，跳出的結果如下<br><img src="https://i.imgur.com/KAh4yhF.png" alt=""></p><h2 id="使用時機">使用時機</h2><ul><li><strong>StreamingDataFrame</strong>:<ul><li>適用於處理連續到達的、持續變化的數據流，例如實時日誌、感測器數據等。</li><li>可以實時進行處理、分析和存儲。</li><li>優點是能夠處理動態數據，但也需要考慮流式處理的性能和延遲。</li></ul></li><li><strong>staticDataFrame</strong>:<ul><li>適用於一次性、靜態的數據集，例如批量文件、靜態數據庫內容等。</li><li>適用於批處理作業，例如數據清理、分析報告等。</li><li>優點是能夠<code>對整個數據集進行全局操作</code>和分析，但無法處理持續更新的數據。</li></ul></li></ul><h1 id="Machine-Learning-and-Advanced-Analytics">Machine Learning and Advanced Analytics</h1><p>Spark 有一個內建的機器學習算法庫（MLlib），這使其<strong>能夠執行大規模的機器學習任務</strong>。MLlib 包括了預處理、數據整理、模型訓練和在大規模數據上進行預測的功能。甚至可以在 Structured Streaming 中使用在 MLlib 中訓練過的模型進行預測。Spark 提供了一個複雜的機器學習 API，可用於執行各種機器學習任務，從分類到回歸，從聚類到深度學習等。</p><h2 id="資料清理">資料清理</h2><p>MLlib 中的機器學習演算法<strong>要求資料以數值表示</strong>。我們目前的資料由多種不同的類型表示，包括時間戳記、整數和字串。因此，我們需要將這些數據<strong>轉換為某種數字表示形式</strong>。那我們就來看看該怎麼做吧！</p><p>在本例中，我們將使用多個 DataFrame 轉換來操作日期資料：</p><ul><li>先把nan的資料填補成0</li><li>將日期轉換成星期幾</li><li><code>coalesce</code> 來減少分區數量，預設是200的分區，但是我們希望 staticDataFrame 只要分成 5 區即可。</li></ul><div class="note warning flat"><p><code>coalesce</code> 跟<code>spark.conf.set(&quot;spark.sql.shuffle.partitions&quot;, &quot;5&quot;)</code>有類似的效果，但是這個是針對所有的DataFrame，而coalesce是針對特定的DataFrame。</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> date_format, col</span><br><span class="line">preppedDataFrame = staticDataFrame\</span><br><span class="line">  .na.fill(<span class="number">0</span>)\</span><br><span class="line">  .withColumn(<span class="string">&quot;day_of_week&quot;</span>, date_format(col(<span class="string">&quot;InvoiceDate&quot;</span>), <span class="string">&quot;EEEE&quot;</span>))\</span><br><span class="line">  .coalesce(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output </span></span><br><span class="line">+---------+---------+--------------------+--------+-------------------+---------+----------+--------------+-----------+</span><br><span class="line">|InvoiceNo|StockCode|         Description|Quantity|        InvoiceDate|UnitPrice|CustomerID|       Country|day_of_week|</span><br><span class="line">+---------+---------+--------------------+--------+-------------------+---------+----------+--------------+-----------+</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">23084</span>|  RABBIT NIGHT LIGHT|      <span class="number">48</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.79</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">23077</span>| DOUGHNUT LIP GLOSS |      <span class="number">20</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.25</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">22906</span>|<span class="number">12</span> MESSAGE CARDS ...|      <span class="number">24</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.65</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">21914</span>|BLUE HARMONICA IN...|      <span class="number">24</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.25</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">22467</span>|   GUMBALL COAT RACK|       <span class="number">6</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">2.55</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">+---------+---------+--------------------+--------+-------------------+---------+----------+--------------+-----------+</span><br><span class="line">only showing top <span class="number">5</span> rows</span><br></pre></td></tr></table></figure><h2 id="資料切割trainning-and-testing">資料切割trainning and testing</h2><p>接著我們可以把資廖根據時間分成 trainning 跟 testing 的資料集，並且將資料轉換成機器學習演算法所需的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">trainDataFrame = preppedDataFrame\</span><br><span class="line">  .where(<span class="string">&quot;InvoiceDate &lt; &#x27;2011-07-01&#x27;&quot;</span>)</span><br><span class="line">testDataFrame = preppedDataFrame\</span><br><span class="line">  .where(<span class="string">&quot;InvoiceDate &gt;= &#x27;2011-07-01&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">trainDataFrame.count()</span><br><span class="line">testDataFrame.count()</span><br></pre></td></tr></table></figure><h2 id="資料轉換成-vector">資料轉換成 vector</h2><p>切割好資料後，我們建立一個 Spark MLlib 中的一個轉換器（transformer）：<code>StringIndexer</code>。</p><ul><li><code>StringIndexer</code> 是用於**將「字串類別」型特徵轉換為「數字類別」**型特徵的轉換器。</li><li>它將一列中的字串值按照它們在該列中<strong>出現的頻率或者字母表順序，映射為數字類別值</strong>。</li></ul><p>在這個例子中，這段程式碼創建了一個 StringIndexer 物件並進行了相關設定：</p><ul><li><code>.setInputCol(&quot;day_of_week&quot;)</code>：設置了輸入列（input column），即要轉換的列的名稱，在這裡是 “day_of_week”。</li><li><code>.setOutputCol(&quot;day_of_week_index&quot;)</code>：設置了輸出列（output column），指定轉換後數字類別值的存儲位置，這裡是 “day_of_week_index”。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># indexer </span></span><br><span class="line"><span class="comment">## setInputCol 針對 day_of_week 轉換成 day_of_week_index </span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> StringIndexer</span><br><span class="line">indexer = StringIndexer()\</span><br><span class="line">  .setInputCol(<span class="string">&quot;day_of_week&quot;</span>)\ </span><br><span class="line">  .setOutputCol(<span class="string">&quot;day_of_week_index&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># encoder </span></span><br><span class="line"><span class="comment">## 把 index 轉換成 one-hot encoding </span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">encoder = OneHotEncoder()\</span><br><span class="line">  .setInputCol(<span class="string">&quot;day_of_week_index&quot;</span>)\</span><br><span class="line">  .setOutputCol(<span class="string">&quot;day_of_week_encoded&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vector </span></span><br><span class="line"><span class="comment">## 把所有的特徵轉換成一個向量</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> VectorAssembler</span><br><span class="line">vectorAssembler = VectorAssembler()\</span><br><span class="line">  .setInputCols([<span class="string">&quot;UnitPrice&quot;</span>, <span class="string">&quot;Quantity&quot;</span>, <span class="string">&quot;day_of_week_encoded&quot;</span>])\</span><br><span class="line">  .setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br></pre></td></tr></table></figure><p>準備好 indexer, encoder, vectorAssembler 之後，我們就可以建立一個 pipeline 來執行這些轉換。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line">transformationPipeline = Pipeline()\</span><br><span class="line">  .setStages([indexer, encoder, vectorAssembler])</span><br></pre></td></tr></table></figure><p>接著我們就可以透過 pipeline 來轉換資料了。我們必須先透過 fit 來建立一個 pipeline model，因為當使用 StringIndexer 對類別型特徵進行轉換時，<strong>它需要將每個不同的類別值映射為一個唯一的數字</strong>。在這個過程中，<strong>需要確定要被索引的類別型特徵列中有多少個唯一的類別值</strong>。</p><p>例如，如果你有一列包含星期幾（Monday、Tuesday、Wednesday 等），<strong>StringIndexer 會將每個不同的星期幾映射為一個唯一的數字標識</strong>，例如 Monday: 0, Tuesday: 1, 等等。在訓練過程中，<strong>StringIndexer 需要看到整個訓練數據集中的所有不同的類別值，這樣它才能確保給每個類別值分配一個唯一的數字標識</strong>。</p><p>fittedPipeline，這是在訓練數據集上進行了訓練的 Pipeline。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fittedPipeline = transformationPipeline.fit(trainDataFrame)</span><br></pre></td></tr></table></figure><p>接著我們透過 fittedPipeline 的 transform 方法將這個訓練完的 Pipeline 應用於訓練數據集 trainDataFrame，<strong>對數據進行相同的轉換</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transformedTraining = fittedPipeline.transform(trainDataFrame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用快取這種優化技術，該技術會將中間轉換後的數據集存儲到內存中</span></span><br><span class="line"><span class="comment"># 這樣就可以以更低的成本重複訪問它。</span></span><br><span class="line">transformedTraining.cache()</span><br></pre></td></tr></table></figure><h2 id="準備模型">準備模型</h2><p>在 MLlib 的 DataFrame API 中，每個算法都有兩種類型。</p><ul><li>未訓練的版本按照 Algorithm 命名模式，而訓練過的版本則是 AlgorithmModel。</li><li>在這個例子中，例如 KMeans 表示未訓練的版本，而 KMeansModel 則是經過訓練的版本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.clustering <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還未訓練的版本</span></span><br><span class="line">kmeans = KMeans()\</span><br><span class="line">    .setK(<span class="number">20</span>)\</span><br><span class="line">    .setSeed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 訓練好的 model </span></span><br><span class="line">kmModel = kmeans.fit(transformedTraining)</span><br></pre></td></tr></table></figure><h2 id="計算-Loss">計算 Loss</h2><p>因為 3.0.0 的版本後，就把 <code>computeCost</code> 移除了，所以要使用 <code>ClusteringEvaluator</code> 來計算 Loss。這邊我們要計算的是 <code>Silhouette score</code>，他與 Loss 是用於不同類型的機器學習問題評估的指標。</p><ul><li><strong>Silhouette score</strong>：<ul><li>主要用於評估聚類（Clustering）的質量。</li><li>分數範圍在 -1 到 1 之間，分數越接近 1 表示聚類結果越好，表示樣本與自己的聚類比與其他聚類更相似，而分數越接近 -1 則表示聚類結果較差，樣本更可能被分配到錯誤的聚類中。</li></ul></li><li><strong>Loss</strong>：<ul><li>損失是在監督式學習（Supervised Learning）中使用的評估指標，用於衡量模型預測與實際目標值之間的差距。</li><li>損失的計算方式因問題而異，例如在回歸問題中可以使用均方誤差（Mean Squared Error），在分類問題中可以使用交叉熵損失（Cross-Entropy Loss）。損失值越小表示模型預測與實際值之間的差距越小，模型的性能越好。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.evaluation <span class="keyword">import</span> ClusteringEvaluator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在訓練後使用訓練好的模型對測試數據進行預測</span></span><br><span class="line">predictions = kmModel.transform(transformedTest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 評估聚類模型的 Silhouette score</span></span><br><span class="line">evaluator = ClusteringEvaluator()</span><br><span class="line">silhouette = evaluator.evaluate(predictions)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Silhouette with squared euclidean distance = &quot;</span> + <span class="built_in">str</span>(silhouette))</span><br></pre></td></tr></table></figure><h1 id="Low-Level-APIs">Low-Level APIs</h1><p><img src="https://i.imgur.com/DbwJUEd.png" alt=""></p><p>RDD 是 Spark 中的一個基本抽象，它是一個具有容錯性和可並行處理的、分佈式的元素集合。<strong>RDD 提供了一種能夠在大規模集群上進行並行操作的抽象方式</strong>，它是 Spark 運行的核心基礎。事實上，幾乎所有 Spark 的操作都是建立在 RDD 之上的。</p><p>然而，<strong>DataFrame 是建立在 RDD 之上的更高級抽象</strong>，它提供了一種更方便、更高效的方式來進行分佈式數據操作。DataFrame 基於 RDD，但它提供了更高層次的抽象，隱藏了底層 RDD 的物理特性（例如分區等），使得用戶可以更方便地進行數據操作，並且能夠獲得更好的性能。</p><p>在 Spark 中，大部分情況下，<strong>建議使用 DataFrame 或 Structured APIs 進行數據操作，因為它們提供了更高層次的抽象和更好的性能</strong>。但是在某些情況下，仍然可能會使用到 RDD，例如在讀取或操作原始數據時。</p><p>下面的程式碼示例展示了如何使用 parallelize 方法將一組數據轉換為 RDD，然後將其轉換為 DataFrame，這是一種使用 RDD 創建 DataFrame 的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">spark.sparkContext.parallelize([</span><br><span class="line">  Row(<span class="number">1</span>),</span><br><span class="line">  Row(<span class="number">2</span>),</span><br><span class="line">  Row(<span class="number">3</span>)</span><br><span class="line">]).toDF()</span><br></pre></td></tr></table></figure><h2 id="RDD（Resilient-Distributed-Dataset）">RDD（Resilient Distributed Dataset）</h2><p>RDD 是 Spark 中的基本抽象，它代表一個分佈式的、不可變的集合，能夠容錯和並行處理。RDD 提供了對數據的精細控制，允許使用者管理數據分區、內存使用以及計算過程。</p><p><strong>適合的使用時機</strong>：</p><ul><li>當需要更精細的控制和低層次的操作時，例如需要手動控制數據分區、優化內存使用或者需要使用一些特定於 RDD 的操作時。</li><li>在一些需要自定義的計算邏輯或者在遷移舊有 Spark 代碼到新版本時，可以使用 RDD 以保持兼容性。</li></ul><p><strong>優缺點</strong>：</p><ul><li>優點：<ul><li>提供更多細節級別的控制，可以手動調整分區、緩存策略等。</li><li>在特定場景下可以更靈活，並提供一些 DataFrame 不具備的操作。</li></ul></li><li>缺點：<ul><li>較為低階，需要更多的手動管理和優化。</li><li>較 DataFrame 更複雜，需要更多的代碼量。</li></ul></li></ul><h2 id="與-DataFrame-的差異">與 DataFrame 的差異</h2><p><strong>與 DataFrame 的差異</strong></p><ul><li>DataFrame 是在 RDD 基礎上的高層次抽象，提供了更簡潔的 API 和更高效的優化。<br>DataFrame 提供了結構化數據處理的抽象，允許使用者進行類似 SQL 的操作。</li></ul><p><strong>相對於 RDD，DataFrame 適合的使用時機</strong>：</p><ul><li>當進行結構化數據處理時，例如進行篩選、聚合、排序等操作。</li><li>在需要高效並行處理和內建優化的情況下，DataFrame 更為適合。</li></ul><p><strong>相對於RDD的優缺點</strong>：</p><ul><li>優點：<ul><li>提供了更高級的抽象和更簡潔的 API，易於使用和理解。</li><li>具有內置的優化功能，能夠自動優化和提高效率。</li></ul></li><li>缺點：<ul><li>對於某些特定場景下的低層次操作，DataFrame 可能無法提供足夠的靈活性。</li></ul></li></ul><h1 id="Stage-Executor-Driver">Stage, Executor, Driver</h1><p><img src="https://i.imgur.com/13PtxAr.png" alt=""></p><ul><li>spark context:</li><li>cluster manager: 資源管理器收到請求，會在滿足條件的 worker node 上建立 executor</li><li>executor: 他就是一個獨立的JVM process，單個節點的執行進程，裡面會有多個Task線程</li><li>Driver: 他就是我們寫的spark應用程式，創建sparkcontext或sparksession，driver會和cluster manager通信，分配task道executor上。<ul><li>會根據sparkcontext中的資源需求，向resource manager申請資源，包括executor數量與內存。</li></ul></li></ul><h1 id="Fault-Tolerance">Fault Tolerance</h1><p>If we want our system to be fault tolerant, it should be redundant because we ==require a redundant component to obtain the lost data==. The faulty data recovers by redundant data.</p><h2 id="Cluster-容錯">Cluster 容錯</h2><h3 id="Worker-異常">Worker 異常</h3><div class="note info flat"><p>當 Worker 異常，Master 會透過心跳機制發現，並且移除異常的 Worker，然後重新啟動 Executor。</p></div><ul><li>Spark Worker會保持和Master的心跳，當Worker出現逾時時，Master呼叫timeOutDeadWorkers()方法進行處理，<em>移除逾時的Worker</em>。</li><li>移除時會通知Driver Executor已經移除(Executor異常處理詳見下文)，然後設定運行在目前Worker上的Driver重啟或直接刪除：</li></ul><h3 id="Executor-異常">Executor 異常</h3><div class="note info flat"><p>當 Executor 異常，會會重試三次，若仍是無法，則嘗試取得可用的 Worker 節點並重新啟動 Executor。</p></div><ul><li>Executor發生異常時，外部的包裝類別ExecutorRunner會<em>把異常訊息傳送給Worker</em></li><li>然後Worker會<em>傳訊息給Master</em>。</li><li>Master 接收 Executor 狀態變更訊息後，如果發現 Executor 出現異常退出，則呼叫 Master.schedule 方法，<em>嘗試取得可用的 Worker 節點</em>並重新啟動 Executor。</li></ul><p>簡單來說，如果因為Worker異常而導致Stage失敗，就會觸發RDD容錯機制，會對運行失敗的Stage進行重試，預設三次。</p><h2 id="Job-Task-容錯">Job Task 容錯</h2><p>RDD Lineage：</p><ul><li>基於RDD的各項transformation構成compute chain，這樣在計算結果丟失時可以根據lineage重新計算。</li><li>在<em>窄依賴</em>的情況下，因為每個父RDD Partition依賴於特定的子RDD Partition，<em>重新計算時可以直接使用這個子RDD Partition的數據</em>，沒有Redundant Computation（冗餘計算）。</li><li>在<em>寬依賴</em>的情況下，當丟失整一個子RDD Partition時，因為<em>多個父RDD Partition可能會依賴於這個子RDD Partition，因此Spark必須將與該子RDD相關的所有父RDD都重新計算</em>。<ul><li>因此如果compute chain很長的寬依賴情況下，建議做一次Checkpoint或是cache來先做緩存，減少執行開銷。</li></ul></li></ul><div class="note warning flat"><p><strong>Q: 什麼是Redundant Computation（冗餘計算）？</strong><br>主要常發生在寬依賴的情況下，因為每個父RDD Partition依賴多個子RDD Partition，重新計算時需要重新計算所有子RDD Partition，這樣就會造成Redundant Computation（冗餘計算）。</p></div><h1 id="補充：Spark’s-Interactive-Consoles">補充：Spark’s Interactive Consoles</h1><p>如果以 interactive mode 啟動 Spark，就是間接的建立管理 Spark Application 的SparkSession。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/pyspark <span class="comment"># Python console: starts an interactive Spark application </span></span><br><span class="line">./bin/spark-shell <span class="comment"># Scala Console: access the Scala console to start an interactive sesion</span></span><br><span class="line">./bin/spark-sql <span class="comment"># SQL console</span></span><br><span class="line">./bin/spark-submit <span class="comment"># submit an application to a cluster 他可以幫你把程式打包</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> Debugging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Twitter Dataset - 使用 LSTM 預測文章的情緒</title>
      <link href="/posts/nlp-twitter-emotion-diagnoise/"/>
      <url>/posts/nlp-twitter-emotion-diagnoise/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第六個作業，主要教授內容為以下主題：</p><ol><li>學會使用 LSTM</li><li>使用SpaCy</li></ol><h1 id="作業要求">作業要求</h1><p>Train a text classification on the <a href="https://github.com/cardiffnlp/tweeteval">TweetEval</a> emotion recognition dataset using LSTMs and GRUs.</p><ol><li><strong>建立LSTM模型</strong>：Follow the example described <a href="https://pytorch.org/tutorials/beginner/nlp/sequence_models_tutorial.html">here</a>. Use the same architecture, but:<ol><li>only use the last output of the LSTM in the loss function</li><li>use an embedding dim of 128</li><li>use a hidden dim of 256.</li></ol></li><li><strong>使用SpaCy切割字</strong>：Use spaCy to split the tweets into words.</li><li><strong>挑選Top5000的字</strong>：Limit your vocabulary (i.e. the words that you converted to an index) to the most frequent 5000<br>words and replace all other words with an placeholder index (e.g. 1001).</li><li><strong>訓練模型並計算準確度</strong>：Evaluate the accuracy on the test set. (Note: If the training takes to long, try to use only a fraction of the training data.)</li><li><strong>建立GRU模型，並訓練</strong>：Do the same, but this time use GRUs instead of LSTMs.</li></ol><h1 id="Task-0-下載資料集">Task 0: 下載資料集</h1><div class="note info flat"><p>在這個章節我們需要做的事有以下：</p><ol><li>下載資料集</li><li>使用 panda 將資料集轉換成我們需要的格式</li></ol></div><h2 id="下載資料集">下載資料集</h2><ol><li>可以參考此連結，下載所需要的資料：<a href="https://github.com/cardiffnlp/tweeteval">TweetEval</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cardiffnlp/tweeteval.git</span><br></pre></td></tr></table></figure><ol start="2"><li>下載完後，可以看到以下資料， <code>emotion</code> 資料夾中是我們這次會使用的資料：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── TweetEval_Tutorial.ipynb</span><br><span class="line">├── datasets</span><br><span class="line">│   ├── README.txt</span><br><span class="line">│   ├── emoji</span><br><span class="line">│   ├── emotion <span class="comment"># 這是我們需要的資料 </span></span><br><span class="line">│   │   ├── mapping.txt <span class="comment"># 情緒對應的數字 e.g. &#123;0:&#x27;angry&#x27;, 1:&#x27;happy&#x27;&#125;</span></span><br><span class="line">│   │   ├── test_labels.txt <span class="comment"># 測試資料的情緒標籤，也就是解答 e.g. 0 </span></span><br><span class="line">│   │   ├── test_text.txt <span class="comment"># 測試資料的內容 e.g. &quot;I&#x27;m so angry&quot;</span></span><br><span class="line">│   │   ├── train_labels.txt <span class="comment"># 訓練資料的情緒標籤，也就是解答 e.g. 0</span></span><br><span class="line">│   │   ├── train_text.txt <span class="comment"># 訓練資料的內容 e.g. &quot;I&#x27;m so angry&quot;</span></span><br><span class="line">│   │   ├── val_labels.txt <span class="comment"># 驗證資料的情緒標籤，也就是解答 e.g. 0</span></span><br><span class="line">│   │   └── val_text.txt <span class="comment"># 驗證資料的內容 e.g. &quot;I&#x27;m so angry&quot; </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="轉換資料格式">轉換資料格式</h2><p>我們先引入所需要的套件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CNN</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset</span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, models, transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> Flowers102</span><br><span class="line"></span><br><span class="line"><span class="comment"># read file </span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># label</span></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><p>接著我們將資料轉換成我們需要的格式，這邊我們使用 <code>panda</code> 來處理資料，並將資料讀取至變數中，方便我們之後使用。</p><div class="note warning flat"><p>記得修改 root 的路徑到你 git clone 的資料夾路徑喔！！</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先設定每個檔案的相對路徑 </span></span><br><span class="line">root = <span class="string">&#x27;../../Data/tweeteval/datasets/emotion/&#x27;</span></span><br><span class="line">mapping_file = os.path.join(root, <span class="string">&#x27;mapping.txt&#x27;</span>)</span><br><span class="line">test_labels_file = os.path.join(root, <span class="string">&#x27;test_labels.txt&#x27;</span>)</span><br><span class="line">test_text_file = os.path.join(root, <span class="string">&#x27;test_text.txt&#x27;</span>)</span><br><span class="line">train_labels_file = os.path.join(root, <span class="string">&#x27;train_labels.txt&#x27;</span>)</span><br><span class="line">train_text_file = os.path.join(root, <span class="string">&#x27;train_text.txt&#x27;</span>)</span><br><span class="line">val_labels_file = os.path.join(root, <span class="string">&#x27;val_labels.txt&#x27;</span>)</span><br><span class="line">val_text_file = os.path.join(root, <span class="string">&#x27;val_text.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用panda讀取資料 把標籤進行讀取 </span></span><br><span class="line">mapping_pd = pd.read_csv(mapping_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">test_label_pd = pd.read_csv(test_labels_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">train_label_pd = pd.read_csv(train_labels_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">val_label_pd = pd.read_csv(val_labels_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把訓練用的內容和測試用的內容，透過 \n 進行切割，並且把最後一個空白的字去除  </span></span><br><span class="line"><span class="comment"># 因為 test_dataset[-1] 是空的，並且要去除 長度才會與 labels 的長度一致</span></span><br><span class="line">test_dataset = <span class="built_in">open</span>(test_text_file).read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>] <span class="comment"># remove last empty line </span></span><br><span class="line">train_dataset = <span class="built_in">open</span>(train_text_file).read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>] <span class="comment"># remove last empty line</span></span><br><span class="line">val_dataset = <span class="built_in">open</span>(val_text_file).read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>] <span class="comment"># remove last empty line</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列印看看資料的長度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(train_dataset)= <span class="subst">&#123;<span class="built_in">len</span>(train_dataset)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(train_label_pd)= <span class="subst">&#123;<span class="built_in">len</span>(train_label_pd)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;=== train_label_pd === \n<span class="subst">&#123;train_label_pd.value_counts()&#125;</span>&#x27;</span>) <span class="comment"># 查看train的情緒標籤資料分布</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(test_dataset)= <span class="subst">&#123;<span class="built_in">len</span>(test_dataset)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(test_label_pd)= <span class="subst">&#123;<span class="built_in">len</span>(test_label_pd)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;=== test_label_pd === \n<span class="subst">&#123;test_label_pd.value_counts()&#125;</span>&#x27;</span>) <span class="comment"># 查看test的情緒標籤資料分布</span></span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(train_dataset)= <span class="number">3257</span></span><br><span class="line"><span class="built_in">len</span>(train_label_pd)= <span class="number">3257</span></span><br><span class="line">=== train_label_pd === </span><br><span class="line"><span class="number">0</span>    <span class="number">1400</span></span><br><span class="line"><span class="number">3</span>     <span class="number">855</span></span><br><span class="line"><span class="number">1</span>     <span class="number">708</span></span><br><span class="line"><span class="number">2</span>     <span class="number">294</span></span><br><span class="line">Name: count, dtype: int64</span><br><span class="line"><span class="built_in">len</span>(test_dataset)= <span class="number">1421</span></span><br><span class="line"><span class="built_in">len</span>(test_label_pd)= <span class="number">1421</span></span><br><span class="line">=== test_label_pd === </span><br><span class="line"><span class="number">0</span>    <span class="number">558</span></span><br><span class="line"><span class="number">3</span>    <span class="number">382</span></span><br><span class="line"><span class="number">1</span>    <span class="number">358</span></span><br><span class="line"><span class="number">2</span>    <span class="number">123</span></span><br><span class="line">Name: count, dtype: int64</span><br></pre></td></tr></table></figure><h1 id="Task-1-5-建立LSTM-GRU-模型">Task 1 + 5 : 建立LSTM, GRU 模型</h1><div class="note info flat"><ol><li><strong>建立LSTM模型</strong>：Follow the example described <a href="https://pytorch.org/tutorials/beginner/nlp/sequence_models_tutorial.html">here</a>. Use the same architecture, but:<ol><li>only use the last output of the LSTM in the loss function</li><li>use an embedding dim of 128</li><li>use a hidden dim of 256.</li></ol></li><li><strong>建立GRU模型，並訓練</strong>：Do the same, but this time use GRUs instead of LSTMs.</li></ol></div><p>從官網範例中我們可以學習到如何建置LSTM模型，基本上我們會有以下元素：</p><ul><li><code>hidden_dim</code>：隱藏層的維度，代表的是 hidden layer 的神經元數量</li><li><code>word_embeddings</code>：將輸入的句子中的每個詞都轉換成詞向量<ul><li><code>embedding_dim(vocab_size, embedding_dim)</code>：<ul><li><code>vocab_size</code>：字典的大小，也就是我們總共有多少個字，這個例子中我們之後會輸入 5001 個字，5000 常用字 ＋ 1 無法辨識的字</li><li><code>embedding_dim</code>：表示將每個詞或符號映射到固定大小的向量空間中。如果你的 <code>embedding_dim</code> 設定為 6，而你的 input 向量是 [1, 2, 3, 5]，模型會將每個數字映射到六維度的向量空間中，形成類似 [1, 2, 3, 5, 6, 4] 的表示。</li></ul></li><li><code>lstm(input_size, hidden_size, dropout)</code><ul><li><code>input_size</code>：輸入的維度，也就是我們的詞向量維度</li><li><code>hidden_size</code>：隱藏層的維度，代表的是 hidden layer 的神經元數量</li><li><code>dropout</code>：dropout的比例，預設為0，代表不使用dropout</li></ul></li><li><code>hidden2tag(in_features, out_features)</code><ul><li><code>in_features</code>：也就是 hidden_dim 輸入的維度，也就是我們的詞向量維度</li><li><code>out_features</code>：也就是 tagset_size 輸出的維度，也就是我們的情緒標籤維度</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LSTMTagger</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_dim, hidden_dim, vocab_size, tagset_size, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(LSTMTagger, self).__init__()</span><br><span class="line">        self.hidden_dim = hidden_dim</span><br><span class="line">        <span class="comment"># 把每個詞都轉換成詞向量</span></span><br><span class="line">        self.word_embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The LSTM takes word embeddings as inputs, and outputs hidden states</span></span><br><span class="line">        <span class="comment"># with dimensionality hidden_dim.</span></span><br><span class="line">        self.lstm = nn.LSTM(embedding_dim, hidden_dim, dropout=dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The linear layer that maps from hidden state space to tag space</span></span><br><span class="line">        self.hidden2tag = nn.Linear(hidden_dim, tagset_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        embeds = self.word_embeddings(sentence) <span class="comment"># 將輸入的句子中的每個詞都轉換成詞向量 此時的 sentence 已經是 index 形式的向量</span></span><br><span class="line">        lstm_out, _ = self.lstm(embeds.view(<span class="built_in">len</span>(sentence), <span class="number">1</span>, -<span class="number">1</span>)) <span class="comment"># 將詞向量作為LSTM模型的輸入 得到LSTM曾的輸出和隱藏狀態</span></span><br><span class="line">        <span class="comment"># Take only the last output of the LSTM</span></span><br><span class="line">        last_output = lstm_out[-<span class="number">1</span>].view(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># Selecting the last output 為了滿足作業要求，我們只取最後一個輸出 </span></span><br><span class="line">        tag_space = self.hidden2tag(last_output) <span class="comment"># 將LSTM模型的最後輸出轉換成 詞標籤 空間</span></span><br><span class="line">        tag_scores = F.log_softmax(tag_space, dim=<span class="number">1</span>) <span class="comment"># 將詞標籤 空間 轉換成 機率空間 </span></span><br><span class="line">        <span class="keyword">return</span> tag_scores</span><br></pre></td></tr></table></figure><p>GRU 與 LSTM 類似，唯獨要修改的地方是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GRUTagger</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_dim, hidden_dim, vocab_size, tagset_size, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Here !!! 修改成 GRU </span></span><br><span class="line">        self.gru = nn.GRU(embedding_dim, hidden_dim, dropout=dropout)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Here !!! 這邊套用 gru </span></span><br><span class="line">        gru_out, _ = self.gru(embeds.view(<span class="built_in">len</span>(sentence), <span class="number">1</span>, -<span class="number">1</span>)) <span class="comment"># 將詞向量作為LSTM模型的輸入 得到LSTM曾的輸出和隱藏狀態</span></span><br><span class="line">        last_output = gru_out[-<span class="number">1</span>].view(<span class="number">1</span>, -<span class="number">1</span>) <span class="comment"># Selecting the last output 為了滿足作業要求，我們只取最後一個輸出 </span></span><br><span class="line">        ... </span><br></pre></td></tr></table></figure><p>完成的GRU程式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GRUTagger</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_dim, hidden_dim, vocab_size, tagset_size, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GRUTagger, self).__init__()</span><br><span class="line">        self.hidden_dim = hidden_dim</span><br><span class="line">        self.word_embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line">        self.gru = nn.GRU(embedding_dim, hidden_dim, dropout=dropout) <span class="comment"># &lt;== Here ! </span></span><br><span class="line">        self.hidden2tag = nn.Linear(hidden_dim, tagset_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        embeds = self.word_embeddings(sentence) </span><br><span class="line">        gru_out, _ = self.gru(embeds.view(<span class="built_in">len</span>(sentence), <span class="number">1</span>, -<span class="number">1</span>))  <span class="comment"># &lt;== Here ! </span></span><br><span class="line">        last_output = gru_out[-<span class="number">1</span>].view(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># &lt;== Here ! </span></span><br><span class="line">        tag_space = self.hidden2tag(last_output)</span><br><span class="line">        tag_scores = F.log_softmax(tag_space, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tag_scores</span><br></pre></td></tr></table></figure><h1 id="Task-2-3-使用SpaCy切割字-找出Top5000的字">Task 2 + 3 : 使用SpaCy切割字, 找出Top5000的字</h1><div class="note info flat"><p>我們已經在 Task0 把所需要的資料都放入變數list當中，每筆資料都是一個句子，我們現在要做幾件事情：<br>2. <strong>使用SpaCy切割字</strong>：Use spaCy to split the tweets into words.<br>3. <strong>挑選Top5000的字</strong>：Limit your vocabulary (i.e. the words that you converted to an index) to the most frequent 5000<br>words and replace all other words with an placeholder index (e.g. 1001).</p></div><h2 id="安裝-SpaCy">安裝 SpaCy</h2><p>我們要先執行以下指令，安裝 SpaCy 套件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你是 Python3 </span></span><br><span class="line">pip install -U spacy</span><br><span class="line"><span class="comment"># 如果你是 Anaconda </span></span><br><span class="line">conda install -c conda-forge spacy</span><br></pre></td></tr></table></figure><p>因為我們分析的是英文，所以我們需要下載英文用的模型，執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download en_core_web_sm</span><br></pre></td></tr></table></figure><p>這樣才可以在 notebook 中 import spacy 套件，並且使用英文模型。</p><div class="note warning flat"><p>如果沒有執行上述指令，這邊會出錯喔！！<br><code>nlp = spacy.load(&quot;en_core_web_sm&quot;)</code></p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># use spacy to tokenize the sentence with english model </span></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>) <span class="comment"># &lt;=== 如果沒有執行上述指令，這邊會出錯喔！！</span></span><br></pre></td></tr></table></figure><h2 id="準備-top-5000-常用字的字典">準備 top 5000 常用字的字典</h2><p>我們要先找出 top 5000 常用字，並且建立一個字典，為了做到這樣的事情：</p><ol><li>我們先準備好一個字串，把所有句子串起來。</li><li>然後把整個字串送入 spacy 進行資料切割，並且過濾掉<code>標點符號(punct)</code>和<code>停用字(stop word)</code>還有<code>空白(space)</code>。</li><li>使用 Counter 套件，把 word 進行計數，以方便找出 top 5000 常用字。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># join all the sentence together </span></span><br><span class="line"><span class="comment"># e.g. [&#x27;today is good&#x27;, &#x27;today is bad&#x27;] =&gt; [&#x27;today is good today is bad&#x27;]</span></span><br><span class="line">text = <span class="string">&#x27; &#x27;</span>.join(train_dataset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use spacy to tokenize the sentence </span></span><br><span class="line">doc = nlp(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter out the punctuation and stop words</span></span><br><span class="line">word_freq = Counter(token.text <span class="keyword">for</span> token <span class="keyword">in</span> doc \</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> token.is_punct <span class="keyword">and</span> \</span><br><span class="line">                        <span class="keyword">not</span> token.is_stop <span class="keyword">and</span> \</span><br><span class="line">                            <span class="keyword">not</span> token.is_space )</span><br><span class="line">word_freq</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Counter(&#123;<span class="string">&#x27;@user&#x27;</span>: <span class="number">2019</span>, <span class="comment">-- 光是 @user 就出現了 2019 次 </span></span><br><span class="line">         <span class="string">&#x27;like&#x27;</span>: <span class="number">212</span>,</span><br><span class="line">         <span class="string">&#x27;amp&#x27;</span>: <span class="number">148</span>,</span><br><span class="line">         <span class="string">&#x27;people&#x27;</span>: <span class="number">126</span>,</span><br><span class="line">         <span class="string">&#x27;know&#x27;</span>: <span class="number">96</span>,</span><br><span class="line">         <span class="string">&#x27;think&#x27;</span>: <span class="number">92</span>,</span><br><span class="line">         <span class="string">&#x27;sad&#x27;</span>: <span class="number">90</span>,</span><br><span class="line">         <span class="string">&#x27;got&#x27;</span>: <span class="number">85</span>,</span><br><span class="line">         <span class="string">&#x27;day&#x27;</span>: <span class="number">81</span>,</span><br><span class="line">         <span class="string">&#x27;u&#x27;</span>: <span class="number">80</span>,</span><br><span class="line">         <span class="string">&#x27;time&#x27;</span>: <span class="number">78</span>,</span><br><span class="line">         <span class="string">&#x27;✨&#x27;</span>: <span class="number">75</span>,</span><br><span class="line">         <span class="string">&#x27;😂&#x27;</span>: <span class="number">75</span>,</span><br><span class="line">         <span class="string">&#x27;want&#x27;</span>: <span class="number">74</span>,</span><br><span class="line">         <span class="string">&#x27;life&#x27;</span>: <span class="number">73</span>,</span><br><span class="line">         <span class="string">&#x27;going&#x27;</span>: <span class="number">69</span>,</span><br><span class="line">         <span class="string">&#x27;feel&#x27;</span>: <span class="number">67</span>,</span><br><span class="line">         <span class="string">&#x27;angry&#x27;</span>: <span class="number">66</span>,</span><br><span class="line">         <span class="string">&#x27;2&#x27;</span>: <span class="number">65</span>,</span><br><span class="line">         ...&#125;)</span><br></pre></td></tr></table></figure><p>接下來我們就可以根據 words 出現的次數，選出最多的前 5000 筆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 選擇最常見的 5000 個單詞作為詞彙表</span></span><br><span class="line">most_common_words = word_freq.most_common(<span class="number">5000</span>)</span><br><span class="line"><span class="comment"># 建立詞彙到索引的映射 e.g. &#123;&#x27;hello&#x27;:0, &#x27;like&#x27;:1 ...&#125;</span></span><br><span class="line">vocab = &#123;word[<span class="number">0</span>]: idx <span class="keyword">for</span> idx, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(most_common_words)&#125;</span><br></pre></td></tr></table></figure><h2 id="將句子轉換成-tensor">將句子轉換成 tensor</h2><p>有了 <code>vocab</code> 這個字典後，我們就可以基於這個字典，把句子轉換成 index 的形式。舉例來說：</p><ul><li>原本的句子：<code>I like apple</code></li><li>轉換成 index 的形式：<code>[100, 3923, 123]</code></li></ul><p>但是萬一出現了我們看不懂的單字，或是沒收錄的單字該怎麼辦？</p><ul><li>這邊我們還需要一個 <code>placeholder_index</code></li><li>當我們的句子中有字不在 <code>vocab</code> 字典中時，我們就把這個字轉換成 <code>placeholder_index</code></li><li>這邊我們設定為 5000，代表無法辨識的字，舉例來說：<ul><li>原本的句子：<code>I like jifw8evjk</code></li><li>轉換成 index 的形式：<code>[100, 3923, 5000]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 轉換單詞為索引，超出詞彙表的單詞用佔位索引 5000 代替 因為我們會收集前 0-4999 index 的單詞</span></span><br><span class="line">placeholder_index = <span class="number">5000</span></span><br><span class="line"><span class="comment"># 存放整個 dataset 轉換成 index 的結果 </span></span><br><span class="line">indexed_dataset = []</span><br><span class="line"><span class="keyword">for</span> tweet <span class="keyword">in</span> train_dataset: <span class="comment"># 取出第一個句子 </span></span><br><span class="line">    indexed_words = [] <span class="comment"># 建立一個空的 list 存放當前句子的結果 (e.g. I like apple -&gt; [100, 3923, 123]) </span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> nlp(tweet): <span class="comment"># 透過 spacy 切割句子成單詞 </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token.is_punct <span class="keyword">and</span> <span class="keyword">not</span> token.is_stop <span class="keyword">and</span> <span class="keyword">not</span> token.is_space: <span class="comment"># 確保單字不是標點符號、停用字、空白 </span></span><br><span class="line">            word = token.text </span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> vocab: <span class="comment"># 如果該單字在我們的常見 5000 單字中，就把它轉換成 index </span></span><br><span class="line">                indexed_words.append(vocab[word])</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 否則 index 就是 placeholder_index </span></span><br><span class="line">                indexed_words.append(placeholder_index)</span><br><span class="line">    indexed_dataset.append(indexed_words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印轉換後的數據</span></span><br><span class="line"><span class="built_in">print</span>(indexed_dataset)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[2013, 3615, 269, 3616, 3617, 1426, 717, 86], [1069, 339, 2014, 2015, 44, 2016], ...] </span></span><br></pre></td></tr></table></figure><p>那根據上面的說明，我們可以把上面的程式碼包裝成一個 function，方便我們之後在進行訓練時，把句子轉換成 index list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for sentence to sequence </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_sentence_sequence</span>(<span class="params">seq, to_ix</span>):</span><br><span class="line">    idx = []</span><br><span class="line">    <span class="comment"># use spacy to tokenize the sentence </span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> nlp(seq):</span><br><span class="line">        <span class="comment"># filter out the punctuation and stop words and space </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token.is_punct <span class="keyword">and</span> <span class="keyword">not</span> token.is_stop <span class="keyword">and</span> <span class="keyword">not</span> token.is_space:</span><br><span class="line">            word = token.text</span><br><span class="line">            <span class="comment"># if the token is in the top 5000 words in the vocab, add its index to the list</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> to_ix:</span><br><span class="line">                idx.append(to_ix[word])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># else add the index of the placeholder token</span></span><br><span class="line">                idx.append(placeholder_index)</span><br><span class="line">    <span class="keyword">return</span> torch.tensor(idx, dtype=torch.long) <span class="comment"># 把 list 轉換成 tensor </span></span><br></pre></td></tr></table></figure><h2 id="將標籤轉換成-tensor">將標籤轉換成 tensor</h2><p>接下來，我們要處理標籤，標籤也需要轉換成向量，這樣 model 的 ouput 才可以與 正確解答 做比較：</p><ul><li>通常我們預期 model 的 output 會長這樣：<code>[0.1, 0.2, 0.3, 0.4]</code><ul><li>分別代表 <code>&#123;0: 'anger', 1: 'joy', 2: 'optimism', 3: 'sadness'&#125;</code>的機率</li></ul></li><li>當解答是 <code>anger</code> 時，我們希望 model 的 output 越接近 <code>[1, 0, 0, 0]</code> 越好<ul><li>也就是說，我們需要把 label 進行 one-hot-encoding 轉換成向量的形式，才可以進行比較</li><li>為了可以把「模型產生的結果」 <code>[0.1, 0.2, 0.3, 0.4]</code> 和 「正確解答」<code>[1,0,0,0]</code> 放入 loss function 中計算 loss</li><li>因此我們需要一個函式，把標籤轉換成向量的形式，這個函示就是 <code>one_hot_encode</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">one_hot_encode</span>(<span class="params">val, to_ix</span>): <span class="comment"># val 是標籤的 index (e.g. 2); to_ix 是標籤的字典 (e.g. &#123;0:&#x27;angry&#x27;, 1:&#x27;happy&#x27;&#125;) </span></span><br><span class="line">    result = [] <span class="comment"># 建立一個空的 list 儲存結果 </span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> to_ix.items(): <span class="comment"># 我們把標籤的字典進行迭代</span></span><br><span class="line">        <span class="keyword">if</span> val == k: <span class="comment"># 一但發現，val 等於 k，代表我們找到了正確的標籤 </span></span><br><span class="line">            result.append(<span class="number">1</span>) <span class="comment"># 在這個位置我們要填上 1 </span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            result.append(<span class="number">0</span>) <span class="comment"># 其他位置都填上 0 </span></span><br><span class="line">    <span class="keyword">return</span> torch.tensor(result, dtype=torch.float32) <span class="comment"># 把 list 轉換成 tensor </span></span><br></pre></td></tr></table></figure><p>建立好上述的函示之後我們可以來實驗看看這個函示有沒有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因為 mapping_pd 是一個 dataframe，我們要把它轉換成字典，方便我們之後使用 </span></span><br><span class="line">mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(mapping_pd[<span class="number">0</span>], mapping_pd[<span class="number">1</span>])) <span class="comment"># 回傳 &#123;0:&#x27;angry&#x27;, 1:&#x27;happy&#x27;, 2:&#x27;optimism&#x27;, 3:&#x27;sadness&#x27;&#125; </span></span><br><span class="line"><span class="built_in">print</span>(mapping)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;ans=2; vector=<span class="subst">&#123;one_hot_encode(<span class="number">2</span>, tag_to_ix)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下: 你看！我們把 2 成功轉換成 <code>[0, 0, 1, 0]</code> 的向量了！</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;anger&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;joy&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;optimism&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;sadness&#x27;</span>&#125;</span><br><span class="line">ans=<span class="number">2</span>; vector=tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure><h1 id="Task-4-訓練模型並計算準確度">Task 4: 訓練模型並計算準確度</h1><div class="note info flat"><ol start="4"><li><strong>訓練模型並計算準確度</strong>：Evaluate the accuracy on the test set. (Note: If the training takes to long, try to use only a fraction of the training data.)</li></ol></div><h2 id="小試身手">小試身手</h2><p>在開始訓練模型前，<strong>我們要先知道我們的模型的輸入和輸出長什麼樣子</strong>，在這邊我們試試看，模型還沒訓練前預測的結果吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># See what the scores are before training</span></span><br><span class="line"><span class="comment"># Here we don&#x27;t need to train, so the code is wrapped in torch.no_grad()</span></span><br><span class="line">sentence_idx = <span class="number">1</span> <span class="comment"># 拿第一個句子來測試</span></span><br><span class="line"><span class="comment"># 印出：My roommate: it&#x27;s okay that we can&#x27;t spell because we have autocorrect. #terrible #firstworldprobs </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;First Sentense = <span class="subst">&#123;train_dataset[sentence_idx]&#125;</span>&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># 這時候我們可以把第一個句子轉換成 index 的形式，並且把它轉換成 tensor </span></span><br><span class="line">    inputs = prepare_sentence_sequence(train_dataset[sentence_idx], word_to_ix)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Sentense to tensor = <span class="subst">&#123;inputs&#125;</span>&#x27;</span>) <span class="comment"># 印出：tensor([1070,  340, 2015, 2016,   45, 2017])</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 然後把解答轉換成 tensor </span></span><br><span class="line">    labels = one_hot_encode(train_label_pd[<span class="number">0</span>][sentence_idx], tag_to_ix)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Sentense of result to tensor = <span class="subst">&#123;labels&#125;</span>&#x27;</span>) <span class="comment"># 印出：tensor([1., 0., 0., 0.])</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 把 inputs 送入模型中，得到模型的預測結果 </span></span><br><span class="line">    outputs = model(inputs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;tag_scores = <span class="subst">&#123;outputs&#125;</span>&#x27;</span>) <span class="comment"># 印出：tensor([[-1.3280, -1.4272, -1.4998, -1.3026]])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出最大的機率值，並且取出 index </span></span><br><span class="line">    _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;preds = <span class="subst">&#123;preds&#125;</span>&#x27;</span>) <span class="comment"># 印出：preds = tensor([3])  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 計算 loss 看看 output 跟 label 的差距，這邊 output[0] 是因為發現 output 多包一層 </span></span><br><span class="line">    result_idx = torch.argmax(outputs).item()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;result = <span class="subst">&#123;result_idx&#125;</span>, ans = <span class="subst">&#123;train_label_pd[<span class="number">0</span>][sentence_idx]&#125;</span>&#x27;</span>) <span class="comment"># 印出：result = 3, ans = 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 計算 loss 看看 output 跟 label 的差距，這邊 output[0] 是因為發現 output 多包一層</span></span><br><span class="line">    loss = loss_function(outputs[<span class="number">0</span>], labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss = <span class="subst">&#123;loss&#125;</span>&#x27;</span>) </span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">First Sentense = My roommate: it<span class="string">&#x27;s okay that we can&#x27;</span>t spell because we have autocorrect. <span class="comment">#terrible #firstworldprobs </span></span><br><span class="line">Sentense to tensor = tensor([<span class="number">1070</span>,  <span class="number">340</span>, <span class="number">2015</span>, <span class="number">2016</span>,   <span class="number">45</span>, <span class="number">2017</span>])</span><br><span class="line">Sentense of result to tensor = tensor([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">tag_scores = tensor([[-<span class="number">1.3280</span>, -<span class="number">1.4272</span>, -<span class="number">1.4998</span>, -<span class="number">1.3026</span>]])</span><br><span class="line">loss = <span class="number">1.32795250415802</span></span><br><span class="line">preds = tensor([<span class="number">3</span>])</span><br><span class="line">result = <span class="number">3</span>, ans = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>看起來運行的還挺順暢的對吧？<br>那我們正式開始囉！</p><h2 id="準備-training-用的函示">準備 training 用的函示</h2><p>這邊我希望在 training 每次的 epoch 時：</p><ul><li>列印出 training 的 loss 和 accuracy 來確認模型的訓練狀況。</li><li>同時保留最好的model。</li><li>計算訓練時間。</li><li>我們預期輸出的結果會長這樣：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">29</span> </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.2157</span> Acc: <span class="number">0.4642</span> Time elapsed: <span class="number">25</span> sec. <span class="comment">-- 列印出 training 的 accuracy 來確認模型的訓練狀況。</span></span><br><span class="line">test Loss: <span class="number">1.2095</span> Acc: <span class="number">0.4553</span> Time elapsed: <span class="number">32</span> sec. <span class="comment">-- 列印出 testing 的 accuracy 來確認模型的訓練狀況。</span></span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.1019</span> Acc: <span class="number">0.5333</span> Time elapsed: <span class="number">58</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1816</span> Acc: <span class="number">0.4708</span> Time elapsed: <span class="number">65</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.0151</span> Acc: <span class="number">0.5812</span> Time elapsed: <span class="number">92</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1603</span> Acc: <span class="number">0.4898</span> Time elapsed: <span class="number">99</span> sec.</span><br><span class="line">...</span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">17</span>m <span class="number">5</span>s <span class="comment">-- 列印出 訓練所有 epoch 的時間。 </span></span><br><span class="line">Best val Acc: <span class="number">0.599578</span> #  <span class="comment">-- 列印出並保留 最好的 accuracy 的 model </span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>有沒有覺得上述的程式碼很熟悉？沒錯！如果你有按照這篇<a href="https://shannonhung.github.io/posts/flower102-transfer-learning.html">Flower102 Dataset - 使用 Transfer Learning 訓練 + 使用 Batch Normalization 於 CNN</a>裡面也是用同一種training的方式。<br>因為它既可以同時觀察 training 的結果，還可以觀察 testing 的結果訓練狀況是否有過擬合的情況。<br>儘管過度擬合，這個方式也可以保存最佳的模型。</p></div><p>那我們就開始 <code>train_model</code> 的函式，我這邊會透過 <code>!!!</code> 來標示出我們需要修改的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, criterion, optimizer, scheduler, num_epochs=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># 開始訓練的時間 </span></span><br><span class="line">    since = time.time()</span><br><span class="line">    <span class="comment"># 建立一個暫存資料夾，用來存放最好的模型 </span></span><br><span class="line">    <span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> tempdir:</span><br><span class="line">        <span class="comment"># 把目前最好的模型存放的路徑 </span></span><br><span class="line">        best_model_params_path = os.path.join(tempdir, <span class="string">&#x27;best_model_params.pt&#x27;</span>)</span><br><span class="line">        <span class="comment"># 先把最好的模型存放起來 </span></span><br><span class="line">        torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line">        <span class="comment"># 當前最好的準確度，如果有更好的準確度就會更新 </span></span><br><span class="line">        best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 開始訓練 n 個 epoch </span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;num_epochs - <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Each epoch has a training and validation phase</span></span><br><span class="line">            <span class="keyword">for</span> phase <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]:</span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    model.train()</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    model.<span class="built_in">eval</span>()</span><br><span class="line">                </span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line">                running_corrects = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Iterate over data.</span></span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">input</span>, label <span class="keyword">in</span> <span class="built_in">zip</span>(dataloaders[phase], resultloaders[phase]):</span><br><span class="line">                    <span class="comment"># ===== !!! Here !!! ====== </span></span><br><span class="line">                        <span class="comment"># 這邊就會使用到我們Task 2+3 所建立的函式，把句子轉換成 index 的形式，還有把label轉換成向量的形式 </span></span><br><span class="line">                        <span class="comment"># e.g. tensor([1070,  340, 2015, 2016,   45, 2017])</span></span><br><span class="line">                    inputs_vector = prepare_sentence_sequence(<span class="built_in">input</span>, word_to_ix) </span><br><span class="line">                        <span class="comment"># e.g. tensor([1., 0., 0., 0.]) </span></span><br><span class="line">                    labels_vector = one_hot_encode(label, tag_to_ix) </span><br><span class="line">                    <span class="comment"># ===== !!! End !!! ====== </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># zero the parameter gradients </span></span><br><span class="line">                    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># forward</span></span><br><span class="line">                    <span class="comment"># track history if only in train</span></span><br><span class="line">                    <span class="keyword">with</span> torch.set_grad_enabled(phase == <span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">                        <span class="comment"># 以下就會跟小試身手類似</span></span><br><span class="line">                        <span class="comment"># 取得針對每個emotion的預測結果tensor  </span></span><br><span class="line">                        outputs = model(inputs_vector) <span class="comment"># (e.g. tensor([[-1.3948, -1.4476, -1.3804, -1.3261]]))</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># ===== !!! Here !!! ====== </span></span><br><span class="line">                            <span class="comment"># 取得最大值的index </span></span><br><span class="line">                        pred = torch.argmax(outputs).item() <span class="comment"># (e.g. 2)</span></span><br><span class="line">                            <span class="comment"># 外面還有一層，只需取得內層 [-1.3948, -1.4476, -1.3804, -1.3261] 與 [0, 0, 1, 0] 的計算loss </span></span><br><span class="line">                        loss = criterion(outputs[<span class="number">0</span>], labels_vector) <span class="comment"># </span></span><br><span class="line">                        <span class="comment"># ===== !!! End !!! ====== </span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># backward + optimize only if in training phase</span></span><br><span class="line">                        <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                            loss.backward()</span><br><span class="line">                            optimizer.step()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># statistics</span></span><br><span class="line">                    running_loss += loss.item()</span><br><span class="line">                    <span class="keyword">if</span> pred == label:</span><br><span class="line">                        running_corrects += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    scheduler.step()</span><br><span class="line">                <span class="comment"># 計算每個 epoch 的 loss 和 accuracy </span></span><br><span class="line">                epoch_loss = running_loss / dataset_sizes[phase]</span><br><span class="line">                epoch_acc = running_corrects / dataset_sizes[phase]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;phase&#125;</span> Loss: <span class="subst">&#123;epoch_loss:<span class="number">.4</span>f&#125;</span> Acc: <span class="subst">&#123;epoch_acc:<span class="number">.4</span>f&#125;</span> Time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - since))&#125;</span> sec.&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果發現 有更好的準確度，就把模型存起來 </span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> epoch_acc &gt; best_acc:</span><br><span class="line">                    best_acc = epoch_acc</span><br><span class="line">                    torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        time_elapsed = time.time() - since</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Training complete in <span class="subst">&#123;time_elapsed // <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>m <span class="subst">&#123;time_elapsed % <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>s&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Best val Acc: <span class="subst">&#123;best_acc:4f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load best model weights 然後執行下一個 epoch </span></span><br><span class="line">        model.load_state_dict(torch.load(best_model_params_path))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p><strong>你會發現要改的地方沒幾個…頂多就是</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment"># input 跟 label 的轉換 </span></span><br><span class="line">        inputs_vector = prepare_sentence_sequence(<span class="built_in">input</span>, word_to_ix) </span><br><span class="line">        labels_vector = one_hot_encode(label, tag_to_ix) </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 然後取出 pred 的 index 才可以判斷預測是否正確 </span></span><br><span class="line">        pred = torch.argmax(outputs).item()</span><br><span class="line">        <span class="comment"># 計算 loss 時要特別取出內層的值</span></span><br><span class="line">        loss = criterion(outputs[<span class="number">0</span>], labels_vector)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那我們現在來準備訓練模型吧！</p><h2 id="訓練模型">訓練模型</h2><p>那我們先準備好訓練使用的dataset吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在這之前我們先準備好模型使用的dataset </span></span><br><span class="line">dataloaders = &#123;<span class="string">&#x27;train&#x27;</span>: train_dataset, <span class="string">&#x27;test&#x27;</span>: test_dataset&#125;</span><br><span class="line">resultloaders = &#123;<span class="string">&#x27;train&#x27;</span>: train_label_pd[<span class="number">0</span>].tolist(), <span class="string">&#x27;test&#x27;</span>: test_label_pd[<span class="number">0</span>].tolist()&#125;</span><br><span class="line">dataset_sizes = &#123;x: <span class="built_in">len</span>(dataloaders[x]) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><p>首先建立 LSTM 的模型吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 model </span></span><br><span class="line"><span class="comment"># vocab_size 要添加 1 因為如果 sentence 中有出現沒在 vocab 中的單字，使用 5000 來代替，所以要加 1</span></span><br><span class="line">model_LSTM = LSTMTagger(EMBEDDING_DIM, HIDDEN_DIM, <span class="built_in">len</span>(word_to_ix)+<span class="number">1</span>, <span class="built_in">len</span>(tag_to_ix), dropout=<span class="number">0.5</span>)</span><br><span class="line">loss_function_LSTM = nn.CrossEntropyLoss()</span><br><span class="line">optimizer_LSTM = optim.SGD(model_LSTM.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">exp_lr_scheduler_LSTM = lr_scheduler.StepLR(optimizer_LSTM, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始訓練 </span></span><br><span class="line">modelLSTM = train_model(model_LSTM, loss_function_LSTM, optimizer_LSTM, exp_lr_scheduler_LSTM, num_epochs=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">2</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.9885</span> Acc: <span class="number">0.5840</span> Time elapsed: <span class="number">97</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1279</span> Acc: <span class="number">0.5236</span> Time elapsed: <span class="number">104</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.8893</span> Acc: <span class="number">0.6371</span> Time elapsed: <span class="number">132</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1053</span> Acc: <span class="number">0.5369</span> Time elapsed: <span class="number">139</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.7683</span> Acc: <span class="number">0.7003</span> Time elapsed: <span class="number">168</span> sec.</span><br><span class="line">test Loss: <span class="number">1.0772</span> Acc: <span class="number">0.5658</span> Time elapsed: <span class="number">175</span> sec.</span><br><span class="line">...</span><br><span class="line">test Loss: <span class="number">1.1330</span> Acc: <span class="number">0.6059</span> Time elapsed: <span class="number">1040</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">17</span>m <span class="number">20</span>s</span><br><span class="line">Best val Acc: <span class="number">0.610134</span></span><br></pre></td></tr></table></figure><p>然後建立 GRU 的模型吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vocab_size 要添加 2 因為如果 sentence 中有出現沒在 vocab 中的單字，使用 5001 來代替，所以要加 1</span></span><br><span class="line">modelGRU = GRUTagger(EMBEDDING_DIM, HIDDEN_DIM, <span class="built_in">len</span>(word_to_ix)+<span class="number">1</span>, <span class="built_in">len</span>(tag_to_ix), dropout=<span class="number">0.5</span>)</span><br><span class="line">loss_function_gru = nn.CrossEntropyLoss()</span><br><span class="line">optimizer_gru = optim.SGD(modelGRU.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">exp_lr_scheduler_gru = lr_scheduler.StepLR(optimizer_gru, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始訓練 </span></span><br><span class="line">modelGRU = train_model(modelGRU, loss_function_gru, optimizer_gru, exp_lr_scheduler_gru, num_epochs=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">3</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.8445</span> Acc: <span class="number">0.6702</span> Time elapsed: <span class="number">131</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1211</span> Acc: <span class="number">0.5327</span> Time elapsed: <span class="number">138</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.6843</span> Acc: <span class="number">0.7393</span> Time elapsed: <span class="number">166</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1305</span> Acc: <span class="number">0.5707</span> Time elapsed: <span class="number">173</span> sec.</span><br><span class="line">...</span><br><span class="line">test Loss: <span class="number">1.3237</span> Acc: <span class="number">0.6073</span> Time elapsed: <span class="number">1003</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">16</span>m <span class="number">43</span>s</span><br><span class="line">Best val Acc: <span class="number">0.608726</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COCO Dataset - 使用 Faster RCNN + MobileNet 進行 Object Detection</title>
      <link href="/posts/coco-object-diagnoise/"/>
      <url>/posts/coco-object-diagnoise/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第四個作業，主要教授內容為以下主題：</p><ol><li>Download Coco dataset</li><li>User pre-trained version of Faster R-CNN to predict the bounding box</li><li>Calculate IoU</li></ol><h1 id="作業要求">作業要求</h1><ol><li><strong>下載coco資料集</strong>：Download the file „2017 Val images [5/1GB]“ and „ 2017 Train/Val annotations [241MB]“ from<br>the Coco page. You can use the library pycocotools to load them into your notebook.</li><li><strong>隨機從dataset選擇十張</strong>：Randomly select 10 images from this dataset.</li><li><strong>使用pre-trained模型FasterR-CNN預測bbox</strong>：Use a pre-trained version of Faster R-CNN (Resnet50 backbone) to predict the bounding box<br>of objects on the 10 images. Only keep regions that have a score &gt; 0.8.</li><li><strong>把模型跟解答視覺化擺在一起</strong>：Visualize the predicted bounding boxes and label together with the ground truth bounding<br>boxes and label. Show all 10 pairs of images side by side in the jupyter notebook.</li><li><strong>使用另一個pre-trained模型Mobilnet</strong>：Repeat the steps from above using a Mobilenet backbone for the Faster R-CNN.</li><li><strong>計算IoU比較模型</strong>：Wich backbone delivers the better results? Calculate the IoU for both approaches.</li></ol><h1 id="Task-1-下載coco資料集">Task 1: 下載coco資料集</h1><div class="note info flat"><p><strong>Task 1</strong></p><ol><li><strong>下載coco資料集</strong>：Download the file „2017 Val images [5/1GB]“ and „ 2017 Train/Val annotations [241MB]“ from the Coco page. You can use the library pycocotools to load them into your notebook.</li></ol></div><p>可以看照這個說明進行下載：<a href="https://jason-chen-1992.weebly.com/home/coco-dataset">https://jason-chen-1992.weebly.com/home/coco-dataset</a><br><img src="https://i.imgur.com/BieHtLG.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── annotations <span class="comment"># 這是標注資料</span></span><br><span class="line">│   ├── captions_train2017.json</span><br><span class="line">│   ├── captions_val2017.json</span><br><span class="line">│   ├── instances_train2017.json</span><br><span class="line">│   ├── instances_val2017.json</span><br><span class="line">│   ├── person_keypoints_train2017.json</span><br><span class="line">│   └── person_keypoints_val2017.json</span><br><span class="line">└── val2017 <span class="comment"># 這是圖片集 </span></span><br><span class="line">    ├── 000000000139.jpg</span><br><span class="line">    ├── 000000000285.jpg</span><br><span class="line">    ├── 000000000632.jpg</span><br><span class="line">    ├── 000000000724.jpg</span><br><span class="line">    ├── 000000000776.jpg</span><br><span class="line">    ├── 000000000785.jpg</span><br><span class="line">    ├── 000000000802.jpg</span><br><span class="line">    ... </span><br></pre></td></tr></table></figure><ul><li>去官網下載這兩個檔案如圖一</li><li>下載後資料夾解壓縮會如上面的檔案結構</li></ul><h1 id="Task-2-隨機選十張">Task 2: 隨機選十張</h1><div class="note info flat"><p><strong>Task 2</strong><br>2. <strong>隨機從dataset選擇十張</strong>：Randomly select 10 images from this dataset.</p></div><p>這邊我們主要會做幾件事情：</p><ul><li>匯入必要套件</li><li>設定coco api，讓他可以引入我們的資料集的相關資訊，像是預測框位置、標籤位置、圖片資訊</li><li>視覺化圖片並且進行標示</li><li>隨機選十個圖片</li></ul><p>我們先匯入必要的套件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># CNN </span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># torchvision</span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset </span></span><br><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cudnn.benchmark = <span class="literal">True</span></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure><h2 id="設定coco-api">設定coco api</h2><p>coco 有提供獲取資料集的 api，只要給他json檔案，我們就可以輕易的我們可以透過這個 api 來根據json檔案，獲取我們需要的資料，像是圖片、標籤、預測框等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定資料集位置</span></span><br><span class="line">cocoRoot = <span class="string">&quot;../../Data/Coco/&quot;</span></span><br><span class="line">dataType = <span class="string">&quot;val2017&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定標註檔案位置</span></span><br><span class="line">annFile = os.path.join(cocoRoot, <span class="string">f&#x27;annotations/instances_<span class="subst">&#123;dataType&#125;</span>.json&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Annotation file: <span class="subst">&#123;annFile&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># # initialize COCO api for instance annotations</span></span><br><span class="line">coco=COCO(annFile)</span><br><span class="line">coco </span><br></pre></td></tr></table></figure><blockquote><p>結果如下</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Annotation file: ../../Data/Coco/annotations/instances_val2017.json</span><br><span class="line">## 表示成功讀取標註檔案</span><br><span class="line">loading annotations into memory...</span><br><span class="line">Done (t=<span class="number">0.35</span>s)</span><br><span class="line">creating index...</span><br><span class="line">index created!</span><br></pre></td></tr></table></figure><h2 id="標註視覺化">標註視覺化</h2><p>為了確保會使用coco所提供的API這邊有一個練習，主要學習以下內容：</p><ul><li>取得 image info by id</li><li>取得 annotation info by id</li><li>學會在 image 上畫 bounding box 並標籤</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做一個function，只要給他 image id 就可以畫出圖片並且標示出 bounding box和標籤</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_image_with_annotations</span>(<span class="params">coco, cocoRoot, dataType, imgId, ax=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 取得圖片資訊  </span></span><br><span class="line">    imgInfo = coco.loadImgs(imgId)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取得圖片位置 準備拿來視覺化 </span></span><br><span class="line">    imPath = os.path.join(cocoRoot, dataType, imgInfo[<span class="string">&#x27;file_name&#x27;</span>])    </span><br><span class="line">    <span class="comment"># 讀取圖片</span></span><br><span class="line">    im = cv2.imread(imPath)</span><br><span class="line">    <span class="comment"># 轉換色彩空間 cv2 的預設色彩空間為 BGR，但是 matplotlib 的預設色彩空間為 RGB，因此這邊需要轉換一下</span></span><br><span class="line">    im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到圖片的所有標註 bounding boxes </span></span><br><span class="line">    annIds = coco.getAnnIds(imgIds=imgInfo[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    <span class="comment"># 取得所有標註資訊，回傳每個box的座標資訊, 標籤, 準確率</span></span><br><span class="line">    anns = coco.loadAnns(annIds)</span><br><span class="line">    all_labels = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 座標資訊, 標籤, 準確率 </span></span><br><span class="line">    <span class="keyword">for</span> ann <span class="keyword">in</span> anns:</span><br><span class="line">        <span class="comment"># 特別只選取 bbox 的資訊，會傳回 (x, y)圖片左下角, w（框寬）, h（寬高）</span></span><br><span class="line">        x, y, w, h = ann[<span class="string">&#x27;bbox&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取得標籤的文字資訊，load category name by category id </span></span><br><span class="line">        label = coco.loadCats(ann[<span class="string">&#x27;category_id&#x27;</span>])[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        all_labels.add(label)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提供坐標資訊畫出 bounding box</span></span><br><span class="line">        rect = Rectangle((x, y), w, h, linewidth=<span class="number">2</span>, edgecolor=<span class="string">&#x27;r&#x27;</span>, facecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 畫出圖片，因為我可能需要排序圖片，所以可以透過 ax 來指定圖片畫在哪個位置</span></span><br><span class="line">        <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># gca 可以取得目前的 axes，如果沒有就會自動創建一個，axes 你可以想像他是一個畫布，你可以在上面畫點,線,圖,文字等等</span></span><br><span class="line">            <span class="comment"># 然後透過 add_patch 把 預測框 畫上去 </span></span><br><span class="line">            plt.gca().add_patch(rect) </span><br><span class="line">            <span class="comment"># plt.text() 它會將文字標籤加入到目前的Axes物件中，會畫出標籤</span></span><br><span class="line">            plt.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="comment"># 如果沒有 ax 就直接畫在 plt 上 </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ax.add_patch(rect)</span><br><span class="line">            ax.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=<span class="string">&#x27;r&#x27;</span> )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顯示圖片並給他一個標題</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        plt.imshow(im)</span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">f&#x27;Ans: <span class="subst">&#123;all_labels&#125;</span>&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&#x27;Ans: <span class="subst">&#123;all_labels&#125;</span>&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>,loc=<span class="string">&#x27;center&#x27;</span>, pad=<span class="number">20</span>)</span><br><span class="line">        ax.imshow(im)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取第十張圖片</span></span><br><span class="line">imgIds = coco.getImgIds()</span><br><span class="line">imgId = imgIds[<span class="number">10</span>]</span><br><span class="line"><span class="comment"># 繪製出來</span></span><br><span class="line">plot_image_with_annotations(coco, cocoRoot, dataType, imgId)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><p><img src="https://i.imgur.com/C0nZWY9.png" alt=""></p><h2 id="隨機選10張">隨機選10張</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_select</span>(<span class="params">coco, cocoRoot, dataType, num_images=<span class="number">10</span></span>):</span><br><span class="line">    <span class="comment"># 取得所有圖片的 id</span></span><br><span class="line">    imgIds = coco.getImgIds()</span><br><span class="line">    <span class="comment"># 從這些 id 中隨機選取 num_images 個 id </span></span><br><span class="line">    selected_imgIds = random.sample(imgIds, num_images)</span><br><span class="line">    <span class="comment"># 遞迴呼叫每個 id </span></span><br><span class="line">    <span class="keyword">for</span> imgId <span class="keyword">in</span> selected_imgIds:</span><br><span class="line">        <span class="comment"># 根據 id 繪製圖片</span></span><br><span class="line">        plot_image_with_annotations(coco, cocoRoot, dataType, imgId)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最後印出所有選取的 id</span></span><br><span class="line">    <span class="keyword">return</span> selected_imgIds</span><br><span class="line">    </span><br><span class="line">valid_ids = random_select(coco, cocoRoot, dataType, num_images=<span class="number">10</span>)</span><br><span class="line">valid_ids</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><p><img src="https://i.imgur.com/TUiI82h.png" alt=""></p><h1 id="Task-3-5-FasterR-CNN-v-s-Mobilnet">Task 3+5: FasterR-CNN v.s Mobilnet</h1><div class="note info flat"><p><strong>Task 3 &amp; 5</strong><br>3. <strong>使用pre-trained模型FasterR-CNN預測bbox</strong>：Use a pre-trained version of Faster R-CNN (Resnet50 backbone) to predict the bounding box<br>of objects on the 10 images. Only keep regions that have a score &gt; 0.8.<br>5. <strong>使用另一個pre-trained模型Mobilnet</strong>：Repeat the steps from above using a Mobilenet backbone for the Faster R-CNN.</p></div><h2 id="引用-pre-train-model">引用 pre-train model</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引用 pre-train model  (FasterR-CNN)</span></span><br><span class="line">model_res = torchvision.models.detection.fasterrcnn_resnet50_fpn(weights=<span class="string">&quot;FasterRCNN_ResNet50_FPN_Weights.DEFAULT&quot;</span>)</span><br><span class="line">model_res.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用 pre-train model  (Mobilenet)</span></span><br><span class="line">model_mobile = torchvision.models.detection.fasterrcnn_mobilenet_v3_large_fpn(weights=torchvision.models.detection.FasterRCNN_MobileNet_V3_Large_FPN_Weights)</span><br><span class="line">model_mobile.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><h2 id="圖片轉換成-tensor函式">圖片轉換成 tensor函式</h2><p>我們要先能夠根據圖片的位置，圖取圖片出來。然後把讀書來得圖片，轉換成 tensor，才能放入 model 中進行預測。所以我們做了兩個函式:</p><ul><li>一個是讀取圖片</li><li>一個是把圖片轉成 tensor。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">imgIdx</span>):</span><br><span class="line">    <span class="comment"># 取得圖片資訊</span></span><br><span class="line">    imgInfo = coco.loadImgs(imgIdx)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取得圖片位置 準備拿來視覺化</span></span><br><span class="line">    imPath = os.path.join(cocoRoot, dataType, imgInfo[<span class="string">&#x27;file_name&#x27;</span>])    </span><br><span class="line">    <span class="comment"># 印出圖片位置</span></span><br><span class="line">    <span class="built_in">print</span>(imPath)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 讀取圖片</span></span><br><span class="line">        <span class="keyword">return</span> Image.<span class="built_in">open</span>(imPath)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把圖片轉成 tensor 才可以放入 model 中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pil2tensor</span>(<span class="params">pil_image</span>):</span><br><span class="line">    <span class="comment"># 使用 unsqueeze(0) 是因為 model 的 還包含 batch size 的維度，共四個維度 (batch_size, channel-RGB, height, width)</span></span><br><span class="line">    <span class="comment"># 但是圖片只有一張沒有batch size，圖片轉tensor會只有三個維度（channel-RGB, height, width），所以我們需要增加一個維度</span></span><br><span class="line">    <span class="comment"># /255 是因為 model 的輸入是 0~1 之間的數字，而圖片的數值是 0~255，所以需要除以 255 來做正規化</span></span><br><span class="line">    <span class="keyword">return</span> torchvision.transforms.PILToTensor()(pil_image).unsqueeze(<span class="number">0</span>) / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><h2 id="訓練模型">訓練模型</h2><p>前置作業都準備好了，我們就可以開始使用pre-trained好的模型進行預測，並儲存回傳的結果，等等視覺化使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用來存放預測結果</span></span><br><span class="line">predictions_res = []</span><br><span class="line">predictions_mobile = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遞迴呼叫每個 id，這些id是我們在上面隨機選取的10個id</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> valid_ids:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment"># transform to tensor from PIL image</span></span><br><span class="line">    img_as_tensor = pil2tensor(load_image(i))</span><br><span class="line">    <span class="comment"># put the tensor to resnet model</span></span><br><span class="line">    prediction = model_res(img_as_tensor)</span><br><span class="line">    <span class="comment"># 存放預測結果：預測結果是一個字典，裡面包含了預測的 bounding box, 標籤, 準確率</span></span><br><span class="line">    predictions_res.append(prediction)</span><br><span class="line">    <span class="comment"># put the tensor to mobilenet model</span></span><br><span class="line">    prediction = model_mobile(img_as_tensor)</span><br><span class="line">    <span class="comment"># 存放預測結果：預測結果是一個字典，裡面包含了預測的 bounding box, 標籤, 準確率</span></span><br><span class="line">    predictions_mobile.append(prediction)</span><br></pre></td></tr></table></figure><h2 id="只選擇-0-8的預測結果">只選擇&gt;0.8的預測結果</h2><p>在收集好所有的結果後，我們要特別從這一大堆預測框中，只挑選準確率大於 0.8 的預測框，這樣視覺化的時候才不會太亂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter_valid_boxes</span>(<span class="params">predictions, threshold=<span class="number">0.8</span></span>):</span><br><span class="line">    <span class="comment"># 用來存放過濾後的預測結果</span></span><br><span class="line">    valid_boxes_list = []</span><br><span class="line">    <span class="comment"># 遞迴呼叫每個預測結果</span></span><br><span class="line">    <span class="keyword">for</span> prediction <span class="keyword">in</span> predictions:</span><br><span class="line">        valid_boxes_for_this_prediction = []</span><br><span class="line">        <span class="comment"># 遞迴呼叫每個預測框</span></span><br><span class="line">        <span class="keyword">for</span> box, label, score <span class="keyword">in</span> <span class="built_in">zip</span>(prediction[<span class="number">0</span>][<span class="string">&quot;boxes&quot;</span>], prediction[<span class="number">0</span>][<span class="string">&quot;labels&quot;</span>], prediction[<span class="number">0</span>][<span class="string">&quot;scores&quot;</span>]):</span><br><span class="line">            <span class="comment"># 保留準確率大於 threshold 的預測框</span></span><br><span class="line">            <span class="keyword">if</span> score &gt;= threshold:</span><br><span class="line">                <span class="comment"># 把預測框, 標籤, 準確率存起來</span></span><br><span class="line">                valid_boxes_for_this_prediction.append((box, label, score))</span><br><span class="line">        <span class="comment"># 如果這張圖片沒有任何一個預測框的準確率大於 threshold，就存一個空的 list</span></span><br><span class="line">        valid_boxes_list.append(valid_boxes_for_this_prediction)</span><br><span class="line">    <span class="comment"># 回傳過濾後的預測結果</span></span><br><span class="line">    <span class="keyword">return</span> valid_boxes_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 threshold 設定為 0.8，並且獲取 resnet 與 mobilenet 的預測結果 </span></span><br><span class="line">valid_boxes_res = filter_valid_boxes(predictions_res, threshold=<span class="number">0.8</span>)</span><br><span class="line">valid_boxes_mobile = filter_valid_boxes(predictions_mobile, threshold=<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><h1 id="Task-4-6-視覺化-IoU">Task 4+6: 視覺化 + IoU</h1><div class="note info flat"><p><strong>Task 4 &amp; 6</strong><br>4. <strong>把模型跟解答視覺化擺在一起</strong>：Visualize the predicted bounding boxes and label together with the ground truth bounding<br>6. <strong>計算IoU比較模型</strong>：Wich backbone delivers the better results? Calculate the IoU for both approaches.</p></div><p>視覺話有很重要的幾點，步驟大概如下：</p><ul><li>要先知道圖片id，根據id取得annotation的資訊，這樣才可以計算 IoU</li><li>我們將ann的資訊跟model的資訊，進行 IoU 的計算</li><li>我們讀取圖片在電腦中的位置，根據圖片路徑，把圖片先透過plt畫出來</li><li>然後基於這個圖片，才可以在上面畫上預測框跟標籤還有 IoU 的平均值</li></ul><p>以下程式就是上述所描述的步驟，我們會把兩個模型的結果都畫出來，並且計算 IoU 的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以把不同 model 的結果放入此函式，並且會回傳 IoU 的平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_annotated_results</span>(<span class="params">imgId, valid_boxes, model_name, color=<span class="string">&#x27;g&#x27;</span>, ax=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Load the image</span></span><br><span class="line">    imgInfo = coco.loadImgs(imgId)[<span class="number">0</span>]</span><br><span class="line">    image_path = os.path.join(cocoRoot, dataType, imgInfo[<span class="string">&#x27;file_name&#x27;</span>])</span><br><span class="line">    image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得正確的 bounding box 結果 </span></span><br><span class="line">    annIds = coco.getAnnIds(imgIds=imgInfo[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    anns = coco.loadAnns(annIds)</span><br><span class="line">    bbox_tlist_anns = torch.tensor([ann[<span class="string">&quot;bbox&quot;</span>] <span class="keyword">for</span> ann <span class="keyword">in</span> anns]) <span class="comment"># tensor.shape[2,4]</span></span><br><span class="line">    <span class="comment"># 因為我們的 bounding box 是 x,y,w,h 也就是 框框 左下角的座標(x,y) ＋ 框框的長與寬</span></span><br><span class="line">    <span class="comment"># 但是 torchvision 計算出 IoU 的 box_iou 必須給予 左下角的座標(x,y) 跟 右上角的座標(x2,y2)，所以要透過(x+w, y+h)來計算(x2,y2) 取得右上角的座標 </span></span><br><span class="line">    <span class="comment"># x,y,w,h -&gt; x1,y1,x2,y2 = x,y,x+w,y+h </span></span><br><span class="line">    bbox_tlist_anns[:, <span class="number">2</span>] = bbox_tlist_anns[:, <span class="number">0</span>] + bbox_tlist_anns[:, <span class="number">2</span>]</span><br><span class="line">    bbox_tlist_anns[:, <span class="number">3</span>] = bbox_tlist_anns[:, <span class="number">1</span>] + bbox_tlist_anns[:, <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 從結果valid_boxes中，我們只要box的部分，把label, score拿掉，因此我們使用(box, _, _) </span></span><br><span class="line">    <span class="comment"># 使用 stack 是因為我們要把所有的 box 疊起來，變成一個 tensor   </span></span><br><span class="line">    bbox_tlist_model = torch.stack([box <span class="keyword">for</span> box, _, _ <span class="keyword">in</span> valid_boxes]) <span class="comment"># turn [4] to tensor.shape[2,4]</span></span><br><span class="line">    <span class="comment"># 使用 box_iou 來計算 IoU </span></span><br><span class="line">    iou = torchvision.ops.box_iou(bbox_tlist_anns, bbox_tlist_model) <span class="comment"># get IoU </span></span><br><span class="line">    <span class="comment"># 取得ann每個預測框的最大值後（可以看補充IoU了解詳細），進行 IoU 的平均值</span></span><br><span class="line">    avg_iou = np.mean([t.cpu().detach().numpy().<span class="built_in">max</span>() <span class="keyword">for</span> t <span class="keyword">in</span> iou]) <span class="comment"># calculate the mean of IoU</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顯示圖片標籤</span></span><br><span class="line">    all_labels = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 開始繪製預測框</span></span><br><span class="line">    <span class="keyword">for</span> boxes <span class="keyword">in</span> valid_boxes:</span><br><span class="line">        <span class="comment"># 取得預測框的資訊 包含 box, label, score </span></span><br><span class="line">        box, label, score = boxes</span><br><span class="line">        <span class="comment"># 取得標籤的文字資訊，load category name by category id </span></span><br><span class="line">        label = coco.loadCats(label.item())[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        <span class="comment"># 把標籤存起來後續顯示用</span></span><br><span class="line">        all_labels.add(label)</span><br><span class="line">        <span class="comment"># 模型回傳的結果是兩個座標，左下角與右上角，所以我們要把他們轉換成 x,y,w,h 的形式放入Rectangle </span></span><br><span class="line">        x, y, x2, y2 = box.detach().numpy() <span class="comment"># x,y,w,h -&gt; x,y,x2-x,y2-y</span></span><br><span class="line">        rect = Rectangle((x, y), x2 - x, y2 - y, linewidth=<span class="number">2</span>, edgecolor=color, facecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 繪製圖片，因為我可能需要排序圖片，所以可以透過 ax 來指定圖片畫在哪個位置</span></span><br><span class="line">        <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># gca 可以取得目前的 axes，如果沒有就會自動創建一個，然後透過 add_patch 把 預測框 畫上去</span></span><br><span class="line">            plt.gca().add_patch(rect) </span><br><span class="line">            <span class="comment"># 在預測框上面畫上標籤</span></span><br><span class="line">            plt.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=color)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不用 gca 是因為我們已經有指定 ax 了，所以直接在 ax 上畫就好</span></span><br><span class="line">            ax.add_patch(rect)</span><br><span class="line">            <span class="comment"># 在預測框上面畫上標籤 </span></span><br><span class="line">            ax.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=color)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 顯示圖片並給他一個標題，標題是這個圖片有出現過的標籤，以及 IoU 的平均值</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span>: <span class="subst">&#123;all_labels&#125;</span> \n IoU: <span class="subst">&#123;avg_iou:<span class="number">.4</span>f&#125;</span>&#x27;</span>, color=color)</span><br><span class="line">        plt.imshow(image)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span>: <span class="subst">&#123;all_labels&#125;</span> \n I0U: <span class="subst">&#123;avg_iou:<span class="number">.4</span>f&#125;</span>&#x27;</span>, color=color)</span><br><span class="line">        ax.imshow(image)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> avg_iou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res_iou = []</span><br><span class="line">mobile_iou = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遞迴呼叫每個 id，id是我們在上面隨機選取的10個id </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(valid_ids)):</span><br><span class="line">    <span class="comment"># 建立一個 1x3 的圖片，每一張圖片的大小為 15x5 </span></span><br><span class="line">    fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">5</span>))   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># draw truth image 繪製正確解答，並且把圖片畫在中間的圖片上</span></span><br><span class="line">    plot_image_with_annotations(coco, cocoRoot, dataType, valid_ids[i], ax=axs[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 繪製兩個不同模型的預測結果圖片，分別放在左右兩側，並回傳 IoU </span></span><br><span class="line">    i_mobil_iou = display_annotated_results(valid_ids[i], valid_boxes_mobile[i], <span class="string">&quot;mobile&quot;</span>, color=<span class="string">&#x27;g&#x27;</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">    i_res_iou = display_annotated_results(valid_ids[i], valid_boxes_res[i], <span class="string">&quot;ResNet&quot;</span>, color=<span class="string">&#x27;b&#x27;</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 儲存每個圖片的 IoU 以得知整個模型的表現 </span></span><br><span class="line">    mobile_iou.append(i_mobil_iou)</span><br><span class="line">    res_iou.append(i_res_iou)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># organize the layout</span></span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the mean of IoU list </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ResNet: Avg.&quot;</span>, np.mean(res_iou), <span class="string">&quot;; each IoU:&quot;</span>, res_iou)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MobileNet: Avg.&quot;</span>, np.mean(mobile_iou), <span class="string">&quot;; each IoU:&quot;</span>, mobile_iou)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><p><img src="https://i.imgur.com/LjCVWdY.png" alt=""></p><h1 id="補充：IoU">補充：IoU</h1><ul><li>Ref: <a href="https://blog.csdn.net/IAMoldpan/article/details/78799857">https://blog.csdn.net/IAMoldpan/article/details/78799857</a></li><li>Ref: <a href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/">https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/</a></li></ul><div class="note info flat"><p>IoU (Intersection over Union) 是一個用來評估物件偵測演算法的指標，其定義為<code>預測框</code>與<code>真實框</code>其<code>交集面積</code> / <code>聯集面積</code>，其值介於 0 與 1 之間，值越大代表預測框與真實框的重疊程度越高，也就是預測框越準確。</p></div><p><img src="https://i.imgur.com/VzMudvr.png" alt=""><br><img src="https://i.imgur.com/OKroIoL.png" alt=""><br>取自：<a href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/">https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/</a></p><div class="note info flat"><p><strong>從上面的範例中，你可能會好奇，以下這段程式到底做了什麽？</strong></p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.ops.box_iou(bbox_tlist_anns, bbox_tlist_model) </span><br></pre></td></tr></table></figure><ul><li>其實基本上他就是把 解答的所有預測框，跟 model 的所有預測框，兩兩計算 IoU，並且回傳一個 tensor，其 shape 為 (解答的預測框數量, model 的預測框數量)，參考下圖。<br><img src="https://i.imgur.com/kQ6IVMY.png" alt=""><br><img src="https://i.imgur.com/lnjmgeD.png" alt=""></li></ul><p><strong>這邊我們只需要取得每個解答預測框的最大 IoU，並且計算平均值即可，因此我們使用以下程式碼</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得ann每個預測框的最大值後（可以看補充IoU了解詳細），進行 IoU 的平均值</span></span><br><span class="line">avg_iou = np.mean([t.cpu().detach().numpy().<span class="built_in">max</span>() <span class="keyword">for</span> t <span class="keyword">in</span> iou]) <span class="comment"># calculate the mean of IoU</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>你可能會好奇，使用 <code>max()</code>, <code>mean()</code>, <code>sum()</code> 這些函式，是否會影響我們的結果？</p></div><p><img src="https://i.imgur.com/lnQtu1r.png" alt=""><br><strong>可以從上圖看到其實會發現</strong></p><ul><li>使用 <code>sum()</code> 你會發現他有可能會超過1，這並不是 IoU 合理的數值範圍。</li><li>使用 <code>max()</code> 他會針對解答的預測框，從 model 選一個最接近的預測框，當作該預測框的IoU，之後就可以取得解答的<code>所有預測框</code>其最大值，並進行平均來獲得整體的 IoU。</li><li>使用 <code>mean()</code> 會有一個問題，這個 IoU的計算永遠不可能為1，因為你考慮到其他預測框的 IoU，這樣就會把 IoU 降低，舉例來說，解答預測框有兩個<code>[A1,A2]</code>，而模型也產生兩個<code>[B1,B2]</code>，一眼就知道，B1預測的是A1，而B2預測A2，而模型也預測的很準確。但是你卻透過 mean 把B1當作A2，B2當作A1，顯然是錯的，而且這兩組的 IoU 也很低，你如果透過 mean() 這樣就會把 IoU 降低，這樣就不合理了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flower102 Dataset - 使用 Transfer Learning 訓練 + 使用 Batch Normalization 於 CNN</title>
      <link href="/posts/flower102-transfer-learning/"/>
      <url>/posts/flower102-transfer-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第四個作業，主要教授內容為以下主題：</p><ol><li>Pick a dataset and train a model on it.</li><li>Transfer Learning - Fine Tuning.</li><li>Batch Normalization in CNN.</li></ol><p>主要參考以下網站：</p><ol><li><a href="https://pytorch.org/vision/stable/generated/torchvision.datasets.Flowers102.html#torchvision.datasets.Flowers102">Flower102 Dataset</a></li><li><a href="https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a></li><li><a href="https://pytorch.org/vision/stable/datasets.html">DataSet of Pytorch</a></li><li><a href="https://pytorch.org/vision/stable/models.html">Models for transfer learning</a></li><li><a href="/posts/ML.html#Transfer-Learning">Shannon’s Blog of Transfer Learning</a></li><li><a href="https://pytorch.org/vision/stable/models/generated/torchvision.models.resnet18.html#torchvision.models.resnet18">Resnet18</a></li></ol><h1 id="作業要求">作業要求</h1><p>Task:</p><ol><li><strong>選擇一個DataSet</strong>： Check out the torchvision <a href="https://pytorch.org/vision/stable/datasets.html">DataSet of Pytorch</a> and decide one dataset that you want to use (no<br>CIFAR, no ImageNet, no FashionMNIST).</li><li><strong>印出圖片和資料大小</strong>：Show some example images of the dataset in the notebook and print the dataset size.</li><li><strong>建構使用Batch Normalization的CNN</strong>：Design a CNN to predict on the dataset. Use a similar architecture like last time, but this time<br>also include batch normalization layers.</li><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li><li><strong>使用ResNet18來進行Transfer-Learning</strong>：Now use transfer learning to use a pre-trained ResNet18 on the dataset as follows:<ol><li><strong>不改變別人模型訓練好的權重</strong>：ResNet18 as fixed feature extractor.</li><li><strong>使用RestNet進行Fineturned</strong>：ResNet18 finetuned on the training data.</li></ol></li><li><strong>使用EfficientNet_B5進行Fineturned</strong>：Repeat step 4 but now use EfficientNet_B5 instead of RestNet18.</li><li><strong>比較這些不同的方法，並列印出準確度</strong>：Compare the accuracy of the different approaches on the test data and print out the training<br>times for each approach.</li></ol><h1 id="Task-0-import-package">Task 0 - import package</h1><p>先來導入所需的套件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CNN </span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset </span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, models, transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> Flowers102</span><br><span class="line"></span><br><span class="line"><span class="comment"># label </span></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">cudnn.benchmark = <span class="literal">True</span></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure><h1 id="Task-1-選擇一個DataSet">Task 1 - 選擇一個DataSet</h1><ul><li>Ref: <a href="https://www.geeksforgeeks.org/how-to-normalize-images-in-pytorch/">為什麼是[0.485, 0.456, 0.406]進行Normalization</a></li></ul><div class="note info flat"><p><strong>選擇一個DataSet</strong>： Check out the torchvision <a href="https://pytorch.org/vision/stable/datasets.html">DataSet of Pytorch</a> and decide one dataset that you want to use (no<br>CIFAR, no ImageNet, no FashionMNIST).</p></div><p>為了體驗 Transfer Learning，並且快速訓練。我們這邊使用 flower102 來作為我們的資料集。因為 flower102 沒有提供中文的 Label，我網路上找大部分都是讀取已經寫好的 <code>.json</code> 或是 <code>.txt</code> 檔案，該檔案會描述每一個 label index 對應的中文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定你要下載的資料及路徑 和 btach size 一次訓練的量</span></span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line">data_dir = <span class="string">&#x27;../../Data/flowers-102&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 dataset 的 classes_name </span></span><br><span class="line">json_data = <span class="string">&#x27;&#123;&quot;21&quot;: &quot;fire lily&quot;, &quot;3&quot;: &quot;canterbury bells&quot;, &quot;45&quot;: &quot;bolero deep blue&quot;, &quot;1&quot;: &quot;pink primrose&quot;, &quot;34&quot;: &quot;mexican aster&quot;, &quot;27&quot;: &quot;prince of wales feathers&quot;, &quot;7&quot;: &quot;moon orchid&quot;, &quot;16&quot;: &quot;globe-flower&quot;, &quot;25&quot;: &quot;grape hyacinth&quot;, &quot;26&quot;: &quot;corn poppy&quot;, &quot;79&quot;: &quot;toad lily&quot;, &quot;39&quot;: &quot;siam tulip&quot;, &quot;24&quot;: &quot;red ginger&quot;, &quot;67&quot;: &quot;spring crocus&quot;, &quot;35&quot;: &quot;alpine sea holly&quot;, &quot;32&quot;: &quot;garden phlox&quot;, &quot;10&quot;: &quot;globe thistle&quot;, &quot;6&quot;: &quot;tiger lily&quot;, &quot;93&quot;: &quot;ball moss&quot;, &quot;33&quot;: &quot;love in the mist&quot;, &quot;9&quot;: &quot;monkshood&quot;, &quot;102&quot;: &quot;blackberry lily&quot;, &quot;14&quot;: &quot;spear thistle&quot;, &quot;19&quot;: &quot;balloon flower&quot;, &quot;100&quot;: &quot;blanket flower&quot;, &quot;13&quot;: &quot;king protea&quot;, &quot;49&quot;: &quot;oxeye daisy&quot;, &quot;15&quot;: &quot;yellow iris&quot;, &quot;61&quot;: &quot;cautleya spicata&quot;, &quot;31&quot;: &quot;carnation&quot;, &quot;64&quot;: &quot;silverbush&quot;, &quot;68&quot;: &quot;bearded iris&quot;, &quot;63&quot;: &quot;black-eyed susan&quot;, &quot;69&quot;: &quot;windflower&quot;, &quot;62&quot;: &quot;japanese anemone&quot;, &quot;20&quot;: &quot;giant white arum lily&quot;, &quot;38&quot;: &quot;great masterwort&quot;, &quot;4&quot;: &quot;sweet pea&quot;, &quot;86&quot;: &quot;tree mallow&quot;, &quot;101&quot;: &quot;trumpet creeper&quot;, &quot;42&quot;: &quot;daffodil&quot;, &quot;22&quot;: &quot;pincushion flower&quot;, &quot;2&quot;: &quot;hard-leaved pocket orchid&quot;, &quot;54&quot;: &quot;sunflower&quot;, &quot;66&quot;: &quot;osteospermum&quot;, &quot;70&quot;: &quot;tree poppy&quot;, &quot;85&quot;: &quot;desert-rose&quot;, &quot;99&quot;: &quot;bromelia&quot;, &quot;87&quot;: &quot;magnolia&quot;, &quot;5&quot;: &quot;english marigold&quot;, &quot;92&quot;: &quot;bee balm&quot;, &quot;28&quot;: &quot;stemless gentian&quot;, &quot;97&quot;: &quot;mallow&quot;, &quot;57&quot;: &quot;gaura&quot;, &quot;40&quot;: &quot;lenten rose&quot;, &quot;47&quot;: &quot;marigold&quot;, &quot;59&quot;: &quot;orange dahlia&quot;, &quot;48&quot;: &quot;buttercup&quot;, &quot;55&quot;: &quot;pelargonium&quot;, &quot;36&quot;: &quot;ruby-lipped cattleya&quot;, &quot;91&quot;: &quot;hippeastrum&quot;, &quot;29&quot;: &quot;artichoke&quot;, &quot;71&quot;: &quot;gazania&quot;, &quot;90&quot;: &quot;canna lily&quot;, &quot;18&quot;: &quot;peruvian lily&quot;, &quot;98&quot;: &quot;mexican petunia&quot;, &quot;8&quot;: &quot;bird of paradise&quot;, &quot;30&quot;: &quot;sweet william&quot;, &quot;17&quot;: &quot;purple coneflower&quot;, &quot;52&quot;: &quot;wild pansy&quot;, &quot;84&quot;: &quot;columbine&quot;, &quot;12&quot;: &quot;colt\&#x27;s foot&quot;, &quot;11&quot;: &quot;snapdragon&quot;, &quot;96&quot;: &quot;camellia&quot;, &quot;23&quot;: &quot;fritillary&quot;, &quot;50&quot;: &quot;common dandelion&quot;, &quot;44&quot;: &quot;poinsettia&quot;, &quot;53&quot;: &quot;primula&quot;, &quot;72&quot;: &quot;azalea&quot;, &quot;65&quot;: &quot;californian poppy&quot;, &quot;80&quot;: &quot;anthurium&quot;, &quot;76&quot;: &quot;morning glory&quot;, &quot;37&quot;: &quot;cape flower&quot;, &quot;56&quot;: &quot;bishop of llandaff&quot;, &quot;60&quot;: &quot;pink-yellow dahlia&quot;, &quot;82&quot;: &quot;clematis&quot;, &quot;58&quot;: &quot;geranium&quot;, &quot;75&quot;: &quot;thorn apple&quot;, &quot;41&quot;: &quot;barbeton daisy&quot;, &quot;95&quot;: &quot;bougainvillea&quot;, &quot;43&quot;: &quot;sword lily&quot;, &quot;83&quot;: &quot;hibiscus&quot;, &quot;78&quot;: &quot;lotus lotus&quot;, &quot;88&quot;: &quot;cyclamen&quot;, &quot;94&quot;: &quot;foxglove&quot;, &quot;81&quot;: &quot;frangipani&quot;, &quot;74&quot;: &quot;rose&quot;, &quot;89&quot;: &quot;watercress&quot;, &quot;73&quot;: &quot;water lily&quot;, &quot;46&quot;: &quot;wallflower&quot;, &quot;77&quot;: &quot;passion flower&quot;, &quot;51&quot;: &quot;petunia&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment"># load data </span></span><br><span class="line">cat_to_name = json.loads(json_data)</span><br><span class="line"><span class="comment"># 把 key 轉成 int，因為 dataset 的 label 從 0 開始。但是這個 json 從 1 開始，所以我們要 -1</span></span><br><span class="line">cat_to_name = &#123;<span class="built_in">int</span>(k)-<span class="number">1</span>:v <span class="keyword">for</span> k,v <span class="keyword">in</span> cat_to_name.items()&#125;</span><br><span class="line"><span class="comment"># 排序，轉換成 dic 並印出來</span></span><br><span class="line">class_names = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(cat_to_name.items()))</span><br><span class="line"><span class="built_in">print</span>(class_names)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;pink primrose&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;hard-leaved pocket orchid&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;canterbury bells&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;sweet pea&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;english marigold&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;tiger lily&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;moon orchid&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;bird of paradise&#x27;</span>, <span class="number">8</span>: <span class="string">&#x27;monkshood&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;globe thistle&#x27;</span>, <span class="number">10</span>: <span class="string">&#x27;snapdragon&#x27;</span>, <span class="number">11</span>: <span class="string">&quot;colt&#x27;s foot&quot;</span>, <span class="number">12</span>: <span class="string">&#x27;king protea&#x27;</span>, <span class="number">13</span>: <span class="string">&#x27;spear thistle&#x27;</span>, <span class="number">14</span>: <span class="string">&#x27;yellow iris&#x27;</span>, <span class="number">15</span>: <span class="string">&#x27;globe-flower&#x27;</span>, <span class="number">16</span>: <span class="string">&#x27;purple coneflower&#x27;</span>, <span class="number">17</span>: <span class="string">&#x27;peruvian lily&#x27;</span>, <span class="number">18</span>: <span class="string">&#x27;balloon flower&#x27;</span>, <span class="number">19</span>: <span class="string">&#x27;giant white arum lily&#x27;</span>, <span class="number">20</span>: <span class="string">&#x27;fire lily&#x27;</span>, <span class="number">21</span>: <span class="string">&#x27;pincushion flower&#x27;</span>, <span class="number">22</span>: <span class="string">&#x27;fritillary&#x27;</span>, <span class="number">23</span>: <span class="string">&#x27;red ginger&#x27;</span>, <span class="number">24</span>: <span class="string">&#x27;grape hyacinth&#x27;</span>, <span class="number">25</span>: <span class="string">&#x27;corn poppy&#x27;</span>, <span class="number">26</span>: <span class="string">&#x27;prince of wales feathers&#x27;</span>, <span class="number">27</span>: <span class="string">&#x27;stemless gentian&#x27;</span>, <span class="number">28</span>: <span class="string">&#x27;artichoke&#x27;</span>, <span class="number">29</span>: <span class="string">&#x27;sweet william&#x27;</span>, <span class="number">30</span>: <span class="string">&#x27;carnation&#x27;</span>, <span class="number">31</span>: <span class="string">&#x27;garden phlox&#x27;</span>, <span class="number">32</span>: <span class="string">&#x27;love in the mist&#x27;</span>, <span class="number">33</span>: <span class="string">&#x27;mexican aster&#x27;</span>, <span class="number">34</span>: <span class="string">&#x27;alpine sea holly&#x27;</span>, <span class="number">35</span>: <span class="string">&#x27;ruby-lipped cattleya&#x27;</span>, <span class="number">36</span>: <span class="string">&#x27;cape flower&#x27;</span>, <span class="number">37</span>: <span class="string">&#x27;great masterwort&#x27;</span>, <span class="number">38</span>: <span class="string">&#x27;siam tulip&#x27;</span>, <span class="number">39</span>: <span class="string">&#x27;lenten rose&#x27;</span>, <span class="number">40</span>: <span class="string">&#x27;barbeton daisy&#x27;</span>, <span class="number">41</span>: <span class="string">&#x27;daffodil&#x27;</span>, <span class="number">42</span>: <span class="string">&#x27;sword lily&#x27;</span>, <span class="number">43</span>: <span class="string">&#x27;poinsettia&#x27;</span>, <span class="number">44</span>: <span class="string">&#x27;bolero deep blue&#x27;</span>, <span class="number">45</span>: <span class="string">&#x27;wallflower&#x27;</span>, <span class="number">46</span>: <span class="string">&#x27;marigold&#x27;</span>, <span class="number">47</span>: <span class="string">&#x27;buttercup&#x27;</span>, <span class="number">48</span>: <span class="string">&#x27;oxeye daisy&#x27;</span>, <span class="number">49</span>: <span class="string">&#x27;common dandelion&#x27;</span>, <span class="number">50</span>: <span class="string">&#x27;petunia&#x27;</span>, <span class="number">51</span>: <span class="string">&#x27;wild pansy&#x27;</span>, <span class="number">52</span>: <span class="string">&#x27;primula&#x27;</span>, <span class="number">53</span>: <span class="string">&#x27;sunflower&#x27;</span>, <span class="number">54</span>: <span class="string">&#x27;pelargonium&#x27;</span>, <span class="number">55</span>: <span class="string">&#x27;bishop of llandaff&#x27;</span>, <span class="number">56</span>: <span class="string">&#x27;gaura&#x27;</span>, <span class="number">57</span>: <span class="string">&#x27;geranium&#x27;</span>, <span class="number">58</span>: <span class="string">&#x27;orange dahlia&#x27;</span>, <span class="number">59</span>: <span class="string">&#x27;pink-yellow dahlia&#x27;</span>, <span class="number">60</span>: <span class="string">&#x27;cautleya spicata&#x27;</span>, <span class="number">61</span>: <span class="string">&#x27;japanese anemone&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;black-eyed susan&#x27;</span>, <span class="number">63</span>: <span class="string">&#x27;silverbush&#x27;</span>, <span class="number">64</span>: <span class="string">&#x27;californian poppy&#x27;</span>, <span class="number">65</span>: <span class="string">&#x27;osteospermum&#x27;</span>, <span class="number">66</span>: <span class="string">&#x27;spring crocus&#x27;</span>, <span class="number">67</span>: <span class="string">&#x27;bearded iris&#x27;</span>, <span class="number">68</span>: <span class="string">&#x27;windflower&#x27;</span>, <span class="number">69</span>: <span class="string">&#x27;tree poppy&#x27;</span>, <span class="number">70</span>: <span class="string">&#x27;gazania&#x27;</span>, <span class="number">71</span>: <span class="string">&#x27;azalea&#x27;</span>, <span class="number">72</span>: <span class="string">&#x27;water lily&#x27;</span>, <span class="number">73</span>: <span class="string">&#x27;rose&#x27;</span>, <span class="number">74</span>: <span class="string">&#x27;thorn apple&#x27;</span>, <span class="number">75</span>: <span class="string">&#x27;morning glory&#x27;</span>, <span class="number">76</span>: <span class="string">&#x27;passion flower&#x27;</span>, <span class="number">77</span>: <span class="string">&#x27;lotus lotus&#x27;</span>, <span class="number">78</span>: <span class="string">&#x27;toad lily&#x27;</span>, <span class="number">79</span>: <span class="string">&#x27;anthurium&#x27;</span>, <span class="number">80</span>: <span class="string">&#x27;frangipani&#x27;</span>, <span class="number">81</span>: <span class="string">&#x27;clematis&#x27;</span>, <span class="number">82</span>: <span class="string">&#x27;hibiscus&#x27;</span>, <span class="number">83</span>: <span class="string">&#x27;columbine&#x27;</span>, <span class="number">84</span>: <span class="string">&#x27;desert-rose&#x27;</span>, <span class="number">85</span>: <span class="string">&#x27;tree mallow&#x27;</span>, <span class="number">86</span>: <span class="string">&#x27;magnolia&#x27;</span>, <span class="number">87</span>: <span class="string">&#x27;cyclamen&#x27;</span>, <span class="number">88</span>: <span class="string">&#x27;watercress&#x27;</span>, <span class="number">89</span>: <span class="string">&#x27;canna lily&#x27;</span>, <span class="number">90</span>: <span class="string">&#x27;hippeastrum&#x27;</span>, <span class="number">91</span>: <span class="string">&#x27;bee balm&#x27;</span>, <span class="number">92</span>: <span class="string">&#x27;ball moss&#x27;</span>, <span class="number">93</span>: <span class="string">&#x27;foxglove&#x27;</span>, <span class="number">94</span>: <span class="string">&#x27;bougainvillea&#x27;</span>, <span class="number">95</span>: <span class="string">&#x27;camellia&#x27;</span>, <span class="number">96</span>: <span class="string">&#x27;mallow&#x27;</span>, <span class="number">97</span>: <span class="string">&#x27;mexican petunia&#x27;</span>, <span class="number">98</span>: <span class="string">&#x27;bromelia&#x27;</span>, <span class="number">99</span>: <span class="string">&#x27;blanket flower&#x27;</span>, <span class="number">100</span>: <span class="string">&#x27;trumpet creeper&#x27;</span>, <span class="number">101</span>: <span class="string">&#x27;blackberry lily&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>這邊我主要是參考官方網站<a href="hhttps://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a>的寫法，改成自己想要的 dataSet，並開始下載檔案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Data augmentation and normalization for training</span></span><br><span class="line"><span class="comment"># Just normalization for validation</span></span><br><span class="line">data_transforms = &#123;</span><br><span class="line">    <span class="string">&#x27;train&#x27;</span>: transforms.Compose([</span><br><span class="line">        <span class="comment"># 首先對圖像進行裁剪，然後再調整大小。它隨機選擇一個矩形區域並裁剪圖像</span></span><br><span class="line">        <span class="comment"># 然後將裁剪的圖像調整為指定的大小為 224x224 像素。</span></span><br><span class="line">        transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">        <span class="comment"># 設定圖像的翻轉機率，通常是一個 0 到 1 的數字，例如 0.5，表示有 50% 的機率翻轉圖像。Default value is 0.5</span></span><br><span class="line">        transforms.RandomHorizontalFlip(),</span><br><span class="line">        <span class="comment"># 將圖像轉換成 Tensor</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        <span class="comment"># 用數值 normalize 的方式來正規化 image 的數值，第一參數是 mean，第二個參數是 std 標準差</span></span><br><span class="line">        <span class="comment"># 設定 [0.485, 0.456, 0.406] 的原因可參考：https://www.geeksforgeeks.org/how-to-normalize-images-in-pytorch/</span></span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ]),</span><br><span class="line">    <span class="string">&#x27;val&#x27;</span>: transforms.Compose([</span><br><span class="line">        <span class="comment"># 這個沒有隨機選擇區域，而是直接整圖像的尺寸，使其符合指定的大小</span></span><br><span class="line">        transforms.Resize(<span class="number">256</span>),</span><br><span class="line">        <span class="comment"># 將圖像的中心部分保留，然後調整尺寸以滿足指定的大小。</span></span><br><span class="line">        <span class="comment"># 用於驗證或測試數據，以確保測試圖像具有相似的特徵，並且不像 RandomResizedCrop 那樣具有隨機性</span></span><br><span class="line">        transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ]),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 我們把 trainning 用的資料下載到 data_dir/train 資料夾，並且使用 data_transforms[&quot;train&quot;] 這個函式來做資料的轉換</span></span><br><span class="line">train_datasets = Flowers102(root=data_dir+<span class="string">&quot;/train&quot;</span>, split=<span class="string">&quot;train&quot;</span>, download=<span class="literal">True</span>, transform=data_transforms[<span class="string">&quot;train&quot;</span>])</span><br><span class="line"><span class="comment"># 我們把 validation 用的資料下載到 data_dir/val 資料夾，並且使用 data_transforms[&quot;val&quot;] 這個函式來做資料的轉換</span></span><br><span class="line">val_datasets = Flowers102(root=data_dir+<span class="string">&quot;/val&quot;</span>, split=<span class="string">&quot;val&quot;</span>, download=<span class="literal">True</span>, transform=data_transforms[<span class="string">&quot;val&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定下載 flowers102 的資料集，下載 train 和 val 的資料集</span></span><br><span class="line">image_datasets = &#123;x: Flowers102(root=data_dir, split=x, download=<span class="literal">True</span>, transform=data_transforms[x])</span><br><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 轉換成 DataLoader 的形式，並且指定 batch_size</span></span><br><span class="line">dataloaders = &#123;x: torch.utils.data.DataLoader(image_datasets[x], batch_size=batch_size,</span><br><span class="line">                                             shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line">              <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;device: &quot;</span>,device)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;image_datasets function call: &quot;</span>, <span class="built_in">dir</span>(image_datasets[<span class="string">&quot;train&quot;</span>]))</span><br></pre></td></tr></table></figure><div class="note info flat"><p>這樣我們就完成了第一個Task，也就是下載好我們想要的 dataset。</p></div><h1 id="Task-2-印出圖片和資料大小">Task 2 - 印出圖片和資料大小</h1><div class="note info flat"><ol start="2"><li><strong>印出圖片和資料大小</strong>：Show some example images of the dataset in the notebook and print the dataset size.</li></ol></div><p>參考官方網站<a href="hhttps://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a>的寫法，我們先建立</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">imshow</span>(<span class="params">inp, title=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Display image for Tensor.&quot;&quot;&quot;</span></span><br><span class="line">    inp = inp.numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    mean = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">    std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    inp = std * inp + mean</span><br><span class="line">    inp = np.clip(inp, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    plt.imshow(inp)</span><br><span class="line">    <span class="keyword">if</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        plt.title(title)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)  <span class="comment"># pause a bit so that plots are updated</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get a batch of training data</span></span><br><span class="line">inputs, classes = <span class="built_in">next</span>(<span class="built_in">iter</span>(dataloaders[<span class="string">&#x27;train&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a grid from batch</span></span><br><span class="line">out = torchvision.utils.make_grid(inputs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x.item() 取出 tensor 的值，通常是數字，然後在 class_names dic 找到該數字對應的英文名字</span></span><br><span class="line">imshow(out, title=[class_names[x.item()] <span class="keyword">for</span> x <span class="keyword">in</span> classes])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(inputs.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dataset_sizes: &quot;</span>,dataset_sizes)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下：</p></blockquote><p><img src="https://i.imgur.com/dPGyFvN.png" alt=""></p><h1 id="Task-3-4-CNN-Batch-Normalization">Task 3 &amp; 4 - CNN + Batch Normalization</h1><div class="note info flat"><ol start="3"><li><strong>建構使用Batch Normalization的CNN</strong>：Design a CNN to predict on the dataset. Use a similar architecture like last time, but this time also include batch normalization layers.</li><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li></ol></div><p><strong>根據李鴻毅教授在 Transfer Learning 提到…</strong><br>通常會在 <code>Activation Function</code> 之前執行 <code>Batch Normalization</code>，有興趣可以參考這個<a href="/posts/ML.html#Feature-Normalization">章節</a>。<code>Batch Normalization</code> 簡單來說就是以 <code>Batch</code> 的方式，執行 <code>feature normalization</code>。</p><p><strong>為什麼要做 feature normalization ?</strong><br>他就是為了讓不同的 feature 有類似接近的數值範圍，這樣模型在執行Gradient Descent的時候，w1, w2 對 loss 的影響才不會太大，他們擁有相似的數值範圍，才能夠平均的影響 loss，而不是某個 w1 對 loss 的影響遠大於 w2。</p><blockquote><p>大概是下圖這種效果。</p></blockquote><p><img src="https://i.imgur.com/RB51XXy.png" alt=""></p><h2 id="建立-Network">建立 Network</h2><div class="note warning flat"><p>請注意，根據不同的 dataset 其尺寸大小還有 hidden layer的數量，你要做兩個調整！！</p><ol><li>在 fully connection layer 中，input 要根據你的 hidden layer 執行 <code>max-pooling</code> 跟 <code>convolution</code> 的次數來決定。</li><li>然後你要根據你 dataset 的 categories 數量，調整最後一層 output layer 的output數量。</li></ol><p>請注意程式碼中標示註解箭頭<code>&lt;====</code> 的部分</p></div><p>所以我們這邊的 CNN 架構如下，<code>你可以根據需求決定是否要執行 dropout，來解開註解</code>。<br>但是在我的情境中，我測試 dropout 並沒有帶來比較高的準確率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NewNet, self).__init__()</span><br><span class="line">        <span class="comment"># Layer 1: 3x3 kernel，depth = 32，224-3+1=222 =&gt; 222x222 pixel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        <span class="comment"># self.dropout1 = nn.Dropout(0.5) # 可根據需求套用 dropout</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 2: Max pooling with 2x2 kernel，222/2=111 =&gt; 111x111 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 3: 3x3 kernel，depth = 64，111-3+1=109 =&gt; 109x109 pixel</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        <span class="comment"># self.dropout2 = nn.Dropout(0.5) # 可根據需求套用 dropout</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 4: Max pooling with 2x2 kernel，109/2=54 =&gt; 54x54 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 5: 3x3 kernel，depth = 128，54-3+1=52 =&gt; 52x52 pixel</span></span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(<span class="number">128</span>)</span><br><span class="line">        <span class="comment"># self.dropout3 = nn.Dropout(0.5) # 可根據需求套用 dropout  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 6: Max pooling with 2x2 kernel，52/2=26 =&gt; 26x26 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Final input is 512，pixel is 26*26 =&gt; 128*26*26</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span> * <span class="number">26</span> * <span class="number">26</span>, <span class="number">2048</span>) <span class="comment"># &lt;==== 128 * 26 * 26 根據 hidden layer 來調整</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">2048</span>, <span class="number">1024</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">512</span>, <span class="number">102</span>)<span class="comment"># &lt;==== 102 根據 dataset 的種類數量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># We put the batch normalization before the activation function. </span></span><br><span class="line">        x = F.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        <span class="comment"># x = self.dropout1(x) # 可根據需求套用 dropout </span></span><br><span class="line">        x = F.relu(self.bn2(self.conv2(x)))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        <span class="comment"># x = self.dropout2(x) # 可根據需求套用 dropout  </span></span><br><span class="line">        x = F.relu(self.bn3(self.conv3(x)))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        <span class="comment"># x = self.dropout3(x) # 可根據需求套用 dropout  </span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">128</span> * <span class="number">26</span> * <span class="number">26</span>) <span class="comment"># &lt;==== 128 * 26 * 26 根據 hidden layer 來調整</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = F.relu(self.fc3(x))</span><br><span class="line">        x = self.fc4(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = NewNet()</span><br><span class="line">net.to(device)</span><br></pre></td></tr></table></figure><p>並且指定 optimizer 和 loss function：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><h2 id="建立-Training-Func">建立 Training Func</h2><p>我們需要建立一個fucntion來執行訓練模型的動作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch, start_time</span>):</span><br><span class="line">    net.train()</span><br><span class="line">    cur_count = <span class="number">0</span> </span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloaders[<span class="string">&quot;train&quot;</span>], <span class="number">0</span>):</span><br><span class="line">        cur_count += <span class="built_in">len</span>(data)</span><br><span class="line">        inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        outputs.to(device)</span><br><span class="line">        </span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.to(device)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">99</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch&#125;</span>, <span class="subst">&#123;batch_idx + <span class="number">1</span>:5d&#125;</span>] loss: <span class="subst">&#123;running_loss / <span class="number">100</span>:<span class="number">.3</span>f&#125;</span> time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time))&#125;</span> sec.&#x27;</span>)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br></pre></td></tr></table></figure><h2 id="建立-Testing-Func">建立 Testing Func</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(): </span><br><span class="line">    net.<span class="built_in">eval</span>()  <span class="comment"># set model to evaluation mode</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    class_correct = [<span class="number">0</span>] * <span class="built_in">len</span>(class_names)  </span><br><span class="line">    class_total = [<span class="number">0</span>] * <span class="built_in">len</span>(class_names)  </span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> dataloaders[<span class="string">&quot;val&quot;</span>]:</span><br><span class="line">            images, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            outputs = net(images) </span><br><span class="line"></span><br><span class="line">            <span class="comment"># select top 3 predictions</span></span><br><span class="line">            _, predicted = torch.topk(outputs, <span class="number">1</span>, dim=<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># check if predicted labels are in true labels</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">                total += <span class="number">1</span></span><br><span class="line">                class_total[labels[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> labels[i] <span class="keyword">in</span> predicted[i]:</span><br><span class="line">                    correct += <span class="number">1</span></span><br><span class="line">                    class_correct[labels[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    class_accuracies = [class_correct[i] / class_total[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(class_names))]</span><br><span class="line">    accuracy = correct / total</span><br><span class="line">    <span class="keyword">return</span> accuracy, class_accuracies</span><br></pre></td></tr></table></figure><h2 id="執行-Training">執行 Training</h2><p>為了讓訓練過程中，我們可以看到訓練的狀況，所以我們每 100 個 batch 就印出一次訓練的狀況，並且每 5 個 epoch 就印出一次 test 的狀況。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">100</span> </span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line">accuracy, class_accuracies = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test data (top-1): <span class="subst">&#123;<span class="number">100</span> * accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_epochs - <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;============ Epoch: <span class="subst">&#123;epoch&#125;</span> ==========&quot;</span>)</span><br><span class="line">    train(epoch, start_time)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每 5 個 epoch 執行一次 test，看一下訓練狀況</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        accuracy, class_accuracies = test()</span><br><span class="line">        <span class="comment"># print accuracies</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test data (top-1): <span class="subst">&#123;<span class="number">100</span> * accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Finished Training. Total elapsed time: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>, <span class="number">1</span>)&#125;</span> min&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accuracy on test data (top<span class="number">-1</span>): <span class="number">0.0019</span>%</span><br><span class="line">============ Epoch: <span class="number">0</span> ==========</span><br><span class="line">[<span class="number">0</span>,   <span class="number">100</span>] loss: <span class="number">4.984</span> <span class="built_in">time</span> elapsed: <span class="number">40</span> sec.</span><br><span class="line">[<span class="number">0</span>,   <span class="number">200</span>] loss: <span class="number">4.876</span> <span class="built_in">time</span> elapsed: <span class="number">47</span> sec.</span><br><span class="line">...</span><br><span class="line">Accuracy on test data (top<span class="number">-1</span>): <span class="number">35.59</span>%</span><br><span class="line">Finished Training. Total elapsed <span class="built_in">time</span>: <span class="number">67</span> <span class="built_in">min</span></span><br></pre></td></tr></table></figure><h1 id="Task-5-4-Transfer-Learning：Resnet18">Task 5 &amp; 4 - Transfer Learning：Resnet18</h1><div class="note info flat"><ol start="4"><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li><li><strong>使用ResNet18來進行Transfer-Learning</strong>：Now use transfer learning to use a pre-trained ResNet18 on the dataset as follows:<ol><li><strong>把參數fixed</strong>：ResNet18 as fixed feature extractor.</li><li><strong>使用RestNet進行Fineturned</strong>：ResNet18 finetuned on the training data.</li></ol></li></ol></div><h2 id="建立-Trainning-Testing-Func">建立 Trainning &amp; Testing Func</h2><p>根據官方的範例<a href="https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a>，我是直接複製過來的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, criterion, optimizer, scheduler, num_epochs=<span class="number">25</span></span>):</span><br><span class="line">    <span class="comment"># 設定開始時間，用於log印出以看每個Epoch的訓練時間</span></span><br><span class="line">    since = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立一個暫存的資料夾，用於存放最好的模型參數</span></span><br><span class="line">    <span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> tempdir:</span><br><span class="line">        best_model_params_path = os.path.join(tempdir, <span class="string">&#x27;best_model_params.pt&#x27;</span>)</span><br><span class="line">        <span class="comment"># 還沒訓練，但是我們先存當前的模型</span></span><br><span class="line">        torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line">        best_acc = <span class="number">0.0</span> <span class="comment"># 設定目前最佳的 accuracy 是 0，一但比這個數字大，就會更新該數值以判斷目前最好的模型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;num_epochs - <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每一個 epoch 一但 train 完，就會進行 validation</span></span><br><span class="line">            <span class="keyword">for</span> phase <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 判斷目前應該是 training 還是 validation </span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    model.train()  <span class="comment"># Set model to training mode</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    model.<span class="built_in">eval</span>()   <span class="comment"># Set model to evaluate mode</span></span><br><span class="line"></span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line">                running_corrects = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Iterate over data.</span></span><br><span class="line">                <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> dataloaders[phase]:</span><br><span class="line">                    <span class="comment"># 放到 gpu 中</span></span><br><span class="line">                    inputs = inputs.to(device)</span><br><span class="line">                    labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 歸零梯度</span></span><br><span class="line">                    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 執行 forward propagation</span></span><br><span class="line">                    <span class="comment"># track history if only in train</span></span><br><span class="line">                    <span class="keyword">with</span> torch.set_grad_enabled(phase == <span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">                        outputs = model(inputs)</span><br><span class="line">                        _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>) <span class="comment"># 選最大的那個數字當作預測的 label </span></span><br><span class="line">                        loss = criterion(outputs, labels) <span class="comment"># 計算答案和預測的差距 </span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># backward + optimize only if in training phase</span></span><br><span class="line">                        <span class="comment"># 執行 backward propagation</span></span><br><span class="line">                        <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                            loss.backward()</span><br><span class="line">                            optimizer.step()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 因為 batch_size 是 4，所以 loss 乘上 4，才是一個 batch 的 loss</span></span><br><span class="line">                    running_loss += loss.item() * inputs.size(<span class="number">0</span>)</span><br><span class="line">                    <span class="comment"># 算出一個 batch 中，有多少答對的</span></span><br><span class="line">                    running_corrects += torch.<span class="built_in">sum</span>(preds == labels.data)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 只有在 training 的時候，才會調整 learning rate</span></span><br><span class="line">                <span class="comment"># scheduler 是學習率lr調整器 用於在模型訓練過程中調整學習率lr 的值</span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    scheduler.step()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 一整個 epoch 訓練完後，算出該 epoch 的 loss 和 accuracy</span></span><br><span class="line">                <span class="comment"># Avg. loss = 全部的 loss / 正個 dataset 的大小 </span></span><br><span class="line">                epoch_loss = running_loss / dataset_sizes[phase]</span><br><span class="line">                <span class="comment"># Avg. Acc = 全部的答對數 / 正個 dataset 的大小</span></span><br><span class="line">                epoch_acc = running_corrects.<span class="built_in">float</span>() / dataset_sizes[phase]</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;phase&#125;</span> Loss: <span class="subst">&#123;epoch_loss:<span class="number">.4</span>f&#125;</span> Acc: <span class="subst">&#123;epoch_acc:<span class="number">.4</span>f&#125;</span> Time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - since))&#125;</span> sec.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果在 validation 的時候，一但發現 accuracy 比目前最好的還要好，就把模型參數存起來</span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;val&#x27;</span> <span class="keyword">and</span> epoch_acc &gt; best_acc:</span><br><span class="line">                    <span class="comment"># 更新目前最好的 accuracy</span></span><br><span class="line">                    best_acc = epoch_acc</span><br><span class="line">                    <span class="comment"># deep copy the model</span></span><br><span class="line">                    torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        time_elapsed = time.time() - since</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Training complete in <span class="subst">&#123;time_elapsed // <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>m <span class="subst">&#123;time_elapsed % <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>s&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Best val Acc: <span class="subst">&#123;best_acc:4f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load best model weights</span></span><br><span class="line">        <span class="comment"># 以目前最好的 model 取出來，繼續下一個 epoch 的訓練</span></span><br><span class="line">        model.load_state_dict(torch.load(best_model_params_path))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h2 id="使用-Transfer-Learning">使用 Transfer Learning</h2><p>根據老師的要求，要使用 resnet18 來進行 Transfer Learning，目前根據<a href="https://pytorch.org/vision/stable/models/generated/torchvision.models.resnet18.html#torchvision.models.ResNet18_Weights">官方說明</a>，<code>resent18</code> 如果不給予參數，則預設就是 <code>IMAGENET1K_V1</code>，為了清楚我們到底使用哪一個 model 的參數，我們還是給予參數。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">model_ft = models.resnet18(weights=<span class="string">&#x27;IMAGENET1K_V1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># num_ftrs is the number of input features for the last layer. </span></span><br><span class="line"><span class="comment"># 抓取最後一層的輸入數量</span></span><br><span class="line">num_ftrs = model_ft.fc.in_features</span><br><span class="line"></span><br><span class="line"><span class="comment"># Here the size of each output sample is set to 102.</span></span><br><span class="line"><span class="comment"># model_ft.fc is the final layer of the model, and used for classification.</span></span><br><span class="line"><span class="comment"># 自己建立最後一層 layer，並且把輸入數量設定為 num_ftrs，輸出數量設定為 102（因為這個case有102個）</span></span><br><span class="line">model_ft.fc = nn.Linear(num_ftrs, <span class="number">102</span>)</span><br><span class="line">model_ft = model_ft.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss function 使用 CrossEntropyLoss </span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Observe that all parameters are being optimized</span></span><br><span class="line"><span class="comment"># optimizer 使用 SGD，learning rate = 0.001，momentum = 0.9</span></span><br><span class="line">optimizer_ft = optim.SGD(model_ft.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decay LR by a factor of 0.1 every 7 epochs</span></span><br><span class="line"><span class="comment"># 每 7 個 epoch 就把 learning rate 乘上 0.1 來對 lr 進行 decay</span></span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>大概是這種感覺來進行Transfer Learning<br><img src="https://i.imgur.com/rygK4KS.png" alt=""></p><div class="note warning flat"><p><strong>為什麼要調整lr?</strong><br>將學習率每隔一定的 epoch 進行調整是一種常見的學習率調整策略，稱為學習率衰減（learning rate decay）或學習率調度（learning rate scheduling）。這樣的效果是：</p><ol><li><p>提高模型的穩定性：在訓練過程中，<code>一開始使用相對較大的學習率，有助於快速收斂</code>。但當訓練<code>靠近最佳解時，較大的學習率可能導致模型在最佳解附近震盪或過度調整</code>。透過週期性地降低學習率，模型在訓練的後期會更穩定，更接近最佳解。</p></li><li><p>防止過度擬合：<code>週期性地降低學習率有助於防止模型在訓練集上過度擬合</code>。當學習率降低時，模型更謹慎地調整參數，不太容易陷入訓練集中的噪聲。</p></li></ol><p>在實際應用中，學習率調整策略的具體設置（例如，<code>step_size</code> 和 <code>gamma</code> 的值）通常是根據試驗和經驗來調整的，以達到最佳性能。通常，這些參數的設置取決於你的數據集大小、模型架構、問題的難度和其他因素。</p></div><h2 id="開始訓練">開始訓練</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_ft = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,</span><br><span class="line">                       num_epochs=<span class="number">25</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下: 準確率 89.41% 挺好的</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.4280</span> Acc: <span class="number">0.0657</span> Time elapsed: <span class="number">33</span> sec.</span><br><span class="line">val Loss: <span class="number">2.9901</span> Acc: <span class="number">0.3118</span> Time elapsed: <span class="number">58</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.3046</span> Acc: <span class="number">0.2353</span> Time elapsed: <span class="number">87</span> sec.</span><br><span class="line">val Loss: <span class="number">1.6604</span> Acc: <span class="number">0.5941</span> Time elapsed: <span class="number">112</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">2.5080</span> Acc: <span class="number">0.4029</span> Time elapsed: <span class="number">141</span> sec.</span><br><span class="line">val Loss: <span class="number">1.2243</span> Acc: <span class="number">0.6951</span> Time elapsed: <span class="number">166</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.9871</span> Acc: <span class="number">0.5196</span> Time elapsed: <span class="number">195</span> sec.</span><br><span class="line">val Loss: <span class="number">0.9578</span> Acc: <span class="number">0.7216</span> Time elapsed: <span class="number">219</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.5865</span> Acc: <span class="number">0.6225</span> Time elapsed: <span class="number">249</span> sec.</span><br><span class="line">val Loss: <span class="number">0.6911</span> Acc: <span class="number">0.8108</span> Time elapsed: <span class="number">273</span> sec.</span><br><span class="line">...</span><br><span class="line">val Loss: <span class="number">0.3919</span> Acc: <span class="number">0.8912</span> Time elapsed: <span class="number">1313</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">21</span>m <span class="number">53</span>s</span><br><span class="line">Best val Acc: <span class="number">0.894118</span></span><br></pre></td></tr></table></figure><h2 id="使用-ResNet18-作為-fixed-feature-extractor">使用 ResNet18 作為 fixed feature extractor</h2><p>因為作業有要求，要使用 ResNet18 作為 fixed feature extractor，所以我們要把所有的參數都設定為不可訓練，只有最後一層的參數是可以訓練的，<strong>簡單來說就是別人訓練好的 model 你就不要改人家的 weight 了拉</strong>。要改的地方就是，把 model 的每個 parameters 的 <code>requires_grad</code> 都設定為 False。這樣，我們就可以把 ResNet18 當作 fixed feature extractor 來使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他都老樣子</span></span><br><span class="line">model_conv = torchvision.models.resnet18(weights=<span class="string">&#x27;IMAGENET1K_V1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># !!! 添加這兩行，把 requires_grad 設定為 False，這樣就不會更新該參數了</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model_conv.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他都老樣子</span></span><br><span class="line">num_ftrs = model_conv.fc.in_features</span><br><span class="line">model_conv.fc = nn.Linear(num_ftrs, <span class="number">102</span>)</span><br><span class="line">model_conv = model_conv.to(device)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer_conv = optim.SGD(model_conv.fc.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_conv, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然後我們開始訓練 </span></span><br><span class="line">model_conv_SGD = train_model(model_conv, criterion, optimizer_conv,</span><br><span class="line">                         exp_lr_scheduler, num_epochs=<span class="number">25</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下：準確率 79.11% 比較差一點，但是這樣的訓練速度會比較快</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.6979</span> Acc: <span class="number">0.0176</span> Time elapsed: <span class="number">24</span> sec.</span><br><span class="line">val Loss: <span class="number">3.9863</span> Acc: <span class="number">0.1235</span> Time elapsed: <span class="number">48</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.0589</span> Acc: <span class="number">0.1137</span> Time elapsed: <span class="number">72</span> sec.</span><br><span class="line">val Loss: <span class="number">3.1125</span> Acc: <span class="number">0.3608</span> Time elapsed: <span class="number">95</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.4935</span> Acc: <span class="number">0.2304</span> Time elapsed: <span class="number">119</span> sec.</span><br><span class="line">val Loss: <span class="number">2.5003</span> Acc: <span class="number">0.4912</span> Time elapsed: <span class="number">142</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.1030</span> Acc: <span class="number">0.3422</span> Time elapsed: <span class="number">165</span> sec.</span><br><span class="line">val Loss: <span class="number">2.1583</span> Acc: <span class="number">0.5510</span> Time elapsed: <span class="number">189</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">2.7367</span> Acc: <span class="number">0.4402</span> Time elapsed: <span class="number">212</span> sec.</span><br><span class="line">val Loss: <span class="number">1.7064</span> Acc: <span class="number">0.6304</span> Time elapsed: <span class="number">236</span> sec.</span><br><span class="line">...</span><br><span class="line">val Loss: <span class="number">1.0910</span> Acc: <span class="number">0.7824</span> Time elapsed: <span class="number">1179</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">19</span>m <span class="number">39</span>s</span><br><span class="line">Best val Acc: <span class="number">0.791176</span></span><br></pre></td></tr></table></figure><h1 id="Task-6-4-Transfer-Learning：EfficientNet-B5">Task 6 &amp; 4 - Transfer Learning：EfficientNet_B5</h1><div class="note info flat"><ol start="4"><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li><li><strong>使用EfficientNet_B5進行Fineturned</strong>：Repeat step 4 but now use EfficientNet_B5 instead of RestNet18.</li></ol></div><p>接下來，我們需要把 RestNet18 根據題目要求換成別的訓練好的模型，你可能會需要先透過 pip 安裝 <code>efficientnet_pytorch</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install efficientnet_pytorch</span><br></pre></td></tr></table></figure><p>然後再執行下面的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> efficientnet_pytorch <span class="keyword">import</span> EfficientNet</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the pre-trained EfficientNet-B5 model</span></span><br><span class="line">model_ft = EfficientNet.from_pretrained(<span class="string">&#x27;efficientnet-b5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一樣，我們先取得該 model 最後一層 layer 的輸入數量</span></span><br><span class="line">num_ftrs = model_ft._fc.in_features</span><br><span class="line"><span class="comment"># 建立一個新的 layer，輸入數量是 num_ftrs，輸出數量是 102（因為這個case有102個）</span></span><br><span class="line">model_ft.fc = nn.Linear(num_ftrs, <span class="number">102</span>)</span><br><span class="line"><span class="comment"># 把 model 放到 GPU 中</span></span><br><span class="line">model_ft = model_ft.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loss function</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Observe that all parameters are being optimized</span></span><br><span class="line">optimizer_ft = optim.SGD(model_ft.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decay LR by a factor of 0.1 every 7 epochs</span></span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始訓練</span></span><br><span class="line">model_ft_effb5 = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,</span><br><span class="line">                       num_epochs=<span class="number">25</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下：準確率 73.33% 好像沒有比較好。</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">6.2860</span> Acc: <span class="number">0.0157</span> Time elapsed: <span class="number">156</span> sec.</span><br><span class="line">val Loss: <span class="number">5.6637</span> Acc: <span class="number">0.0382</span> Time elapsed: <span class="number">200</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.8955</span> Acc: <span class="number">0.1039</span> Time elapsed: <span class="number">322</span> sec.</span><br><span class="line">val Loss: <span class="number">4.5101</span> Acc: <span class="number">0.2392</span> Time elapsed: <span class="number">365</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.8566</span> Acc: <span class="number">0.2422</span> Time elapsed: <span class="number">485</span> sec.</span><br><span class="line">val Loss: <span class="number">3.6194</span> Acc: <span class="number">0.4265</span> Time elapsed: <span class="number">529</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.0979</span> Acc: <span class="number">0.3637</span> Time elapsed: <span class="number">653</span> sec.</span><br><span class="line">val Loss: <span class="number">2.8613</span> Acc: <span class="number">0.5539</span> Time elapsed: <span class="number">696</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">2.4323</span> Acc: <span class="number">0.4725</span> Time elapsed: <span class="number">818</span> sec.</span><br><span class="line">val Loss: <span class="number">2.2894</span> Acc: <span class="number">0.6725</span> Time elapsed: <span class="number">863</span> sec.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Epoch <span class="number">24</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.3168</span> Acc: <span class="number">0.7343</span> Time elapsed: <span class="number">4769</span> sec.</span><br><span class="line">val Loss: <span class="number">1.3167</span> Acc: <span class="number">0.8167</span> Time elapsed: <span class="number">4812</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">80</span>m <span class="number">12</span>s</span><br><span class="line">Best val Acc: <span class="number">0.821569</span></span><br></pre></td></tr></table></figure><h1 id="Task-7-討論">Task 7 - 討論</h1><div class="note info flat"><ol start="7"><li><strong>比較這些不同的方法，並列印出準確度</strong>：Compare the accuracy of the different approaches on the test data and print out the training</li></ol></div><p>從前面開始，我們測試了幾個方法：</p><ul><li><a href="#Task-3-4-CNN-Batch-Normalization">使用自己建立的 CNN</a></li><li><a href="#Task-5-4-Transfer-Learning%EF%BC%9AResnet18">使用Transfer Learning Resnet18</a></li><li><a href="#Task-6-4-Transfer-Learning%EF%BC%9AEfficientNet-B5">使用Transfer Learning EfficientNet-B5</a></li></ul><p>他們的數據大概如下：</p><table><thead><tr><th>Model</th><th>Accuracy</th><th>Training Time</th><th>Result</th></tr></thead><tbody><tr><td>自建 CNN</td><td><code>35%</code></td><td><code>超過1小時</code></td><td>最差</td></tr><tr><td>Resnet18</td><td><strong>89.41%</strong></td><td>21分鐘</td><td>準確率最高</td></tr><tr><td>Resnet18 (fixed feature extractor)</td><td>79.11%</td><td><strong>19分鐘</strong></td><td>時間最短</td></tr><tr><td>EfficientNet-B5</td><td>82.15%</td><td>80分鐘</td><td>普普</td></tr></tbody></table><div class="note warning flat"><p><strong>結論</strong></p><ul><li>如果使用 Transfer Learning 可明顯感受到，準確率明顯提高，並且訓練時間大幅縮短。</li><li>再者，以目前的案例來說，不要fixed model 的參數，準確率比較好，雖然相對的時間也會比較長，因為要做gradient descent。</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CIFAR10 Dataset - 使用 Pytorch 搭建 CNN + 啟用 GPU + 結果展示至 TensorBoard</title>
      <link href="/posts/pytorch-CNN-TensorBoard/"/>
      <url>/posts/pytorch-CNN-TensorBoard/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第三個作業，主要參考以下網站：</p><ul><li>教授如何使用 Pytorch 搭建 CNN：<a href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html">Pytorch Tutorial</a></li><li>教授如何使用 TensorBoard：<a href="https://pytorch.org/tutorials/intermediate/tensorboard_tutorial.html">Pytorch TensorBoard Tutorial</a></li><li>在 CoLabe 使用 TensorBoard 教學：<a href="https://www.tensorflow.org/tensorboard/tensorboard_in_notebooks">TensorBoard in CoLabe Tutorial</a></li></ul><p>本篇的主要目的是理解 CNN，並試圖搭建更深層的 Network，並使用GPU加快效率，最後將結果 Loss 與 猜錯的結果 顯示在 TensorBoard 上。</p><h1 id="環境設置與作業要求">環境設置與作業要求</h1><blockquote><p>環境設置：</p><ul><li>Python 3.10.9</li><li>Pytorch 2.0.1</li></ul></blockquote><h1 id="作業要求">作業要求</h1><p>Task:</p><ol><li><strong>先建立一個CNN</strong>：Train the same network as in the PyTorch CNN tutorial.</li><li><strong>建立出CNN滿足以下要求</strong>：Change now the network architecture as follows and train the network:<ol><li>Conv layer with 3x3 kernel and depth = 8, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 16, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Conv layer with 3x3 kernel and depth = 32, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 64, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Fully connected with 4096 nodes, ReLu activation</li><li>Fully connected with 1000 nodes, ReLu activation</li><li>Fully connected with 10 nodes, no activation</li></ol></li><li><strong>使用GPU並比較CPU結果</strong>：Run the training on the GPU and compare the training time to CPU.</li><li><strong>把 Trainning Loss 放到 Tensorboard</strong>: Log the training loss in tensorboard.</li><li><strong>修改表示正確的標準為只要答案在前三者output 的prediction中，就視為正確</strong>：Change the test metric as follows: A prediction is considered „correct“ if the true label is within the top three outputs of the network. Print the accuracy on the test data (with respect to this new definition).</li><li><strong>雖機抽取五個例子是猜錯的，並放到tensorboard中</strong>：Randomly take 5 examples on which the network was wrong on the test data (according to the new definition of correct) and plot them to tensorboard together<br>with the true label.</li><li><strong>在 notebook 上顯示 tensorBoard</strong>：Show the tensor board widget at the end of your notebook.</li></ol><ul><li><strong>Bonus</strong>: See if you can get better by using a deeper network (or another architecture).</li></ul><h1 id="前置準備">前置準備</h1><ol><li>先載入必要的套件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把tesorBaord的結果存到 ./board/assignment_3</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;./board/resule&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>下載訓練和測試用的 Dataset 到當前文件中所在的資料夾中建立<code>/data</code>資料夾。為了做歸一化，把均值設定為 0.5 標準差設定為 0.5，表示圖像的範圍在 [0, 1] 之間，變成 [-1, 1] 之間。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義圖像轉換，將圖像轉換成張量並進行歸一化</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 將圖像轉換為 PyTorch 张量</span></span><br><span class="line">    <span class="comment"># 因為每個像素有三個通道（紅、綠、藍），且通道值通常在 [0, 1] 範圍內。</span></span><br><span class="line">    <span class="comment"># 所以我們要把這三個通道，進行歸一化，讓它們的範圍變成 [-1, 1]。</span></span><br><span class="line">    <span class="comment"># 因 [0,1] 的均值是 0.5，mean 設定 0.5 表示減去均值 0.5 使得原本的均值由 0.5 變成 0 </span></span><br><span class="line">    <span class="comment"># 因 [0,1] 的標準差是 0.5，std 設定 0.5 表示除以標準差 0.5 使得原本的標準差由 0.5 變成 1</span></span><br><span class="line">    <span class="comment"># 最後因為 mean 變成 0 標準差是 1 所以就獲得 [-1,1]</span></span><br><span class="line">    transforms.Normalize(mean=(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), std=(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))  <span class="comment"># 歸一化圖像數據</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義訓練批次大小</span></span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載和加載 CIFAR-10 訓練數據集</span></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,  <span class="comment"># 存儲數據的根目錄</span></span><br><span class="line">    train=<span class="literal">True</span>,  <span class="comment"># 載入訓練數據</span></span><br><span class="line">    download=<span class="literal">True</span>,  <span class="comment"># 下載數據（如果還未下載）</span></span><br><span class="line">    transform=transform  <span class="comment"># 應用先前定義的圖像轉換</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 創建一個用於訓練數據的 DataLoader，用於批次處理和數據加載</span></span><br><span class="line">trainloader = torch.utils.data.DataLoader(</span><br><span class="line">    trainset,</span><br><span class="line">    batch_size=batch_size,  <span class="comment"># 設置每個批次的大小</span></span><br><span class="line">    shuffle=<span class="literal">True</span>,  <span class="comment"># 隨機打亂數據，增加訓練的隨機性</span></span><br><span class="line">    num_workers=<span class="number">2</span>  <span class="comment"># 使用多個工作進程來加快數據讀取速度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載和加載 CIFAR-10 測試數據集，同樣的數據轉換和數據加載設置</span></span><br><span class="line">testset = torchvision.datasets.CIFAR10(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,  <span class="comment"># 載入測試數據</span></span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=transform</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 創建一個用於測試數據的 DataLoader</span></span><br><span class="line">testloader = torch.utils.data.DataLoader(</span><br><span class="line">    testset,</span><br><span class="line">    batch_size=batch_size,</span><br><span class="line">    shuffle=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有的類別名稱放到一個 tuple 中</span></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Task-1-2-建立出-CNN">Task 1+2 建立出 CNN</h1><div class="note info flat"><ol><li><strong>先建立一個CNN</strong>：Train the same network as in the PyTorch CNN tutorial.</li><li><strong>建立出CNN滿足以下要求</strong>：Change now the network architecture as follows and train the network.</li></ol></div><h2 id="建立-CNN">建立 CNN</h2><p><strong>Task 2. 建立出CNN滿足以下要求</strong>：Change now the network architecture as follows and train the network:</p><ol><li>Conv layer with 3x3 kernel and depth = 8, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 16, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Conv layer with 3x3 kernel and depth = 32, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 64, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Fully connected with 4096 nodes, ReLu activation</li><li>Fully connected with 1000 nodes, ReLu activation</li><li>Fully connected with 10 nodes, no activation</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NewNet, self).__init__()</span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 color 3 RGB，32*32 pixel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">8</span>, <span class="number">3</span>)  <span class="comment"># 第1層：3x3 kernel and depth = 8 </span></span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 題目要求的 8，32-3+1=30，因此是 30*30 pixel</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">8</span>, <span class="number">16</span>, <span class="number">3</span>)  <span class="comment"># 第2層：3x3 kernel and depth = 16</span></span><br><span class="line">        <span class="comment"># 30/2=15，因此是 15*15 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 第3層：Max pooling with 2x2 kernel</span></span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 題目要求的 16，15-3+1=13，因此是 13*13 pixel</span></span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">3</span>)  <span class="comment"># 第4層：3x3 kernel and depth = 32</span></span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 題目要求的 32，13-3+1=11，因此是 11*11 pixel</span></span><br><span class="line">        self.conv4 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>)  <span class="comment"># 第5層：3x3 kernel and depth = 64 </span></span><br><span class="line">        <span class="comment"># 還要再做一個 Max pooling，11/2=5，因此是 5*5 pixel</span></span><br><span class="line">        <span class="comment"># 因此最終 input 是 64，pixel 是 5*5 因此 64*5*5</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">64</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">4096</span>)  <span class="comment"># 第6層：Fully connected with 4096 nodes</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">4096</span>, <span class="number">1000</span>)  <span class="comment"># 第7層：Fully connected with 1000 nodes</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">1000</span>, <span class="number">10</span>)  <span class="comment"># 第8層：Fully connected with 10 nodes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(self.conv1(x))  <span class="comment"># ReLu activation</span></span><br><span class="line">        x = F.relu(self.conv2(x))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = F.relu(self.conv3(x))</span><br><span class="line">        x = F.relu(self.conv4(x))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">64</span> * <span class="number">5</span> * <span class="number">5</span>)  <span class="comment"># flatten</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="Task-3-4-GPU-and-loss-on-tensorBoard">Task 3 + 4 GPU and loss on tensorBoard</h1><div class="note info flat"><ol start="3"><li><strong>使用GPU並比較CPU結果</strong>：Run the training on the GPU and compare the training time to CPU.</li><li><strong>把 Trainning Loss 放到 Tensorboard</strong>: Log the training loss in tensorboard.</li></ol></div><h2 id="使用-GPU-加速-Network">使用 GPU 加速 Network</h2><p>因為我是使用mac，因此輸入<code>mps</code>，但如果你是 windows 系統，請輸入 <code>cuda</code>。<br>初始化function and optimizer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># device = torch.device(&quot;cuda&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)</span></span><br><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">net = NewNet()</span><br><span class="line">net.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s use a Classification Cross-Entropy loss and SGD with momentum.</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><h2 id="建立訓練模型">建立訓練模型</h2><p>開始撰寫訓練模型，並且把結果寫到 tensorBoard 上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        <span class="comment"># 把資料放到 gpu 或 cpu 上</span></span><br><span class="line">        inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        outputs.to(device)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.to(device)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">200</span> == <span class="number">199</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, <span class="subst">&#123;i + <span class="number">1</span>:5d&#125;</span>] loss: <span class="subst">&#123;running_loss / <span class="number">200</span>:<span class="number">.3</span>f&#125;</span> time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>)&#125;</span> min&#x27;</span>)</span><br><span class="line">            <span class="comment"># ...log the running loss</span></span><br><span class="line">            <span class="comment"># 把 loss 寫到 tensorBoard，因為每次 200 才寫進去，所以要 / 200 才是真正的 loss</span></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;training loss&#x27;</span>,</span><br><span class="line">                            running_loss / <span class="number">200</span>,</span><br><span class="line">                            epoch * <span class="built_in">len</span>(trainloader) + i)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算時間用來比較 cpu 跟 gpu 的差異</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Finished Training. Total elapsed time: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>, <span class="number">1</span>)&#125;</span> min&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下圖</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,  <span class="number">3600</span>] loss: <span class="number">1.977</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">3800</span>] loss: <span class="number">2.021</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4000</span>] loss: <span class="number">1.933</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4200</span>] loss: <span class="number">1.922</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4400</span>] loss: <span class="number">1.902</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4600</span>] loss: <span class="number">1.836</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4800</span>] loss: <span class="number">1.788</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">5000</span>] loss: <span class="number">1.818</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">...</span><br><span class="line">[<span class="number">1</span>, <span class="number">12000</span>] loss: <span class="number">1.479</span> <span class="built_in">time</span> elapsed: <span class="number">2</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12200</span>] loss: <span class="number">1.469</span> <span class="built_in">time</span> elapsed: <span class="number">2</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12400</span>] loss: <span class="number">1.485</span> <span class="built_in">time</span> elapsed: <span class="number">2</span> <span class="built_in">min</span></span><br><span class="line">Finished Training. Total elapsed <span class="built_in">time</span>: <span class="number">2.2</span> <span class="built_in">min</span></span><br></pre></td></tr></table></figure><p>然後可以再寫一個 cpu 比較一下時間</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use CPU </span></span><br><span class="line">device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">net.to(device)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        <span class="comment"># inputs, labels = data, put the inputs and labels on the device (cpu or gpu)</span></span><br><span class="line">        inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        outputs.to(device)</span><br><span class="line"></span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.to(device) </span><br><span class="line">        loss.backward() <span class="comment"># 計算梯度</span></span><br><span class="line"></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">200</span> == <span class="number">199</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, <span class="subst">&#123;i + <span class="number">1</span>:5d&#125;</span>] loss: <span class="subst">&#123;running_loss / <span class="number">2000</span>:<span class="number">.3</span>f&#125;</span> time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>)&#125;</span> min&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Finished Training. Total elapsed time: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>, <span class="number">1</span>)&#125;</span> min&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/GW04dzw.png" alt=""></p><h2 id="訓練結果儲存">訓練結果儲存</h2><p>我目前是先把模型儲存在 <code>./model/cifar_net.pth</code>，之後再把它讀出來，下次就不用重新訓練了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH = <span class="string">&#x27;./model/cifar_net.pth&#x27;</span></span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br><span class="line">net = NewNet()</span><br><span class="line">net.load_state_dict(torch.load(PATH)) <span class="comment"># load the weights from the saved file</span></span><br></pre></td></tr></table></figure><h2 id="使用-Test-Data-評估模型">使用 Test Data 評估模型</h2><div class="note info flat"><p><strong>Task 5. 修改表示正確的標準為只要答案在前三者output 的prediction中，就視為正確</strong>：Change the test metric as follows: A prediction is considered „correct“ if the true label is within the top three outputs of the network. Print the accuracy on the test data (with respect to this new definition).</p></div><p>根據作業要求，要做以下事情：</p><ul><li>TODO 1 調整對準確率的定義，只要答案在前三者output 的prediction中，就視為正確。</li><li>TODO 2 列印出準確率，這邊我列印出 “每個類別” 的準確率 和 &quot;整個準確率“。</li><li>TODO 3 因為他要把錯誤的圖片、輸出和標籤記錄下來，因此我們要先把它們記錄下來，之後隨機選五個錯誤的會使用到。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">class_correct = [<span class="number">0</span>] * <span class="built_in">len</span>(classes)  <span class="comment"># 用來記錄每個類別的正確預測數</span></span><br><span class="line">class_total = [<span class="number">0</span>] * <span class="built_in">len</span>(classes)    <span class="comment"># 用來記錄每個類別的總樣本數</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來儲存所有錯誤預測的圖片、輸出和標籤</span></span><br><span class="line">all_errors = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因為我們不訓練，所以不需要計算輸出的梯度</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data </span><br><span class="line">        outputs = net(images) </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在這裡我們不需要 values 所以放 _, 但是我們需要 結果的index 所以放 predicted</span></span><br><span class="line">        _, predicted = torch.topk(outputs, <span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 因為 testloader 是 batch，所以我們需要逐個樣本（在這種情況下為 4）進行循環</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">            <span class="comment"># Example Print out =&gt; Predicted: tensor([3, 5, 2]) Actual: 3 Correct: True</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Predicted: <span class="subst">&#123;predicted[i]&#125;</span> Actual: <span class="subst">&#123;labels[i]&#125;</span> \t Correct: <span class="subst">&#123;labels[i] <span class="keyword">in</span> predicted[i]&#125;</span>&#x27;</span>)</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 針對 key 是 labels[i] 的 class_total 加 1</span></span><br><span class="line">            class_total[labels[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 檢查 labels[i] 是否在 predicted[i] 中，因為labels有四個值，所以用 i 來取出</span></span><br><span class="line">            <span class="keyword">if</span> labels[i] <span class="keyword">in</span> predicted[i]:</span><br><span class="line">                correct += <span class="number">1</span></span><br><span class="line">                class_correct[labels[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 將錯誤的圖片、輸出和標籤記錄下來</span></span><br><span class="line">                all_errors.append((images[i], outputs[i], labels[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算每個類別的準確率</span></span><br><span class="line">class_accuracies = [class_correct[i] / class_total[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算並列印新的準確度</span></span><br><span class="line">accuracy = correct / total</span><br></pre></td></tr></table></figure><p>結果長這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Predicted: tensor([3, 5, 2]) Actual: 3  Correct: True</span><br><span class="line">Predicted: tensor([8, 0, 1]) Actual: 8  Correct: True</span><br><span class="line">Predicted: tensor([8, 1, 9]) Actual: 8  Correct: True</span><br><span class="line">Predicted: tensor([8, 0, 1]) Actual: 0  Correct: True</span><br><span class="line">Predicted: tensor([4, 2, 6]) Actual: 6  Correct: True</span><br><span class="line">Predicted: tensor([6, 3, 5]) Actual: 6  Correct: True</span><br><span class="line">Predicted: tensor([1, 9, 5]) Actual: 1  Correct: True</span><br><span class="line">Predicted: tensor([2, 6, 4]) Actual: 6  Correct: True</span><br><span class="line">Predicted: tensor([3, 5, 2]) Actual: 3  Correct: True</span><br><span class="line">Predicted: tensor([1, 8, 9]) Actual: 1  Correct: True</span><br><span class="line">...</span><br><span class="line">Predicted: tensor([5, 7, 2]) Actual: 5  Correct: True</span><br><span class="line">Predicted: tensor([4, 2, 3]) Actual: 1  Correct: False</span><br><span class="line">Predicted: tensor([7, 4, 2]) Actual: 7  Correct: True</span><br></pre></td></tr></table></figure><h2 id="列印出準確率">列印出準確率</h2><p>現在就可以列印出準確率了，我們可以看到準確率是 0.1，因為我們只有 10 個類別，所以隨機猜的準確率就是 0.1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test data (top-3): <span class="subst">&#123;<span class="number">100</span> * accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print each class accuracy</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy for class <span class="subst">&#123;classes[i]&#125;</span>: <span class="subst">&#123;<span class="number">100</span> * class_accuracies[i]:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the number of misclassified images</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Total misclassified images: <span class="subst">&#123;<span class="built_in">len</span>(all_errors)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>結果會如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Accuracy on test data (top-3): 91.60%</span><br><span class="line">Accuracy for class plane: 89.50%</span><br><span class="line">Accuracy for class car: 96.30%</span><br><span class="line">Accuracy for class bird: 85.20%</span><br><span class="line">Accuracy for class cat: 91.80%</span><br><span class="line">Accuracy for class deer: 92.40%</span><br><span class="line">Accuracy for class dog: 91.40%</span><br><span class="line">Accuracy for class frog: 88.30%</span><br><span class="line">Accuracy for class horse: 91.50%</span><br><span class="line">Accuracy for class ship: 96.20%</span><br><span class="line">Accuracy for class truck: 93.40%</span><br><span class="line"></span><br><span class="line">Total misclassified images: 840</span><br></pre></td></tr></table></figure><h1 id="Task-6-Random-5-errors-img">Task 6 Random 5 errors img</h1><div class="note info flat"><p><strong>Task 6. 雖機抽取五個例子是猜錯的，並放到tensorboard中</strong>：Randomly take 5 examples on which the network was wrong on the test data (according to the new definition of correct) and plot them to tensorboard together<br>with the true label.</p></div><h2 id="設定圖片轉換函式">設定圖片轉換函式</h2><p>為了後續可以把圖片印出來，我們需要製作一個顯示圖片用的function，而因為 torchvision 資料集的輸出是範圍 [0, 1] 的 PILImage 影像。我們將它們轉換為歸一化範圍 [-1, 1] 的張量。如果我們要把圖片轉換顯示出來，我們必須進行反歸一化，也就是把歸一化後的 [-1, 1] 變回去 [0, 1]，所以我們可以透過 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>x</mi><mn>2</mn></mfrac><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{x}{2} + 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span> 達成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># functions to show an image</span></span><br><span class="line"><span class="comment"># 如果 one_channel 為 True，則函數假定輸入的影像是單通道的（通常是灰階影像），並使用灰階色圖來顯示影像。</span></span><br><span class="line"><span class="comment"># 如果 one_channel 為 False，則函數假定輸入的影像是三通道的（通常是彩色影像），並使用彩色色圖來顯示影像。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matplotlib_imshow</span>(<span class="params">img, one_channel=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> one_channel:</span><br><span class="line">        img = img.mean(dim=<span class="number">0</span>)</span><br><span class="line">    img = img / <span class="number">2</span> + <span class="number">0.5</span>     <span class="comment"># unnormalize</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    <span class="keyword">if</span> one_channel: </span><br><span class="line">        plt.imshow(npimg, cmap=<span class="string">&quot;Greys&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 因為 matplotlib 所使用的函式輸入是 (高_1, 深度_2, 寬_0) </span></span><br><span class="line">        <span class="comment"># 但是 npimg 預設是 (寬_0, 高_1, 深度=顏色RGB_2) </span></span><br><span class="line">        <span class="comment"># 因此我們需要透過 np.transpose 操作來將通道的順序從(寬_0, 高_1, 深度=顏色RGB_2) 轉換為(高_1, 深度_2, 寬_0)，</span></span><br><span class="line">        plt.imshow(np.transpose(npimg, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><h2 id="隨機選擇-5-個錯誤">隨機選擇 5 個錯誤</h2><p>我們剛剛有收集好所有錯誤的 images 還有 predicts 跟 labels，依據題目要求我們需要從中選出 5 個錯誤的 images，並且把它們印出來。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_classes_preds</span>(<span class="params">all_errors</span>):</span><br><span class="line">    <span class="comment"># 隨機選五個猜錯的圖片</span></span><br><span class="line">    random_errors = random.sample(all_errors, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 創建一個大的 matplotlib 圖表，figsize 參數用於指定圖形物件（Figure）的寬度和高度，通常以英吋為單位</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, (image, output, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(random_errors):</span><br><span class="line">        <span class="comment"># 參數表示：行數，列數，子圖索引（從 1 開始，放五個圖片在 長度12英吋*18英吋的圖表）</span></span><br><span class="line">        <span class="comment"># xticks, yticks 用來設定座標的參數，如果不想顯示座標，可以設定為空串列</span></span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">5</span>, idx+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">        <span class="comment"># 列印出彩色的圖片</span></span><br><span class="line">        matplotlib_imshow(image, one_channel=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 因為 output 是一個 寬1長10 的張量，因此我們要用 dim=0 取出 column 的 top 3 </span></span><br><span class="line">        preds = torch.topk(output, <span class="number">3</span>, dim=<span class="number">0</span>).indices  <span class="comment"># 關於 dim 請看補充</span></span><br><span class="line">        pred_classes = [classes[p] <span class="keyword">for</span> p <span class="keyword">in</span> preds] <span class="comment"># 把 index 轉成 class name，並放入 list 中會有三個 string </span></span><br><span class="line">        <span class="comment"># 給當前這個圖片設定標題，顯示出預測的類別和實際的類別</span></span><br><span class="line">        ax.set_title(<span class="string">&quot;\n(label: &#123;0&#125;)\n(&#123;1&#125;)&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            classes[label],</span><br><span class="line">            <span class="string">&quot;, &quot;</span>.join(pred_classes)),</span><br><span class="line">            color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最後回傳全部畫好的圖表（總共會有5個圖片）</span></span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫函示</span></span><br><span class="line">plot_classes_preds(all_errors)</span><br></pre></td></tr></table></figure><blockquote><p>會如下圖<br><img src="https://i.imgur.com/OY6EvGW.png" alt=""></p></blockquote><h2 id="把圖片放到-tensorBoard">把圖片放到 tensorBoard</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放到 tensorBoard</span></span><br><span class="line">fig = plot_classes_preds(all_errors)</span><br><span class="line">writer.add_figure(<span class="string">&quot;predictions vs. actuals&quot;</span>, fig)</span><br></pre></td></tr></table></figure><h1 id="Task-7-在-notebook-上顯示-tensorBoard">Task 7 在 notebook 上顯示 tensorBoard</h1><div class="note info flat"><p><strong>Task 7. 在 notebook 上顯示 tensorBoard</strong>：Show the tensor board widget at the end of your notebook.</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 notebook 上顯示 tensorBoard</span></span><br><span class="line">%load_ext tensorboard <span class="comment"># 這行程式碼會載入TensorBoard的擴展，以便你可以在Notebook中執行TensorBoard。</span></span><br><span class="line">%tensorboard --logdir board <span class="comment"># 這行程式碼會啟動TensorBoard，並將其指向你的日誌文件夾。</span></span><br></pre></td></tr></table></figure><h1 id="補充">補充</h1><h2 id="歸一化-vs-標準化">歸一化 vs 標準化</h2><ul><li>Ref: <a href="https://medium.com/ai%E5%8F%8D%E6%96%97%E5%9F%8E/preprocessing-data-%E6%95%B8%E6%93%9A%E7%89%B9%E5%BE%B5%E6%A8%99%E6%BA%96%E5%8C%96%E5%92%8C%E6%AD%B8%E4%B8%80%E5%8C%96-9bd3e5a8f2fc">Preprocessing Data : 數據特徵標準化和歸一化</a></li></ul><blockquote><p><strong>歸一化 vs 標準化 差異？</strong></p></blockquote><ul><li><code>歸一化 (Normalization)</code>：將數據按比例縮放，使之落入一個小的特定區間，例如 [0, 1] 或 [-1, 1]。<ul><li>公式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x_i - min(x_i)}{max(x_i) - min(x_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">min</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">min</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li><code>標準化 (Standardization)</code>：將數據按比例縮放，使之落入平均值為 0，方差為 1 的分佈中，因此極端值是可以不在[0, 1]的區間。<ul><li>公式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi></mrow><mrow><mi>s</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x_i - \mu}{sd(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3744em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">d</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul><blockquote><p><strong>這兩者的共同標準？</strong></p></blockquote><ul><li>都是對某個特徵（column）進行縮放（scaling）而不是對某個樣本的特徵向量（row）進行縮放。</li></ul><blockquote><p><strong>為什麼要做歸一化？</strong></p></blockquote><ol><li><strong>提高精準度</strong>：在機器學習算法的目標函數，許多學習算法中目標函數的基礎都是假設所有的特徵都是零均值並且具有同一階數上的平方差。如果某個特徵的平方差比其他特徵大幾個數量級，那麼它就會在學習算法中佔據主導位置，導致學習器並不能像我們說期望的那樣，從其他特徵中學習。因此，歸一化是<strong>讓不同維度之間的特徵在數值上有一定比較性</strong>，可以大大提高分類器的準確性。</li><li><strong>提升收斂速度</strong>：經過歸一化後，<strong>最優解的尋優過程明顯會變得平緩</strong>，更容易正確的收斂到最優解。</li></ol><h2 id="dim">dim ?</h2><p>dim 參數的不同設置，它決定了在哪個維度上進行排名和獲取最大值。<br>讓我們透過一個範例來說明它們之間的差異：</p><ul><li>如果設定 dim=0 就會是看整個 column 的最大值</li><li>如果設定 dim=1 就會是看整個 row 的最大值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个示例张量</span></span><br><span class="line">output = torch.tensor([[<span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">0.9</span>, <span class="number">0.5</span>, <span class="number">0.3</span>],</span><br><span class="line">                       [<span class="number">0.4</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.7</span>, <span class="number">0.2</span>],</span><br><span class="line">                       [<span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.1</span>, <span class="number">0.2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每列中的前 3 个最大值及其索引</span></span><br><span class="line">top_values_col, top_indices_col = torch.topk(output, <span class="number">3</span>, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每行中的前 3 个最大值及其索引</span></span><br><span class="line">top_values_row, top_indices_row = torch.topk(output, <span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Output tensor:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top 3 values and indices per column:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(top_values_col)</span><br><span class="line"><span class="built_in">print</span>(top_indices_col)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top 3 values and indices per row:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(top_values_row)</span><br><span class="line"><span class="built_in">print</span>(top_indices_row)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Output tensor:</span><br><span class="line">tensor([[<span class="number">0.2000</span>, <span class="number">0.6000</span>, <span class="number">0.9000</span>, <span class="number">0.5000</span>, <span class="number">0.3000</span>],</span><br><span class="line">        [<span class="number">0.4000</span>, <span class="number">0.1000</span>, <span class="number">0.8000</span>, <span class="number">0.7000</span>, <span class="number">0.2000</span>],</span><br><span class="line">        [<span class="number">0.5000</span>, <span class="number">0.8000</span>, <span class="number">0.9000</span>, <span class="number">0.1000</span>, <span class="number">0.2000</span>]])</span><br><span class="line">Top <span class="number">3</span> values <span class="keyword">and</span> indices per column:</span><br><span class="line"><span class="comment"># 已經從大到小排好了</span></span><br><span class="line">tensor([[<span class="number">0.5000</span>, <span class="number">0.8000</span>, <span class="number">0.9000</span>, <span class="number">0.7000</span>, <span class="number">0.3000</span>],</span><br><span class="line">        [<span class="number">0.4000</span>, <span class="number">0.6000</span>, <span class="number">0.9000</span>, <span class="number">0.5000</span>, <span class="number">0.2000</span>],</span><br><span class="line">        [<span class="number">0.2000</span>, <span class="number">0.1000</span>, <span class="number">0.8000</span>, <span class="number">0.1000</span>, <span class="number">0.2000</span>]])</span><br><span class="line"><span class="comment"># 印出 column 中依序最大到最小的 index 舉例來說 第一列（0.2,0.4,0.5）的 0.5最大 因此 第一個 index 依序是 2, 1, 0 </span></span><br><span class="line"><span class="comment"># 這就是為什麼你看到第一列出現 [[2...], [1...], [0...]]</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">Top <span class="number">3</span> values <span class="keyword">and</span> indices per row:</span><br><span class="line"><span class="comment"># 已經從大到小排好了</span></span><br><span class="line">tensor([[<span class="number">0.9000</span>, <span class="number">0.6000</span>, <span class="number">0.5000</span>],</span><br><span class="line">        [<span class="number">0.8000</span>, <span class="number">0.7000</span>, <span class="number">0.4000</span>],</span><br><span class="line">        [<span class="number">0.9000</span>, <span class="number">0.8000</span>, <span class="number">0.5000</span>]])</span><br><span class="line"><span class="comment"># 印出 row 中一句最大到最小的 index 舉例來說 第一行 （0.2, 0.6, 0.9, 0.5, 0.3）的 0.9最大 因此 第一個 index 依序是 2, 1, 3</span></span><br><span class="line"><span class="comment"># 這就是為什麼妳看到第一行出現 [[2, 1, 3]</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLP - Data Leakage Protection 的論文 Survey</title>
      <link href="/posts/DLP-Survay-Paper/"/>
      <url>/posts/DLP-Survay-Paper/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因為在做資料庫的零信任相關研究，在這篇<a href="/posts/ZTA-survey-AP-DB-summary">適用於應用程式AP與資料庫DB之間的零信任架構(ZTA)原則 - 總整理篇</a>有提到幾點跟資料保護重要的技術，也就是DLP跟DRM。為此，本篇主要就是總結目前Survey與DLP相關的文獻。</p><p>主要目的是可以找出以下議題的相關論文，並擁有一定的了解：</p><ul><li>DLP 在做什麼？</li><li>DLP 的相關技術？</li><li>DLP 跟 Data Risk Labeling 的結合？</li><li>DLP 跟 Access Control 的結合？</li><li>DLP 關於 Machine Learning 的應用？</li></ul><h1 id="DLP-在做什麼？">DLP 在做什麼？</h1>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> DLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碩士論文 </tag>
            
            <tag> DLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Titanic Dataset - 使用 Pytorch 搭建神經網路 + 測試 overfitting</title>
      <link href="/posts/pytorch-titanic-nn/"/>
      <url>/posts/pytorch-titanic-nn/</url>
      
        <content type="html"><![CDATA[<h1 id="Reference">Reference</h1><ul><li>Ref:<a href="https://towardsdatascience.com/predicting-the-survival-of-titanic-passengers-30870ccc7e8">很詳細說明Titanic資料裡面的結構狀態</a></li></ul><h1 id="前言">前言</h1><p>最近選了一堂AI課程，有一個作業是我們寫出一個Nerual Network，並且使用Titanic Dataset來訓練，並且透過增加 hidden layer 跟 neurons 的方式實現overfitting，並透過 dropout 或其他方法來消除 overfitting 的影響。</p><p>在此紀錄ㄧ下作業撰寫的過程。</p><h1 id="環境設置與作業要求">環境設置與作業要求</h1><blockquote><p>環境設置：</p><ul><li>Python 3.10.9</li><li>Pytorch 2.0.1</li></ul></blockquote><h2 id="作業要求">作業要求</h2><ol><li>Write a custom <strong>dataset class for the titanic data</strong> (see the data folder on <a href="https://github.com/pabair/ki-lab-ss23">GitHub</a>). Use only the features: “Pclass”, “Age”, “SibSp”, “Parch”, „Fare“, „Sex“, „Embarked“. <strong>Preprocess the features</strong> accordingly in that class (scaling, one-hot-encoding, etc) and split the data into train and validation data (80% and 20%). The constructor of that class should look like this: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic_train = TitanicDataSet(<span class="string">&#x27;titanic.csv&#x27;</span>, train=<span class="literal">True</span>)</span><br><span class="line">titanic_val = TitanicDataSet(<span class="string">&#x27;titanic.csv&#x27;</span>, train=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li>Build a neural network with <strong>one hidden layer of size 3</strong> that predicts the survival of the passengers. Use a <strong>BCE loss</strong> (Hint: you need a <strong>sigmoid activation</strong> in the output layer). Use a data loader to train in batches of <strong>size 16</strong> and shuffle the data.</li><li><strong>Evaluate the performance</strong> of the model on the validation data using accuracy as metric.</li><li><strong>Create the following plot</strong> that was introduced in the lecture.<ul><li><img src="https://i.imgur.com/yPNS7vc.png?x300" alt=""></li></ul></li><li>Increase the complexity of the network by <strong>adding more layers and neurons</strong> and see if you can overfit on the training data.</li><li>Try to remove overfitting by introducing a <strong><a href="https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html">dropout</a> layer</strong>.</li></ol><h2 id="簡單來說">簡單來說</h2><p>簡單來說，我們會從以下四個步驟中滿足上述要求：</p><ol><li><p><strong>資料前處理</strong></p><ul><li><code>Task 1</code>: 建制 class 並且把 Titanic 的資料導入</li><li><code>Task 1</code>: 只選取特定欄位作為訓練特徵</li><li><code>Task 1</code>: 資料前處理 (scaling, one-hot-encoding, etc)，把性別或是Embaded的這種object型態，非數字的欄位轉換成數字</li><li><code>Task 1</code>: 資料切分成 train data 跟 validation data (80% and 20%)</li><li><code>Task 1</code>: 建立一個 class 並且把資料導入</li></ul></li><li><p><strong>建置 Neural Network</strong></p><ul><li><code>Task 2</code>: 建立一個 three layer 的 network (1 input layer + 1 hidden layer + 1 output layer)。</li><li><code>Task 2</code>: 第一層 hidden layer 的 neurons size 為 3</li><li><code>Task 2</code>: 使用 BCE loss 作為 loss Function</li><li><code>Task 2</code>: 使用 sigmoid activation 作為 output layer 的 activation function</li></ul></li><li><p><strong>模型訓練</strong></p><ul><li><code>Task 3</code>: 開始訓練模型，並且記錄每次的 accuracy</li></ul></li><li><p><strong>產出結果</strong></p><ul><li><code>Task 4</code>: 產出結果，並且畫出圖表</li></ul></li><li><p><strong>製造 Overfitting</strong></p><ul><li><code>Task 5</code>: 增加 hidden layer 跟 neurons 的方式實現overfitting</li></ul></li><li><p><strong>使用 Dropout</strong></p><ul><li><code>Task 6</code>: 透過 dropout 或其他方法來消除 overfitting 的影響</li></ul></li></ol><h1 id="Step1-資料前處理">Step1. 資料前處理</h1><div class="note info flat"><p>那我們就先來開始做<strong>資料前處理</strong>：</p><ul><li><code>Task 1</code>: 建制 class 並且把 Titanic 的資料導入</li><li><code>Task 1</code>: 只選取特定欄位作為訓練特徵</li><li><code>Task 1</code>: 資料前處理 (scaling, one-hot-encoding, etc)，把性別或是Embaded的這種object型態，非數字的欄位轉換成數字</li><li><code>Task 1</code>: 資料切分成 train data 跟 validation data (80% and 20%)</li><li><code>Task 1</code>: 建立一個 class 並且把資料導入</li></ul></div><h2 id="1-1-資料前處理">1.1 資料前處理</h2><ol><li><p>我們先匯入目前所需要的所有套件</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># data process </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, transform</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot </span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># neural network </span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler,OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure></li><li><p>在開始之前，我想要先把所有需要會使用的參數都放在最上面比較好更改：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># share variables</span></span><br><span class="line">D_in, D_out = <span class="number">10</span>, <span class="number">1</span> </span><br><span class="line">num_epochs = <span class="number">250</span> </span><br><span class="line">log_interval = <span class="number">100</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># batch_size：每次訓練的資料量</span></span><br><span class="line">batch_size = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># learning rate：因為我會建立兩種不同的 network，因此我們分別設定兩種不同的 learning rate</span></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line">multi_learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hidden layers </span></span><br><span class="line">multi_num_layers = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hidden neurons：因為我會建立兩種不同的 network，因此我們分別設定兩種不同的 hidden neurons</span></span><br><span class="line">neurons = <span class="number">3</span> </span><br><span class="line">multi_neurons = <span class="number">1024</span> </span><br></pre></td></tr></table></figure></li><li><p>接著，我們根據要求建制 class 並且把 Titanic 的資料導入，並回傳features</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TitanicDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化函數，用於載入和預處理數據</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, train=<span class="literal">True</span>, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># train 參數用於指示是訓練數據還是測試數據</span></span><br><span class="line">        self.train = train</span><br><span class="line">        <span class="comment"># transform 參數用於定義一個轉換函數，如果需要對數據進行轉換的話</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 創建 MinMaxScaler 和 OneHotEncoder 來進行數據預處理</span></span><br><span class="line">        minmax_scaler = MinMaxScaler()</span><br><span class="line">        onehot_enc = OneHotEncoder()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 讀取 CSV 文件中的鐵達尼號數據</span></span><br><span class="line">        titanic = pd.read_csv(root_dir)</span><br><span class="line">        <span class="comment"># 從數據中選取特定的列</span></span><br><span class="line">        titanic = titanic[[<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;Fare&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;Embarked&quot;</span>, <span class="string">&quot;Survived&quot;</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將 &quot;Age&quot; 列中的缺失值用平均值填充，並刪除包含缺失值的行</span></span><br><span class="line">        titanic[<span class="string">&quot;Age&quot;</span>] = titanic[<span class="string">&quot;Age&quot;</span>].fillna(titanic[<span class="string">&quot;Age&quot;</span>].mean())</span><br><span class="line">        titanic = titanic.dropna()</span><br><span class="line">        titanic = titanic.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將數據分為類別特徵、數值特徵和標籤</span></span><br><span class="line">        categorical_features = titanic[titanic.select_dtypes(include=[<span class="string">&#x27;object&#x27;</span>]).columns.tolist()]</span><br><span class="line">        numerical_features = titanic[titanic.select_dtypes(exclude=[<span class="string">&#x27;object&#x27;</span>]).columns].drop(<span class="string">&#x27;Survived&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">        label_features = titanic[<span class="string">&#x27;Survived&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 對數值特徵進行歸一化（MinMax 歸一化）</span></span><br><span class="line">        numerical_features_arr = minmax_scaler.fit_transform(numerical_features)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 對類別特徵進行獨熱編碼</span></span><br><span class="line">        categorical_features_arr = onehot_enc.fit_transform(categorical_features).toarray()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將歸一化的數值特徵和獨熱編碼後的類別特徵合併成一個數據集</span></span><br><span class="line">        combined_features = pd.DataFrame(data=numerical_features_arr, columns=numerical_features.columns)</span><br><span class="line">        combined_features = pd.concat([combined_features, pd.DataFrame(data=categorical_features_arr)], axis=<span class="number">1</span>)</span><br><span class="line">        combined_features = pd.concat([combined_features, label_features], axis=<span class="number">1</span>).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將數據集分為訓練集和測試集</span></span><br><span class="line">        train_data, test_data = train_test_split(combined_features, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根據訓練或測試模式選擇要使用的數據</span></span><br><span class="line">        <span class="keyword">if</span> train:</span><br><span class="line">            self.data = train_data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data = test_data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回數據集的長度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用於訓練神經網絡的函數，返回特徵和標籤</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="comment"># 獲取在 self.data DataFrame 中的第 idx 行的數據</span></span><br><span class="line">        sample = self.data.iloc[idx] </span><br><span class="line">        <span class="comment"># 將一個數據結構轉換為 PyTorch 張量 並指定這個张量的數據類型為浮點數（float）</span></span><br><span class="line">        features = torch.FloatTensor(sample[:-<span class="number">1</span>])</span><br><span class="line">        label = torch.FloatTensor([sample[<span class="string">&#x27;Survived&#x27;</span>]])</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            features = self.transform(features)</span><br><span class="line">        <span class="keyword">return</span> features, label</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回整個數據集的 DataFrame</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>寫好 function 後，就可以開始使用了，我們可以使用以下指令來測試一下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">titanic_train = TitanicDataset(<span class="string">&#x27;./data/titanic.csv&#x27;</span>, train=<span class="literal">True</span>)</span><br><span class="line">titanic_val = TitanicDataset(<span class="string">&#x27;./data/titanic.csv&#x27;</span>, train=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_dataset len:&#x27;</span>, <span class="built_in">len</span>(titanic_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;val_dataset len:&#x27;</span>, <span class="built_in">len</span>(titanic_val))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;total_dataset len:&#x27;</span>, <span class="built_in">len</span>(titanic_train) + <span class="built_in">len</span>(titanic_val))</span><br><span class="line"><span class="comment"># 最後會印出如下：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">train_dataset len: 711</span></span><br><span class="line"><span class="string">val_dataset len: 178</span></span><br><span class="line"><span class="string">total_dataset len: 889</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>可以透過以下程式，列印出以下結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic_val.getData()</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/d2C0wTF.png" alt=""></p><h1 id="Step2-建制-Neural-Network">Step2. 建制 Neural Network</h1><ol><li>接下來我們建制以下 Neural Network，主要做以下事情：<ul><li><code>__init__</code>: 建立一個 three layer 的 network (1 input layer + 1 hidden layer + 1 output layer)。<ul><li><code>D_in</code>: input layer 的 neurons size</li><li><code>H</code>: hidden layer 的 neurons size</li><li><code>D_out</code>: output layer 的 neurons size</li></ul></li><li><code>forward</code>: 進行 forward pass 的地方，主要做第一層的 linear transformation，並且使用 <code>relu</code> 作為 activation function，第二層的 linear transformation，並且使用 <code>sigmoid</code> 作為 activation function，最後回傳預測的結果。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, H, D_out</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        In the constructor we instantiate two nn.Linear modules and assign them as member variables.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(TwoLayerNet, self).__init__()</span><br><span class="line">        <span class="comment"># the weight and bias of linear1 will be initialized </span></span><br><span class="line">        <span class="comment"># you can access them by self.linear1.weight and self.linear1.bias</span></span><br><span class="line">        self.linear1 = nn.Linear(D_in, H) <span class="comment"># this will create weight, bias for linear1</span></span><br><span class="line">        self.linear2 = nn.Linear(H, D_out) <span class="comment"># this will create weight, bias for linear2</span></span><br><span class="line">        self.sigmoid = nn.Sigmoid() <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        In the forward function we accept a Tensor of input data and we must return a Tensor of output data.</span></span><br><span class="line"><span class="string">        We can use Modules defined in the constructor as well as arbitrary operators on Tensors.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        h_relu = F.relu(self.linear1(x))</span><br><span class="line">        y_pred = self.sigmoid(self.linear2(h_relu))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure></li><li>在訓練模型之前，我們要先把模型建立起來。下面程式碼的意思就是，我們設定 batch_size = 16，每次以 16 個單位進行一次訓練，然後把所有 889 筆資料以 16單位全部訓練完作為一次epoch，input layer 的 neurons size = 10，hidden layer 的 neurons size = 3，output layer 的 neurons size = 1，learning rate = 0.001，總共訓練 500 次。<ul><li>我們建立了 network 把網路神經建立起來</li><li>使用 Adam 作為 optimizer，進行 Gradient Descent 的更新</li><li>使用 Binary Cross-Entropy Loss 作為 loss function</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">N, D_in, H, D_out = <span class="number">16</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line">n_epochs = <span class="number">50</span></span><br><span class="line">log_interval = <span class="number">100</span> <span class="comment"># Print the training status every log_interval epoch</span></span><br><span class="line"></span><br><span class="line">network = TwoLayerNet(D_in, H, D_out)  <span class="comment"># H=3 for one hidden layer with 3 neurons</span></span><br><span class="line">optimizer = optim.Adam(network.parameters(), lr)</span><br><span class="line">criterion = nn.BCELoss() <span class="comment"># Define the loss function as Binary Cross-Entropy Loss</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Step3-模型訓練">Step3. 模型訓練</h1><ol><li>可以先建立好所需的 list 清單來記住每次的 loss 跟 accuracy <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_losses = [] <span class="comment"># Save the loss value of each training loop (epoch) of the neural network model during the training process</span></span><br><span class="line">train_counter = [] <span class="comment"># Save the number of images for training so far</span></span><br><span class="line">test_losses = [] <span class="comment"># Save the loss value of each test loop (epoch) of the neural network model during the training process</span></span><br><span class="line">test_counter = [i*<span class="built_in">len</span>(titanic_train) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs+<span class="number">1</span>)] <span class="comment"># how many data for training so far</span></span><br></pre></td></tr></table></figure></li><li>建制 train function，主要目的是把 model train 好，使用 train dataset 來進行模型訓練。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>): <span class="comment"># 目前跑了第幾個 epoch</span></span><br><span class="line">    network.train() <span class="comment"># 把上一步驟建立好的 network 拿進來使用</span></span><br><span class="line">    correct = <span class="number">0</span> <span class="comment"># 紀錄目前正確的次數</span></span><br><span class="line">    cur_count = <span class="number">0</span>  <span class="comment"># 紀錄目前已經訓練了多少筆資料</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 先把目前的 gradient 清空，因為每次訓練完一個 batch 就會更新一次 gradient</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># forward propagation</span></span><br><span class="line">        output = network(data) <span class="comment"># 把資料餵入 network 進行 forward propagation</span></span><br><span class="line">        loss = criterion(output, target) <span class="comment"># 計算 loss</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># Accuracy</span></span><br><span class="line">        pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># 因為答案不是0就是1，因此我們需要設定 threshold，大於等於 0.5 就是 1，小於 0.5 就是 0</span></span><br><span class="line">        correct += (pred == target).<span class="built_in">sum</span>().item() <span class="comment"># 紀錄目前正確的次數，如果與 target 一樣就 +1 </span></span><br><span class="line">        cur_count += <span class="built_in">len</span>(data) <span class="comment"># 紀錄目前已經訓練了多少筆資料   </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># backword propagation</span></span><br><span class="line">        loss.backward() <span class="comment"># 計算 loss 的 gradient</span></span><br><span class="line">        optimizer.step() <span class="comment"># 更新 gradient</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % log_interval == <span class="number">0</span>: <span class="comment"># 每 log_interval 印出一次訓練狀態</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;\t Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, </span><br><span class="line">                cur_count, </span><br><span class="line">                <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * cur_count / <span class="built_in">len</span>(train_dataloader.dataset), </span><br><span class="line">                loss.item(), </span><br><span class="line">                correct, <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * correct / <span class="built_in">len</span>(train_dataloader.dataset))</span><br><span class="line">            )</span><br><span class="line">            train_losses.append(loss.item())</span><br><span class="line">            train_counter.append((batch_idx*<span class="number">16</span>) + ((epoch-<span class="number">1</span>)*<span class="built_in">len</span>(train_dataloader.dataset)))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 回傳目前的 accuracy</span></span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(train_dataloader.dataset)</span><br></pre></td></tr></table></figure></li><li>建制 test function，主要目的是把 train 好的 model 透過 validation dataset 進行測試，看這個模型訓練在檢測未知資料時，準確率如何。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    network.<span class="built_in">eval</span>() <span class="comment"># 把上一步驟建立好的 network 拿進來使用，告知目前要進行 evaluation 的狀態</span></span><br><span class="line">    test_loss = <span class="number">0</span> <span class="comment"># 紀錄目前的 loss</span></span><br><span class="line">    correct = <span class="number">0</span> <span class="comment"># 紀錄目前正確的次數</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 因為不需要計算 gradient，因此可以使用 torch.no_grad() 來加速</span></span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_dataloader: <span class="comment"># 透過 test_dataloader 來取得資料</span></span><br><span class="line">            <span class="comment"># forward propagation </span></span><br><span class="line">            output = network(data) <span class="comment"># 把資料餵入 train 好的 network 進行 forward propagation</span></span><br><span class="line">            test_loss += criterion(output, target).item() <span class="comment"># 計算 loss </span></span><br><span class="line">            <span class="comment"># Accuracy</span></span><br><span class="line">            pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># 0.5 is the threshold </span></span><br><span class="line">            correct += (pred == target).<span class="built_in">sum</span>().item() <span class="comment"># 紀錄目前正確的次數，如果與 target 一樣就 +1</span></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_dataloader.dataset) <span class="comment"># 計算平均的 loss</span></span><br><span class="line">    test_losses.append(test_loss) <span class="comment"># 把目前的 loss 加入 list 中 </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, </span><br><span class="line">        correct, </span><br><span class="line">        <span class="built_in">len</span>(test_dataloader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_dataloader.dataset))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(test_dataloader.dataset) <span class="comment"># 回傳目前的 accuracy </span></span><br></pre></td></tr></table></figure></li><li>最後我們就可以根據 epoch 數量來進行模型的訓練，並做完每次 epoch 時，就透過 <code>test()</code> 來檢驗一下訓練狀況。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test()</span><br><span class="line">train_accuracy_list = []</span><br><span class="line">test_accuracy_list = []</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_epochs + <span class="number">1</span>): <span class="comment"># 進行 n_epochs 次的訓練</span></span><br><span class="line">    train_accuracy_list.append(train(epoch)) <span class="comment"># 訓練完後，把目前的 accuracy 加入 list 中</span></span><br><span class="line">    test_accuracy_list.append(test()) <span class="comment"># 訓練完後，把目前的 accuracy 加入 list 中</span></span><br></pre></td></tr></table></figure></li><li>出來應該會長這樣：</li></ol><h1 id="Step4-產出結果">Step4. 產出結果</h1><p>最後可以透過以下指令來產出結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(train_accuracy_list, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(test_accuracy_list, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.ylim(0.5, 1)</span></span><br><span class="line">plt.legend([<span class="string">&#x27;Train Accuracy&#x27;</span>, <span class="string">&#x27;Test Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Train Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Test Accuracy&#x27;</span>], loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/8yHAk60.png" alt=""></p><h1 id="Step5-製造-Overfitting">Step5. 製造 Overfitting</h1><div class="note info flat"><p>製造 Overfitting 主要可以有幾種方式：</p><ol><li><strong>epoch 調大</strong>，就會有一點 overfitting 的現象</li><li>或是把 <strong>hidden layer 數量提高</strong>或是把 <strong>neurons size 調大</strong>，也會有一點 overfitting 的現象</li></ol></div><p>因為題目要求把 hidden layer 數量提高獲釋把 neurons size 調大，因此我們就來試試看吧！<br>最簡單的方式就是把，hidden layer調高一點，neurons size 調大一點，並且 epoch 調大一點，就可以看到 overfitting 的現象了。</p><ol><li>建立一個 MultiLayerNet，並且把 hidden layer 跟 neurons size 調高一點 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, H, D_out, num_layers</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        neurons = <span class="number">128</span></span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, H)</span><br><span class="line">        self.linear1 = nn.Linear(H, <span class="number">128</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line">        self.linear4 = nn.Linear(<span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line">        self.output = nn.Linear(<span class="number">16</span>, D_out)</span><br><span class="line">        self.sigmoid = nn.Sigmoid() <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y_relu = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        y_relu = F.relu(self.linear1(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear2(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear3(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear4(y_relu))</span><br><span class="line">        y_pred = self.sigmoid(self.output(y_relu))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure></li></ol><div class="note danger flat"><p>踩雷筆記：如果你純粹增加 layer 並不會有太多學習的效果，你會總是看到一水平的條線…，然後準確率就沒再上升了！後來同學發現，neurons要從多慢慢遞減，才會有學習的效果，因此我們可以把 neurons 設定成 128, 64, 32, 16！<br>「 同學說：這就像沙漏一樣」，這樣會慢慢一步步的過濾掉不重要的資訊，最後留下重要的資訊！」</p></div><ol><li><p>針對 multi network 建立新的 multi_train() 跟 test_multi() function</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_multi</span>(<span class="params">epoch</span>):</span><br><span class="line">    multi_network.train() <span class="comment"># 把上一步驟建立好的 network 拿進來使用</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    cur_count = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        multi_optimizer.zero_grad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># forward propagation</span></span><br><span class="line">        output = multi_network(data) <span class="comment"># 你會發現這裡使用 multi_network 來進行 forward propagation</span></span><br><span class="line">        loss = multi_criterion(output, target) <span class="comment"># 你會發現這裡使用 multi_criterion 來計算 loss</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># Accuracy</span></span><br><span class="line">        pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># survival_rate is the threshold</span></span><br><span class="line">        correct += (pred == target).<span class="built_in">sum</span>().item()</span><br><span class="line">        cur_count += <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># backword propagation</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        multi_optimizer.step()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % log_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Muti Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;\t Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, </span><br><span class="line">                cur_count, </span><br><span class="line">                <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * cur_count / <span class="built_in">len</span>(train_dataloader.dataset), </span><br><span class="line">                loss.item(), </span><br><span class="line">                correct, <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * correct / <span class="built_in">len</span>(train_dataloader.dataset))</span><br><span class="line">            )</span><br><span class="line">            train_losses.append(loss.item())</span><br><span class="line">            train_counter.append((batch_idx*<span class="number">16</span>) + ((epoch-<span class="number">1</span>)*<span class="built_in">len</span>(train_dataloader.dataset)))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(train_dataloader.dataset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_multi</span>():</span><br><span class="line">    multi_network.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            <span class="comment"># forward propagation</span></span><br><span class="line">            output = multi_network(data)</span><br><span class="line">            test_loss += multi_criterion(output, target).item()</span><br><span class="line">            <span class="comment"># Accuracy</span></span><br><span class="line">            pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># 0.5 is the threshold</span></span><br><span class="line">            correct += (pred == target).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_dataloader.dataset)</span><br><span class="line">    test_losses.append(test_loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nMulti Test set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, </span><br><span class="line">        correct, </span><br><span class="line">        <span class="built_in">len</span>(test_dataloader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_dataloader.dataset))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(test_dataloader.dataset)</span><br></pre></td></tr></table></figure></li><li><p>重新 train model</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_multi()</span><br><span class="line"></span><br><span class="line">multi_train_accuracy_list = []</span><br><span class="line">multi_test_accuracy_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_epochs + <span class="number">1</span>):</span><br><span class="line">    multi_train_accuracy_list.append(train_multi(epoch))</span><br><span class="line">    multi_test_accuracy_list.append(test_multi())</span><br></pre></td></tr></table></figure></li><li><p>重新畫圖: 你可以嘗試把 epoch 條到 500 次，就會看到 overfitting 的現象了！</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(multi_train_accuracy_list, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.plot(multi_test_accuracy_list, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.ylim(<span class="number">0.5</span>, <span class="number">0.9</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Train Accuracy&#x27;</span>, <span class="string">&#x27;Test Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Train Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Test Accuracy&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/eVxVkM6.png" alt=""></p><h2 id="進階版">進階版</h2><p>如果希望可以更加動態的調整neurons跟hidden layer的數量，可以使用以下方式：</p><ul><li><code>neurons</code>: 一開始設定的 neurons 數量，如果設定 1024，就會從 1024 開始遞減至 16，每次遞減就除以 2，直到 neurons 數量小於 16 為止</li><li><code>num_layers</code>: hidden layer 數量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">neurons = <span class="number">1024</span> </span><br><span class="line">num_layers = <span class="number">5</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, D_out, neurons, num_layers</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        neurons = neurons</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, neurons)</span><br><span class="line">        self.linears = nn.ModuleList()  <span class="comment"># 需要注意的是，如果要用 for 回圈建立多個 layer，就必須使用 nn.ModuleList() 來建立</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.linears.append(nn.Linear(neurons, <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>)))</span><br><span class="line">            neurons = <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>) </span><br><span class="line">        self.output = nn.Linear(neurons, D_out)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()  <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.linears:</span><br><span class="line">            y = F.relu(layer(y))</span><br><span class="line">        y_pred = self.sigmoid(self.output(y))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><h1 id="Step6-使用-Dropout">Step6. 使用 Dropout</h1><p>這邊我們可以使用 Dropout 來避免 overfitting 的現象，主要是在 forward propagation 的時候，隨機把一些 neurons 給關掉，這樣就可以避免 overfitting 的現象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, H, D_out, num_layers, dropout_prob</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, H)</span><br><span class="line">        self.linear1 = nn.Linear(H, <span class="number">128</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line">        self.linear4 = nn.Linear(<span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line">        self.output = nn.Linear(<span class="number">16</span>, D_out)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout_prob)  <span class="comment"># 添加 Dropout 層</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y_relu = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        y_relu = F.relu(self.linear1(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear2(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear3(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear4(y_relu))</span><br><span class="line">        y_relu = self.dropout(y_relu)  <span class="comment"># 在需要的位置應用 Dropout</span></span><br><span class="line">        y_pred = self.sigmoid(self.output(y_relu))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這時候你會發現，overfitting 的現象就沒那麼嚴重了！以下是 epoch 數量設定為 200 時的結果。</p><blockquote><p>Without Dropout<br><img src="https://i.imgur.com/BxmZNLL.png" alt=""></p></blockquote><blockquote><p>With Dropout<br><img src="https://i.imgur.com/wj5vFvt.png" alt=""></p></blockquote><h2 id="進階版-2">進階版</h2><p>進階版的差異就是，dropout layer 的數量跟 hidden layer 的數量是一樣的，並且 dropout layer 的數量是隨著 hidden layer 的數量遞減的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, D_out, neurons, num_layers, dropout_prob=<span class="number">0.8</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        neurons = neurons</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, neurons)</span><br><span class="line">        self.linears = nn.ModuleList()  </span><br><span class="line">        self.dropouts = nn.ModuleList() <span class="comment">#  ======&gt; dropout layer</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.linears.append(nn.Linear(neurons, <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>)))</span><br><span class="line">            self.dropouts.append(nn.Dropout(p=dropout_prob)) <span class="comment"># ======&gt; dropout layer</span></span><br><span class="line">            neurons = <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>) </span><br><span class="line">        self.output = nn.Linear(neurons, D_out) <span class="comment"># output layer</span></span><br><span class="line">        self.sigmoid = nn.Sigmoid()  <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        <span class="keyword">for</span> layer, dropout <span class="keyword">in</span> <span class="built_in">zip</span>(self.linears, self.dropouts):</span><br><span class="line">            y = F.relu(layer(y))</span><br><span class="line">            y = dropout(y) <span class="comment"># ======&gt; dropout layer</span></span><br><span class="line">        y_pred = self.sigmoid(self.output(y))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC OS - PyTorch 上如何啟用 GPU</title>
      <link href="/posts/PyTorch-Mac-GPU-Setup/"/>
      <url>/posts/PyTorch-Mac-GPU-Setup/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://blog.csdn.net/DaydreamHippo/article/details/128094886">mac m1,m2 安装 提供GPU支持的pytorch和tensorflow</a></li><li><a href="https://developer.apple.com/metal/pytorch/">Accelerated PyTorch training on Mac</a></li></ul><h1 id="Mac-OS-在-PyTorch-啟用-GPU">Mac OS 在 PyTorch 啟用 GPU</h1><ol><li>因為我本身使用我重新基于Anaconda安装了一下GPU支持的Pytorch，你不確定是否有安裝Conda可以使用指令<code>conda --version</code>查看是否有安裝。如果成供輸出帶有本身有安裝，如果沒有請至<a href="https://www.anaconda.com/products/distribution">Anaconda官網</a>下載。</li><li>（可選）如果想要分開環境，特別建立一個支援GPU的python env，可以使用以下指令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一個 torch-gpu 的環境 使用 python 3.10.9</span></span><br><span class="line">conda create -n torch-gpu python=3.10.9</span><br><span class="line"><span class="comment"># 啟用該環境</span></span><br><span class="line">conda activate torch-gpu</span><br><span class="line"><span class="comment"># 查看 所有環境 </span></span><br><span class="line">conda <span class="built_in">env</span> list </span><br><span class="line"><span class="comment"># 查看目前的 python 版本與啟用的 env python 版本是否相同</span></span><br><span class="line">python --version</span><br></pre></td></tr></table></figure><ol start="3"><li><p>根據 <a href="https://pytorch.org/">Pytorch 官網</a>選擇對應的版本，複製安裝指令<br><img src="https://i.imgur.com/i89otBb.png" alt=""></p></li><li><p>您可以使用簡單的 Python 腳本驗證 mps 支援：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">if</span> torch.backends.mps.is_available():</span><br><span class="line">    mps_device = torch.device(<span class="string">&quot;mps&quot;</span>)</span><br><span class="line">    x = torch.ones(<span class="number">1</span>, device=mps_device)</span><br><span class="line">    <span class="built_in">print</span> (x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;MPS device not found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或是</span></span><br><span class="line"><span class="built_in">print</span>(torch.backends.mps.is_available()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(torch.backends.mps.is_built()) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>需要注意的是，如果在 mac os 上，要使用 mps 而非一般 coda:0，要這樣寫：<code>device = torch.device(&quot;mps)</code></p></div>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All basic concept of Mechine Learning - ML 的重點知識整理</title>
      <link href="/posts/ML/"/>
      <url>/posts/ML/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://medium.com/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7-%E5%80%92%E5%BA%95%E6%9C%89%E5%A4%9A%E6%99%BA%E6%85%A7/epoch-batch-size-iteration-learning-rate-b62bf6334c49">Epoch, Batch size, Iteration, Learning Rate</a></li><li><a href="https://youtu.be/Dr-WRlEFefw?si=YUsDXnWbTRSBiR26">ML Lecture 6: Brief Introduction of Deep Learning</a></li><li><a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backporpagation</a></li><li><a href="https://zhuanlan.zhihu.com/p/25110450">聊一聊深度学习的activation function</a></li><li><a href="https://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">台大李鴻毅老師的所有影片</a></li><li><a href="https://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">超詳細的activation function推導公式</a></li><li><a href="https://chih-sheng-huang821.medium.com/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-convolutional-neural-network-cnn-%E5%8D%B7%E7%A9%8D%E8%A8%88%E7%AE%97%E4%B8%AD%E7%9A%84%E6%AD%A5%E4%BC%90-stride-%E5%92%8C%E5%A1%AB%E5%85%85-padding-94449e638e82">卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)</a></li><li><a href="https://cs231n.github.io/neural-networks-3/#hyper">史丹佛nerual-networks-3</a></li></ul><h1 id="Nerual-Network">Nerual Network</h1><p>主要參考：- <a href="https://youtu.be/Dr-WRlEFefw?si=YUsDXnWbTRSBiR26">ML Lecture 6: Brief Introduction of Deep Learning</a></p><p><img src="https://i.imgur.com/agRVsjp.png" alt=""><br><img src="https://i.imgur.com/QiJ6SSW.png" alt=""></p><ul><li>每個 neuron 都有一組 weight 跟 bias，下一個neuron = 上一個 neuron 連到的線中，進行運算以上圖為例 1<em>1+(-1)</em>(-2) 再加上 bias 1 進行 sigmoid function 得到數值。</li><li>就是把 <code>input * weight + bias</code> 進行 <code>activation function</code> (ex. sigmoid )，得到 output，然後再進行下一層的運算。</li><li>如果你知道當下 nerual network 當下計算出結果的所有 weight 和 bias ，一個neuron 就像是一個function一樣提供了weight跟bias，而梯度下降就是在多組 function set中找到最佳的那組 function。</li></ul><h2 id="Goal">Goal</h2><p><img src="https://i.imgur.com/M7cW1Jv.png" alt=""></p><ul><li>透過 Cross Entropy 來看預測的結果跟實際的結果有多接近，越大表示差越多，越小表示差越少。</li><li>而 <strong>Loss function 就是把所有的 Cross Entropy 加起來</strong>，就是我們要<strong>最小化的目標</strong>。</li></ul><p><img src="https://i.imgur.com/MuUNBwO.png" alt=""></p><ul><li>找到一個 function in function set，讓 Loss function 最小化，就是我們要找的 function。</li><li>找到的過程就是透過 梯度下降法 (Gradient Descent) 來找到 network parameters θ (weight, bias) 的最佳解。</li></ul><h2 id="hidden-layer">hidden layer</h2><p><img src="https://i.imgur.com/HHjICpr.png" alt=""></p><ul><li>一個 layer 就是把 <strong>input * metrix + bias 通過 activation function</strong> （ex. sigmoid funciton）得到最後的結果</li></ul><h2 id="output-layer">output layer</h2><p><img src="https://i.imgur.com/xl7SWAK.png" alt=""></p><ul><li>又稱 Multi-class Classifier ，因為output layer是把前一個layer ouput當作feature，他不是直接使用原始的input(x)，而是經過很多hidden layer很多複雜轉換後抽出一組最好的feature。</li><li>Multi-Class Classifier 要通過一個 Softmax function，把每個類別的機率加起來等於1，然後取最大的機率當作預測的類別。</li></ul><h2 id="決定的參數">決定的參數</h2><ul><li>要決定整個network的structure，決定你的function set長什麼樣子<ul><li>幾個 layer ?</li><li>每個 layer 有幾個 node (neuron) ?</li><li>可不可以自己決定 nerual 要使用的 input 自己串？=&gt; 可以，使用CNN</li></ul></li></ul><h1 id="Epoch-Batch-size-Iteration">Epoch, Batch size, Iteration</h1><p>主要參考：- <a href="https://medium.com/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7-%E5%80%92%E5%BA%95%E6%9C%89%E5%A4%9A%E6%99%BA%E6%85%A7/epoch-batch-size-iteration-learning-rate-b62bf6334c49">Epoch, Batch size, Iteration, Learning Rate</a></p><ul><li><p><strong>Epoch</strong></p><ul><li>字面：直接翻譯又稱「時代」或「時期」的意思，但是在神經網路上類似「期」。</li><li>意思：表示在訓練過程中，所有的<code>訓練資丟入神經網路進行一次訓練，稱為一個 Epoch</code>。</li><li>例子：如果有一個資料集10筆資料，這時筆資料丟入神經網路後進行一次訓練表示完成 1 個 Epoch 的訓練。</li></ul></li><li><p><strong>Batch size</strong></p><ul><li>字面：批次大小</li><li>意思：如果資料量太大，例如有100萬筆，但是因為 memory 無法一次放入這麼多資料，就可以透過調整batch size分批把資料放入。</li><li>例子：假設有100萬筆資料，batch size設定為1000，那麼一個 epoch 就要訓練 1000 次 才能完成。</li><li>補充：<ul><li>batch size 越大，因為考慮較多參數，進行梯度下降時修正的方向較為準確，雖然每次iteration計算較久，但是調整方向的次數較少，Epoch可以不用很大。</li><li>相反的batch size 越小，Batch size = 1 又稱 Incremental mode，因為一次 iteration 只需算一筆資料，所以權重會配頻繁更新導致方向不太準確，因此 Epoch 要設定大一點，才能讓權重更新的次數多一點，以找到最佳解。</li></ul></li><li>總結：<ul><li>我可以用較大的 Batch size 搭配較大的 η，那結果可能是不用那麼多的 Epoch 就能達到我的期望。</li></ul></li></ul></li><li><p><strong>Iteration</strong></p><ul><li>字面：迭代</li><li>意思：因為資料量太大，我們需要透過 batch 的方式將資料送進神經網路，在程式語言上會需要透過迴圈進行迭代才能將所有資料批次送入訓練，已完成一次Epoch。</li><li>例子：假設有100萬筆資料，batch size設定為1000，那麼一個 epoch 就要金行 1000 次 的迭代才能完成。</li></ul></li></ul><div class="note warning flat"><p><strong>Data set size = Iteration * Batch size * (1 Epoch)</strong><br>100 萬 = 1000 次 * 1000 批次 = 1 Epoch</p></div><div class="note warning flat"><p><strong>Iteration = (Data set size / Batch size) * (n Epoch)</strong><br>如果決定使用Batch size = 1000，訓練5個Epoch總共要迭代幾次？<br>Ans: 100萬/1000 * 5 = 5000次</p></div><h1 id="Learning-Rate">Learning Rate</h1><p>在進行「梯度下降」（Gradient Descent）時，每次計算誤差後會做偏微分來更新權重，更新的程度會由 ∇E（Gradient）乘上一個「 η（Learning rate）」來決定，目的就是為了讓更新的幅度不要太大或太小，讓每次更新 weight, bias 尋找最小的 Loss 時，移動至下一組(weight, bias)的幅度。</p><p><img src="https://i.imgur.com/CEW4U3F.png" alt=""><br>(左圖)learning rate的變化：</p><ul><li>如果<strong>learning rate很低</strong>，那<strong>Loss value會呈現 linear</strong></li><li>如果<strong>learning rate高</strong>，則是<strong>會呈現 exponential</strong>。</li><li><strong>learning rate 過高</strong> 可能會卡在<strong>比較糟的 loss value</strong> (green line)因為優化過程中「能量」過多，參數亂跳，導致無法在優化領域(optimization landscape)找到一個好的位置。</li></ul><p>(右圖)the amount of wiggle (擺動) 與 batch size 有關：</p><ul><li>如果<strong>batch size很大</strong>，那<strong>wiggle就會很小</strong>，因為<strong>每次更新的方向都會比較準確</strong>，除非learning rate設定太高。</li><li>相反的，如果<strong>batch size很小</strong>，那<strong>wiggle就會很大</strong>。</li></ul><div class="note warning flat"><p>我可以用<strong>較大的 Batch size</strong> 搭配<strong>較大的 η</strong>，那結果可能是不用那麼多的 Epoch 就能達到我的期望。<br>相對的，如果我想用<strong>Batch size = 1</strong>的條件下去訓練，那可能就<strong>要配置較小的 η ，才不會在接近 Minima 的時候來回走動</strong>，也就不用走太多冤枉路。但也因為 η 較小，我可能就需要比較多的 Epoch 才會走到 Minima。</p></div><h2 id="Adagrad">Adagrad</h2><p><img src="https://i.imgur.com/kHY3mYz.png" alt=""></p><ul><li>現在每個 parameters 都有自己的 learning rate，把 learning rate 除以過去所有 gradient 的平方和，得到新的parameters。</li><li>如果平時 Gradient 比較陡峭，那給予小的 Learning Rate。相反的，如果平時 Gradient 比較平緩，那給予大的 Learning Rate。</li></ul><h2 id="RMSProp">RMSProp</h2><div class="note warning flat"><p>但是如果今天平時處理的問題可能比較複雜，怎麼辦？如下圖<br>你可以方向在水平直線的地方，一下 gradient 大，一下 gradient 小，所以我們<strong>要能夠更 dynamic 的調整 learning rate</strong>。因此有了 RMSProp。</p></div><p><img src="https://i.imgur.com/Nr1cIpI.png" alt=""></p><ul><li>第一個時間點：把 learning rate 除以一個值 sigma，這個 sigma 就是第一次算出來的 gradient。</li><li>第二個時間點：新的sigma就是&quot;原本sigma值平方&quot;乘上&quot;a&quot;，再加上&quot;新的gradient值平方&quot;乘上&quot;1-a&quot;，這個&quot;a&quot;可以自由去調整。這樣就可以讓 sigma 有一個平滑的效果。</li></ul><div class="note info flat"><p>與原本的 Adagrad 相比，<strong>RMSProp 因為都會把每次的 gradient 參考進去導致有一個平滑的效果</strong>，也可以隨著gradient改變的大小，動態調整 learning rate 的大小，讓 learning rate 更加的動態。</p></div><h1 id="Gradient-Descent">Gradient Descent</h1><p><img src="https://i.imgur.com/jYAlRkm.png" alt=""><br>我們先很快地複習一下一般的 Gradient Descent 是怎麼做的：</p><ul><li>選一個初始的值並計算一下它的 gradient，假設它的 gradient 是左上角紅色箭頭的方向，那我們就走 gradient 的反方向乘上一個 learning rate，再算 gradient 之後再走一個新的方向，以此類推。</li><li>直到 gradient = 0 的時候，或 gradient 趨近 0 的時候就停止。</li></ul><h2 id="momentum">momentum</h2><ul><li><a href="https://ai.ntu.edu.tw/resource/handouts/ML9-1.html">ML9-1 有提到momentum說明</a></li><li><a href="https://youtu.be/xki61j7z-30?si=8eLJMCTDEklR1PU_">影片ML9-1</a></li></ul><div class="note info flat"><p>他是一個可以幫助我們跳出local minimum的方法。參考慣性的概念，讓每次更新時多跑一點。</p></div><p><img src="https://i.imgur.com/e8GMTen.png" alt=""></p><ul><li>在進行Gradient Descent的時候，可能會<code>碰到 local minimum 的問題</code>。</li><li>但是有一個方法可以幫助我們跳出 local minimum，就是使用 momentum。<ul><li>這個概念有點像是在真實世界裡面，把一個球從上圖的左上角讓它滾下來，在球滾到 plateau 的地方時，因為有慣性，所以它不會停下來，而是會繼續往前。</li><li>就算是走到上坡的地方，假設這個坡沒有很陡，因為慣性的關係，可能還是可以翻過這個山坡，結果它就走到了比這個 local minimum 還要好的地方。</li></ul></li></ul><div class="note info flat"><p><strong>所以我們就把這個慣性的特性加到 Gradient Descent 裡面去，這就叫做 momentum，他就是上一個時間點的 movement。</strong></p></div><p><img src="https://i.imgur.com/GUNg87f.png" alt=""><br><img src="https://i.imgur.com/QqVVOQm.png" alt=""></p><ul><li>綠色線條是慣性，紅色是 gradient 的方向，把這兩個方向加起來，就是我們要走的方向。</li><li>再看Momentum in graph，你可以發現在最後一個地方（最右邊處），如果今天球的gradient &lt; momentum 時，可能可以讓球跳出 local minimum。</li></ul><p><img src="https://i.imgur.com/q0rdRfM.png" alt=""></p><ul><li>v 是之前所有 gradient 的總和，而 v 會乘上一個 momentum 的值，然後再加上現在的 gradient，這樣就可以讓我們的 gradient 有一個慣性的效果，讓它可以跳出 local minimum。</li><li>你會發現，v1 是由 v0 * lemda 所組成，如果lemda &lt; 0，則越早之前的移動影響越小。</li><li><code>每一次的移動都會參考之前的移動，但是之前的移動會越來越小</code>，這樣就可以讓我們的移動不會太大，也不會太小，而是一個適中的值。</li></ul><h2 id="Adam">Adam</h2><div class="note info flat"><p><strong>就是 RMSProp + Momentum = 動態調整 Learning Rate + 添加一點「慣性」</strong></p></div><p><img src="https://i.imgur.com/Ir1J6fR.png" alt=""></p><ul><li>m0 是前一個時間點的movement</li><li>v0 之前算出來gradient的平方和</li><li>gt 是現在的gradient</li><li>mt 根據 gt 計算出來現在要走的方向，這其中考慮了「現在要走的方向」+ 「之前的方向」</li><li>vt 準備放在分母的地方，他是過去前一個時間點的vt，加上 gradient 的平方開根號。</li><li>bias correction: 他把 mt 跟 vt 個除上一個值，1減這個值，而這個值到最後會越接近1。</li><li>最後 update 時把 momentum 「建議的方向 mt hat」 乘上 「learning rate: a」除以「RMSProp Normalze 的Learning Rate」</li></ul><h1 id="Batch-Gradient-Descent-Batch-GD">Batch Gradient Descent (Batch GD)</h1><ul><li>Ref: AI老師的投影片 2023-WS_AI_VL-01b-Recap-Neural-Networks.pdf</li></ul><p>批次梯度下降的主要特點是它將<strong>訓練數據拆分成批次，這降低了內存需求</strong>，並使算法更適合大型數據集。但它可能會導致較多的迭代次數，因為每次迭代僅考慮一個小批次的數據。</p><p>和一般的GD差異在於，<strong>梯度下降在每次迭代中使用整個訓練數據集，而批次梯度下降僅使用一個小批次的數據</strong>。</p><h2 id="Stochastic-Gradient-Descent-SGD">Stochastic Gradient Descent (SGD)</h2><p><img src="https://i.imgur.com/3eLwMwv.png" alt=""></p><ul><li>作法：每次迭代中<strong>僅使用單個訓練樣本</strong>來計算梯度，然後更新模型參數。這導致每次迭代的梯度估計都是隨機的。</li><li>優點：SGD的主要優點是對記憶體要求較低，對大型數據集適用，並且可能幫助模型逃離局部極小值。</li><li>缺點：但它可能需要更多的迭代才能收斂，且更新不太穩定。</li></ul><h2 id="Mini-batch-Gradient-Descent-Mini-batch-GD">Mini-batch Gradient Descent (Mini-batch GD)</h2><p><img src="https://i.imgur.com/0jARl1y.png" alt=""></p><ul><li>作法：小批次梯度下降通常是最常用的優化算法。它在每次迭代中<strong>使用一個小批次（batch）的訓練數據</strong>來計算梯度，然後更新模型參數。這樣既降低了內存需求，又提供了相對<strong>穩定</strong>的梯度估計。</li><li>優點：因為它兼具SGD和標準梯度下降的優勢。它可以在大型數據集上工作，提供相對穩定的梯度估計，並在收斂速度和計算效率之間取得良好的平衡</li></ul><h1 id="Back-Propagation">Back Propagation</h1><ul><li>Ref:<ul><li><a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backporpagation</a></li><li><a href="https://zhuanlan.zhihu.com/p/25110450">聊一聊深度学习的activation function</a></li><li><a href="https://youtu.be/Ilg3gGewQ5U?si=tpVt1tpMpa0mlgpk">我看過最讚的解說</a></li></ul></li></ul><p>他是一種優化神經網路的方法，名稱為Back Propagation，可以想像就是能更快的執行梯度下降 Gradient Descent，透過 forward pooling 導數的後向傳遞：先計算輸出層對應的loss，然後將<strong>loss以導數的形式不斷向上一層網路傳遞，修正對應的參數</strong>，達到降低loss的目的。</p><p>詳細可以參考 <a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backporpagation</a>。</p><div class="note warning flat"><p>但是，<code>Sigmoid函數在深度網路中常常會導致導數逐漸變成0，使得參數無法被更新</code>，神經網路無法被最佳化。因此，現在常用的激活函數是ReLU，它的導數在正數部分恆為1，因此不會有上述問題。</p></div><h1 id="Loss-of-classification">Loss of classification</h1><ul><li><a href="https://chih-sheng-huang821.medium.com/%E6%A9%9F%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%B8%E7%BF%92-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9-%E6%90%8D%E5%A4%B1%E5%87%BD%E6%95%B8-loss-function-2dcac5ebb6cb">可以參考這篇了解Cross-Entropy很神</a><br><img src="https://i.imgur.com/ti55P7J.png" alt=""></li><li>pytourch 中的 Cross Entropy 已經包含 softmax 的功能，所以不需要自己寫 softmax function。</li></ul><p><img src="https://i.imgur.com/YNVjMiA.png" alt=""></p><ul><li>Cross Entropy 比較容易透過梯度下降找到最小 loss 但是如果使用 MSE （Mean Square Error）會比較難找到最小 loss，可能會卡住。</li></ul><h1 id="Activation-Function">Activation Function</h1><ul><li>Ref:<ul><li><a href="https://youtu.be/s-V7gKrsels?si=K2y00JURot0GKOlb">Activation Functions - EXPLAINED!</a></li><li><a href="https://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">超詳細的activation function推導公式</a></li></ul></li></ul><div class="note info flat"><p>其實Activation Function就是在經歷每一層 hidden layer <strong>經過非線性的activation function，傳入到下一層神經元繼續往下傳遞</strong>，如此循環往復，直到輸出層。，讓神經網路可以抓取複雜的pattern。</p></div><h2 id="Sigmoid">Sigmoid</h2><p><img src="https://i.imgur.com/nAcok6B.png" alt=""></p><ul><li>左邊是微分前，右邊是微分後。</li><li>適用於二分類問題，或是多標籤分類問題（每個標籤“是”或“否”）。</li><li>輸出範圍介於[0,1]之間，因此通常使用的時機為二元分類問題的輸出層，例如&gt;=0.5的話為“是”否則為“否”。</li><li>問題：<ul><li><code>Vanishing Gradient Problem</code>: 執行 back Propagation的時候，因為 sigmoid 微分的值都是 &lt; 1，最大值頂多 0.25，會導致<strong>在 train network 從後面的 layer 往 input 靠近的 layer，靠近 input 的 weight update 的量比較小</strong>，使得參數無法被更新，神經網路無法被最佳化，相對地靠近 output 的 weight 每次 update 比較大，學得比較快。</li><li>因此<strong>接近 input 的 weight 還是跟 random 差不多</strong>，但是後面的 weight 會差異很多。這樣會導致整個 network 的 <strong>weight update 很不平均，很難找到最佳解</strong>。</li><li>因此使用sigmoid function時反而不能有太多layer，這會導致靠近input的layer對loss的影響很小。</li></ul></li></ul><p><img src="https://i.imgur.com/P0WuoPn.png" alt=""></p><h2 id="ReLU">ReLU</h2><p><img src="https://i.imgur.com/Z5iB9iE.png" alt=""></p><ul><li>input &lt; 0 就是 0 ，input &gt; 0 就是 input</li><li>這個東西可以微分，但是 input = 0 時是不可微分的，所以在 input = 0 時，我們就隨便給一個數字，例如 0.5 。</li></ul><h3 id="Why-need-ReLU">Why need ReLU?</h3><ul><li><code>Fast to compute</code> : 計算比較快，只要check input 大於小於 0 會比 sigmoid 快很多。</li><li><code>Biological reason</code> : 人腦神經只能傳遞正值，負值會被忽略，所以 ReLU 比較符合人腦神經的運作方式。sigmoid input = 0 的地方，output = 0.5 很奇怪</li><li><code>no vanishing gradient problem</code>:<ul><li>ReLU 微分不是 0 就是 1，output 是 0 的可以想像他是不存在，當我們把output是0的neuron，剩下的又是input=ouput都是linear時，這整個就像a thinner linear network）。</li><li>這導致不會有activation function 遞減的問題。</li><li>input 就直接是 output ，因此如果調整底層 input 的變化就是 output 的變化<strong>每通過一個 layer 每個 layer 的變化量不會有縮減，每層 layer 的影響力都是一樣的，這樣就不會有 vanishing gradient problem。這樣就可以把network重疊的更深。</strong></li></ul></li></ul><h3 id="Problem-of-ReLU">Problem of ReLU?</h3><ul><li>問題：<ul><li>Q1: 變成linear，這個 network 會很弱嗎，因為不是 non-linear function？<ul><li>Ans: 如果對 input 做比較大的改變時，導致改變operational region時，他就變成non-learn。</li></ul></li><li>Q2: 可以微分嗎，因為input &lt; 0的時候，output是0導致無法updata參數？<ul><li>Ans: 可以使用 leaky ReLU。或是透過使用 softplus 解決、或使用 initialize with large bias 解決。但是基本上是 0 的機率比較小，所以問題不會太大。</li></ul></li></ul></li></ul><h2 id="Leaky-Parametric-ReLU">Leaky / Parametric ReLU</h2><p><img src="https://i.imgur.com/9QyRAZ6.png" alt=""><br><img src="https://i.imgur.com/gjxg1M2.png" alt=""></p><div class="note info flat"><p>Leaky ReLU就是在input &lt; 0的時候，output不是0，而是乘上一個很小的數字，例如0.01。</p></div><div class="note info flat"><p>為什麼input不能&lt;0呢？<br>Ans: 因為這會導致output是0，這樣就無法進行back propagation，因為這樣就無法更新gradient。</p></div><p>Leaky ReLU 跟 Parameteric ReLU 的差別在於 <strong>Parameteric ReLU 的 alpha 是可以被訓練的</strong>，而 Leaky ReLU 的 alpha 是固定的(0.01)。</p><div class="note warning flat"><p>但是你可能會想…為什麼input&lt;0時，一定要長成這樣的公式呢？<br>當然還有其他的樣子，因此有了Maxout的概念。</p></div><h2 id="Maxout">Maxout</h2><div class="note info flat"><p>讓<strong>training data決定你的network自動學習activation function</strong>，而不是人為的決定。</p></div><p><img src="https://i.imgur.com/ALMazw3.png" alt=""></p><ul><li>Step1: 他把 value group 起來，將個elements放在一個group裡面是你可以自己決定的</li><li>Step2: 在同一個group裡面，取最大的那個值當作 output。類似max pooling，在layer上做max pooling。</li><li>Step3: 再乘上一個 weight，回去做Step1。</li></ul><h3 id="Maxout-implement-ReLU">Maxout implement ReLU</h3><p><img src="https://i.imgur.com/ZQgNYlD.png" alt=""><br>Maxout 可以模仿 ReLU:</p><ul><li>ReLU<ul><li>在ReLU你可以透過乘上weight＋bias得到z通過ReLU得到a。</li><li>a 與 z 的關係是，如果 z &gt; 0，a = z，如果 z &lt; 0，a = 0。</li></ul></li><li>Maxout<ul><li>input 做兩組計算，第一組將input乘上 w 與 b 得到 z1，第二組是乘上0與0得到 z2。</li><li>然後做 maxpooling，可以從上圖看到 z1 和 z2 中選大的，就是 ReLU 。</li></ul></li></ul><h3 id="multi-activation-function">multi activation function</h3><p><img src="https://i.imgur.com/TwMbHI8.png" alt=""></p><ul><li>可以透過將 0,0 <strong>weight 調整成其他參數</strong>，產生不同的 activation function。<br><img src="https://i.imgur.com/60PVR91.png" alt=""></li><li>也可以透過將<strong>多個 elements groups 再一起</strong>產生不同的 activation function。</li></ul><h3 id="How-to-Train">How to Train</h3><p><img src="https://i.imgur.com/Txu18Kp.png" alt=""><br><img src="https://i.imgur.com/icMx1qg.png" alt=""></p><ul><li>當我們在做 maxout 也是得到一個細長的 linear network，會捨棄掉比較小的output</li></ul><div class="note warning flat"><p>但是這導致某些 neuron 沒 train 到，但是這不是一個問題…為什麼？<br>Ans: 因為當給不同 input 時會導致選擇 max 值的 neuron 不一樣。而 training 的過程中，<strong>有很多不同的 input 重複跑這些 neural network，因此每次training時input值也會不同</strong>，這將會導致每次training時選擇的 max neuron 也會不同，因此每個 neuron 都有機會被 train 到。</p></div><h1 id="Softmax">Softmax</h1><p><img src="https://i.imgur.com/sO085f5.png" alt=""><br><img src="https://i.imgur.com/Ozq0g5F.png" alt=""></p><ul><li>Softmax 是一種激活函數，通常使用在最後的output layer 主要用於多分類（classification）問題，將神經網路的輸出轉換成每一類的機率，並且機率總和為1。</li><li>類似 normalization。</li></ul><h1 id="CNN">CNN</h1><ul><li><p><a href="https://chih-sheng-huang821.medium.com/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-convolutional-neural-network-cnn-%E5%8D%B7%E7%A9%8D%E8%A8%88%E7%AE%97%E4%B8%AD%E7%9A%84%E6%AD%A5%E4%BC%90-stride-%E5%92%8C%E5%A1%AB%E5%85%85-padding-94449e638e82">卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)</a></p></li><li><p>在CNN的過程中，圖會因為你的<strong>kernel map大小做完卷積後變的更小</strong>。</p></li><li><p>一般卷積網路過程中，除了Input image不稱為Feature map外，中間產生的圖我們都稱之為Feature map，，深度學習過程就是在學資料的特性，所以中間出來的結果都是特徵資料，在影像因為是2D，所以用Feature map來稱呼。</p></li><li><p>原因很簡單就是這些中間產生的圖都是為了「描繪出該任務所應該產生對應的特徵資料」，這也呼應Yann LeCun, Yoshua Bengio &amp; Geoffrey Hinton寫的Deep Learning第一句話寫的「Deep learning allows computational models that are composed of multiple processing layers to learn representations of data with multiple levels of abstraction」</p></li></ul><p>卷積計算基本上有幾個部分：</p><ol><li>輸入的圖：假設 W * W</li><li>Filter (Kernal map): ks * ks</li><li>Stride: 通常是1，表示kernal map在移動時的步伐長度。</li><li>輸出的圖片大小：new_hight * new_width</li></ol><p><img src="https://i.imgur.com/Hhn9ecA.png" alt=""><br>以上圖為例：</p><ol><li>輸入的圖: W × W =10 × 10。</li><li>Filter (kernel map): ks × ks = 3 × 3</li><li>Stride: S=1</li><li>輸出的圖大小為 new_height × new_width = 8 × 8</li></ol><h2 id="padding">padding</h2><p>是不是卷積計算後，卷積後的圖是不是就一定只能變小?<br>ANS: 用zero padding</p><p>這個手法就是看你會消失多少的大小，在輸入的圖部份就給你加上0元素進去，這個手法稱為zero padding，實際作法如下圖。<br><img src="https://i.imgur.com/sXW7Yt2.png" alt=""></p><h2 id="Feature-Normalization">Feature Normalization</h2><ul><li>Ref: <a href="https://youtu.be/BABPWOkSbLE?si=V8dv0zVW95fY56GR">【機器學習2021】類神經網路訓練不起來怎麼辦 (五)： 批次標準化 (Batch Normalization) 簡介</a></li></ul><div class="note info flat"><p>原因：兩個參數W1,W2對斜率的變化很大，固定的Learning Rate可能不會得到好的結果。<br><strong>讓不同的feature有類似接近的數值範圍有很多方法，這些方法統稱為Feature Normalization</strong>。</p></div><blockquote><p>兩個參數W1,W2對斜率的變化很大，固定的Learning Rate可能不會得到好的結果。</p></blockquote><p><img src="https://i.imgur.com/RB51XXy.png" alt=""></p><ul><li>什麼時候w1的改變會對L很小?<ul><li>有可能w1接的input很小的時候，才會有這樣的狀況產生。x2很大，導致乘上w2的時候，會變得很大。</li><li>結論：input的大小，會想想到參數進行optimization的斜率大小。因此問題是，我們如何讓不同feature的dimension都有相同的scale呢?</li></ul></li></ul><p><img src="https://i.imgur.com/8slnaKM.png" alt=""></p><blockquote><p><strong>公式</strong></p></blockquote><ol><li>把同個dimenstion的feature都拿出來，算出他們的平均值和標準差。</li><li>做 normalization，把 (x - dimenstion 平均值) / dimenstion 標準差。</li><li>之後該dimenstaion的feature平均值是0，標準差是1，所有不同的數值都是在0上下。</li><li>他可以讓你在做Gradient Descent訓練更順利，Loss收斂更快。</li></ol><div class="note info flat"><p>問題：如果經過 某一層hidden layer 的計算後 (乘上 w 之後)，會變成很大或很小的數字，這樣就會導致後面的 layer 在接收 input 的時候這些 input 已經變成不同的範圍。因此我們對於 a (經過activation function後) 跟 z (經過activation function之前)都要執行Feature Normalization。</p><p><code>但是對 a 或 z 做 normalization 不會有太大的差別。</code></p></div><p><img src="https://i.imgur.com/eqMZs7Q.png" alt=""></p><ul><li><strong>說明</strong>：<ul><li>我們如果做了feature normalization，會造成<strong>讓所有input都有關連</strong>，因為z1改變會導致平均值跟標準差都改變，使得後面的z跟a都會改變。</li><li>所以我們要<strong>把算出平均值跟標準差的過程，都當作是network的一部分</strong>，因為概念雷同，有一堆input然後計算平均值跟標準差，然後得到一堆output。</li></ul></li></ul><h3 id="Batch-Normalization">Batch Normalization</h3><div class="note info flat"><p>問題：我剛說進行feature normalization的過程就有如network一班，但是他的input很大時，我們沒辦法放這麼多計算進GPU那該怎麼辦？</p></div><p><img src="https://i.imgur.com/jtDm2sm.png" alt=""></p><ul><li><strong>作法</strong>：上述講的把feature normalization 的過程當作 network，然而<strong>一次把上百萬筆資料丟到network就太多了</strong>，才有了batch normalization的概念。</li><li><strong>舉例</strong>：假設batch設定64，所以我們可以一次使用64筆資料，計算這64筆資料的平均值跟標準差，對這64筆data做batch normalization。</li></ul><div class="note warning flat"><p>注意：但是你必須要有夠大的batch size才會有效果，如果設定1那計算出來的平均值跟標準差就是原本的值，沒有任何改變。</p></div><div class="note info flat"><p>問題：如果我不希望mean是0該怎麼做？</p></div><p><img src="https://i.imgur.com/LkDaDvI.png" alt=""><br>還會有其他的設定，乘上另一個向量gama是一個向量，加上另一個向量beta，<strong>有些時候不希望平均是0，這樣可以讓hidden layer的output平均不是0</strong>。gama是全部都是1的向量，beta是全部都是0的向量，這樣一開始訓練的時候每個dimention的分布比較平均。</p><div class="note info flat"><p>問題：Batch normalization 怎麼在 testing 的時候運作？因為testing的時候沒有batch，就沒辦法計算平均值跟標準差。</p></div><p><img src="https://i.imgur.com/iziqNgH.png" alt=""><br>因此這時候會會談到 Moving Average (移動平均)，在Trainning的時候，每次計算完一次batch的平均值跟標準差，就會更新一次 Moving Average，把現在算出來的平均值*p，加上1-p公式如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover><mo>←</mo><mi>p</mi><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><msup><mi>y</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">\bar{u} \gets p\bar{u}+(1-p)y^{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5678em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></p><p>那在<strong>訓練的時候，直接拿Moving Average的平均值跟標準差來做batch normalization即可</strong>。</p><blockquote><p>結果<br><img src="https://i.imgur.com/9y9uccI.png" alt=""></p></blockquote><h1 id="Overfitting">Overfitting</h1><p><img src="https://i.imgur.com/Ck5jTMb.png" alt=""></p><ul><li>Overfitting 就是你的 model 在 training data 上表現得很好，但是在 testing data 上表現得很差。</li><li>你可以從上圖看到，vlidation accuracy在某個epoch開始下降。</li></ul><p><img src="https://i.imgur.com/0NZ1OxN.png" alt=""></p><ul><li>Validation Data Set 驗證數據：集用於內部調整和評估模型的訓練過程。驗證數據集在訓練過程中使用，通常是在每個訓練週期（epoch）結束後，用來評估模型的性能。</li><li>Test Data Set 測試數據集：用於最終評估模型的性能，以確保它對新數據的泛化能力。</li></ul><p>training 結果好但training 結果不好時該怎麼辦呢？有三個作法如下：</p><ol><li>Early Stopping</li><li>Dropout</li><li>Regularization</li></ol><h2 id="Early-Stopping">Early Stopping</h2><p><img src="https://i.imgur.com/q3PniQa.png" alt=""></p><ul><li>如果 learning rate 調整得好，Loss會變小，但是有可能導致Testing data的Loss變大，這時候就需要Early Stopping。</li><li>理想上，如果我們知道 Testing Data Loss 的變化，我們應該要想辦法<strong>找到 Testing Loss最小的時候停下來</strong>。</li><li>但是<code>實際上我們無法知道 Testing Set(有label的data set)</code><ul><li>所以我們會使用 Validation Set來進行驗證。</li><li>也就是說，我們會<strong>把 Training Set 分成 Training Set 和 Validation Set</strong>，然後在 Training Set 上訓練，並在 Validation Set 上驗證，找到 Validation Loss 最小的時候停下來。</li></ul></li></ul><h2 id="Regularization">Regularization</h2><div class="note info flat"><p>重新定義了原本的Minimized的Loss function，透過在原本的 Loss Function (e.g. Minimize square error, cross entropy)添加上「Regularization term」，來達到防止 overfitting 的效果。</p></div><p><img src="https://i.imgur.com/Bdiqb9p.png" alt=""></p><ul><li>Regularization Term<ul><li>他就是添加了 <code>||theta||</code>，這是每一個參數的平方相加(稱為L2 Regularization)，如果不平方就是L1 Regularization。</li><li>一般來說不會考慮 bias，因為加入 Regularization 的目的是為了讓function平滑，bias跟function的平滑程度沒有關係，所以不會考慮進去。</li></ul></li></ul><h3 id="How-to-do-Regularization">How to do Regularization?</h3><p><img src="https://i.imgur.com/iCrRsDt.png" alt=""></p><ul><li>新的 Loss function進行偏微分：<ul><li>update 是原本參數 - learning rate * 偏微分後的結果。</li><li>你會發現每次 update 參數的時候，會把weight減少一點，也就是 learning rate 乘上 lemda，這兩個數都 &lt; 1，因此你會發現每次 update 的時候，w 都是乘上一個小於 1 的值，使得整個 <code>(1- learning rate * lemda)*wt</code>會隨著更新的次數增加而遞減至0。這叫做 <code>weight decay</code>。</li><li>但是越靠近0會使整個w變成0？不會，因為還有後面微分的部分。</li></ul></li></ul><p><img src="https://i.imgur.com/WTd6044.png" alt=""></p><ul><li>絕對值怎麼微分？<ul><li>他是一個V型的圖像，所以微分後會有兩個值，一個是1，一個是-1，而0無法微分就無視或隨便找個數字替代即可，所以就是sgn。</li></ul></li><li>sgn 就是 w &gt; 0 就是 1，w &lt; 0 就是 -1，= 0 就是 0。</li><li>compare with L2 vs L1 ?<ul><li>L1: always delete something，減掉的值都是固定的，所以當w很大的時候，其實檢調固定的值影響不大，因此train出來的結果很多接近0的值，也有很大的值。</li><li>L2: always multiple something smaller than 1，減掉的值會隨著w大小改變（乘上&lt;1的值），train出來的結果會平均的比較小。</li></ul></li></ul><h2 id="Dropout">Dropout</h2><p><img src="https://i.imgur.com/gqNoDQW.png" alt=""></p><div class="note info flat"><p>在training更新參數之前，每個neuron有p％的幾率被丟掉。他就像是每次 train 都是新的 network，所以總共做了 2^N 種不同的 network。</p></div><p><img src="https://i.imgur.com/ArlhR3J.png" alt=""></p><ul><li>可能導致performance變差，但他的目地是為了讓testing結果變好。</li><li>training用dropout，testing 不用 dropout</li></ul><h3 id="How-to-do-dropout">How to do dropout?</h3><p><img src="https://i.imgur.com/3rOdy4W.png" alt=""><br><img src="https://i.imgur.com/2eSN0c3.png" alt=""></p><ul><li>為什麼會需要在 training 的時候反而要將所有 weight 乘上 1-p 是為了讓 testing 時所使用的 weight 接近沒有 dropout 的 training。</li><li>如果不乘上 1-p 會導致 testing 時的 weight 會比 training 時的 weight 大（如果p=0.5，就會大兩倍1/0.5），這樣會導致 testing 時的結果變差。</li></ul><h3 id="Why-dropout-solve-overfitting">Why dropout solve overfitting?</h3><p><img src="https://i.imgur.com/L0ydgyD.png" alt=""></p><ul><li>Training<ul><li>他類似一個終極 Ensemble 方法。</li><li>Ensemble 就是 <code>train 很多個 model，每個 model 平均起來當做最後的結果</code>，類似 Random forest</li><li>每一次更新參數時都會產生新的 network，就有點像是使用了各種不同的 2^n 種network，然後把他們平均起來，這樣就可以避免 overfitting。</li></ul></li></ul><h3 id="Why-not-use-dropout-in-testing">Why not use dropout in testing?</h3><p><img src="https://i.imgur.com/jf67zvl.png" alt=""></p><ul><li>Testing 為什麼不跟 training 一樣做 dropout 呢？<ul><li>因為這一把 network 太多了，沒辦法每次都 input進去再看 output 然後再平均起來，這樣會太花時間。</li><li>但是<strong>如果完整的 network 不做 dropout，但是把 weight 乘上 1-p% 的結果是相近的</strong>。（但是這僅限於Linear Network 才適用）</li><li>因此如果使用接近 Linear 的 Network 時，像是 ReLU，Performance 會比較好。</li></ul></li></ul><h1 id="Transfer-Learning">Transfer Learning</h1><ul><li>Ref: <a href="https://youtu.be/qD6iD4TFsdQ?si=F_Q8-xvBCUaFccMX">Transfer Learning in PyTorch</a></li></ul><div class="note info flat"><p>因為我們沒有大量的資料，因此我們可以透過 Transfer Learning 就是使用別人訓練好的 model，然後再依據此使用自己的 data set 近一步訓練。</p></div><p>Transfer Learning 主要可以分成四個不同的象限來討論：</p><ul><li>Target Data: 與我們的Task有直接相關（訓練目標），有可能是有Label或是沒有的。</li><li>Source Data: 與我們的Task沒有直接相關（無關的資料），有可能是有Label或是沒有的。</li></ul><h2 id="TargetData-Label-SourceData-Label">TargetData Label &amp; SourceData Label</h2><h3 id="Fine-Tuning">Fine-Tuning</h3><div class="note info flat"><p>如果你的target data很少，source data 很多，這可以說是 one-shot learning。</p></div><p><img src="https://i.imgur.com/9p8Of7L.png" alt=""></p><ul><li>Source Data: 很多，先利用source data當作初始的值。</li><li>Target Data: 很少，再利用target data來微調。</li><li>注意：但是要很小心，可能會發生overfitting。</li></ul><h4 id="Conservative-Training">Conservative Training</h4><p><img src="https://i.imgur.com/8eTjv2p.png" alt=""></p><ul><li>Source Data: 很多 speaker 的聲音。</li><li>Target Data: 特定 speaker 的聲音。</li><li>training 的時候下一些限制（Regulization） 透過 Regulization L1 或是 L2 的方式，讓新的 model 和 舊的 model 其 output 不要差異太大，防止 overfitting。</li></ul><h4 id="Layer-Transfer">Layer Transfer</h4><div class="note info flat"><p>用 source data train 好一個 model，把某幾個layer copy 到新 model 裡面，然後 source data 只去 train 沒有 copy 的 layer。</p></div><p><img src="https://i.imgur.com/cL6pvre.png" alt=""></p><ul><li>model 某幾個 layer 直接複製到新的model</li><li>接下來用 source data 只去 train 沒有 copy 的 layer。？？</li><li>如果你覺得data夠通，最後也可以fine-tune整個model</li></ul><p><strong>Ｑ：哪些Layer應該被Trasnfer？</strong></p><ul><li>影像辨識通常是 copy 前面幾層，在 Nerual Network 前面幾層用是學習到一些基本的特徵，後面幾層是學習到一些複雜的特徵。</li><li>聲音辨識通常是 copy 後面幾層，後面幾層是根聲音沒有關係，所以可以copy; 但是前面聲音訊號到發音方式每個人不一樣。</li></ul><h1 id="Object-Detection">Object Detection</h1><ul><li>ref: <a href="https://youtu.be/c1l0mHO5CBA?si=a1mzYmn-Wwbopor7">1.1基於tensorflow的faster rcnn物體鑑測概述</a></li><li>ref: <a href="https://youtu.be/4aAkJCxjzRU?si=waJ0FwOEZ-elzSsA">1.2基于faster rcnn的 深度学习经典检测方法</a></li><li>ref: <a href="https://youtu.be/YKaa1RHmff8?si=9d-tlD8O_5Oi8qIP">1.3faster rcnn概述</a></li></ul><div class="note info flat"><p>Object Detection 就是要找出圖片中的物件，並且要知道物件的位置。</p></div><p><strong>What is Sliding Window?</strong></p><ul><li>他是一個 window，這個 window 會在圖片上移動，然後在每個位置都會做一次辨識，檢查裡面有沒有物件。</li><li>但是這樣會有很多問題，因為你不知道物件的大小，也不知道物件在圖片的哪個位置，因此你會需要很多不同大小的 window，然後在圖片上移動。</li></ul><p><strong>Selective Search?</strong></p><ul><li>如果一個個Sliding Window做辨識，會花很多時間，因此有人提出了Selective Search的概念。</li><li>他會先找出圖片中的一些區域，潛在可能是物體的候選框，大概可能會產生約2k左右。</li></ul><h2 id="R-CNN">R-CNN</h2><div class="note info flat"><p>就是做 Bbox Reg 線性回歸，然後做 SVMs 分類。</p></div><p><strong>步驟</strong></p><ul><li>把候選框拿出來</li><li>作捲積</li><li>再把卷積做好的特徵放到SVMs跟Bbox reg的分類器當中</li></ul><p><strong>問題：速度太慢了</strong></p><ul><li>Q1: 每個框，都要自己構造一個網路，無法共享一個捲積，因為fully connection layer 要保持 input 大小的一致，但是候選框大小不一樣。</li><li>Q2: 使用SVMs太慢了，花了84小時</li></ul><h2 id="使用SPP-net">使用SPP-net</h2><div class="note info flat"><p>為了解決都要自己構造一個網路，<code>無法共享一個捲積的問題</code>，Spatial Pyramid Pooling Layer透過通過一個pooling layer，把<code>不同大小的特徵圖拼接再一起形成一個新的特徵</code>，這樣就可以執行fully connection layer。</p></div><p><img src="https://i.imgur.com/unumRh1.png" alt=""></p><ul><li>feature maps of conv: arbitrary size 任意大小</li><li>把任意大小的size做 SPP (pooling layer)</li><li>pooling 後的不同大小拼接再一起，形成一個新的特徵，但是大小是固定的。</li></ul><h2 id="Fast-R-CNN">Fast R-CNN</h2><div class="note info flat"><p>跟第一代算法的區別：跟R-CNN不同，R-CNN是透過候選框，一個個判斷。但是Faster R-CNN是先把整個圖片放入CNN，然後再去透過特徵找候選框。</p></div><p><img src="https://i.imgur.com/1JxmWGM.png" alt=""></p><p><strong>步驟</strong></p><ol><li>Regions of Interest (RoIs)：但是Faster R-CNN 先對整個圖片執行捲積層操作，在特徵圖上找對有興趣的對應框，以此回去看整個圖片對應到的位置。</li><li>RoI Pooling Layer: 有點像是SPP-net得到一個固定的特徵大小，以連接fully-connected layer</li><li>Linear Classifier &amp; Bounding Box Regressors: 最後辨識物體，跟框出物體的位置。</li></ol><div class="note warning flat"><p>問題：RoIs 產生一個個潛在區域還是很慢</p></div><p><strong>R-CNN vs SPP vs Fast R-CNN</strong><br><img src="https://i.imgur.com/v7drAIO.png" alt=""></p><ul><li>Including Region Proposals: 產生一個候選框所需的時間</li><li>Excluding Region Proposals: 選擇不處理候選框所需的時間</li><li><code>結果 Fast R-CNN的時間還是取決於Region Proposal的方法</code></li></ul><h2 id="Faster-R-CNN">Faster R-CNN</h2><div class="note info flat"><p>Faster R-CNN 就是把 Region Proposal Network (RPN:找出圖像中可能的邊界框) 加入 Fast R-CNN，讓他可以一起訓練。<strong>他先做二元分類、再做多元分類</strong>。</p></div><p><img src="https://i.imgur.com/2aPdqho.png" alt=""></p><ul><li>多了 Region Proposal Network (RPN) 邊迭代邊自動產生候選框，當地一個候選框產生的時候…<ul><li>先做二分類<ul><li>Classification Loss: 先做二元分類，看這個候選框是不是物體，是前景還是背景</li><li>Bounding-Box Regression Loss: 再做Bbox Reg，找出物體的位置</li></ul></li><li>再做多分類<ul><li>Classification Loss: 再來辨識該物體是什麼</li><li>Bounding-Box Regression Loss: 再來找出物體的位置</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/LsywKgU.png" alt=""></p><ul><li>這樣的結果是可以1s執行五個圖像</li></ul><h2 id="Yolo">Yolo</h2><ul><li>ref:<a href="https://youtu.be/OuutT-XrvP0?si=UhRBv9-GuXqQXBz_">Deep Learning - Yolov5 (1) 簡介及架構說明</a></li><li>ref: <a href="https://hackmd.io/@allen108108/r1-wSTAjS?utm_source=preview-mode&amp;utm_medium=rec">[論文] You Only Look Once : Unified, Real-Time Object Detection</a></li><li>ref: <a href="https://medium.com/ching-i/yolo-c49f70241aa7">YOLOv4 訓練教學 - 李謦伊 Medium</a></li></ul><div class="note info flat"><p>YOLO (You only look once) 是一個 one-stage 的 object detection 演算法，透過將整個影像輸入只需要一個 CNN 就可以一次性的預測多個目標物位置及類別。將物件偵測視為一個回歸任務，來從空間中分割出邊界框 ( Bounding Box )並且計算出類別機率。僅利用一個神經網路CNN 進行一次計算來直接「預測邊界框」及「類別機率」，也因為整個偵測過程只有使用單一個神經網路，因此可以視為是一個 End-to-End 的優化過程。</p></div><p><strong>Yolo 的版本介紹</strong></p><ul><li><code>The original Yolo</code>: 把畫bbox跟辨識物體的工作放在一起做。</li><li><code>Yolo v2</code>：基於original添加<code>BatchNorm</code>, <code>higher resoultion</code>, <code>anchor boxes</code>.</li><li><code>Yolo v3</code>：添加objectness score來評估bbox的好壞，objectness score是一個0~1的數值，越接近1表示越像物體，越接近0表示越不像物體。小的物件檢測的準確度提升。</li><li><code>Yolo v4 &amp; v5</code>（最近的版本，2020相差兩個月，v5網路比較小）<ul><li>v4 使用 Cross Stage Partial Network (CSP)來防止gradient vanishing。</li></ul></li></ul><p><img src="https://i.imgur.com/aQSMFA0.png" alt=""></p><p><strong>作法</strong><br><img src="https://i.imgur.com/5W5eWFj.png" alt=""></p><ol><li>將輸入的影像切割成 SxS 的網格 (grid)</li><li>若被偵測物體的中心落入某個網格內，這個網格就要負責去偵測該物體。</li><li>而每個網格要負責預測B個 bounding boxes (在 YOLO 的設計中，YOLOv1: B=2, YOLOv2: B=5, YOLOv3: B=3) 和屬於各別類別的機率 (假設有C個類別)，其中對每個 bbox 的預測會輸出5個預測值: x, y, w, h 以及 confidence。</li></ol><ul><li>x, y 代表該bndBox的中心座標與圖片寬高的比值，是bndBox歸一化後的中心座標</li><li>w, h代表該bndBox的寬高與輸入圖像寬高的比值，是bndBox歸一化後的寬高座標</li><li>confidence代表bndBox與Ground Truth的IOU值</li></ul><p><strong>主要架構</strong>：</p><ol><li>Backbone：不段做convolution，形成 feature map。<ul><li>通常會使用 pre-trained model，例如 CSPResNet50、CSPDarknet53、EfficientNet-B3。再由新的訓練樣本慢慢調整。</li></ul></li><li>Neck：放在backone和head之間，由一系列layer組成，將 backbone 所取得的 feature 執行 mix and combine 的動作，然後送到 prediction。</li><li>Head：獲取網路輸出內容的網路，利用之前提與的特徵，繪製 bbox 跟 class 的預測。</li></ol><p><strong>關於CSP (Cross Stage Partial Network)</strong>：</p><ul><li>目的：在Yolo v4中使用了Cross Stage Partial Network (CSP)，一個基於DenseNet的模型，可以有效的防止gradient vanishing。</li></ul><p><strong>關於FPN (Feature Pyramid Network)</strong>：</p><ul><li>目的：他是一個feature extractor，利用feature maps的概念，辨識出比較小的物件。</li><li>缺點：很耗時，對記憶體要求高。</li></ul><h1 id="Image-Segmentation">Image Segmentation</h1><ul><li>Ref: <a href="https://medium.com/ching-i/%E5%BD%B1%E5%83%8F%E5%88%86%E5%89%B2-image-segmentation-%E8%AA%9E%E7%BE%A9%E5%88%86%E5%89%B2-semantic-segmentation-1-53a1dde9ed92">影像分割 Image Segmentation — 語義分割 Semantic Segmentation(1)</a></li><li>Ref: <a href="https://kknews.cc/code/95q8rzl.html">一文看懂反卷積層</a></li></ul><p><img src="https://i.imgur.com/cVkfrIn.png" alt=""></p><ul><li><strong>Image classification</strong>: <code>判別一個圖片有哪些物體</code>，但是不知道物體的位置。</li><li><strong>Object detection</strong>: 判別一個圖片有哪些物體，並且知道物體的<code>位置會匡列</code>出來。</li><li><strong>Instance Segmentation 實例分割</strong>: 可以清楚<code>描繪出物體的輪廓</code>，並且知道物體的位置。</li><li><strong>Semantic Segmentation 語意分割</strong>: 可以清楚描繪出物體的論闊，針對圖像中所有像素點進行分類，但是<code>無法辨別同一類別不同物體</code>。</li></ul><h2 id="Semantic-Segmentation-U-Net">Semantic Segmentation: U-Net</h2><ul><li><a href="https://arxiv.org/abs/1505.04366">https://arxiv.org/abs/1505.04366</a></li></ul><p><img src="https://i.imgur.com/8laTgKf.png" alt=""><br>U-Net 基於 Encoder-Decoder 結構，主要應用於醫學影像分割。Encoder (U-Net 稱為 contracting path) 負責提取特徵、Decoder (U-Net 稱為 expansive path) 則是用於 upsampling，網路架構形似 U。此外，經過上採樣後會與 contracting path 進行 concat，不過 contracting path 特徵圖的尺寸較大需要經過 crop 裁剪。</p><h2 id="Instance-Segmentation-SegNet">Instance Segmentation: SegNet</h2><p><img src="https://i.imgur.com/s2dwXTH.png" alt=""><br>SegNet 結構與 DeconvNet 類似，不同的是去除了中間的 1x1 卷積層，為了降低記憶體使用及提升推理速度，主要應用於場景理解。由上圖可以看到 SegNet 的網路架構：</p><ul><li>Encoder 用於提取特徵</li><li>Decoder 則是將特徵圖做 upsampling</li></ul><h2 id="Evaluation-Metrics">Evaluation Metrics</h2><ul><li>以下圖片取自：<a href="https://medium.com/ching-i/fully-convolutional-networks-%E8%AB%96%E6%96%87%E9%96%B1%E8%AE%80-246aa68ce4ad">https://medium.com/ching-i/fully-convolutional-networks-論文閱讀-246aa68ce4ad</a><br>介紹 Semantic Segmentation 的評估指標，主要建立於 Confusion Matrix的基礎之上(TP, FP, FN)：<br><img src="https://i.imgur.com/tiRNvkq.png" alt=""><br><img src="https://i.imgur.com/qaIn1qP.png" alt=""><br><img src="https://i.imgur.com/VNtD1yj.png" alt=""></li></ul><h1 id="NLP">NLP</h1><ul><li><a href="https://leemeng.tw/shortest-path-to-the-nlp-world-a-gentle-guide-of-natural-language-processing-and-deep-learning-for-everyone.html">https://leemeng.tw/shortest-path-to-the-nlp-world-a-gentle-guide-of-natural-language-processing-and-deep-learning-for-everyone.html</a></li><li>實作nlp-lstm: <a href="https://peaceful0907.medium.com/%E4%BE%86%E7%8E%A9%E9%BB%9Enlp-lstm-vs-bert-on-imdb-dataset-4aa18ecd65e2">https://peaceful0907.medium.com/來玩點nlp-lstm-vs-bert-on-imdb-dataset-4aa18ecd65e2</a></li><li></li></ul><h1 id="RNN-Recurrent-Neural-Network">(RNN) Recurrent Neural Network</h1><ul><li>ML Lecture 21-1: Recurrent Neural Network (Part I):<a href="https://www.youtube.com/watch?v=xCGidAeyS4M">https://www.youtube.com/watch?v=xCGidAeyS4M</a></li></ul><p><strong>為什麼會需要RNN?</strong><br>我們先來看一個例子，如果要把一個句子，放入 Neural Network 來辨識其意義：</p><ul><li>Input: “Arrive Taipei on November 2nd”</li></ul><p>我們希望他辨識出 Taipei 是一個 destination</p><ul><li>Output: <code>&#123;Taipei: destination&#125;</code></li></ul><p>那這必須解決以下問題：</p><ol><li>我們需要把 Taipei 轉換成一個 向量<ul><li>可以使用 one-hot-encoding</li><li>或是 1-of-n-encoding，n 表示為字典的大小，e.g. n=3切割 Taipei，就會看aaa, aab, tai, aip, ipe, … 轉換成 0,0,1,1,1…來構成Taipei這個單字。</li></ul></li><li>但是這出現第二個問題，<ul><li>如果改成句子例&quot;Leave Taipei on November 2nd&quot; 這時候的 Taipei 不是 destination，而是 place of departure。</li><li>我們希望模型可以學習出現過的字&quot;arrive&quot;參考上下文，來判斷出這時候的taipei已經不是destination。</li></ul></li></ol><div class="note info flat"><p>RNN 是一種有記憶的Neural Network，稱做 Recurrent Neural Network，每一層產生的output都會存到 memory，下一層的input會加上上一層的output，這樣就可以記住之前的資訊。</p></div><p><strong>RNN的運作原理</strong><br><img src="https://i.imgur.com/Wgj0fGt.png" alt=""></p><ul><li>因為是第一筆input，沒有前一筆資料，因此我們可以給初始值0</li><li>然後開始計算，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">2=1+1+0+0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>(黃色跟藍色相加)，最後得到output <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>=</mo><mn>2</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">4=2+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>(綠色)</li><li>並且於下一步把 hidden layer 的 neuron output 值儲存，也就是將綠色的 neuron 值 2 儲存</li></ul><p><img src="https://i.imgur.com/Vv2Utec.png" alt=""></p><ul><li>然後開始計算這時考慮到之前的值2（綠色，hidden layer output），得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>=</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">6=2+2+1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最後得到output <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>=</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">12=6+6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span></li><li>並且於下一步把 hidden layer 的 neuron 值儲存，也就是將綠色的 neuron 儲存</li></ul><div class="note info flat"><p>總結，你會發現 <strong>RNN 會考慮 input 的 order</strong>，如果把<code>[2,2]</code>移動到前面，很顯然的綠色的內容一定會改變(hidden layer output改變)，導致後面的output也會改變。</p></div><p><img src="https://i.imgur.com/HrZrlTT.png" alt=""><br>也因此，當我們放進去 <code>Arrive Taipei on November 2nd</code> 時，Arrive 的output會影響到 Taipei 的output，<strong>這讓 Arrive 跟 Taipei 產生關聯</strong>，因此可以判斷出 Taipei 是 destination。</p><p><strong>RNN 的三個缺點：</strong><br>但是傳統RNN也是有一些問題</p><ul><li><code>訓練速度慢</code>：由於 RNN 是順序進行的，難以並行處理以加快訓練速度。</li><li><code>梯度消失或梯度爆炸</code>：梯度消失指多個小於一的梯度相乘，導致接近零，無法有效更新權重；梯度爆炸則是多個大於一的梯度相乘，導致結果過大。使用 ReLU 等非線性激活函數和 LSTM 等 RNN 變體可以解決此問題。</li><li><code>難以處理長期依賴性</code>：在長序列中，RNN 可能難以捕捉遠處元素之間的關聯，導致漏掉重要信息。LSTM 能夠解決這個問題。</li></ul><h2 id="Elman-v-s-Jordan-Network">Elman v.s Jordan Network</h2><p><img src="https://i.imgur.com/KUQrBbv.png" alt=""></p><ul><li>Elman Network: 他的 hidden layer 的 input 是來自於<strong>上一層的 hidden layer 的 output</strong>。</li><li>Jordan Network: 他的 hidden layer 的 input 是來自於<strong>上一層的 output</strong>。（有人說此效果比較好）</li></ul><h2 id="Bidirectional-RNN">Bidirectional RNN</h2><p><img src="https://i.imgur.com/3Em8uRq.png" alt=""></p><ul><li>可以<em>同時train正向跟逆向的RNN，把這兩個RNN的hidden layer output相加</em>，就可以得到最後的output。</li><li>好處是，<strong>他看的範圍比較廣，他是看了整個句子，而不是只看前面的字</strong>。</li></ul><h2 id="LSTM">LSTM</h2><div class="note info flat"><p>RNN 只要有新的 input 進來，使用完上一個 memory 後，內容就會被洗掉，而 LSTM 則是可以記得比較長，<strong>關鍵在於gate</strong>：</p><ul><li><em>先通過input gate，才可以寫道memory裡面，所以有可能存在memory裡面的是很前面的字</em>。</li><li>output 則是要通過 gate 讀控制才能取得。</li><li>forget gate 何時要把過去記得的東西忘記</li></ul><p>這個gate何時打開關閉是Neural Network自己學到決定的。但是他跟一般的Neural Network感覺不太一樣，這樣還叫做Neural Network嗎？<br><strong>其實，你只要想像Memory中的值就是一個Neuron，那這個LSTM就是一個Neural Network。</strong></p></div><p><img src="https://i.imgur.com/CA4mkvG.png" alt=""><br>LSTM 有四個 input 和 一個 output，四個inputs分別為：</p><ol><li>input</li><li>操作input gate 的訊號: 是否要收錄input的值？</li><li>操作forget gate 的訊號:  是否要忘記memory的值？</li><li>操作output gate 的訊號: 是否要輸出output的值？</li></ol><p><strong>LSTM的簡單範例</strong><br><img src="https://i.imgur.com/0YPS7Ka.png" alt=""><br><img src="https://i.imgur.com/CJOUTOP.png" alt=""></p><p><strong>運作原理Simplfy</strong><br><img src="https://i.imgur.com/fk3KLR0.png" alt=""></p><ol><li>Input (z) 先經過 activation function (g(x)) 得到 ⇒ g(z)</li><li>g(z) 經過 input gate，如果 input gate 是打開的 f(z) ⇒ g(z)*f(z)</li><li>g(z)*f(z) 經過 forget gate，如果 forget gate 打開，把結果存入 ⇒ c’= g(z)*f(z)</li><li>c’ 經過 activation function (h(x)) 得到 ⇒ h(c’)</li><li>h(c’) 經過 output gate，如果 output gate f(z) 打開，最後output ⇒ h(c’)*f(z)</li></ol><p><img src="https://i.imgur.com/1iVgXng.png" alt=""><br><img src="https://i.imgur.com/JVKRvR6.png" alt=""></p><ul><li>z 是的input經過transform的值，其dimension是LSTM中cell（存memory）的數目</li><li>z_i 是x乘上另一個transform，每個dimension分別操控不同的input gate。</li><li>z_f 是x乘上另一個transform，每個dimension分別操控不同的forget gate。</li><li>z_o 是x乘上另一個transform，每個dimension分別操控不同的output gate。</li><li>上述的 z 都是 vector 的形式。</li><li>執行以下步驟<ol><li>z_i 通過 activation function 與 z 相乘。</li><li>通過 activation function 的 z_f 與 memory 相乘。</li><li>step 1 + step 2 的結果。</li><li>z_o 聽過 activation function 與 step 3 的結果相乘，最後得到output y。</li></ol></li></ul><p><strong>真正的LSTM</strong><br><img src="https://i.imgur.com/nOjfdSC.png" alt=""></p><p><strong>一般NN跟LSTM的差異</strong></p><ul><li>LSTM 需要 4 個 input 才能產生 1 個 output ，參數量是一般 NN 的 4 倍。</li><li>現在基本上RNN就是LSTM。</li></ul><h3 id="BiLSTM">BiLSTM</h3><ul><li>ref: <a href="https://blog.csdn.net/qq_45556665/article/details/127685988">CSDN | BiLSTM 詳解</a></li></ul><p>BiLSTM 全稱 Bi-directional Long Short Term Memory，由前向LSTM與後向LSTM組成，為什麼需要BiLSTM是因為如果只有LSTM，他是由前往後的，但是有時候我們需要考慮到後面的字。舉例來說，句子『我不覺得他好』這裡的『不』是對後面的『好』進行否定，因為LSTM可以記住比較常距離的字，因此可以判斷出這個句子是貶義的。但是因為LSTM無法得到從『後面到前面』的信息，在進行更細顆粒度的分類，像是想要知道貶義的程度，<em>例如『這個餐廳髒的不行，沒有隔壁好』這裡的『不行』是對『髒』的程度的一種修飾，這種由後往前的信息是LSTM無法得到的，因此需要BiLSTM</em>。</p><p><strong>BiLSTM是如何運作的？</strong><br><img src="https://i.imgur.com/5hovLv5.png" alt=""><br>我很喜歡<a href="https://blog.csdn.net/qq_45556665/article/details/127685988">CSDN | BiLSTM 詳解</a>這篇的說明，所以我取用他的圖片來說明：</p><ol><li><code>向前的LSTM</code>: 依序輸入『我』『愛』『你』得到三個向量分別是 {<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>L</mi><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{L0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>L</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{L1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>L</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{L2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}</li><li><code>後向的LSTM</code>: 依序輸入『你』『愛』『我』得到三個向量分別是 {<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>R</mi><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{R0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>R</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{R1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>R</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{R2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}</li><li><code>前後項的hidden layer向量拼接</code>：{[<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>L</mi><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{L0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>R</mi><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{R0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>], [<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>L</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{L1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>R</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{R1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>], [<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>L</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{L2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">L</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mrow><mi>R</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">h_{R2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>]} 得到 {<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">h_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">h_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}，這樣就可以得到前後項的資訊。</li></ol><h1 id="RvNNs-Recursive-Neural-Networks">(RvNNs) Recursive Neural Networks</h1><p>RvNN 概括了 RNN。由於其樹狀結構，它們可以<em>學習hierarchical models，而不是只能處理順序資料的 RNN</em>。樹中每個節點的<em>子節點數量是固定</em>的，以便它可以執行遞歸操作並在步驟中使用相同的權重。</p><p><strong>運作原理</strong></p><ul><li>RvNN 的樹結構意味著為了<em>組合子節點並產生其父節點</em>，每個子父連接都有一個權重矩陣。</li><li>相似的子節點權重相同。換句話說，考慮一棵二元樹，所有右子節點共享一個權重矩陣，所有左子節點共享另一個權重矩陣。</li><li>此外，我們需要一個初始權重矩陣 (v) 來計算每個原始輸入的隱藏狀態。</li></ul><p><img src="https://i.imgur.com/abwgJtk.png" alt=""></p><p><strong>實際應用</strong><br>在自然語言處理中，RvNNs 的一個主要應用是對自然語言句子進行句法分析。</p><p>當進行句法分析時，我們希望識別句子的較小組成部分，例如名詞或動詞短語，並將它們組織成句法層次結構。由於 RNNs 只考慮連續關係，與 RvNNs 相比，它們較不適合處理層次化數據。假設我們想要捕捉這句話中短語“a lot of fun”的表示：<code>Programming is a lot of fun.</code>當我們的 RNN 處理單詞 fun 時，該時間步的隱藏狀態將表示整個句子。相反，RvNNs 的層次結構可以存儲準確短語的表示：<code>a lot of fun</code> 就已經在節點 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>a</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>t</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>f</mi><mi>u</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{a\ lot\ of\ fun}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">t</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mspace mtight"><span class="mtight"> </span></span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 的隱藏狀態中。<br><img src="https://i.imgur.com/h8CVYgr.png" alt=""></p><p><strong>問題</strong></p><ul><li>分析可能會變得緩慢和模糊。特別是，對於單個句子可能存在多個解析樹。</li><li>此外，為 RvNNs 標記訓練數據比構建 RNNs 更耗時且需要更多勞動力。手動將序列解析為較小的組件比為序列分配標籤需要更多的時間和精力。<br><img src="https://i.imgur.com/zE9XvH7.png" alt=""></li></ul><h1 id="Word-Embedding">Word Embedding</h1><ul><li><a href="https://youtu.be/X7PH3NuYW0Q?si=VpsrrK1fMJd7PXOy">ML Lecture 14: Unsupervised Learning - Word Embedding</a></li><li><a href="https://leemeng.tw/attack_on_bert_transfer_learning_in_nlp.html">進擊的 BERT：NLP 界的巨人之力與遷移學習</a></li><li><a href="https://www.youtube.com/watch?v=UYPa347-DdE">Hung-yi-lee ELMO, BERT, GPT</a>：有提到Wording Embedding。</li><li><a href="https://youtu.be/viZrOnJclY0?si=oP-oOIOf3rjCgxq0">Youtube StatQuest | Word Embedding and Word2Vec, Clearly Explained!!!</a>：簡單明瞭有趣的影片說明。</li><li><a href="https://medium.com/@mervebdurna/advanced-word-embeddings-word2vec-glove-and-fasttext-26e546ffedbd">Medium | Advanced Word Embeddings: Word2Vec, GloVe, and FastText</a>：很好的說明這三種 word embedding 的差異。</li></ul><p><img src="https://i.imgur.com/6jcIj0x.png" alt=""></p><ul><li>Word Embedding 類似語意的詞彙在圖上比較接近，所需要的維度也會比1-of-N encoding少很多。</li><li>Word Embedding 是一個 Unsupervised Learning，不需要標籤，只需要大量的文本資料，就可以訓練出一個模型，然後這個模型可以把每個字轉換成一個向量，這個向量可以代表這個字的意思，這個向量就是 word embedding。</li><li><code>問題</code>：問題是你不知道 Unsupervised learning 會產出什麼樣的 output？<ul><li>解決：透過 context 上下文，來學習一個 word 的意思。</li><li>舉例：馬英九 520 宣誓就職 vs 蔡英文 520 宣誓就職，這兩者中的馬英九跟蔡英文後面都接類似的詞彙，因此可以學習到這兩個人的意思是相似的。</li></ul></li></ul><h2 id="特性">特性</h2><ul><li>ref: <a href="https://medium.com/royes-researchcraft/%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80%E8%99%95%E7%90%86-1-word-to-vector-%E5%AF%A6%E4%BD%9C%E6%95%99%E5%AD%B8-99b668faa296">Medium | Word to Vector 實作教學 (理論篇)</a></li></ul><p><img src="https://i.imgur.com/potexfj.png" alt=""><br><img src="https://i.imgur.com/DbQ2XqB.png" alt=""></p><ul><li>Vector(hotter) - Vector(hot) 類似 Vector(bigger) - Vector(big)</li></ul><h2 id="作法">作法</h2><p><strong>Count based</strong><br><img src="https://i.imgur.com/aHgwGI9.png" alt=""></p><p><strong>Prediction based</strong><br><img src="https://i.imgur.com/ueU2zVt.png" alt=""><br><img src="https://i.imgur.com/8nwc2aS.png" alt=""></p><ul><li>透過把 prediction model 的第一層 hidden layer 拿出來，就可以找到 word embedding 的特性。</li></ul><div class="note warning flat"><p>但是這樣就夠了嗎？如果只用 wi-1 去預測 wi 太弱？</p></div><p><strong>Prediction based - Sharing Parameters</strong></p><div class="note info flat"><p>學前面 n 個詞彙，以 input 兩個 word 為例。</p></div><p><img src="https://i.imgur.com/cMZNMZd.png" alt=""><br><img src="https://i.imgur.com/c31OWhe.png" alt=""></p><div class="note warning flat"><blockquote><p>但是如何讓 weight 一樣呢？</p></blockquote><ul><li>只要在做Gradeint Descent，減去彼此的偏微分。<br><img src="https://i.imgur.com/KWqFbxl.png" alt=""></li></ul></div><h2 id="Word2Vec">Word2Vec</h2><p><strong>Word2Vec：Continuous bag of word (CBOW) model, Skip-gram</strong><br>Word2Vec主要有兩種模型：</p><ul><li>CBOW: 用周圍的字預測現在這個字，CBOW的input是Context（預測字的前後文）而Output是現在的字</li><li>Skip-gram: 用現在的字去預測周圍的字，Input是現在的字而Output則是Context。根據Mikolov的論文中提到，就結果來說Skip-gram的結果是比較細膩的，學習到的Vector進行任務驗證的時候準確度比較高。</li><li>問題：這個network不是deep learning，他就只是取 linear 的 hidden layer 的第一層得到 word embedding。<ul><li>作者覺得不用 deep 就可以做得很好，而且更快更有效率，因此就沒有用 deep learning 的方式。</li><li>但是以前的人都是用 deep learning 的方式，但就很慢。<br><img src="https://i.imgur.com/PIv0Gu6.png" alt=""></li></ul></li></ul><p><code>優點</code></p><ul><li>適用於大型dataset</li><li>提供有意義的單詞表示形式</li><li>有效捕獲語意關係<br><code>缺點</code></li><li>在生僻字上可能會有挑戰</li><li>忽略詞序<br><code>應用</code>: 當semantic relationships語意關係重要時，並且你的dataset很大時。</li></ul><h2 id="Glove">Glove</h2><p>與Word2Vec拿周遭來預測字或是拿字來預測周遭不同，Glove是建立一個矩陣，可以知道單字在整個語料庫中出現在另一個單字的機率，每個cell包含在特定上下文中單詞的共現次數。從下圖可以看到？每個 row, column 對應一個整個語料中的唯一單字，而每個 cell 則包含這單字在特定上下文視窗中一起出現的次數。假如W是word，C是context，理想的情況是W.CT(C的Transpose)近似原本的matrix(X)，通過反覆優化調整W與C，最小化X和W.CT之間的差異。</p><p><img src="https://i.imgur.com/PsCYfj4.png" alt=""></p><p>因此對於Glove來說，每個單字所提供的vector不僅僅能捕獲local context，他是針對整個global word的體現。<br><code>優點</code></p><ul><li>可以有效地捕捉全局語義</li><li>比較好的表示詞彙之間的關係<br><code>缺點</code></li><li>需要很多記憶體來儲存co-occurrence matrix</li><li>對於小的語料庫效果不好<br><code>應用</code>: 適用於多樣化的數據，並且對於捕獲全局語義是重要的時候使用。</li></ul><h2 id="FastText">FastText</h2><p>FastText是Facebook AI Research (FAIR)所開發的一種word embedding技術，他擴展了Word2Vec的模型，可以使用CBOW或是Skip-gram架構，但是與Word2Vec不同的是，FastText不僅考慮了單詞本身的特徵，還考慮了單詞的子詞（subword）-- 單詞的一部分（n-grams）。FastText的基本思想是將每個單詞表示為其字符n-gram的平均值，這樣可以捕捉單詞的內部結構，並且可以處理未知單詞處理型態豐富的語言。也因此，它不僅可以根據目標詞預測單詞（CBOW），還可以根據單詞預測目標詞（Skip-gram），甚至使用n-gram來預測單詞。</p><p>簡單來說，FastText除了整個單詞本身之外，透過n-gram的方式把單詞切割成很多小塊，例如&quot;apple&quot;使用n=2切成&quot;ap&quot;, “pp”, “pl”, “le”，這種方法能有效地捕獲較短單詞的含義。更好理解後綴與前綴。</p><p><code>優點</code>：</p><ul><li>更好的表示生僻詞</li><li>能夠處理詞彙量外的單字</li><li>由於子詞的資訊，單詞表示更豐富<br><code>缺點</code>：</li><li>由於n-gram的資訊，模型大小增加</li><li>比word2vec相比訓練時間更長<br><code>應用</code>: 針對型態豐富的語言，或適當處理詞彙外的單詞至關重要時使用。</li></ul><h2 id="ELMO">ELMO</h2><p>是一個RNN的Language Model，不需要標籤，只需要大量的文本資料，就可以訓練出一個模型，然後這個模型可以把每個字轉換成一個向量，這個向量可以代表這個字的意思，這個向量就是 word embedding。</p><p><img src="https://i.imgur.com/0wSfBf5.png" alt=""></p><p>每一層都會給 contextualize embedding，把這些embedding全部加起來，把第一層<em>a1，第二層</em>a2，第三層<em>a3</em>加起來，就可以得到最後的embedding。a1, a2 會根據不同的任務學出不同的weight。</p><h2 id="BERT">BERT</h2><div class="note info flat"><p>他是 Transformer 的 Embedding 不是 RNN，不管相鄰多遠的word對他來說是沒有差的。<br><strong>做的事情給他一個句子，每個句子中的詞彙，都會吐出一個embedding。這個embedding可以代表這個詞彙的意思。</strong></p></div><p><strong>Masked LM</strong><br>訓練Bert的方法：Masked LM 交給 Bert 的句子中，隨機有 15% 的詞彙會替換成 <code>[Mask]</code>的Token，你會蓋掉一個句子15%的詞彙。然後讓 Bert 去預測這個詞彙是什麼。</p><p>Bert 怎麼填回來的？<br><img src="https://i.imgur.com/bzB5CRW.png" alt=""></p><p><strong>Next Sentence Prediction</strong></p><ul><li>目的：預測這兩個句子是不是連續的。Output出 Yes, No。</li><li>特殊Token<ul><li><code>[SEP]</code> 來代表兩個句子的斷句位置。</li><li><code>[CLS]</code> 來代表這個句子的開頭，要做分類的意思。</li></ul></li><li>Masked 跟 Next Sentence Prediction 一起訓練，讓他可以學習到更多的東西。</li></ul><p><img src="https://i.imgur.com/UU5vd63.png" alt=""></p><h2 id="Use-Case">Use Case</h2><p><strong>丟入一個句子，分類這個句子是什麼類型？經濟？政治？…</strong><br><img src="https://i.imgur.com/Npt0lp8.png" alt=""></p><p><strong>丟入一個句子，句子每個詞彙是什麼類型</strong><br><img src="https://i.imgur.com/lwR1kwf.png" alt=""></p><p><strong>丟入兩個句子，output一個class - Natural Language Inference</strong></p><ul><li>給一個前提，跟一個假設，然後要判斷這個假設是不是Ture, False, Don’t know。<br><img src="https://i.imgur.com/tA7Gy8J.png" alt=""></li></ul><p><strong>給句子，然後問問題：Extraction-based Question Answering</strong><br><img src="https://i.imgur.com/17yCdUI.png" alt=""></p><h1 id="Transformer">Transformer</h1><ul><li><a href="https://youtu.be/n9TlOhRjYoc?si=1t8NVnDfUW3NILUc">【機器學習2021】Transformer (上) 說明 Encoder </a></li><li><a href="https://youtu.be/N6aRv06iv2g?si=N6xAd3qEWkimC7xw">【機器學習2021】Transformer (下) 說明 Decoder </a></li><li><a href="https://www.youtube.com/watch?v=ugWDIIOHtPA"> 2019 - Transformer</a></li></ul><h2 id="Seq2Seq">Seq2Seq</h2><p><img src="https://i.imgur.com/3j6BlE1.png" alt=""><br>Transformer 就是一個 Seq2Seq 的模型，input是一個句子，output是另一個句子，這兩個句子的長度可以不一樣，由機器自己決定輸出的文字長度。<br><em>各種NLP的任務都可以使用Seq2Seq的模型來解決</em>，例如：</p><ul><li>例子1：聲音訊號 轉換成 文字，很顯然的這兩個長度不一樣。</li><li>例子2：翻譯，中文轉英文，這兩個長度也不一樣。</li><li>例子3：做一個聊天機器人，像是QA問答，可以透過收集大量的對話實現。<ul><li>input: Question+文章 接在一起當作</li><li>output: Answer</li></ul></li></ul><h3 id="Use-Case-2">Use Case</h3><p><strong>Synntactic Parsing</strong></p><ul><li><a href="https://arxiv.org/abs/1412.7449">論文</a></li></ul><p><img src="https://i.imgur.com/Vsizg39.png" alt=""><br><img src="https://i.imgur.com/sopklbZ.png" alt=""><br>可以把它看成一個樹狀結構，然後<em>把樹狀結構轉成一個Sequence如上圖</em>，就可以套進Seq2Seq的模型中。</p><p><strong>Multi-label/class Classification</strong><br><img src="https://i.imgur.com/gfvyd4E.png" alt=""></p><ul><li>Multi-label Classification: 一個句子<em>可以有多個標籤</em><ul><li>例如：一個句子可以同時有多個情緒，例如：開心跟難過。</li></ul></li><li>Multi-class Classification: 一個句子<em>只有一個標籤</em><ul><li>例如：一個句子只有一個情緒，例如：開心。</li></ul></li></ul><h3 id="原理-Encoder">原理 - Encoder</h3><p><img src="https://i.imgur.com/1Ro4dJO.png" alt=""></p><ul><li>把一排向量，轉換成另一個同樣長度向量</li><li>在Transformer裡…<ul><li>Encoder使用的是Self-Attention，而不是RNN。</li></ul></li></ul><hr><p><img src="https://i.imgur.com/YxjpAUK.png" alt=""><br><img src="https://i.imgur.com/dpuPb42.png" alt=""></p><ul><li>一個Block裡面做了什麼？<ul><li>有使用 residual 簡單來說就是把加上某個一個向量，為了避免gradient vanishing。</li><li>然後使用 Layer Normalization</li><li>放入 Fully Connected Layer 並且也執行 residual，然後再做 Layer Normalization。</li><li>這就是一個block的output。</li></ul></li></ul><div class="note info flat"><p>不一定要使用上述的架構，我們仍可以使用其他的架構，例如：<br><img src="https://i.imgur.com/18kkGIy.png" alt=""></p></div><h3 id="原理-Decoder">原理 - Decoder</h3><blockquote><p>有一個Begin表示句子的開始，選擇最大的可能字選，做輸出。<br><img src="https://i.imgur.com/u2fAN3F.png" alt=""></p></blockquote><blockquote><p>以此類推，將word（e.g. 機）轉換成one-hot-encoder 做輸入，Decoder會把自己的輸出當作下一個輸入，直到遇到End。<br><img src="https://i.imgur.com/sfgmiPE.png" alt=""></p></blockquote><p><img src="https://i.imgur.com/QkAcwmk.png" alt=""></p><div class="note info flat"><p>Transformer 中其實Encoder與Decoder沒有太大的差別，<br>只是Block多了一個 Masked Multi-Head Attention</p></div><p><strong>Masked Multi-Head Attention</strong></p><blockquote><p>產生b1的時候，只能考慮b2~b4的資訊，不能考慮b1的資訊。以此類推<br><img src="https://i.imgur.com/I9EQnU3.png" alt=""></p></blockquote><blockquote><p>更具體一點，做 q2 只考慮 k1, k2 的資訊<br><img src="https://i.imgur.com/1n72zpz.png" alt=""></p></blockquote><p><strong>為什麼要做 Masked Multi-Head Attention？</strong><br>因為在做 Decoder 的時候，<em>他是一個個字產生，因此只能考慮左邊的東西，不能考慮右邊的東西</em>，因此要做 Masked Multi-Head Attention。<br>但是怎麼讓他停下來呢？因為只要有output就可以一直下去。</p><p><strong>如何中斷結果？其實只要添加End Token即可</strong><br><img src="https://i.imgur.com/ip50K86.png" alt=""></p><p><strong>NAT Decoder</strong><br><img src="https://i.imgur.com/KQYepFj.png" alt=""></p><ul><li>他是一次性產生所有的字，而不是一個一個產生。</li><li>可以做到平行化處理，因此可以加速。</li><li>他的目的是可以控制輸出的長度，如何控制？可以讓他任意產生，但是只取End之前的部分。</li><li>他的結果沒有AT好。</li></ul><h4 id="運作原理：Cross-Attention">運作原理：Cross Attention</h4><p><strong>運作原理：Cross Attention</strong></p><blockquote><p>輸入一個Begin產生一個vector，經過 transform 得到 q，與 encoder 產生的 a1~a3 做 attention，得到 a_hat 加上 v1~v3，最後得到 v<br>然後把 v 丟進去 Fully Connected Layer 作為 input<br><img src="https://i.imgur.com/E3DLYAV.png" alt=""></p></blockquote><blockquote><p>Decoder 的輸入是拿 Encoder 最後一層的輸出（Paper原始是這樣，但是不一定要這樣）<br><img src="https://i.imgur.com/uJZxz3Q.png" alt=""></p></blockquote><h4 id="訓練-Training">訓練 Training</h4><p><strong>Training</strong><br><img src="https://i.imgur.com/whHNujt.png" alt=""></p><ul><li>我們希望第一個輸入所產生的輸出與Ground Truth(解答)越接近越好，因此我們可以使用 Cross Entropy 來計算 Loss。</li><li>這跟分類很像，每次encoder產生一個輸出時，我們就是透過Decoder將它分類。</li><li>我們希望所有 Cross Entropy 的 Loss 越小越好。</li></ul><p><strong>Decoder的輸入會提供正確答案</strong><br><img src="https://i.imgur.com/LcyFKS9.png" alt=""></p><ul><li>我們在Decoder訓練的時候，會把正確答案丟進去，提供 (Begin + 機 + 器) 時我們希望他產生 (學)，讓他可以學習到正確答案。</li><li>這叫做 <em>Teacher Forcing</em></li></ul><div class="note warning flat"><p>但是，在 Testing 的時候，我們就沒有正確解答…，因此我們要怎麼做呢？</p></div><p><strong>BLUE score</strong><br><img src="https://i.imgur.com/q16eAXz.png" alt=""></p><ul><li>他是將Decoder產出的整句話，跟正確答案做比較，然後算出一個分數。</li><li><em>訓練的時候看Cross Entropy，測試的時候看BLUE score</em>。</li><li>訓練不能使用Blue Score是因為他無法微分，因此無法做Gradient Descent。</li></ul><p><strong>Scheduled Sampling</strong></p><ul><li>Decoder 在訓練的時候，不要一直給正確答案，而是有一定的機率給正確答案，也參雜錯誤的答案有時候結果會比較好。</li></ul><h1 id="Self-Attention">Self-Attention</h1><ul><li><a href="https://youtu.be/hYdO9CscNes?si=sg3fzz12lLteC7FA">【機器學習2021】自注意力機制 (Self-attention) (上)</a></li><li><a href="https://youtu.be/gmsMY5kc-zw?si=-q-fsFLYW-tpScNN">【機器學習2021】自注意力機制 (Self-attention) (下)</a></li></ul><div class="note info flat"><p>輸入與輸出與RNN類似，擁有bidirectional的特性，但是與RNN不同的是他可以同時計算所有輸出，而不是一個一個。<br>目的在使用 Self-Attention Layer 來取代 RNN。</p></div><p>Self-Attention 最早出現在 <a href="https://arxiv.org/abs/1706.03762">Attention is all you need</a> 這篇論文中，這篇論文提出了一個 Transformer 的架構，這個架構是一個完全不使用 RNN 的架構，但是效果卻比 RNN 還要好。</p><h2 id="運作原理">運作原理</h2><p><strong>在 Self-Attention Layer裡面的運作</strong><br><img src="https://i.imgur.com/ul0a0a9.png" alt=""></p><ol><li>每個 <em>input 都會乘上3個不同的transformation產生三個向量</em>，分別是 Query, Key, Value。<ul><li>Q: 主要 match 其他人。</li><li>K: 主要被其他人 match。</li><li>V: 被抽取出來的 information。</li></ul></li></ol><hr><p><img src="https://i.imgur.com/sxQ7NHa.png" alt=""></p><ol><li>接下來要做的事情，<em>拿每個 query q 去對每個 key k 做 attention</em>。<ul><li>這邊的 attention 稱作 <em>Scaled Dot-Product Attention</em>，是用 q 跟 k 做 dot product，然後再除以一個根號d (d is the dim of q and k)，然後做Soft-max。</li><li>除以根號 d 的原因是因為<em>兩個向量的內積會隨著向量維度的增加而增加，因此為了讓兩個向量的內積不會太大，所以除以 d 來平衡</em>。</li><li>這樣就可以得到一個 attention score，這個 score 代表 q 對 k 的注意力（有多匹配）。</li></ul></li></ol><hr><p><img src="https://i.imgur.com/4aQmcXA.png" alt=""></p><ol><li>最後這個 <em>attention 會乘上 v，然後把所有的 v 加起來，就可以得到 output</em>。<ul><li>在產生 b1 的時候，已經看過 a1~a4 所有的輸入。</li><li>如果不想考慮 global 的資訊，而是 local 的資訊，不管是遠的還是近的，只要把 alpha 設成 0 就可以了。</li></ul></li></ol><hr><p><img src="https://i.imgur.com/9zMQ1k9.png" alt=""></p><ol><li>在同時，也可以算出 b2。<em>b1, b2, b3, b4 可以被平行計算的</em>。</li></ol><h2 id="平行化處理">平行化處理</h2><p><strong>Self-Attention怎麼做平行化</strong><br><img src="https://i.imgur.com/Uih1h6E.png" alt=""></p><ul><li><p><em>關於position的平行計算</em></p><ul><li>首先要知道，<code>a1*Wq</code>會得到q1，<code>a2*Wq</code>會得到q2，<code>a3*Wq</code>會得到q3，<code>a4*Wq</code>會得到q4。</li><li>可以把 a1~a4 拼起來(I)變成 metrix A，然後乘上 Wq，就可以得到 q1~q4 (Q)。</li><li>以此類推，可以分別獲得 k1~k4 (K) 跟 v1~v4 (V)。</li><li>已得到所有position的value</li></ul></li><li><p><em>關於 alpha 的平行計算</em></p></li></ul><blockquote><p>透過 <code>k1xq1</code> 可以獲得 <code>a1,1</code>，透過 <code>k1xq2</code> 可以獲得 <code>a1,2</code>，透過 <code>k1xq3</code> 可以獲得 <code>a1,3</code>，透過 <code>k1xq4</code> 可以獲得 <code>a1,4</code>。<br><img src="https://i.imgur.com/cjzg5Rg.png" alt=""></p></blockquote><blockquote><p>同樣的，我們把所有k1~k4拼起來做一個Transpose(K)變成 metrix K_T，然後乘上 Q，就可以得到 <code>a1,1</code>~<code>a3,4</code> 來實現平行運算。<br><img src="https://i.imgur.com/8wImgzW.png" alt=""></p></blockquote><blockquote><p>最後做 Soft-max 就可以得到 alpha hat。<br><img src="https://i.imgur.com/vVth7WX.png" alt=""></p></blockquote><blockquote><p>最後要做 weighted sum，就可以得到 b1~b4。</p><ul><li>把剛剛計算好的 alpha hat 乘上 V，就可以得到 b1~b4。</li><li>把 a1,1_hat 乘上 v1，把 a1,2_hat 乘上 v2，把 a1,3_hat 乘上 v3，把 a1,4_hat 乘上 v4，(就是把 v1~v4 對 alpha1.1~1.4_hat做weighted sum 就可以得到 b1。</li><li>以此類推，來得到 b2~b4。<br><img src="https://i.imgur.com/gi4XGEE.png" alt=""></li></ul></blockquote><p><strong>總結</strong><br><img src="https://i.imgur.com/fzT0iol.png" alt=""></p><ol><li>總結來說，I (input)會乘上三個不同的 Metrics (Wq, Wk, Wv)得到Q, K, V。</li><li>把 K 轉置後，乘上 Q，得到 A (Attention Metrics)。</li><li>將 A 做 Soft-max，得到 A hat。</li><li>將 A hat 乘上 V，得到 O (output)。</li></ol><div class="note info flat"><p><em>基本上就是做矩陣乘法，可以用GPU來做加速。</em></p></div><h2 id="Multi-head-Self-Attention">Multi-head Self-Attention</h2><blockquote><p><strong>會把 Q, K, V 變成兩個 Metrics，然後分別做 Self-Attention</strong><br><img src="https://i.imgur.com/vde8YPn.png" alt=""><br><img src="https://i.imgur.com/u2pR8XU.png" alt=""></p></blockquote><blockquote><p><strong>把兩個結果 bi,1 和 bi,2 做 concat，就可以得到 bi。</strong><br><img src="https://i.imgur.com/GleVufQ.png" alt=""></p></blockquote><div class="note info flat"><p><strong>好處</strong>: <em>不同 head 可以負責不同的任務</em></p><ul><li>例如：一個 head 負責看 local 的資訊，一個 head 負責global資訊。</li></ul></div><h2 id="Position-Encoding">Position Encoding</h2><div class="note warning flat"><p><em>對於 Self-Attention 來說，並不考慮input squence的順序</em>，因此對他來說以下兩個句子是一樣的。</p><ul><li><code>B hit A.</code> 跟 <code>A hit B.</code> 是一樣的。</li><li><em>我們希望把 input sequence 的順序考慮進去，因此我們要加上 position encoding</em>。</li></ul></div><p><strong>Position Encoding</strong> 的作法是 <em>input 通過 transform 變成 ai 時，還要加上一個神奇的 vector ei</em> (dimenstion與ai相同)</p><ul><li>ei 不是學出來的，是我們自己定義的</li><li><em>ei 代表著順序</em>，每個input都有一個ei，而且ei是不會改變的。</li></ul><p><strong>為什麼是相加一個ei？</strong><br><img src="https://i.imgur.com/1Xa7FQb.png" alt=""></p><ul><li>你可以想像，我們有一個 <em>pi 是一個很大的矩陣</em>，裡面的每個值都是0，只有一個值是1，這個1的位置<em>代表著這個字的順序</em>。</li><li>我們將 pi 乘上 xi 後乘上一個 W，此時我們可以使用線性代數中，<em>透過 metrics partition的特性</em>，把W拆成兩個矩陣，一個是 Wi，一個是 Wp。</li><li>並且將 Wi 乘上 xi 加上 Wp 乘上 pi，<em>最後得出 ai + ei</em>。</li></ul><h2 id="Seq2Seq-with-Attention">Seq2Seq with Attention</h2><ul><li>Ref: <a href="https://blog.research.google/2017/08/transformer-novel-neural-network.html">Transformer: A Novel Neural Network Architecture for Language Understanding</a></li></ul><div class="note info flat"><p>剛剛我們主要提到可以使用Self-Attention取代RNN。接下來我們看看如何使用Self-Attention來做Seq2Seq。</p></div><blockquote><p><img src="https://3.bp.blogspot.com/-aZ3zvPiCoXM/WaiKQO7KRnI/AAAAAAAAB_8/7a1CYjp40nUg4lKpW7covGZJQAySxlg8QCLcBGAs/s1600/transform20fps.gif" alt=""><br><strong>Encoder</strong></p><ol><li>input 一個 sequence</li><li>每個 timestamp 互相之間做 attention，得到一個新的 sequence</li><li>這些 attention 平行運算</li></ol><p><strong>Decoder</strong></p><ol><li>給一個 Begin Token 把 Encoder 最後一層 output 當作 Decoder 的 input</li><li>不僅僅會<em>對 Encoder 的 input 做 attention 也會對 Decoder 之前所產生的 input 做 attention（Masked Attention）</em></li><li>最後就產生出一個 sequence，input是英文，output是另一個語言的翻譯結果</li></ol></blockquote><p><strong>Attention Visualization</strong><br>你可以發現，不同的 input 同一個字對不同的單字產生不同的 attention<br><img src="https://i.imgur.com/zcnj40q.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Pattern - Day1: Introd to Design Pattern</title>
      <link href="/posts/Design-Pattern-Hands-on/"/>
      <url>/posts/Design-Pattern-Hands-on/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction">Introduction</h1><p>I am going to complete something I have always want to do, which is finishing the Design Patterns book written by Eric Freeman. I have read this book for several times, but I never managed to finish it. I believe it’s time to finaly complete it. And for not forgeting the knowledge I have learned, I will write down the notes here.</p><h1 id="Agenda">Agenda</h1><p>The following are the agenda of this hands-on. I will try to base on my understanding to explain the design pattern.</p><ul><li>[ ] Day1: Introd to Design Pattern</li><li>[ ] Day2: Observer Pattern</li><li>[ ] Day3: Decorator Pattern</li><li>[ ] Day4: Factory Pattern</li><li>[ ] Day5: Singleton Patterns</li><li>[ ] Day6: Command Pattern</li><li>[ ] Day7: Adapter and Facade Pattern</li><li>[ ] Day8: Template Method Pattern</li><li>[ ] Day9: Iterator and Composite Pattern</li><li>[ ] Day10: State Pattern</li><li>[ ] Day11: Proxy Pattern</li><li>[ ] Day12: Compound Pattern</li></ul><h1 id="How-to-bend-your-brain-into-submission">How to bend your brain into submission?</h1><p>These tips are a starting point; <strong>listen to your brain and figure out what works for you and what doesn’t</strong>. Try new things.</p><ul><li>Slow down. The more you understand, the less you have to memorize.</li><li>Do the exercises. Write your own notes.</li><li>Read the “There Are No Dumb Questions”</li><li>Make this the last thing you read before bed. Or at least the last challenging thing.</li><li>Drink water. Lots of it.</li><li>Talk about it. Out loud.</li><li>Listen to your brain.</li><li>Feel something! Get involved with the stories.</li><li>Design something!</li></ul><h1 id="When-to-use-superclass-and-interface">When to use superclass and interface?</h1><p>Let’s tell a story, we are an game factory and making different species of ducks. Every duck have their own quack and fly behavior. So we can <strong>create a superclass called Duck and put the common behavior in it</strong>. However, when the boss wants to add new behavior, such as fly, if we put the fly behavior in the superclass, then all the ducks will have the fly behavior. But not all the ducks can fly, so we need to <strong>create an interface called Flyable and put the fly behavior in it</strong>. Then we can implement the interface in the duck that can fly.</p><p><img src="https://i.imgur.com/nQXkpmN.png" alt=""></p><ul><li>reduce code <code>duplication in subclasses</code>, we need to implement the fly behavior in every duck that can fly or even can’t fly.</li></ul><p><img src="https://i.imgur.com/Vs9rzAq.png" alt=""></p><ul><li>Now we take out the fly behavior from the superclass and <code>put it in the interface</code>. So we can <code>implement the interface in the subclass duck that can fly</code>. And the duck that can’t fly doesn’t need to implement the interface.</li></ul><div class="note danger flat"><p>But there is a problem. <code>If you want to override a few methods, these implemented subclass are all needed to be changed</code>, which is a lot of work.</p><blockquote><blockquote><p>Therefore, we need to use the <code>Design Pattern</code> to solve this problem.</p></blockquote></blockquote></div><h1 id="The-core-of-Design-Pattern">The core of Design Pattern</h1><div class="note warning flat"><p><strong>Take what varies and “encapsulate” it so it won’t affect the rest of your code.</strong></p><p>Design Pattern provide a way to <strong>let some part of a system vary independetly of all other parts.</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code Style </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德國鐵路交通大全</title>
      <link href="/posts/transportation-germany/"/>
      <url>/posts/transportation-germany/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><div class="note warning flat"><p>主要是為了自己觀看方便，想把所有跟德國鐵路的相關資訊一併整理在這。</p></div><h1 id="德鐵種類">德鐵種類</h1><p>國鐵分為以下三種，A最快C最慢，要注意早鳥票只有A、B類火車有販售，最早可以提前半年在官網上訂購。</p><ul><li>A 長途高速列車ICE (從法蘭克福搭往Karlsruhe就是這個)</li><li>Ｂ快速城際火車IC、EC、CNL</li><li>Ｃ 區間火車IRE、RE、RB、S-Bahn、U-Bahn</li></ul><h2 id="近郊列車-區間車-S-Bahn-、地鐵-捷運-U-bahn">近郊列車/區間車(S-Bahn)、地鐵/捷運(U-bahn)</h2><p><img src="https://i.imgur.com/NYUP2vB.png" alt=""></p><ul><li>在德國市區，S-Bahn跟U-Bahn常常都是會一起出現的，會有<code>綠色S</code>跟<code>藍色U</code>作為標示（如上圖）：<ul><li>S-Bahn就像我們台鐵的區間車，S代表的是Suburban也就是郊區；</li><li>U-Bahn像我們的捷運，U代表地下Underground。</li></ul></li></ul><p><strong>#購票方式</strong>：地鐵站內的自動售票機<br><strong>#注意事項</strong>：</p><ul><li><code>搭車的時候，上下車要自己按鈕開門</code>(超重要！！很多人忘記！！)</li><li>一天去<code>超過3個景點</code>就建議<code>購買一日卷</code></li><li>記得準備<code>小鈔</code>或<code>Visa信用卡</code>，<strong>機器只接受5歐以下的現金</strong></li><li>記得檢查<code>票卷上是否有日期</code>，沒有日期被查票也視同逃票！</li><li>月台沒有閘門及驗票口，可自由通行</li></ul><h2 id="電車-Tram">電車(Tram)</h2><p><img src="https://i.imgur.com/TuWbg5F.png" alt=""></p><p>相對於地鐵，較少使用到，在<code>慕尼黑跟紐倫堡才比較有機會</code>搭乘～。慕尼黑是德國很有歷史的一座城市，電車也早在1876年就開始發展了，如果是電車迷的話，來慕尼黑一定要來搭搭看，目前1960年產的電車也還在服役中哦！坐在有點年代感的電車配上慕尼黑古色古香的風景，讓人彷彿瞬間回到20世紀。</p><p><strong>#購票方式</strong>：可以上車購買，但較複雜，建議可以在地鐵站內購買。</p><h2 id="巴士（公車）Bus">巴士（公車）Bus</h2><p>其實在德國的大城市中，地鐵就相當方便，搭乘的機會比較不多，不過到一些大城市，像是慕尼黑跟柏林，就可以搭觀光路線的巴士，讓你一覽德國市內風光～<br><strong>＃觀光巴士路線推薦</strong><br>・慕尼黑：100號<br>・柏林：100號、200號</p><p><strong>＃購票方式</strong>：可以上車向司機購買車票，或使用車上的機器。</p><p><strong>＃注意事項</strong>：<br>・要按Stop才會停車<br>・在公車站牌前等候就可，不必揮手示意</p><h1 id="德鐵搭乘須知：誤點-換月台-搭錯終點">德鐵搭乘須知：誤點 換月台 搭錯終點</h1><p>德鐵最有名的就是無限誤點、改站台等等，建議看這個<a href="https://youtu.be/SkaQqGffgxM?si=j2SFaz3qSkqyMrhm%25">影片</a>！<br>總結：</p><ul><li>下載DB Navigator App</li><li>選單裡面有 Trip Planner，進行搜尋會出現幾個不同的交通選擇<ul><li><img src="https://i.imgur.com/JbuMlFc.png" alt=""></li></ul></li><li>找到想要搭乘的車次後，可以添加到Favorite<ul><li><img src="https://i.imgur.com/IdK6yNJ.png" alt=""></li></ul></li><li>之後搭乘前，就可以在Favorite的頁面看到最新資訊<ul><li><img src="https://i.imgur.com/BidGI49.png" alt=""></li></ul></li></ul><p>可能出現的列車變更：<br><img src="https://i.imgur.com/JPwNg8u.png" alt=""></p><h2 id="月台更換">月台更換</h2><p>換月台的前兆：</p><ul><li>誤點超過30分鐘以上</li><li>車班資訊突然消失（大概會需要等3-4分鐘更新資訊）</li><li>站牌顯示 Gleis (站台)，表示新站台要更換</li><li>隨時觀察周遭的人動作</li></ul><h2 id="車廂等級與終點">車廂等級與終點</h2><p>要注意，德國的車廂外面會寫「車廂等級」（主要分）class 1, class 2），還有「終點」。<br>更奇特的是，你要注意的是「終點」，因為<strong>德國的火車會有分段</strong>，例如從法蘭克福到Karlsruhe，會有一段是法蘭克福到Mannheim，然後Mannheim到Karlsruhe，所以你要注意的是「終點」，如果寫Mnniheim，是否跟你的車票一樣，如果寫Karlsruhe，那就是你要搭的車廂對不對。因為<strong>他們有可能中途分裂開來…就開到別的國家或市區去了</strong>。</p><h2 id="上車查票">上車查票</h2><p>德國都不需要再上車前先過票閘或檢票，大多是在車上進行查票。車長會不定IC EC IC基本上一定會查票，甚至會要求身份檢查（passport）。</p><h2 id="可以坐的位置">可以坐的位置</h2><ul><li>一般來說<strong>德國「座位」跟「票」是分開買的</strong>，座位大概4.5歐元。如果是長途的話還是建議買票比較保險。</li><li>要特別注意座位上面的資訊燈會顯示有被劃位的區段。<ul><li>如果沒有被劃位，就不會顯示任何東西。</li><li>劃位會顯示區段</li><li><code>GGF. RESERVIERT</code> 表示可能被劃位了，系統更新不全問題所導致。</li></ul></li></ul><p><img src="https://i.imgur.com/MnVYLqU.png" alt=""><br><img src="https://i.imgur.com/dIOBe0Q.png" alt=""><br><img src="https://i.imgur.com/0GFul53.png" alt=""></p><h2 id="車班大亂">車班大亂</h2><ul><li>app 會顯示綠色字<code>Current alternative</code>系統幫你計算可以接上去的時間，不用退票或重新買票。</li><li>如果車長問題，就截圖說明即可。<br><img src="https://i.imgur.com/HaVPoJL.png" alt=""></li></ul><h1 id="德鐵劃位規則">德鐵劃位規則</h1><ul><li>參考這個寫得很詳細：<a href="https://www.euphotravel.com/2021/07/DB-Seat-reservation.html">https://www.euphotravel.com/2021/07/DB-Seat-reservation.html</a></li></ul><p><strong>德鐵車票有包括座位嗎?</strong><br>除了一等艙有整合劃位，票價包含座位。德鐵快車(ICE,IC,EC)的二等艙不論是超級特價票、特價票跟原價票<code>都要另外劃位</code>。如果你在查詢的時候覺得人沒很多，那可以不用。。請特別注意劃位要綁定德鐵快車的搭乘日期跟車次，劃位錯誤是無法更換到車班(2021年已取消)甚至退款。</p><h2 id="劃位費">劃位費</h2><ul><li>Einzelreservierung (Single Reservation 單字劃位)<ul><li><ol start="2"><li>Klasse (二等艙)</li></ol><ul><li>購票時訂位: 4 €/整段單程路線的快車座位</li><li>單獨訂位: 4 €/整段單程路線的快車座位</li></ul></li><li><ol><li>Flasses (一等艙)</li></ol><ul><li>購票時已整合訂位</li><li>單獨訂位: 5.3 €/整段單程路線的快車座位</li></ul></li></ul></li><li>Familienreservierung (Family reservation，家庭訂位)<ul><li><ol start="2"><li>Klasse (二等艙):</li></ol><ul><li>購票時訂位: 8 €/整段單程路線</li><li>單獨訂位: 8 €/整段單程路線</li></ul></li><li><ol><li>Klasse (一等艙)</li></ol><ul><li>購票時已整合訂位</li><li>單獨訂位: 10.6 €/整段單程路線</li></ul></li></ul></li><li>Gruppenreservierung(Group reservation，團體票訂位)<ul><li><ol start="2"><li>Klasse (二等艙)</li></ol><ul><li>購票時已包含座位</li></ul></li><li><ol><li>Klasse (一等艙)</li></ol><ul><li>購票時已包含座位</li></ul></li></ul></li><li>Dauerreservierung (Duration reservation，定期票訂位)<ul><li><ol start="2"><li>Klasse (二等艙):41.4 €/月</li></ol></li><li><ol><li>Klasse (一等艙):41.4 €/月</li></ol></li></ul></li></ul><h2 id="車廂類型">車廂類型</h2><p><img src="https://i.imgur.com/hriYFHv.png" alt=""></p><ul><li>選項一 any (德文:beliebig,中文:任意) :  交由德鐵系統安排</li><li>選項二 Open saloon (德文: Großraum, 中文: 開放車廂): 二等艙是中央走道兩邊各兩排相鄰座位，一等艙是中央走道兩邊，一邊是一排座位，另一邊兩排相鄰座位。</li><li>選項三 Open saloon with table (德文: Großraum mit Tisch, 中文: 開放車廂座位附桌子)  通常兩人一桌或四人一桌，兩兩面對面。家庭出遊可以考慮訂這個座位，讓好動的小朋友有桌子可以玩玩具、吃東西跟看書。</li><li>選項四 Compartment (德文: Abteil, 中文: 包廂):  大多是6張座位一間，一邊各三張座位面對面坐。部分ICE一等艙也有4張座位一間，一邊各兩張座位面對面坐。有冷暖空調跟玻璃門，可用拉簾遮住整面玻璃門，保持隱私。</li></ul><h2 id="座位位置">座位位置</h2><p><img src="https://i.imgur.com/HcfYLpU.png" alt=""></p><p>單人訂位時<br>選項一: any (德文:beliebig, 中文:任意): 由德鐵系統安排<br>選項二:Window (德文:Fenster , 中文:窗戶): 靠窗邊<br>選項三:Aisle ( 德文:Gang, 中文:走道) : 靠走道</p><p>兩人訂位時: <code>很多時候，因為車廂內的配置，德鐵系統只能盡力配合，但不能盡如人意!!</code><br>選項一: any (德文:beliebig, 中文: 任意): 由德鐵系統安排。<br>選項二: Window across from each other (德文: Fenster gegenüber , 中文: 彼此相對靠窗坐著)。<br>選項三:across from each other (德文:Gang gegenüber, 中文:彼此相對靠走道坐著)</p><h2 id="車廂區域">車廂區域</h2><p><img src="https://i.imgur.com/FHFk98B.png" alt=""><br>選項一 any (德文:beliebig, 中文:任意): 由德鐵系統安排<br>選項二 Phone zone (德文:Handybereich,中文:手機區): 車上有手機訊號放大設備，在高速行進時還可以接聽手機。<br>選項三 Quiet zone (德文:Ruhebereich, 中文:靜音區): 禁止講手機跟大聲喧嘩。只有 ICE Sprinter 及 ICE 車班能選擇靜音區。</p><p>如果如願選到你想要的位置，都會是<code>綠色勾勾</code>，否則會出現<code>紅色驚嘆號</code>表示系統幫你修改某個選項來安排座位。</p><h2 id="圖示說明">圖示說明</h2><p><img src="https://i.imgur.com/9NyNd3s.png" alt=""></p><p><img src="https://i.imgur.com/v5pkm5H.png" alt=""><br><img src="http://i.imgur.com/uploading.png" alt=""></p><h1 id="德鐵搭乘方向">德鐵搭乘方向</h1><p>我蠻多朋友不太擅長搭在對的方向德鐵，所以我整理一下我自己搭乘的注意要點：</p><ul><li>有些鐵路在路面上，有些在地下，所以要注意看一下站牌上有沒有你要搭的號碼，如果沒有可能就在地下（S1跟1是完全不一樣的！）</li><li>德國是靠右走，所以你要搭車的方向應該是在你要前往方向的右手邊</li><li>HBF是中央火車站的意思，火車、地鐵、區間車，三者皆有</li></ul><h1 id="專有名詞">專有名詞</h1><ul><li>大城市火車站大多會有地名+「<strong>HBF</strong>」的字樣 (ex. <code>Karlsruhe HBF</code>)，這個是<strong>中央火車站的意思，火車、地鐵、區間車，三者皆有</strong>！</li></ul><h1 id="參考連結">參考連結</h1><ul><li><a href="https://www.tripresso.com/blog/2019/02/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E9%80%9A-%E6%94%BB%E7%95%A5/">【德國交通】第一次德國自由行就上手！ 德國交通工具、APP攻略總整理</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 交通旅遊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 德國 </tag>
            
            <tag> 交通鐵路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德國交換留學準備攻略（入籍|第三方責任險|延簽+居留證|sim|提領帳戶|Revolut）</title>
      <link href="/posts/prepare-germnay/"/>
      <url>/posts/prepare-germnay/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>準備9/3飛往德國，在抵達德國前總要知道抵達後應該做的事情，因此整理出這篇文章條列說明，需要做的事情，包含入籍、延簽、居留證、開戶、申請電話卡等。全部一併在這裡準備，我不喜歡分太多文章，如果你想<strong>快速知道去德國到底具體要做哪些事情，可以直接參考我這篇～</strong>。畢竟網戶很多文章都是單獨分開的，有的入籍，但你不會知道要辦理延簽，有的想要提領帳戶但是不知道要怎麼開戶，還有一堆小事情要處理分散在網路各個不同的地方。</p><p>所以我這篇主要目的就是<strong>希望提供大家一個快速可以知道自己到底去德國要做什麼事情的整理，和我的心得</strong>。但是如果想要知道更詳細的操作畫面，建議還是參考別的網站，但是我主要是希望你可以知道自己具體要準備什麼。</p><h1 id="保險-提領帳戶：Expatrio">保險+提領帳戶：Expatrio</h1><p>保險和提領帳戶我是透過 <a href="https://www.expatrio.com/">Expatrio</a> 申請，因為他們有提供一個套餐，包含了保險和提領帳戶，而且申請起來也很方便，只需要填寫一些基本資料，就可以申請成功，而且他們的保險也是德國政府認可公保 TK 的，所以我就直接申請了。</p><p>選擇Expatrio好處：</p><ul><li>速度快（提領帳戶匯錢後當天就更新通知了）</li><li>繳交文件方便</li><li>公保是TK，如果想打子宮頸疫苗可以免費打</li></ul><p>幸好當時的匯率不貴，大概是33塊台幣換算一歐元，而德國政府規定每個月應該要有935歐元的生活費，而我是去一年，因此大概換算台幣約39萬左右。<br>至於怎麼填寫裡面的內容，我建議上網找有很多教學。至於<strong>匯款至提領帳戶的部分，絕對不要使用郵局喔，因為郵局不保證全額到帳</strong>！除非你自己先算把中間可能會付的手續費都算好，一次轉你要匯入的金額＋你算的手續費，不然還是建議使用銀行匯款，銀行才能確保全額到帳。</p><h2 id="Q1-公保-vs-私保？">Q1: 公保 vs 私保？</h2><ul><li>詳細可參考：<a href="https://www.german-preture.com/%E5%BE%B7%E4%BA%A4%E6%8F%9B%E7%95%99%E5%AD%B8%E5%BF%85%E7%9C%8B%E4%BF%9D%E9%9A%AA%E6%94%BB%E7%95%A5%EF%BD%9C%E5%85%AC%E4%BF%9D%E7%A7%81%E4%BF%9D%E5%93%AA%E4%B8%80%E5%80%8B%E5%A5%BD%EF%BC%9F/">德交換留學必看保險攻略｜公保私保哪一個好？</a></li></ul><p><img src="https://i.imgur.com/8TCaDx1.png" alt=""></p><h2 id="Q2-簽證需要保險的什麼文件？">Q2: 簽證需要保險的什麼文件？</h2><ul><li>如果你是 Expatrio 去下載 Incoming Insurance Certificate incl. dates.pdf<br><img src="https://i.imgur.com/N6J6lFa.png" alt=""></li></ul><h1 id="第三方責任險：AXA">第三方責任險：AXA</h1><ul><li>參考來源：<a href="https://www.german-preture.com/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E6%8F%9B%E3%80%81%E7%95%99%E5%AD%B8%E5%BF%85%E5%82%99%E4%BF%9D%E9%9A%AA%EF%BD%9C%E7%AC%AC%E4%B8%89%E8%B2%AC%E4%BB%BB%E9%9A%AA-haftpflichtversicherung/">德國交換、留學必備保險｜第三責任險-haftpflichtversicherung</a></li></ul><p>如果<strong>在德國弄壞別人的東西，或是遺失鑰匙，可能會付出慘痛的代價</strong>。&quot;Haftpflichtversicherung&quot;第三方責任險又名責任保險 (英文是：Liability Insurance），這是一種在德國普及率很高的保險，根據德國法律，每個人對別人造成的傷害都必須負責，因此85%-90%德國人都有基本上人人都有。第三方責任險價錢大慨每月€5－10（我自己使用AXA年費是33.99歐元，這樣算換下來更加划算），第三方責任險並不像醫療保險是強制的，但是我覺得第三方責任險是非常有用。</p><h2 id="包含哪些範圍？">包含哪些範圍？</h2><p>受保人的行為對第三方造成了損害時要賠償給對方，大致上分為3類：</p><ol><li>他人物品損壞</li><li>人身傷害</li><li>金錢損失</li></ol><p>第三方責任險特別適合租房的人，有些<strong>屋主會要求租客有第三方責任險</strong>，以免發生需要賠償時無法負擔令雙方更有保障。有第三方責任險找房時也會加大自己租到房子的籌碼呢！我們的房東雖然沒有要求第三方責任險也告訴我們非常建議要有。租房較常見的意外例如：</p><ul><li>租屋裡的水龍頭因忘記關掉而水浸導致地板受損波及下層鄰居的天花板滲水</li><li>屋主的傢具受損/出租屋遺失鑰匙等等</li></ul><p>遺失鑰匙是最常發生需要索償理賠的，只是不見自己家的鑰匙費用還不很糟（找維修工換鎖100歐起跳啊！），<strong>遺失了宿舍大門的鑰匙而且房間門鑰匙都一樣的話，所有人的鑰匙就得換新的，這種情況費用就付出非常昂貴的代價</strong>。</p><p>日常生活中不小心損壞他人的物品這些事常常發生，誰也不知道哪一天因不小心的錯失而需要賠償小則幾百歐大則幾萬歐金額給對方。一般都會在保障範圍內可以申請理賠，保障我們不用高額賠償給對方，有第三方責任險給自己增添保障。</p><h2 id="申辦方法？">申辦方法？</h2><p>我問德國的同學是參考間保險公司，大多聽到是購買AXA的家庭方案，他們說家人從小就會幫他們保（不能小看小孩破壞力呀！）。本來有在網路上看到有<a href="https://www.german-preture.com/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E6%8F%9B%E3%80%81%E7%95%99%E5%AD%B8%E5%BF%85%E5%82%99%E4%BF%9D%E9%9A%AA%EF%BD%9C%E7%AC%AC%E4%B8%89%E8%B2%AC%E4%BB%BB%E9%9A%AA-haftpflichtversicherung/">台灣人買COYA</a>，後來改名叫Luko，使用他們網站後頻繁出現錯誤，就放棄了。改用AXA，我大概做了以下事情：</p><ol><li>前往官網的<a href="https://www.axa.de/pk/haftpflicht/p/private-haftpflichtversicherung">Private Liability Insurance</a>，大概看了一下他們的合約。</li><li>因為我希望鑰匙不見得部分都包含在內，因此選擇了 “M” 方案。<ul><li><img src="https://i.imgur.com/NzwFWJ4.png" alt=""></li></ul></li><li>填寫完資訊後，他會跳出以下畫面，要你聯絡他們。(好麻煩呀！還是要聯絡真人幹嘛填表單)<ul><li><img src="https://i.imgur.com/xE66Wj4.png" alt=""></li></ul></li><li>我是想採用email，點擊進去<a href="https://www.axa-betreuer.de/">Start your consultant search</a> 然後我輸入Karlsruhe 他會show給你該地區的保險業務人。<ul><li><img src="https://i.imgur.com/P3JQoLa.png" alt=""></li></ul></li><li>點擊進去保險人的資訊（ex. 例如我選<a href="https://www.axa-betreuer.de/eric_lagasse">Eric Lagasse</a>可以點擊進去，Make an appointment<ul><li><img src="https://i.imgur.com/omsl4Bk.png" alt=""></li></ul></li><li>大概是跟他說你的需求（身份,要購買的產品)，就差不多惹@…@，寫完內容他會問你要phone call還是email選email即可。</li></ol><h1 id="台灣信用卡-雙幣帳戶">台灣信用卡+雙幣帳戶</h1><p>如果要去德國留學一年，包含提領帳戶至少要準備40萬比較好，因為到德國後還無法立刻取得提領帳戶的錢。<br>最好<strong>帶一個月的生活費</strong>，並且在<strong>台灣先開好雙幣帳戶</strong>（比較多人推薦：大戶卡雙幣卡）。我是使用媽媽的副卡辦理玉山銀行的雙幣信用卡，當時一年內刷卡免手續費，一年到期後就要繳會費了（反正只留學一年 XD），這樣刷卡額度高，也不是直接從帳戶扣款。玉山銀行的雙幣信用卡好處是：</p><ol><li>你可以直接把台幣轉換成歐元存在另一個帳戶。</li><li>如果每個月結帳的時候，他會直接從歐元帳戶扣款。</li><li>手續費免。</li></ol><p>我也有辦理大戶卡，只是那就是Debit Card，不是信用卡。到時候要辦理刷退會比較沒效率…（畢竟是扣自己的錢，如果使用信用卡就是扣銀行的）。</p><h1 id="入籍：karlsruhe">入籍：karlsruhe</h1><p>我是在Karlsruhe留學，所以跟一般大都市流程可能會有所差異，但是都不會差太遠。基本上要準備以下事情，和相關文件：</p><ul><li>預約登記網址進行預約，並把預約資訊列印出來：<a href="https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe/extern/calendar/?uid=f91279e2-e275-4165-a3af-515a7d4e0990">https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe/extern/calendar/?uid=f91279e2-e275-4165-a3af-515a7d4e0990</a> (refresh th epage; choose “Zuzug nach Karlsruhe” (Residence - Moving to Karlsruhe (students)).</li><li>準備的相關文件：<ul><li>要給房東填寫的表單: <a href="https://web1.karlsruhe.de/service/Formulare/ordnungsamt/OA2_Wohnungsgeberbescheinigung.pdf">Wohnungsgeberbescheinigung (Papierformular) / Landlord certificate</a></li><li>列印好你跟房東簽約的合約紙本（對方會需要看）。</li><li>攜帶好你的VISA跟護照。</li></ul></li></ul><p>基本上當天準備好的時候，就是希望上述這些東西過去。辦入籍大概等約一兩週，他們就會寄入籍資料（包含稅號）給你，有了稅號到時候如果要實習，或是工作都比較方便。</p><h1 id="德國開戶：N26-vs-Revolut">德國開戶：N26 vs Revolut</h1><p>本來是想使用 N26，但是近期好像因為疫情關係，他們不再接受台灣的Passport跟德國簽證，<strong>N26視訊時要看的是居留證，不接受護照或簽證</strong>！！！你想想我們這種菜雞還沒過去德國，哪來的居留證…。所以如果你想在台灣就先開好，建議Revolut，基本上只要上傳Passport，並且有德國的地址就可以開戶了。方便多了。</p><p>我所申辦的方案是 Standard (不用錢的那個)，然後有辦理實體卡用來提款用。到時候提領帳戶就可以直接綁在Revolut。</p><h1 id="SIM-卡：Fraenk">SIM 卡：Fraenk</h1><p>這邊SIM最常聽到的就是 Telekon, O2, Vodafone，但是我問一些過來台灣留學的德國人他們反而推薦 Fraenk。後來去看看真的不錯，畢竟歐洲不像台灣是網路吃到飽，（難怪他們在通勤的時候會看書XD），<strong>O2先不考慮災情太多，Telekon則是費用很貴</strong>。我反而是Vodafone跟Fraenk在選。<strong>最後打算選擇Fraenk</strong>，是因為他邀請朋友可以再+1G，直到上限滿了(15個朋友)。<strong>他一個月費用10歐元7Ｇ（+ xG 朋友邀請加量），相比Vodafone是9.99歐元4Ｇ而已</strong>，不僅如此，Fraenk除了跟Vodafone一樣可以在歐盟區使用免費漫遊，他還包含了被排除在外的瑞士！！</p><ul><li>Fraenk 預付卡官網：<a href="https://fraenk.de/prepaid-alternative/">https://fraenk.de/prepaid-alternative/</a></li><li>Vodafone 預付卡種類：<a href="https://www.vodafone.de/prepaid/">https://www.vodafone.de/prepaid/</a></li></ul><div class="note warning flat"><p>其實預付卡可以上網買，只是<strong>德國政府規定現在買預付卡也要身分證明</strong>，所以記得帶護照，驗證後他可以線上認證後送你家。但應該還是去實體比較快，只是擔心實體沒有預付卡的庫存（我爬文看到德國有些時候門市都買不到，因為他們希望你簽合約…）</p></div><h2 id="辦理過程？">辦理過程？</h2><p>可能因為我是外國人，所以透過app申請的時候，被通知申請失敗，需要在他們官網透過 <a href="https://www.fraenk.de/chat">service chat</a>的方式近一步確認身份！</p><ol><li>下載app</li><li>透過邀請碼進行註冊（到時候合約成功雙方可獲得1G)<ul><li>可以使用邀請碼：<a href="https://fraenk.page.link/?link=https%3A%2F%2Ffraenk.de%2Fdeeplink%2Fmgm%3FfriendCode%3DYIHH1&amp;apn=de.congstar.fraenk&amp;amv=1040000&amp;imv=1.4&amp;isi=1493980266&amp;ibi=de.congstar.fraenk&amp;ius=fraenk&amp;ofl=https%3A%2F%2Ffraenk.de">YIHH1</a></li></ul></li><li>註冊完後，他會發信給你說資料不夠請在7天內聯絡Service Chat</li><li>你就根據app提供的訂單number給service chat</li><li>對方會要求你傳&quot;visa+passport&quot;, &quot;入籍&quot;的紙上傳即可。</li><li>通過後等待你的SIM卡(我大概等了3-4天)</li></ol><h1 id="居留證和延簽：Karlsruhe">居留證和延簽：Karlsruhe</h1><p>所有非歐盟交換生都需要持有涵蓋整個交換期的簽證或有效的學習居留許可。為什麼需要延簽？如果您的簽證在交換停留結束之前到期，您將需要在簽證到期之前申請學習居留許可。所以我們會需要在簽證過期前趕緊拿到居留證！但是他可不像入籍一樣好處理，通常要等2-3個月！所以最好到德國的時候就開始準備申請居留證拉！這邊提供的是Karlsruhe的延簽申請準備流程。</p><p>如需向外國人部門 (Ausländerbehörde) 登記，請準備以下文件（副本）：</p><ol><li>填寫居留許可申請表（點擊<a href="https://web1.karlsruhe.de/service/Buergerdienste/organisation.php?id=6028411">此處</a>並選擇“Formulare”下的“Antrag auf Erteilung einer Aufenthaltserlaubnis”），基本上就是填寫<img src="https://i.imgur.com/6mVctAi.png" alt=""></li><li>biometric picture （大頭照）</li><li>護照+Visa影本</li><li>入籍後的相關文件 confirmation of your registration as a resident of the city of Karlsruhe</li><li>租賃合同副本</li><li>提領帳戶證明：足夠的資金證明足以支付您在德國逗留期間的所有費用（每月至少 934 歐元，例如凍結的銀行賬戶或獎學金的官方聲明）</li><li>《錄取通知書》和《在學證明》</li><li>健康保險證明</li></ol><p>準備好上述文件之後，執行以下步驟：</p><ol><li>您需要在簽證到期之前<strong>及時將填妥並簽名的申請表</strong>和<strong>所需文件</strong>以 <strong>PDF 文件形式通過電子郵件發送至 <code>abh@oa.karlsruhe.de</code></strong></li><li>確保您的申請完整併保存自動發送的收據確認信息。(目前，<code>申請的處理時間約為 10 週，因此儘早提交申請非常重要</code>。)</li><li>您將通過電子郵件或郵寄收到他們的決定結果。</li><li>他們會回應你通不通過，收到結果後您可以在<a href="https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe-abh/extern/calendar/?uid=8311b67c-7f17-41d3-801d-ae23fb82fd51&amp;wsid=45b88bcd-75e1-44cd-8605-2a741189bbc6&amp;lang=de">這裡預約</a>提交生物識別數據（指紋和照片 - 選擇“Abgabe biometrischer Daten”）。在這次預約的同時時，他們將為您訂購新的電子居留許可證。</li></ol><blockquote><p>寄信的範本：</p></blockquote><p><img src="https://i.imgur.com/1x2CJrw.png" alt=""></p><div class="note danger flat"><p><strong>目前收取的費用是: EUR 100,00 （只能付現）</strong></p><p>根據官方說明 <a href="https://web1.karlsruhe.de/service/Buergerdienste/leistung.php?id=6004449">Kosten</a><br>居留許可或ICT卡的發放：EUR 100,00<br>居留許可或ICT卡的延期長度最多三個月：EUR 96,00<br>居留許可或ICT卡的延期超過三個月：EUR 93,00<br>永久居留許可：EUR 113,00<br>歐盟長期居留許可：EUR 109,00<br>高技能移民的永久居留許可：EUR 147,00<br>自主工作居留許可：EUR 124,00<br>移動ICT卡的發放：EUR 80,00<br>移動ICT卡的延期：EUR 70,00</p></div><h2 id="時程">時程</h2><ul><li>2023/09/06 寄信給 <code>abh@oa.karlsruhe.de</code></li><li>2023/11/01 收到實體信件說明要預約提供生物識別數據（指紋和照片）</li><li>2023/11/16 到場提供指紋和照片</li><li>2323/12/14 收到PIN和PUK碼</li><li>2023/01/15 預約領取居留證</li></ul><h2 id="流程">流程</h2><div class="note info flat"><p>前提：如果是要提供生物識別資料，攜帶以下即可：</p><ul><li>[x] 有效護照</li><li>[x] 目前的生物辨識護照照片（照片不得超過 6 個月；每個新申請都需要一張新的生物辨識照片！）</li><li>[x] 現金/EC卡支付費用</li><li>[ ] 居留許可申請表 （可帶可不帶，可以加快處理速度）</li></ul></div><ol><li>收到信請你預約繳交指紋跟照片的時段後，當天就前往事務處 <a href="https://maps.app.goo.gl/k2BBHuNLWADuhuxZA">Ausländerbehörde Kaiserallee 8, 76133 Karlsruhe</a>。</li><li>進去後，<strong>一樓左轉，前往 Zimmer 16</strong>。</li><li>裡面有一台機器，<strong>輸入你 Email 收到的預約號碼</strong>：e.g. 8046</li><li>然後房間會有一台電視，當你的<strong>號碼出現在電視上</strong>的時候，前往該房間，以圖中為例就是 Zimmer 02。<br><img src="https://i.imgur.com/x8cwcKA.png" alt=""></li><li>前往 Zimmer 02，是一個小房間，裡面有兩個人而已，你就<strong>直接把照片跟護照給他即可</strong>。<br><img src="https://i.imgur.com/xOjUGRW.png" alt=""></li><li>過程中他會請你<strong>簽名,提交左右手食指的指紋</strong>。</li><li>他還會問你身高、髮色（這當初表單都有填寫，你也<strong>可以攜帶表單給他看</strong>）。</li><li>完成後他會給你一張紙（說明書）處理卡片大概會<strong>需要4個週期的工作天</strong>，到時候會寄信給你，內含有PIN碼。屆時根據紙上的預約網址<strong>預約領取時間即可</strong>。</li><li>最後，你會到付款環節，他會給你一個<strong>繳款卡片</strong>。<br><img src="https://i.imgur.com/FxPwqHQ.png" alt=""></li><li>卡片要去一樓，進門後的<strong>正門口左邊有一台機器</strong>。繳費後，他就會給你收據（注意不支援信用卡付款，建議攜帶足夠的現金，不收200或500）<br><img src="https://i.imgur.com/8wVDOL4.png" alt=""><br><img src="https://i.imgur.com/gb0AXt6.png" alt=""></li></ol><p><strong>收到PIN與PUK後</strong><br>線上預約領取居留證：可以在<a href="https://web1.karlsruhe.de/service/Buergerdienste/leistung.php?id=6006219">官網</a>找到預約連結，進行<a href="https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe-abh/extern/calendar/?uid=f81cf5dd-c902-467b-963a-19b46d1d905b">線上預約</a>領取居留證</p><h1 id="除籍-Abmeldung">除籍 Abmeldung</h1><p>可以點擊<a href="https://web1.karlsruhe.de/service/Buergerdienste/leistung.php?id=6000874">連結</a>，上面會寫詳細的資料。然後可以點擊<a href="https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe/extern/calendar/?uid=6a9ffa64-fd7a-44dd-8650-61cde42df997">預約</a></p><p><img src="https://i.imgur.com/NKUaAsM.png" alt=""></p><div class="note warning flat"><p>必須在兩周內除籍。<br>最早可以在退房前一周除籍。</p></div><p><em>要攜帶的東西（本人）</em><br><img src="https://i.imgur.com/6uvaoJS.png" alt=""></p><ul><li>護照</li><li>護照複印件</li><li>居留證</li><li>填寫完並且簽署的除籍表格（表格<a href="https://web1.karlsruhe.de/service/Formulare/ordnungsamt/Wohnsitz_Abmeldung.pdf">連結</a>）</li></ul><h1 id="參考資料">參考資料</h1><ul><li><a href="https://annie89339.pixnet.net/blog/post/403314302-%E5%88%B0%E9%81%94%E5%BE%B7%E5%9C%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%B6%E4%BA%8B%EF%BC%9A%E5%9F%8E%E5%B8%82%E5%85%A5%E7%B1%8D-%28anmelden%29---%E4%B8%80">到達德國的第一件事：城市入籍 (Anmelden) 一點也不難！---- @ 享受孤獨走出舒適圈 :: 痞客邦 :: (pixnet.net)</a> ：有蠻詳細要做的事情，包含入籍申請、開戶、申請電話卡。</li><li><a href="https://tingundting.medium.com/2022-%E5%BE%B7%E5%9C%8B-%E5%85%A5%E7%B1%8D-anmeldung-%E5%B1%85%E7%95%99%E8%AD%89-aufenthaltserlaubnis-%E7%94%B3%E8%AB%8B%E5%88%86%E4%BA%AB-ff6495a75df2">2022 德國 入籍(Anmeldung)、延簽轉居留證(Aufenthaltserlaubnis) 申請分享 - Ting&amp;Ting - Medium</a>：詳細說明入籍跟取得居留證的內容。（要有居留證才可以申請N26喔…）</li><li><a href="https://mwentalk.pixnet.net/blog/post/165268">2019如何啟用Expatrio 領到錢(連結Revolut帳戶) @ 奶玟TALK :: 痞客邦 :: (pixnet.net)</a>: 詳細說明怎麼把提領帳戶與Revolut進行連結。</li><li><a href="https://expateva.com/recommendation/revolut/">2023年最詳細的Revolut使用教學指南與攻略 - Expateva</a>：Revolut超級詳細解說app使用教學</li><li><a href="https://annie89339.pixnet.net/blog/post/405347211-%E4%BB%80%E9%BA%BC%E6%98%AF%E5%BB%B6%E7%B0%BD%EF%BC%9F%E4%BB%80%E9%BA%BC%E6%98%AF%E5%B1%85%E7%95%99%E8%AD%89%EF%BC%9F%E5%88%B0%E9%81%94%E5%BE%B7%E5%9C%8B%E5%BE%8C%E5%BF%85%E9%A0%88">什麼是延簽？什麼是居留證？到達德國後必須做的事情 （慕尼黑經驗分享） @ 享受孤獨走出舒適圈 :: 痞客邦 :: (pixnet.net)</a>：居留證申請教學。</li><li><a href="https://emilydelife.wordpress.com/2019/03/22/%E5%BE%B7%E5%9C%8B%E7%94%B3%E8%BE%A6%E9%A0%90%E4%BB%98%E5%8D%A1/">德國申辦 Vodafone 預付卡 – 德國日常 x 歐洲旅遊 (wordpress.com)</a>：詳細說明Vodafone有哪些卡可以申辦。</li><li><a href="https://www.travelclassroom.net/2017/07/europe-sim.html">歐洲上網卡(SIM卡)：覆蓋、速度與價格比較 + 購買攻略和使用方法分享 - 旅遊教室 (travelclassroom.net)</a>：詳細說明預付卡可以使用的範圍。</li><li><a href="https://www.h-ka.de/en/exchange-students#c61005">Die HKA - Die Hochschule Karlsruhe : Exchange students (h-ka.de)</a> : 學校官網提醒要做的延簽,入籍等事項</li><li><a href="https://www.german-preture.com/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E6%8F%9B%E3%80%81%E7%95%99%E5%AD%B8%E5%BF%85%E5%82%99%E4%BF%9D%E9%9A%AA%EF%BD%9C%E7%AC%AC%E4%B8%89%E8%B2%AC%E4%BB%BB%E9%9A%AA-haftpflichtversicherung/">德國交換、留學必備保險｜第三責任險-haftpflichtversicherung</a>：講到買第三方責任險的必要性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 抵達德國必做 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 德國 </tag>
            
            <tag> 入籍 </tag>
            
            <tag> 延簽 </tag>
            
            <tag> 居留證 </tag>
            
            <tag> sim卡 </tag>
            
            <tag> 提領帳戶 </tag>
            
            <tag> Revolut </tag>
            
            <tag> 保險 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>適用於應用程式AP與資料庫DB之間的零信任架構(ZTA)原則 - 總整理篇</title>
      <link href="/posts/ZTA-survey-AP-DB-summary/"/>
      <url>/posts/ZTA-survey-AP-DB-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>根據<a href="/posts/ZTA-survey-AP-DB-summary">上一篇</a>的內容，我們整理的主流的ZTA相關文件，並針對AP與DB的部分做重點。而本篇的目的就是針對這些文件做一個總整理，並且<strong>針對AP與DB的部分做一個總結</strong>。會想要整理這篇的目的是這樣的：</p><p>目前市面上的<code>零信任架構文件更多探討的是使用者訪問敏感數據或受保護資源之前，與「應用程式或服務」的互動中如何實施持續性的驗證</code>，並且由動態策略來進行決策。但是，這往往讓人<strong>忽略了在使用者完成與應用程式的驗證後，延續到應用程式對資料進行存取時的安全策略</strong>，儘管文件有提及到一些適用於應用程式應滿足的安全要求，例如應該要確保第三方元件的安全等。但並無特別列出應用服務在存取資源時如何持續地進行驗證、授權，或是對事件的監控、資料的收集和分析等，而資料安全方面也僅僅提出基本的要求，包含對重點資料座標記和分類，在應用程式對資源進行存取時，動態存取策略所需考量的要素、架構模型等以滿足零信任要求皆無更多的討論。</p><p>在微服務與雲原生架構的盛行下，<code>多個應用程式可能會有存取相同的資源的需求</code>，而對資源的存取權限往往掌控在應用程式對使用者的驗證與授權，然而基於零信任原則，<strong>我們不應信任並假設每個應用程式的驗證機制都能滿足零信任原則</strong>，在使用者環境或裝置本身遭受惡意人士入侵時，仍存在因為某些的應用程式或其設備的安全性不足而遭受入侵的風險，導致資料洩露或進行未經授權的篡改，而影響其他應用或服務的正常運作。</p><div class="note warning flat"><p>有鑑於此，本研究將會著重在應用程式進行資料存取時，探討該如何滿足<code>AP與DB之間的零信任要求，適用於應用程式與資料存取之間的所應滿足的原則與應該實現的能力</code>。最後，並基於零信任原則<code>設計出適用於應用程式與資料之間的存取控制模型</code>，以針對應用程式進行驗證授權，實現動態決策的存取控制滿足零信任要求。</p></div><h1 id="架構與流程介紹">架構與流程介紹</h1><p>本文的架構主要會依序說明：</p><ul><li>零信任的核心、情境假設、原則</li><li>部署種類與架構：定位論文採取的部署方式</li><li>從零信任的相關文獻中，主要挑選出適用於 AP 與 DB 所應滿足的要求。</li></ul><h1 id="標準之間的比較">標準之間的比較</h1><p><img src="https://i.imgur.com/vFwAl6t.png" alt=""><br>在開始之前，我們先來看一下以下三者的內容中的比較：</p><blockquote><p><strong>NIST SP 800-207</strong></p></blockquote><p>說到零信任架構，最先會被提及的就是NIST SP 800-207了！</p><ul><li>優點：裏面說明的內容比較全面，也潛顯易懂，在ZTA架構的元件其工作職責有定義清楚。</li><li>缺點：只是<strong>針對&quot;資料保護&quot;的存取控制較少</strong>、沒有特別針對AP與DB之間的控制。</li></ul><blockquote><p><strong>DoD Zero Trust Reference Architecture</strong></p></blockquote><p>這裡面中我認為DoD的標準文件更加詳細！</p><ul><li><strong>優點</strong>：<ul><li>他與其他兩者不同之處在於他不僅僅限於User與AP之間的授權驗證，他有<code>特別提及NPE(Non-Person Entity)的授權</code>要求。</li><li>同時也包含提供針對保護資源的架構、提及資料保護元件。</li></ul></li><li><strong>缺點</strong>：只是資料<code>保護元件具體功能不清楚、架構較為複雜，執行流程不清楚</code>，那就是我要負責研究跟實作的議題了。</li></ul><blockquote><p><strong>OMB Federal Zero Trust Strategy</strong></p></blockquote><ul><li><strong>優點</strong>：這份文件&quot;針對User的身份驗證&quot;要求具體。</li><li><strong>缺點</strong>：<ul><li>但是針對Data的要求很基本，沒特別細說存取控制在Data面的要求</li><li>Identity的部分著重在 User，所以如果想要在這裡面找到特別針對AP和DB之間的授權驗證要求，可能會比較困難。</li></ul></li></ul><h1 id="原則-假設">原則 &amp; 假設</h1><p><img src="https://i.imgur.com/nQQDg6t.png" alt=""><br><img src="https://i.imgur.com/VMKkymZ.png" alt=""></p><p>這邊列出每一個文件中所提及ZTA的Tenets，並且做 Mapping，以方便用全局的角度去看具體來說應該滿足的原則。<br>首先主要整理出以下幾個層級，來探討每個層級所應滿足的零信人原則：</p><ul><li>使用者：使用者本人。</li><li>使用者裝置：使用者所存取資料時所使用的裝置。</li><li>工作流程：使用者透過裝置執行特定的工作流程。</li><li>應用/服務/裝置：主要提供服務給使用者的主體，該主體可能是應用程式、服務或是裝置。</li><li>網路：使用者與應用程式、服務或是裝置之間的網路。</li><li>資料：使用者所存取的資料。</li></ul><p>從上圖中，本研究主要探討工作流程到資源層級所應滿足的零信任要求。並以以下假設作為前提：</p><ul><li>工作流程方面：我們應該確保如何保有一致的安全策略。</li><li>應用/服務/裝置方面：在授予資源存取前，應確保這些資產都通過PEP的評估其安全狀態。</li><li>網路：企業內部網路不能被視為隱性信任區。</li><li>資源：不是所有企業資源都位於企業擁有的基礎設施上。</li></ul><h1 id="部署種類">部署種類</h1><ul><li>Ref: <a href="/posts/zta-survey.html#Enclave-Based-Deployement">詳細可以參考這篇</a></li></ul><p><img src="https://i.imgur.com/R85LkBO.png" alt=""><br>部署種類會偏好 Enclave-Based Deployment 的架構:</p><ul><li>應用/服務/裝置：在執行應傭服務的機器上，安裝 agent</li><li>資源：在前面建立Gateway而非建制在資源上。</li><li>適用：適用於具有Legacy的應用程式或on-premises的數據中心</li></ul><h1 id="AP與DB應滿足的要求">AP與DB應滿足的要求</h1><p><img src="https://i.imgur.com/x5B209y.png" alt=""></p><p><img src="https://i.imgur.com/2xZ3xAF.png" alt=""><br>可以從 DoD 文獻的 7 Pillar 來探討，針對AP與DB的部分，應滿足下列：</p><ul><li><p>Users &amp; Device : Continuous Authentication &amp; Authorization</p><ul><li><code>AP</code>：要執行 Application 的 MFA。</li><li><code>AP</code>：基於 ABAC 的存取控制。</li><li><code>AP</code>：Application 的裝置數據收集。</li><li><code>AP</code>：Application 的行為記錄。</li><li><code>AP</code>：即時的存取控制。</li><li><code>PDP</code>：統一的存取政策管理。</li></ul></li><li><p>Network/Environment &amp; Workloads &amp; Data : ZT infra</p><ul><li><code>AP</code>：基於風險考量的應用程式存取。</li><li><code>DB</code>：資料標籤的方法。</li><li><code>PEP</code>：動態的政策執行。</li><li><code>DB</code>：Data Right Management。</li><li><code>DB</code>：Data Loss Prevention。</li></ul></li><li><p>Visibility &amp; Analytics / Orchestration &amp; Automation : Analytics &amp; Orchestration</p><ul><li><code>AP&amp;DB</code>：持續監控</li><li><code>PDP</code>：ZT Policy Engine</li><li><code>PDP</code>：存取控制政策</li></ul></li></ul><h1 id="研究總結">研究總結</h1><blockquote><p>系統架構：條列每個元件應該滿足的要求</p></blockquote><p><img src="https://i.imgur.com/d3hNCsr.png" alt=""></p><h1 id="有哪些研究議題？">有哪些研究議題？</h1><blockquote><p>成熟度模型要求</p></blockquote><p><img src="https://i.imgur.com/sra6GPM.png" alt=""></p><h2 id="實作內容">實作內容</h2><p>上述為成熟度模型，可以依據此參考逐步滿足零信任的要求，而本研究主要著重在“<code>紅色</code>”的部分，如下：</p><ul><li><p><strong>存取控制 AC, Access Control</strong></p><ul><li>AC: 確保存取 DAAS 的時候是經由 Cybersecurity policies 所決定的。</li><li>AC: 實現最小權限存取。</li><li>AC: 基於細顆粒度 (user and device attribute) 進行控制</li><li>AC: 確保存取 DAAS 的時候是經由 Cybersecurity policies 所決定的。</li><li>AC: 完全的實施 Just-in-Time 和 Just-Enough 的存取政策</li></ul></li><li><p><strong>風險標籤 RL, Risk Labeling</strong></p><ul><li>RL: 資料透過 flow analysis 和簡單的自動化進行標籤與分類</li><li>RL: 實施DLP &amp; DRM</li><li>RL: 進階分析技術，使威脅檢測能夠自動化並根據事先設計的策略進行協調（Risk Label實現）</li></ul></li><li><p><strong>身份驗證 IA, Identity Authentication</strong></p><ul><li>IA: 使用MFA進行驗證</li><li>AC:持續性適應驗證與授權</li></ul></li><li><p><strong>網路安全 NS, Network Security</strong></p><ul><li>NS: 滿足加密要求</li></ul></li></ul><h2 id="文獻補充">文獻補充</h2><p>以下是預計要探討的相關文獻，以輔助本研究的存取控制模型架構：</p><ul><li><strong>機器學習 ML</strong><ul><li>DL: 進行 data 辨識，並標示敏感或關鍵資料</li><li>DL: (自動)辨識 DAAS (數據、應用程序、資產和服務)</li><li>DL: Map data flows</li><li>ML: 使用者和 Entity 的行為分析（UEBA, User and Entity Behavior Analytics）建立 baseline policy</li></ul></li></ul><h1 id="缺乏的部分？">缺乏的部分？</h1><p>還缺乏以下部分要進行 survey …</p><ul><li><code>實作</code> Data<ul><li>如何執行DRM、DLP、軟體定義環境和細粒度數據標記等解決方案支持對關鍵數據的保護？</li><li>如何結合上述兩者於Data Labeling?</li></ul></li><li><code>實作</code> AP<ul><li>AP 如何做 MFA？</li><li>思考怎麼把 DLP, DRM 併入存取控制政策中？</li></ul></li><li><code>文獻</code> ML<ul><li>怎麼透過 ML 辨識 DAAS?</li><li>怎麼透過 ML 進行 data 辨識，並標示敏感或關鍵資料，甚至將其自動化？</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Zero Trust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碩士論文 </tag>
            
            <tag> Zero Trust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 方便的常用指令（SSH,加密分割壓縮檔）</title>
      <link href="/posts/linux-usual-command/"/>
      <url>/posts/linux-usual-command/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH">SSH</h1><p>參考：<a href="https://askie.today/lets-set-ssh-config/">https://askie.today/lets-set-ssh-config/</a></p><div class="note warning flat"><p>SSH登入主機時，<strong>不用再輸入密碼，然後也不用輸入ip</strong>的方法:</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地產生金鑰</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把金鑰送入想要免輸入密碼的host</span></span><br><span class="line"><span class="comment"># 把公開金鑰送入遠端主機</span></span><br><span class="line">ssh-copy-id 帳號@主機IP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先進入ssh目錄準備設定host別名</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">vi config </span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定如下</span></span><br><span class="line"><span class="comment"># vmware</span></span><br><span class="line">Host <span class="built_in">test</span> <span class="comment"># 以下機器的簡稱</span></span><br><span class="line">  HostName 192.168.4.18 <span class="comment"># ip </span></span><br><span class="line">  User prlab <span class="comment"># 帳號</span></span><br><span class="line">  identityfile ~/.ssh/id_rsa <span class="comment"># 金鑰位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之後就可以直接輸入</span></span><br><span class="line">ssh <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="zip">zip</h1><div class="note warning flat"><p>我最常用的就是壓所檔案，並且需要<strong>加密或分割檔案</strong>用。</p></div><ol><li>一般加密檔案用的指令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ”加密“要使用-e，&quot;資料夾“要使用-r，如果只是一般檔案-e即可，不需要r</span></span><br><span class="line"><span class="comment"># 把本地 ./test 資料夾 加密成 ./test.zip，並且輸入密碼</span></span><br><span class="line">zip -er ./test.zip ./test</span><br></pre></td></tr></table></figure><ol start="2"><li>把zip檔案進行分割和合併的做法。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 以下指令 - 表示標準輸入。這個命令的意思是將 zip 命令的輸出作為 split 命令的輸入。</span></span><br><span class="line"><span class="comment"># 如果不添加 -，則 split 命令將不會接收到 zip 命令的輸出，而是會試圖從文件中讀取數據。</span></span><br><span class="line"><span class="comment"># 下面的指令就是透過 zip 把 zip 檔案輸出給 split 這個指令以10MB為單位進行切割</span></span><br><span class="line"><span class="comment"># 以下指令就是回到上一層，找到zip檔案開始分割</span></span><br><span class="line">zip - ../test.zip | <span class="built_in">split</span> -b 10MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># $ &gt; 會產出 xaa, xab, xac, ... # 這樣的檔案，所以我們可以透過 cat 來進行合併</span></span><br><span class="line"><span class="comment"># 把當前目錄底下x開頭的檔案都合併成 test.zip</span></span><br><span class="line"><span class="built_in">cat</span> x* &gt; ../test.zip</span><br></pre></td></tr></table></figure><h1 id="Mac">Mac</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 轉換成中文</span><br><span class="line">option + shift + B : 可以打入顏文字 </span><br><span class="line"># emoji </span><br><span class="line">ctrl + command + space : 可以打入表情符號</span><br><span class="line"></span><br><span class="line"># mac </span><br><span class="line">ctrl + command + F : 全螢幕</span><br><span class="line">ctrl + 左右鍵 : 往右邊的 desktop 切換</span><br><span class="line">command + M : 收起來最小化</span><br><span class="line"></span><br><span class="line"># 瀏覽器</span><br><span class="line">command + T : 新增分頁</span><br><span class="line">command + W : 關閉分頁</span><br><span class="line">command + shift + T : 還原關閉分頁</span><br><span class="line">command + L : 跳到網址列</span><br><span class="line">command + R : 重新整理</span><br><span class="line">command + [ : 上一頁</span><br><span class="line">command + ] : 下一頁</span><br><span class="line"></span><br><span class="line"># Aflred </span><br><span class="line">command + , : 開啟 Preference 設定</span><br></pre></td></tr></table></figure><h1 id="SHELL-配置文件">SHELL 配置文件</h1><ul><li>參考：<a href="https://www.cnblogs.com/MaelDNM/p/16196273.html">https://www.cnblogs.com/MaelDNM/p/16196273.html</a></li></ul><div class="note info flat"><p><code>.bashrc</code> vs <code>.zshrc</code> vs <code>.profile</code> vs <code>.bash_profile</code> 差異在哪裡？</p></div><table><thead><tr><th>比較</th><th>bashrc</th><th>bash_profile</th><th>zshrc</th></tr></thead><tbody><tr><td>啟動時間</td><td><code>系統啟動後</code>自動運行，只在bash shell下執行</td><td><code>用戶登入後</code>才會運行</td><td><code>系統啟動後</code>自動運行，只在 zsh shell下執行</td></tr><tr><td>實行時機</td><td><code>每次打開終端</code>都會運行</td><td><code>每次登入</code>都會運行一次</td><td><code>每次打開終端</code>都會運行</td></tr><tr><td>更新方法</td><td><code>source bashrc</code></td><td><code>source profile</code></td><td><code>source zshrc</code></td></tr><tr><td>局面變量</td><td><code>局部</code>，只能繼承 <code>/etc/profile</code> 中的變量</td><td><code>/etc/profile</code> 中設定的變量是<code>全局</code>。</td><td><code>全局</code>，可以用於任何用戶</td></tr></tbody></table><p>總結：</p><ul><li>如果使用 bash 請更改 <code>~/.bashrc</code> 或是 <code>~/.bash_profile</code><ul><li>bashrc 是每次打開終端都會運行</li><li>bash_profile 是每次登入都會運行一次</li></ul></li><li>如果使用 zsh 請更改<code> ~/.zshrc</code> 或是 <code>~/.zshenv</code></li><li>如果使用 bash 並且想要讓所有用戶都生效，請更改 <code>/etc/profile</code></li></ul><h1 id="關於-usr">關於 /usr/</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local <span class="comment"># 通常是用戶自己手動下載的非系統預設軟體，這個folder由用戶自己管理</span></span><br><span class="line">/usr/bin <span class="comment"># 是用來存放系統預設的可執行檔，這是MacOS預設就幫你裝好的，不要亂動</span></span><br></pre></td></tr></table></figure><h1 id="關於-python-conda">關於 python &amp; conda</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> python <span class="comment"># 查看 python 的路徑</span></span><br><span class="line"><span class="built_in">which</span> -a python <span class="comment"># 查看所有 python 的路徑</span></span><br><span class="line"><span class="built_in">which</span> -a python3 <span class="comment"># 查看所有 python3 的路徑</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conda </span></span><br><span class="line">conda <span class="built_in">env</span> list <span class="comment"># 查看所有環境</span></span><br><span class="line">conda search python <span class="comment"># 查看所有 python 版本 </span></span><br><span class="line">conda list -n your_environment_name python</span><br><span class="line">conda list <span class="comment"># 查看當前環境的所有套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立環境 </span></span><br><span class="line">conda create -n &lt;env_name&gt; python=3.7 <span class="comment"># 建立環境 python=3.7 的名稱是 &lt;env_name&gt; </span></span><br><span class="line">conda activate &lt;env_name&gt; <span class="comment"># 進入環境 到時候輸入 python --version 就是新的環境版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除環境</span></span><br><span class="line">conda remove -n &lt;env_name&gt; --all <span class="comment"># 刪除環境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 環境改名 需要先 copy 到其他新環境 再刪除舊環境 </span></span><br><span class="line">conda create --name new_name --<span class="built_in">clone</span> old_name</span><br><span class="line">conda remove --name old_name --all</span><br></pre></td></tr></table></figure><h2 id="python-項目自動產生requirements-txt">python 項目自動產生requirements.txt</h2><p>ref: <a href="https://blog.csdn.net/pearl8899/article/details/113877334">https://blog.csdn.net/pearl8899/article/details/113877334</a><br>ref: <a href="https://stackoverflow.com/questions/62885911/pip-freeze-creates-some-weird-path-instead-of-the-package-version">pip freeze creates some weird path instead of the package version</a></p><p>有時候我們在和別人合作的時候會希望保持環境的一致。</p><p><em>方法1: 整個環境下的安裝包都保存到 requirements.txt</em><br>使用這個方法的建議是你使用 virtualenv 環境下安裝的包都保存到 requirements.txt 中。<br>如果開啟一個新專案，建議建立一個新的virtualenv環境，並使用以下指令來建立所有的package清單。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不建議使用這個：這是open issue in version 20.1 這有時候會輸出奇怪的路徑而不是版本號 </span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建議使用這個</span></span><br><span class="line">pip list --format=freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p><em>方法2: 只生成單個項目中有使用到的安裝包</em><br>以下的作用範圍只會將當前項目使用的內容導出成為requirements.txt<br>先定點到項目目錄下，然後執行 <code>pipreqs ./ --encoding=utf-8</code>，可以避免編碼錯誤，並自動在根目錄生成requirements.txt文件。<br>速度會比方法1還要慢。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pipreqs</span><br><span class="line">pipreqs . </span><br></pre></td></tr></table></figure><p>如何安裝 requirements.txt 的套件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>一鍵安裝各種包<br>最好先使用conda建立新環境，以做好環境隔離，然後再使用以下指令安裝所有的包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt </span><br><span class="line">conda install --<span class="built_in">yes</span> --file requirements.txt</span><br></pre></td></tr></table></figure><h2 id="conda-install-vs-pip-install">conda install vs pip install</h2><ul><li><p>ref: <a href="https://www.zhihu.com/question/395145313">pip install 和conda install有什么区别吗？</a></p></li><li><p><code>conda install xxx</code> 這種安裝方式都會放在 <code>anaconda3/pkgs</code>，通常在這個目錄下的套件，在不同環境下需要使用到這個套件時，就會直接從這個目錄下將該套件複製到新環境不用重新下載。</p></li><li><p><code>pip install xxx</code> 分兩種情況：</p><ul><li>第一種：當前conda的環境python是conda安裝的，那麼xxx就會被安裝到<code>anaconda3/envs/your_env/lib/python3.x/site-packages</code>下。</li><li>第二種：當前conda的環境python是系統自帶的，那麼xxx就會被安裝到<code>/usr/local/lib/python3.x/site-packages</code>下。</li></ul></li></ul><p>如果使用conda安裝的python會建議使用conda install，因為他是嚴格檢查依賴，表示如果下載某個套件，該套件相關的依賴也會一併下載，conda比較能保證工作，如果conda沒有的再使用pip install即可。</p><h2 id="Kaggle-Input-Data-下載">Kaggle Input Data 下載</h2><ul><li>參考: <a href="https://medium.com/@ankushchoubey/how-to-download-dataset-from-kaggle-7f700d7f9198">https://medium.com/@ankushchoubey/how-to-download-dataset-from-kaggle-7f700d7f9198</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先透過anoconda prompt下載kaggle套件</span></span><br><span class="line">pip install kaggle</span><br></pre></td></tr></table></figure><p>接下來我們要去自己的網站下載api json檔案，然後放到 <code>~/.kaggle/kaggle.json</code> 這個目錄下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然後透過以下指令下載</span></span><br><span class="line">kaggle datasets download -d &lt;owner-name&gt;/&lt;dataset-name&gt; -p &lt;path-to-download&gt;</span><br></pre></td></tr></table></figure><p>也可以透過opendatasets套件來下載</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opendatasets</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> opendatasets <span class="keyword">as</span> od</span><br><span class="line">od.download(<span class="string">&#x27;https://www.kaggle.com/c/3136/download-all&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="關於-Java">關於 Java</h1><ul><li>ref: <a href="https://blog.csdn.net/xijieyuan2qi/article/details/120949011">切換不同java bash設定</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜尋一下有哪些版本</span></span><br><span class="line">brew search openjdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然後挑選自己喜歡的版本 以8為例 </span></span><br><span class="line">brew install openjdk@8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝好後就可以查看版本</span></span><br><span class="line">java -version </span><br></pre></td></tr></table></figure><p>快速切換版本的做法，以我的微粒我目前本機上有17跟8<br>你會發現版本都裝在 <code>/Library/Java/JavaVirtualMachines/</code> 這個目錄下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确认一下有没有存在下面的目录</span></span><br><span class="line"><span class="built_in">cd</span> /Library/Java/JavaVirtualMachines/  <span class="comment">#进入这个目录</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#查看目录下的文件</span></span><br><span class="line"><span class="built_in">ls</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是我的openjdk8的目录，也就是java8的安装目录</span></span><br><span class="line">/Library/Java/JavaVirtualMachines/openjdk-8.jdk/Contents/Home</span><br><span class="line"></span><br><span class="line"><span class="comment"># openjdk11的目录，也就是java11的安装目录</span></span><br><span class="line">/Library/Java/JavaVirtualMachines/adoptopenjdk-11.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>但是如果你是使用arm架構，例如Macos m1, m2晶片，那可能不適用<br>會看到以下錯誤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ brew install openjdk@8</span><br><span class="line">==&gt; Downloading https://formulae.brew.sh/api/formula.jws.json</span><br><span class="line"><span class="comment">############################################################################################################################ 100.0%</span></span><br><span class="line">==&gt; Downloading https://formulae.brew.sh/api/cask.jws.json</span><br><span class="line"><span class="comment">############################################################################################################################ 100.0%</span></span><br><span class="line">openjdk@8: The x86_64 architecture is required <span class="keyword">for</span> this software.</span><br><span class="line">Error: openjdk@8: An unsatisfied requirement failed this build.</span><br></pre></td></tr></table></figure><ol><li>要去oracle下載是用自己架構的版本：<a href="https://www.oracle.com/java/technologies/javase/jdk8-arm-downloads.html">https://www.oracle.com/java/technologies/javase/jdk8-arm-downloads.html</a></li><li>進行解壓縮後，我自己放到 <code>/Library/Java/</code> 這個目錄下面</li><li><code>vi ~/.bash_profile</code> 進去添加以下內容</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java version</span></span><br><span class="line">java8=/Library/Java/jdk1.8.0_401.jdk/Contents/Home</span><br><span class="line">java17=/usr/bin/java</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$java17</span></span><br><span class="line"><span class="built_in">alias</span> java8=<span class="string">&quot;export JAVA_HOME=<span class="variable">$java8</span>&quot;</span></span><br><span class="line"><span class="built_in">alias</span> java17=<span class="string">&quot;export JAVA_HOME=<span class="variable">$java17</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile <span class="comment"># 讓他生效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以透過輸入 java8 或是 java17 來切換版本</span></span><br><span class="line">java8 </span><br><span class="line">java -version</span><br><span class="line">&gt; output </span><br><span class="line">java version <span class="string">&quot;1.8.0_401&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_401-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.401-b10, mixed mode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java17 </span><br><span class="line">java -version</span><br><span class="line">&gt; output </span><br><span class="line">openjdk version <span class="string">&quot;17.0.6&quot;</span> 2023-01-17</span><br><span class="line">OpenJDK Runtime Environment Temurin-17.0.6+10 (build 17.0.6+10)</span><br><span class="line">OpenJDK 64-Bit Server VM Temurin-17.0.6+10 (build 17.0.6+10, mixed mode)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>適用於AP與DB之間的零信任架構(ZTA)原則</title>
      <link href="/posts/zta-survey/"/>
      <url>/posts/zta-survey/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf">美國 NIST 在 2020 年發佈了 NIST SP 800-207 的文件</a></li><li><a href="https://dodcio.defense.gov/Portals/0/Documents/Library/(U)ZT_RA_v2.0(U)_Sep22.pdf">美國國防資訊系統局就在 2021發布美國國防部的零信任參考架構 Department of Defense - Zero Trust Reference Architecture</a></li><li><a href="https://zerotrust.cyber.gov/federal-zero-trust-strategy/">美國預算與管理辦公室於 2021 年 9 月先發布推動策略徵求意見後，於 2022 年 1 月發佈正式文件</a></li></ul><h1 id="前言">前言</h1><p>身為一個想要做資料庫與AP之間安全論文的研究生，如果想要套用零信任架構上去，首先就必須了解各種文件上面談到零信任<code>應該滿足的要求</code>或是符合零信任的<code>架構</code>。同時因為是要找AP與資料庫之間的安全，而零信任卻是更全面地談及不同層面應該滿足的要求，像是針對使用者的身份驗證等。因此需要認清楚自己的目標對象怎麼著中在AP與資料之間的安全，為此我將整理的要求和架構進行分類，<strong>哪些是針對User與AP，哪些可以用於AP與AP就需要區分出來</strong>。</p><p>因此這篇文章的目的是在整理以下三篇文章：</p><ul><li><a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf">美國 NIST 在 2020 年發佈了 NIST SP 800-207 的文件</a>：此文件作為國家導入零信任架構訂定基礎。</li><li><a href="https://dodcio.defense.gov/Portals/0/Documents/Library/(U)ZT_RA_v2.0(U)_Sep22.pdf">美國國防資訊系統局就在 2021發布美國國防部的零信任參考架構 (Zero Trust Reference Architecture)</a>：列出要導入零信任架構時的參考元件。</li><li><a href="https://zerotrust.cyber.gov/federal-zero-trust-strategy/">美國預算與管理辦公室於 2021 年 9 月先發布推動策略徵求意見後，於 2022 年 1 月發佈正式文件</a>：要求美國聯邦政府的各單位，要在 2024 年的預算年度，達成零信任安全在身分識別、裝置安全、網路安全、應用安全，與資料安全等五大目標上的要求。</li></ul><div class="note danger flat"><p>因為這篇主要是我自己整理的內容，所以可能內容還沒有更加的統整，如果想直接看總結，建議查看<a href="/posts/ZTA-survey-AP-DB-summary">零信任架構的方法</a>。</p></div><h1 id="NIST-零信任假設">NIST 零信任假設</h1><blockquote><p>以下內容主要出自於 NIST SP 800-207 大概看看就好。</p></blockquote><p>以下是零信任架構的假設前提，我們應該要：</p><ol><li><strong>The entire enterprise private network is not considered an implicit trust zone.</strong><ul><li><code>企業內部網路不能被視為隱性信任區</code></li></ul></li><li><strong>Devices on the network may not be owned or configurable by the enterprise.</strong><ul><li><code>裝置可能不是由企業擁有或設置管理的</code>（ex. BYOD）</li></ul></li><li><strong>No resource is inherently trusted.</strong><ul><li><code>沒有資源本身是受信任的，在授予資源存取前，每項資產都必須通過 PEP 評估其安全狀況</code></li></ul></li><li><strong>Not all enterprise resources are on enterprise-owned infrastructure.</strong><ul><li><code>不是所有企業資源都位於企業擁有的基礎設施上</code>。</li><li>資源包括遠程企業主體以及雲服務。</li><li>企業擁有或管理的資產可能需要使用本地（即非企業）網路進行基本連接和網路服務（例如，DNS解析）。</li></ul></li><li><strong>Remote enterprise subjects and assets cannot fully trust their local network connection</strong><ul><li><code>遠端存取者應假設本地網路環境是不安全的</code>。</li><li>資產應該假設所有流量都被監控並有可能被修改。</li><li>所有連線必須是被驗證獲授權的。</li></ul></li><li><strong>Assets and workflows moving between enterprise and non-enterprise infrastructure should have a consistent security policy and posture.</strong><ul><li><code>在企業基礎設施和非企業基礎設施之間移動的資產和工作流程應該具有一致的安全策略和姿態</code>。</li></ul></li></ol><h1 id="NIST-零信任原則-ZTA-Tenets">NIST 零信任原則 ZTA Tenets</h1><blockquote><p>以下內容主要出自於 NIST SP 800-207</p></blockquote><div class="note warning flat"><p>對於NIST SP 800-207中提出的零信任原則所指的對象通常不限定於使用者、應用或服務，主要提出作為存取者發出對於資源的請求時，所應滿足的原則以符合零信任，而對於應用程式或服務在存取資源時的特定情況並沒有具體的說明。</p><p><strong>因此這裡我會多補充一些關於應用程式與資源之間，應如何做到滿足零信任的原則。</strong></p></div><details class="toggle" ><summary class="toggle-button" style="">Tenet 1. All data sources and computing services are consider resources. <br> > 原則1: 企業內部的數據資源或是計算服務都需要被視為受保護的資源</summary><div class="toggle-content"><p>感想：</p><ul><li>已資料庫來說，<strong>資料庫可以視為被保護的資源</strong>之ㄧ。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenet 2. All communication is secured regardless of network location. <br> > 原則2: 不能只是根據網路位置就授予信任，內部的存取請求所經歷的安全要求與外部請求必須相同</summary><div class="toggle-content"><p>感想：</p><ul><li>不會預設有信任應用程式，<code>所有存取資料庫的應用程式</code>應該都要<strong>持續授權與驗證</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenet 3. Access to individual enterprise resources is granted on a per-session basis. <br> > 原則3: 企業內部的資源存取必須是基於每個連線的基礎</summary><div class="toggle-content"><p>內容：</p><ul><li>在請求被授權前應該經過衡量並滿足執行任務的<strong>最小權限原則</strong></li><li>值得注意的是，提到不一定要直接在啟動會話或執行與資源的交易之前才授予權限，相反，企業可以在使用者提出存取請求之前，先評估這個使用者的身份和信任程度，並根據這些評估結果授予相應的權限。這樣做可以在使用者真正需要存取資源時，節省時間並簡化存取流程。</li></ul><p>感想：</p><ul><li>應用程式與資料庫在建立連線時，應該要能夠根據應用程式的身份進行驗證。</li><li>並<strong>確保該應用程式執行工作的權限應屬於該應用程式的資料存取範圍</strong>，這表示對於每個存取資料庫的<code>應用程式都要有清楚的身份區別</code>，以辨別該應用程式可以存取的資源。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenets 4. Access to resources is determined by dynamic policy - including the observable state of client identity、 application/service、 and the requesting asset - and may include other behavior and environmental attributes. <br> > 原則4: 資源請求應該經由動態政策來決定，這包含觀察客戶端應用和服務的身份、請求狀態、環境屬性、存取行為等</summary><div class="toggle-content"><p>內容：</p><ul><li><code>請求資產</code>狀態：可以包含裝置屬性像是<strong>軟體版本, 網路位置, 請求時間日期, 觀察的歷史行為, 安裝的憑證</strong></li><li><code>行為</code>屬性包含但不限於：自動化的<strong>存取者分析, 裝置分析, 使用模式偏差</strong>。</li><li><code>環境屬性</code>可以包含：請求者<strong>網路位置, 時間, 主動攻擊報告</strong>。</li><li><code>Policy</code>：是基於屬性的存取規則集合，屬性由組織assign給subject, data asset或application。</li></ul><p>感想：</p><ul><li>應該要<strong>設計出一存取控制政策</strong>應該要能包含各種不同的屬性，如上述內容所提到的。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenets 5. The enterprise monitors and measures the integrity and security posture of all owned and associated assets. <br> > 原則 5. 不再預設信任任何資產，而是持續監控和評估所有資產的安全狀態</summary><div class="toggle-content"><p>內容：</p><ul><li>企業應該建立一個持續性診斷和強化CDM來監控裝置和應用程式的狀態，並根據需要應用補丁/修補程式。</li><li>建立健全的監控和報告系統，提供有關企業資源當前狀態的可行數據。</li></ul><p>感想：</p><ul><li>對於<code>存取資料庫的應用程式</code>來說，應該也要<strong>持續性的監控該應用程式所使用的第三方套件版本、補丁</strong>等，作為該應用的狀態。</li><li>同時也要<code>監控應用程式執行的裝置環境</code>是否正常。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenet 6. All resource authentication and authorization are dynamic and strictly enforced before access is allowed. <br> > 原則 6. 資源驗證和授權是動態的，必須在允許訪問之前嚴格執行</summary><div class="toggle-content"><p>內容：</p><ul><li>這是一個不斷循環的過程，包括獲取訪問權限、掃描並評估威脅、適應變化，以及持續重新評估通信中的信任。</li><li>這種方法確保在任何時候只有經過授權的用戶才能訪問企業資源。</li><li>實施零信任架構的企業預期會擁有身份identity、憑證credential和訪問管理access management（簡稱ICAM）以及asset management system資產管理系統。</li><li>在<strong>用戶交易過程中，不斷進行監控，可能需要重新驗證和重新授權</strong>。</li><li>這是根據政策（例如基於時間的重新驗證、新資源請求、資源修改、檢測到異常用戶活動等）來定義和強制執行的。</li><li><strong>政策旨在在安全性、可用性、易用性和成本效率之間取得平衡</strong>。</li></ul><p>感想：</p><ul><li>首先<code>任何應用程式在進行資料庫存取</code>時，都必須<strong>經過嚴格的驗證與授權</strong>，只有經過授權的應用程式才能訪問資料庫。</li><li>在<strong>存取資料的過程</strong>中，都應該<code>持續性地進行監控</code>，可能需要根據存取的資源不同，進行重新驗證與授權。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenets 7. The enterprise collects as much information as possible about the current state of assets、 network infrastructure and communications and uses it to improve its security posture. <br> > 原則 7. 應收集資產的安全狀況、網絡流量和訪問請求等，收集到的資料將用於改進政策制定和執行，以提升資安策略</summary><div class="toggle-content"><p>感想：</p><ul><li>資料庫、應用程式的安全狀況、網路流量、請求內容、請求結果<code>應該要做紀錄並收集</code>。</li><li>這些<strong>收集的資料可以用於改進政策制定和執行</strong>，以提升資安策略。</li></ul></div></details><h1 id="NIST-零信任架構的方法">NIST 零信任架構的方法</h1><div class="note warning flat"><p>我個人個觀點，若是要實施零信任架構於應用程式和資料庫之間，則應該<strong>採用<code>Using Enhanced Identity Governance</code>的做法作為本研究的架構</strong>。</p></div><p>NIST SP 800-207主要題中三種作為零信任架構的方法：</p><ol><li><strong>Using Enhanced Identity Governance 使用增強的身份管理</strong><ul><li><strong>說明</strong>：一種以<code>身份為核心</code>，<code>基於身份和屬性</code>制定資源訪問政策。</li><li><strong>感想</strong>：在放行應用程式的請求至資料庫前，應該要<code>先識別發出請求的應用程式</code>為何？<code>健康狀況</code>？<code>應用程式的第三套件是否有重大資安缺漏</code>？再近一步判斷其擁有得權限，才能放行請求。</li></ul></li><li><strong>Using Micro-Segmentation 使用微分割</strong><ul><li><strong>說明</strong>：將<code>資源放置在受到網關安全元件保護的獨立網絡段</code>，保護資源免受未經授權的訪問。</li><li><strong>感想</strong>：使用微分割的做法主要透過網路安全元件如防火牆等，透過將網段分區的方式，在每個網段透過這些元進行控制與監控。但因為本研究的目的介於應用程式與資料庫之間，<code>為了能夠更清楚的取得兩者之間的資料流，因此不適合使用此方法</code>。</li></ul></li><li><strong>Using Network Infrastructure and Software Defined Perimeters 使用網絡基礎設施和軟體定義的周界</strong><ul><li><strong>說明</strong>：使用<code>網絡基礎設施實現ZTA</code>，可能包含軟體定義網絡和意圖為基礎的網絡概念，PA充當網絡控制器來設置和重新配置網絡。</li><li><strong>感想</strong>：主要透過類似SDN軟體定義網路的方法來進行網路流量的控制，主要在OSI模型中的網路層（Network Layer），這一層負責處理網路之間的路由和轉發，以及封包在不同網路之間的傳遞，因此<code>應用層級的細節不可見</code>。由於無法深入了解應用程式與資料庫之間的細節，<code>若連線設定不當或未能滿足應用程式的安全需求，可能會導致資料外洩或遭受攻擊</code>。</li></ul></li></ol><h1 id="NIST-零信任架構部署種類">NIST 零信任架構部署種類</h1><p>可以從以下架構看到，NIST SP 800-209 中的零信任架構主要都使以使用者為主體，透過裝置來進行資源存取。</p><table><thead><tr><th><div style="width:80px"> 比較項目 </div></th><th>Agent/Gateway</th><th>Enclave Gateway</th><th>Resource Protal</th><th>App Sandboxing</th></tr></thead><tbody><tr><td>有無Agent</td><td><code>有</code></td><td><code>有</code></td><td><code>無</code></td><td><code>無</code></td></tr><tr><td>PEP位置</td><td><code>單一</code>資源前</td><td><code>資源集或私有雲</code>前/入口</td><td><code>資源集或私有雲</code>前/入口</td><td>裝在<code>資源上</code></td></tr><tr><td>適用情境</td><td>有<code>裝置管理計畫</code>之企業</td><td>具有<code>Legacy應用程式或on-premises數據中心</code>之企業</td><td>適用於<code>BYOD環境</code>，不需要再客戶端設備安裝軟體元件。</td><td>適用<code>無法掃瞄客戶資產</code>(裝置)是否存在漏洞。</td></tr></tbody></table><h2 id="Device-Agent-Gateway-Model">Device Agent / Gateway Model</h2><p><img src="https://i.imgur.com/Z4IezQ5.png" alt=""></p><ul><li>在這個模型中，<strong>PEP (Policy Enforcement Point) 被分成兩個部分</strong>它們分別位於「資源」上或直接作為「資源前端」的一個組件。<ul><li><code>第一部分是&quot;Device Agent&quot;</code>: 它被安裝在企業發放的資產上，用於協調連接。這個代理程式<strong>負責將一些（或全部）流量導向適當的 PEP 以便進行請求評估</strong>。</li><li><code>第二部分是&quot;Gateway&quot;</code>: 它被放置在每個資源的前端，使資源只與這個網關進行通訊，本質上充當資源的代理。這個網關負責與政策管理員進行通訊，並僅允許政策管理員配置的批准通訊路徑。</li></ul></li><li>政策管理員PA 和 政策引擎PE 可以是企業本地設備或雲端服務。</li><li>適用情境：<ul><li><strong>適合使用在已建立堅固裝置管理計畫的企業</strong>，同時擁有可以與網關進行通訊的專屬資源。這個模型也適合不希望實施BYOD政策的企業。</li><li><strong>唯有透過裝置代理（device agent），才能取得存取權限</strong>，而裝置代理可以安裝在企業擁有的資產上。</li></ul></li></ul><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant A as Agent     participant PA as Policy Administrator     participant PE as Policy Engine    participant G as Gateway    A-&gt;&gt;+PA: 存取請求由本地代理接收，轉發給政策管理員PA    PA-&gt;&gt;+PE: 政策管理員PA將請求轉發給政策引擎PE進行評估。    PE--&gt;&gt;-PA: 請求被授權，政策管理員將在控制平面上配置設備代理和相關資源閘道之間的通信通道。    A-&gt;&gt;+G: 設備代理和閘道隨後建立連接，開始傳輸加密的應用程式&#x2F;服務數據。    G--&gt;&gt;-A: 當工作流程完成或由政策管理員觸發安全事件（例如會話逾時、重新驗證失敗）時，設備代理和資源閘道之間的連接將被終止。  </pre></div><h2 id="Enclave-Based-Deployement">Enclave-Based Deployement</h2><div class="note info flat"><p>“Enclave” 是一個安全隔離的計算環境，可以保護敏感數據和應用程式免受未經授權的存取或攻擊。</p></div><p><img src="https://i.imgur.com/R85LkBO.png" alt=""></p><ul><li>是 Device Agent / Gateway Model 的一種變體，企業的資產（裝置）透過<code>使用Agent設備代理連接到Enclave gateway</code>，連接過程基本與Device Agent / Gateway相同。</li><li>Gateway 主要保護不只單一資源，而是多個。</li><li>缺點是網關保護一組資源，可能無法保護每個資源，這可能使得使用者看到他們無權訪問的資源。</li><li>適用環境：<ul><li>適用於具有 legacy 應用程式或on-premises 數據中心的企業，無法為每個資源設置個別的 gateway。</li><li>企業需要建立強大的資產和配置管理，以進行安裝/配置設備代理 Device Agents，這樣才可以允許 subjects 看到有哪些權限可以存取。</li></ul></li></ul><h2 id="Resource-Portal-Based-Deployment">Resource Portal-Based Deployment</h2><p><img src="https://i.imgur.com/wU864uN.png" alt=""></p><ul><li>這個模型相比其他模型的主要優勢在於，<strong>不需要在所有客戶端設備上安裝軟體元件</strong>。</li><li>這個模型也有一些限制：<ul><li>由於只有當設備連接到PEP閘道時才能掃描和分析資產和設備，因此<strong>僅能從請求設備獲得有限的信息</strong>。</li><li>模型可能<code>無法持續監控這些設備</code>，檢測惡意軟體、未打補丁的漏洞和適當的設定。</li><li>此模型中沒有本地代理程式處理請求，因此企業<code>可能無法完全查看或隨意控制資產</code>，只有在它們連接到閘道時才能看到/掃描它們。</li></ul></li><li>適用情境：<ul><li>這使得該模型更<strong>適用於BYOD政策</strong>（Bring Your Own Device，即員工使用自己的裝置進行工作）和<strong>跨組織協作項目</strong>。</li></ul></li></ul><h2 id="Device-Application-Sandboxing">Device Application Sandboxing</h2><p><img src="https://i.imgur.com/moNnJsX.png" alt=""></p><ul><li>是 Device Agent / Gateway Model 的一種變體</li><li>讓審核過的應用程式 <strong>Trusted App 或 Process 在「資產上」運行</strong>，進行區隔管理。</li><li>區隔可以是<code>虛擬機、容器</code>或其他形式的實現，目的是保護應用程式免受可能被入侵的主機或其他應用程式的影響。</li><li>PEP可以是企業的本地服務或雲服務，負責管理應用程式的訪問。</li><li>這個模型的優點是將個別應用程式與資產的其餘部分隔離，有助於防止感染。</li><li>缺點：<ul><li>企業需<strong>維護所有資產的沙箱應用程式</strong>，且可能<code>無法完全了解客戶端資產</code>。</li><li>還需要<strong>確保每個應用程式的安全性</strong>，可能相較於其他架構需要<code>花更多努力</code>。</li><li>無法瞭解客戶端資產（裝置）。</li></ul></li><li>適用環境：<ul><li>無法掃瞄資產assets是否存在漏洞，這個模型可以保護AP防止主機上潛在的惡意軟體。</li></ul></li></ul><h1 id="OMB-5大支柱">OMB - 5大支柱</h1><p>美國聯邦政府發布的ZTA政策就是<strong>參考CISA的陳熟度模型以7個pillar</strong>做區分，分別針對identity, devices, networks, applications, data 給出意見具體闡述滿足零信任架構所應滿足的要求。</p><div class="note warning flat"><p>而這其中，有些要求適用於應用程式應滿足的要求，例如針對應用安全應該要確保第三方元件的安全並且有足夠的安全城市。<code>但是，並無特別列出政府機構之應用服務在存取資源時應滿足的要求</code>，而<strong>資料安全方面也僅僅提出基本的要求</strong>，包含對重點資料座標記、自動化分類、自動化安全回應等。</p></div><details class="toggle" ><summary class="toggle-button" style="">Identity 身份驗證</summary><div class="toggle-content"><h2 id="Identity">Identity</h2><p>良好的身分驗證系統是ZTA的基底，政府機構應該要整合身分驗證系統，並根據需要可以和其他機構聯合訪問(Federation)。<strong>並且擴大對MFA來保護使用者避免credential-theft或是釣魚攻擊</strong>。要求含以下：</p><ol><li>建立SSO服務驗證<ol><li>建立SSO服務給使用者，可以和應用程式和通用平台(雲服務)整合</li><li>確保跨各種平台具有相同級別的強身份驗證。</li><li>SSO應該使用公認的標準像是SAML或OpenId連線</li></ol></li><li>應用層 必須 加強 MFA<ol><li>For agency staff, contractors, and partners: phishing-resistant MFA is required.</li><li>For public users: phishing-resistant MFA must be an option.</li><li>必須使用phishing-resistant method 去存取帳號，像是註冊手機電話for SMS或是voice calls，或是WebAuthn，支援one-time codes</li></ol></li><li>實施安全密碼政策，並檢查密碼是否能夠抵抗以外洩的資料</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">Devices 裝置監控</summary><div class="toggle-content"><h2 id="Devices">Devices</h2><p>針對資產的檢測和監控：</p><ol><li>要提供一套服務以改進對資產(裝置那些)的檢測和監控，全面了解有哪些使用者、裝置、或是任何在系統的互動。</li><li>Continuous Diagnostics and Mitigation (CDM) 計畫要實施，可以參考Cisco提供的<a href="https://www.cisa.gov/resources-tools/programs/continuous-diagnostics-and-mitigation-cdm-program">CDM Program</a></li><li>需要有強大的Endpoint detection and response (EDR) 端點偵測與回應 工具來部屬，</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">Networks 網路安全</summary><div class="toggle-content"><h2 id="Networks">Networks</h2><ul><li>DNS請求加密</li><li>使用HTTPS連線</li><li>網域開啟 MTA Strict Transport Security (MTA-STS)<ul><li>使用MTA-STS 針對傳送到您網域的電子郵件要求進行驗證檢查和加密作業，讓Gmail 的安全性更加完善。</li><li>寄件伺服器支援 MTA-STS，並且收件伺服器在強制執行模式下設有 MTA-STS 政策，就能讓電子郵件的 SMTP 連線更加安全。</li></ul></li><li>每個應用程式應該都要在獨立的網路環境中，應該準備好在不同應用之間建立不受信任的網路安全連線</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Applications 應用程式安全</summary><div class="toggle-content"><h2 id="Applications">Applications</h2><ul><li>應用要做足夠專門嚴格的安全測試</li><li>第三方元件要夠安全</li><li>應用的漏洞報告，不要隱瞞</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Data 資料安全</summary><div class="toggle-content"><h2 id="Data">Data</h2><ul><li>針對<code>重點資料做標記</code>，並<code>進行資料的一些自動化分類</code>或是<code>安全性的回應</code></li><li>必須要有全面和即時的<code>完整logging紀錄</code></li><li>自動化的安全回應:<ul><li>機構應努力採用植根於機器學習的數據敏感性分類，和安全自動化的早期候選者，這些候選者不需要立即使用機器學習，可以先用簡單的技術向是腳本或是正規表達式來應用</li><li>盡可能地提供異常行為早期預警和檢測流程</li></ul></li><li>審核對雲中敏感數據的訪問<ul><li>使用加密來保護靜態數據</li><li>可以通過雲端管理的加密和解密操作，以及相關日誌來幫助檢測</li><li>在成熟的階段，機構應該將審計日誌與其他事件數據來源結合起來，採用更複雜的安全監控方法。</li><li>例如，可以比較數據訪問的時間與用戶啟動事件的時間，以識別可能不是由正常應用程序活動引起的數據庫訪問。</li></ul></li></ul></div></details><h1 id="DOD-ZTA-假設">DOD - ZTA 假設</h1><p>這裡主要參考DoD中的<code>chapter 2. Pillars and Principles</code>，裏面提到零信任安全策略原則，如果有人問你…零信任的核心理念是什麼？你可以回答:</p><ul><li>本文提到「<strong>零信任策略的核心理念是在訪問敏感數據或受保護資源之前，要求持續性的驗證或驗證</strong>」。</li><li>零信任安全模型中，「<strong>我們需要重新思考如何對實施對資源的安全訪問，並且由動態策略來決定</strong>」而這裡的動態策略應考慮到以下，超出了僅僅進行憑證驗證的範圍包含:<ul><li>(1) <code>用戶和端點身份</code>的可觀察狀態: 信心水平是從被驗證主體的多個屬性中建立的（身份，位置，時間，設備安全狀態）</li><li>(2) <code>應用程序/服務</code></li><li>(3) <code>請求</code>的資產</li><li>(4) 其他<code>行為</code>和<code>環境屬性</code></li><li>(5) 允許對訪問請求進行<code>更全面的評估</code>。</li></ul></li></ul><p>在DoD中，主要提到<strong>零信任有五個主要原則</strong>，這些原則代表了基本元素，並影響了零信任中的所有方面。</p><details class="toggle" ><summary class="toggle-button" style="">1. Assume a Hostile Environment 假設環境是危險的</summary><div class="toggle-content"><ul><li>假設在<code>環境內部和外部，都有惡意人士</code>存在。</li><li><strong>所有用戶、設備、應用程序、環境和其他非人實體都被視為不受信任</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">2. Presume Breach 假設環境內部已遭受入侵</summary><div class="toggle-content"><ul><li>每天都有數十萬次針對DoD環境的嘗試性網絡攻擊。</li><li>在進行操作和保護資源時，要有一個假設：<code>敵對方已經進入您的環境</code>。</li><li><code>強化對訪問和授權決策的審查</code>，以改善應對結果。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3. Never Trust / Always Verify. 不要信任，始終驗證</summary><div class="toggle-content"><ul><li><code>默認情況下拒絕訪問</code>。</li><li>使用<code>最小特權</code>、<code>多個屬性</code>和<code>動態網絡安全策略</code>，對每個設備、用戶、應用程序/工作負載和數據流<strong>進行身份驗證和明確授權</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">4. Scrutinize Explicitly. 明確審查</summary><div class="toggle-content"><ul><li>所有資源都以<code>安全方式一致地訪問</code>，使用<code>多個屬性</code>（動態和靜態）為資源的情境訪問衍生出信心水平。</li><li>對資源的訪問是有條件的，且基於行動和信心水平的結果，<code>訪問可以動態變更</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">5. Apply Unified Analytics 使用統一分析</summary><div class="toggle-content"><ul><li>對數據、應用程序、資產和服務（DAAS）應用統一分析，包括行為特徵，並<code>log每筆交易</code>。</li></ul></div></details><hr><h1 id="DOD-ZTA-Tenets">DOD - ZTA Tenets</h1><p>上面有點像是基礎元件應包含的部分，以下是 <code>chapter 2.4 Reference Architecture Principles</code> 所描述架構在安全方面應採用的指導原則：</p><details class="toggle" ><summary class="toggle-button" style="">原則 #1: 在網路中不假定任何隱含或明示的受信任區域。 <br> Principle #1: Assume no implicit or explicit trusted zone in networks.</summary><div class="toggle-content"><p>這表示不對網路中的任何區域盲目信任。</p></div></details><details class="toggle" style="border: 1px solid  data"><summary class="toggle-button" style="background-color:  data;color:  and services.">原則 #2: 基於身份的認證和授權將嚴格執行，涵蓋對基礎設施、數據和服務的所有連接和訪問。 <br> Principle #2: Identity-based authentication and authorization are strictly enforced for all connections and access to infrastructure</summary><div class="toggle-content"><p>確保只有經過身份驗證和授權的用戶可以訪問相關資源。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #3: 機器對機器（M2M）的認證和授權將嚴格執行，用於伺服器和應用程序之間的通信。 <br> Principle #3: Machine to machine (M2M) authentication and authorization are strictly enforced for communication between servers and the applications.</summary><div class="toggle-content"><p>這保證伺服器和應用程序之間的通信是安全和可信的。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #4: 通過監控和評估用戶和設備行為生成風險簡介，以用於授權用戶和設備訪問資源時。 <br> Principle #4: Risk profiles、 generated in near-real-time from monitoring and assessment of both user and devices behaviors、 are used in authorizing users and devices to resources.</summary><div class="toggle-content"><p>這意味著根據即時生成的風險值來授權使用者和設備訪問特定資源。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #5: 所有敏感數據在傳輸過程中和靜態存儲時都要進行加密。<br> Principle #5: All sensitive data is encrypted both in transit and at rest.</summary><div class="toggle-content"><p>這確保了數據在傳輸和存儲時的安全性。</p></div></details><details class="toggle" style="border: 1px solid  collected"><summary class="toggle-button" style="background-color:  collected;color:  stored">原則 #6: 所有事件都需要持續監控、收集、存儲和分析，以評估其是否符合安全政策。 <br> Principle #6: All events are to be continuously monitored</summary><div class="toggle-content"><p>這有助於保持對系統行為的實時監控和評估。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #7: 政策管理和分發是集中化的。 rinciple #7: Policy management and distribution is centralized.</summary><div class="toggle-content"><p>這意味著所有的安全政策都集中管理和分發，確保統一的安全措施。</p></div></details><h1 id="DOD-7-大支柱">DOD - 7 大支柱</h1><p><img src="https://i.imgur.com/mh7I5x8.png" alt=""></p><p>主要會列出，每個支柱的說明、與AP與DB之間應用的相關程度，以及個人的感想。</p><details class="toggle" ><summary class="toggle-button" style="">User 使用者 ⭐️⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：這個支柱關注保護並限制<code>人員</code>和<code>非人員</code>實體對 (Data, Applications, Assets, Services)<code>DAAS的訪問</code>。包含對身份身份驗證，如MFA, 特權訪問管理 (Privileged Access Management ,PAM)，持續<code>對使用者進行身份驗證、授權和監控活動模式</code>，以管理使用者的訪問和特權，同時保護所有互動。</li><li><strong>感想</strong>：內容有提到，這個User Pillar 不僅僅是針對使用者，但要提出一方式已持續對AP進行身份驗證，並監控活動模式。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Device 設備 ⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：強調在企業中，對設備進行<code>持續的實時驗證、檢查、評估和修補</code>。如使用 Mobile Device Managers、comply to connect（遵守規定才可以連線）或 可信平台模塊（TPM），這些解決方案可以幫助進行設備的信心評估，即確定設備是否是受信任的。並且符合組織的安全標準。同時，這些數據還可以在進行授權決策時提供依據，確保只有合法的設備能夠訪問資源。<ul><li>對於每個訪問請求，應進行其他評估（例如，檢查是否受到威脅、軟體版本、保護狀態、加密啟用和正確配置等）。</li><li>在零信任方法中，能夠<code>識別、驗證、監察、授權、隔離、保護、糾正和控制所有設備</code>至關重要。</li></ul></li><li><strong>感想</strong>：應該驗證執行AP的環境設備是否安全。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Network/Environment 網絡/環境 ⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：這個支柱強調<code>對網絡/環境進行分段（邏輯和物理）</code>，以<code>精細的訪問和策略限制</code>來進行隔離和控制（無論是在場內還是場外）。隨著邊界變得更加精細，微分段提供了更大的保護和控制能力。這一支柱的關鍵在於<code>控制特權訪問</code>、<code>管理內部和外部數據流</code>，以及防止橫向移動。</li><li><strong>感想</strong>：感覺著重在進行網路的微分割，確保企業內外網都有經過控制。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Applications and Workload 應用程式和工作負載 ⭐️</summary><div class="toggle-content"><p><strong>說明</strong>：這個支柱包含 on-premises 或是雲端環境的<code>應用程式和工作負載</code>。Application Delivery 的相關技術可以實現額外的保護，像是開發的 source code 和 libraries 應<code>通過 DevSecOps 的開發實踐</code>來審核，確保應用程序從一開始就安全。</p><ul><li><strong>感想</strong>感覺這是AP方面單方面的安全準則。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Data 數據 ⭐️⭐️⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：瞭解組織的數據及其重要性對於成功實施 ZT 架構至關重要。<code>組織需要根據任務重要性對其數據進行分類</code>，並將此信息用於<code>制定全面的數據管理策略</code>，作為其整體 ZT 方法的一部分。<ul><li>通過對一致有效的數據進行<code>摄取</code>、數據<code>分類</code>、開發<code>架構</code>，以及在靜止和傳輸中<code>加密</code>數據，可以實現這一目標。</li><li><code>DRM</code>、<code>DLP</code>、<code>軟體定義環境</code>和<code>細粒度數據標記</code>等解決方案支持對關鍵數據的保護。</li></ul></li><li><strong>感想</strong>：這很重要，才能特顯出資料庫方面的保護以實現零信任。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Visibility and Analytics 可見性和分析 ⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：<code>上下文詳細信息</code>提供了對其他 ZT 支柱的性能、行為和活動基線的更深入理解。<ul><li>這種可見性改善了對<code>異常行為的檢測</code>，並能夠在安全策略和實時<code>訪問決策中進行動態更改</code>。</li><li>此外，其他監控系統，如感測器數據以及遙測數據，將有助於填充環境的情況，並有助於觸發用於回應的警報。</li><li>ZT 企業將捕獲和檢查流量，不僅關注網絡遙測，還會<code>深入分析數據包本身</code>，準確地發現網絡上的流量並觀察當前存在的威脅，更智能地調整防禦。</li></ul></li><li><strong>感想</strong>：比較重要的是要紀錄Log，作為異常行為檢測和訪問決策中進行動態更改。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Automation and Orchestration 自動化和協調 ⭐️⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：通過基於策略的自動安全流程，在企業範圍內實現快速且規模化的操作。<ul><li>SOAR(Security Orchestration, Automation, and Response)怎麼幫助企業更<code>有效的回應安全事件以降低了響應時間</code>。</li><li>安全協調整合了安全信息和事件管理（SIEM）以及其他自動化安全工具，有助於管理不同的安全系統。</li><li>在 ZT 企業中，<code>自動安全響應需要明確的流程</code>以及對所有環境的<code>一致性安全策略</code>執行，以提供主動的命令和控制。</li></ul></li><li><strong>感想</strong>：著重在怎麼做到自動化的安全響應，透過響應影響策略，實現動態決策。</li></ul></div></details><h2 id="聚合能力與支柱">聚合能力與支柱</h2><div class="note warning flat"><p>這邊會做一個大表格來整理，這樣才能具體知道如何實現Pillar的目標。<br>然後標示出：</p><ul><li>哪些是我們主要探討的</li><li>哪些不是針對應用程式與DATA之間的部分，有需要納入嗎？如果要該如何調整？</li><li>那些不做的部分，有哪些是可以透過補足文獻來補充的。</li></ul></div><p>（圖片放置處）</p><p>上圖展示了七大支柱中，我們應遵循的能力，而這些能力又該如何透過Pillar來滿足，主要可以區分以下兩者：</p><ul><li><strong>Aggregate</strong>:<ul><li>如果在UML的說詞上A指向B，表示 A 擁有 B，但為弱擁有，<code>A 與 B 有各自的生命週期</code>。</li><li>常見用來描述 A 類別擁有 B 的實體，A 與 B 彼此協作，但又可各自單獨存在。</li></ul></li><li><strong>Dependency</strong>:<ul><li>如果在UML的說詞上A指向B，A 使用 B，B 的變化有可能會影響到 A。</li><li>常見描述 A 在使用某些方法時，會將 <code>B 作為參數傳入，但並不持有 B</code>。</li></ul></li></ul><details class="toggle" ><summary class="toggle-button" style="">Aggregate Capabilities 1: Zero Trust Authentication & Authorization</summary><div class="toggle-content"><p>這兩個主要牽涉兩個Pillar的「<code>條件授權能力</code>」Conditional Authorization Capabilities：</p><ul><li><code>User</code><ul><li>侧重于任何被視為人實體或非人實體的對象。</li><li>對系統和資源的授權將<strong>不僅受限於標准角色，還包括屬性狀態、對該實體的分析、特定時間的需求以及訪問資源和數據的理由</strong>。</li></ul></li><li><code>Device</code><ul><li>「條件授權能力」將圍繞系統和執行可接受基準和<code>設備狀態</code>的強制執行。</li><li>系統將持續評估inventories存和遙測數據的當前狀態。進一步的信息將通過<code>狀態掃描和日誌記錄</code>獲取。</li><li><code>系統將能夠實時更新</code>，或者在協調或其他糾正方法的請求下進行更新。</li><li>訪問數據的系統受到的審查程度和要求將與<code>嘗試訪問的數據的安全級別</code>相關。</li></ul></li></ul></div></details><details class="toggle" style="border: 1px solid  Workload and Data Capability"><summary class="toggle-button" style="background-color:  Workload and Data Capability;">Aggregate Capabilities 2: Zero Trust Infrastructure</summary><div class="toggle-content"><p>針對 <code>Infrastructure</code> 的聚合能力主要與 <code>Network and Environments Pillar</code> 有關</p><ul><li>建立在這個支柱上的控制與任何ZT啟用基礎設施的能力有關。</li><li>這不僅可以包括本地基礎設施，還可以包括雲資源。</li><li>可以設計一個宏觀和微觀分割策略，將特定的工作負載分割和隔離，只要這些工作負載被嚴格定義和驗證。這不僅允許所需節點之間的互聯，而且還滿足了軟件定義邊界的連接要求。</li></ul><p>針對保護<code>Application and Workload</code> 的聚合能力主要與 <code>Workloads Pillar</code> 有關</p><ul><li>這個聚合能力包含圍繞工作負載支柱的所有能力。</li><li>這些能力將保護<code>應用程式</code>和為最終用戶<code>提供數據的設備</code>。</li><li>這些能力旨在防止橫向移動，<code>驗證良好的軟體實踐</code>，並將應用程序分割成離散的高度安全的區域。</li><li>對這個區域的連接受到嚴格的審查，並在<code>內部和外部請求之間進行代理</code>。對應用程序呼叫的標準化將有助於適當的實施政策變更和更新。</li></ul><p>針對保護<code>Data</code> 的聚合能力主要與 <code>Data Pillar</code> 有關</p><ul><li>這個聚合能力包含圍繞數據支柱的所有能力。</li><li>這個能力主要在保護資料，飽含標記資料、識別敏感資料、防止外洩或加密敏感資料。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Aggregate Capabilities 3: Analytics and Orchestration</summary><div class="toggle-content"><p>針對<code>Analytics</code>的聚合能力主要與 <code>Visibility &amp; Analytics Pillar</code> 有關：</p><ul><li>在這個支柱下的能力是<strong>連續實體監控、感應器、日誌記錄、事件驅動的分析工具和機器學習的結合</strong>。</li><li>ZT 將<strong>利用機器學習來建立環境數據和分析的基準</strong>。</li><li>機器學習演算法提供基準數據集，通過人工智慧在 ZT 協調中實現 ZT 政策執行。</li></ul><p>針對 <code>Orchestration</code>(協調)的聚合能力主要與 <code>Automation &amp; Orchestration Pillar</code> 有關：</p><ul><li>其焦點將是<code>提供自動化</code>，以<strong>部署政策變更，以確保企業並在敏感數據周圍進行控制</strong>。</li><li>自動化和協調支柱還能夠考慮從軟體定義企業中引入所需目標狀態數據 account for the ingestion of desired target state data from the Software-Defined Enterprise. 。</li><li>雖然早期能力將集中在政策部署上，但隨著技術的演變，<strong>未來的演進將在核心能力中增加人工智慧和機器人流程自動化的能力</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Dependency Capabilities 4: Zero Trust Enabling</summary><div class="toggle-content"><p>以下是成功應用 ZT 安全策略的關鍵：<br><strong>數據治理：</strong></p><ul><li>數據治理是成功應用 ZT 安全策略的關鍵要素。</li><li><code>數據治理提供了管理從數據創建到處理的流程、工具和框架</code>。</li></ul><p><strong>ZT 和風險管理：</strong></p><ul><li>ZT 提供新的發現內容，供風險管理框架（RMF）使用。</li><li>ZTA 導致風險管理框架（RMF）內的流程為 ZT 提供新的發現內容，同時適應 DevSecOps 等現代應用開發實踐。</li><li>影響主要集中在準備、評估和監控步驟。</li><li>準備階段需要大量的發現工作，特別是對數據流的記錄和分割政策的制定。</li><li>隨著 DevSecOps 能力修改應用程序，評估將有所改變。</li><li><code>ZT 需要大量的監控活動，改進反饋給 RMF 過程和事件響應</code>。</li></ul><p><strong>軟體定義企業Software Defined Enterprise：</strong></p><ul><li>軟體定義企業是實現 ZT 架構廣度和深度的關鍵因素。</li><li><code>虛擬化和軟體定義的基礎設施允許隔離數據和應用程序</code>。</li><li>域協調和控制提供企業控制計劃，以推動與 ZT 控制相符的配置和政策。</li></ul></div></details><h2 id="Pillars-Resources-Capability-Mapping">Pillars, Resources &amp; Capability Mapping</h2><p><img src="https://i.imgur.com/4JdywWA.png" alt=""><br>上圖展示「ZT支柱、資源與能力映射」概念展示如何在架構內實施安全措施的操作視角。</p><ul><li><strong>NPE(non-person entity)身份和個人身份獨立追蹤</strong>，允許在執行點之間分離驗證信心水平的驗證路徑。</li><li>認證和授權活動將在企業內的多個專注點上進行，包括使用者和端點、代理、應用程式和數據。</li><li>在每個執行點，<strong>日誌被送往SIEM，進行分析以開發信心水平</strong>。</li><li><strong>設備和使用者的信心水平是獨立開發的，然後在適當情況下進行彙總</strong>，以供策略執行使用。</li><li>如果非人實體或個人實體的<strong>信心分數超過閾值，則它們被授權查看所需數據</strong>。</li><li><strong>數據在途中透過數據防洩（DLP）進行保護</strong>，同時也將數據餵養到SIEM，以確保正確使用數據。</li></ul><details class="toggle" ><summary class="toggle-button" style="">Enterprise Identity Service 企業身份服務</summary><div class="toggle-content"><p>企業身份服務包括三個主要組件：</p><ul><li><strong>聯合企業身份服務（FEIS）Federated Enterprise Identity Service</strong><ul><li>聚合身份憑證和授權，並在聯合組織之間共享，以實現<code>跨域訪問服務</code>。</li></ul></li><li><strong>自動帳戶配置（AAP）Automation Account Provisioning</strong><ul><li>提供身份治理服務，<code>管理用戶權限，執行業務角色</code>，以及基於<code>人員中心活動的帳戶設置和撤銷</code>。</li></ul></li><li><strong>主用戶記錄（MUR）Master User Record</strong><ul><li>實現整體的知識、<code>審計和數據匯總</code>報告，顯示誰可以訪問哪個系統或應用。</li><li>還支<code>援識別內部和外部威脅</code>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Client and Identity Service: ICAM(Identity/Cridential Access Management) 提供德能力</summary><div class="toggle-content"><p><strong>ICAM 提供的能力</strong>：</p><ul><li><strong>持續認證</strong>：一種認證概念，利用多種兼容的認證策略，在用戶和非人實體試圖訪問資源和數據時，以<code>持續的、幾乎即時的方式驗證其身份</code>。</li><li><strong>條件授權</strong>：在授權一個資源時，需要<code>基於請求者的持續信任來決定</code>。這種信任可以受到設備衛生狀況、用戶和實體行為以及其他因素的影響。</li></ul><p>**Comply-to-Connect（C2C）**服務</p><ul><li>在整個網絡基礎設施上運作的一個工具和技術框架，用於<code>發現、識別、描述並報告連接到網絡的所有設備</code>。</li><li>C2C 能力將協調多個工具，<code>防止不符合規定和未經授權的設備和人員連接到網絡</code>，從而保持網絡的安全配置，按照建立的標準和配置保護信息。</li><li>設備衛生：<code>檢查設備的狀態</code>，檢查是否存在惡意軟件或漏洞，以及管理和未受管理資產的安全控制合規性狀態，以確定允許設備訪問資源和數據的風險水平。</li></ul><div class="note info flat"><p>ICAM 是 “Identity, Credential, and Access Management”（身份、憑證和訪問管理）的縮寫，它是一個在資訊技術和資訊安全領域中的概念，旨在確保組織內部和外部的用戶和實體（如設備、系統等）可以安全且適當地訪問敏感資源和數據。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">Data-Centric Enterprise 企業中心數據</summary><div class="toggle-content"><p>企業中心數據主要決策點有分三個部分，主要做Authorization：<br><strong>資源授權決策點 Resource Authorization Point</strong> &amp; <strong>應用授權決策點 Application Authorization Point</strong></p><ul><li>將評估結合的非人實體和用戶，以授權訪問請求。</li><li>與前面的決策點一樣，這將利用信心水平和定義的策略來判斷是否有權訪問。</li></ul><p><strong>應用授權決策點 Application Authorization Point</strong> 的能力：</p><ul><li>保護應用工作負載 Securing Application Workload：能夠保護和管理應用層以及計算容器和虛擬機。能夠識別和控制技術堆棧，以實現更細粒度和準確的訪問決策。</li><li>保護供應鏈 Securing Supply Chain：能夠防止或應對軟體供應鏈攻擊，這種攻擊發生在網絡威脅行為者滲透軟體供應商的網絡，並使用惡意代碼在供應商將軟件發送給客戶之前損害軟件。</li></ul><p><strong>數據授權決策點 Data Authorization Point</strong></p><ul><li>數據所有者使用 ZT 措施通過協調或數據損失防護/災害恢復（DLP/DRP）服務器對<code>數據進行標記</code>。</li><li>數據標記將用於<code>確保所有數據的適當訪問控制得到滿足</code>。</li><li>能力：<ul><li><code>保護數據 Securing Data</code>：流程和技術控制，用於識別、分類、安全處理、保留和處理數據。</li><li><code>數據發現和分類 Data Discovery</code> ：能夠發現、分類、標記和報告數據，包括數據庫中的敏感數據和風險數據。</li><li><code>動態數據遮蔽 Dynamic Data Masking</code>：提供列級安全功能，使用遮蔽策略在查詢時選擇性地遮蔽表和列。<ul><li>列級安全功能（Column-level security）是一種數據安全措施，它允許在數據庫中對單獨的列（也就是數據表的某個特定欄位）進行安全設置和控制。</li></ul></li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Automation and Orchestration 自動化和協調</summary><div class="toggle-content"><p>內容提到了自動化和協調方面的重點，以及一些相關的能力和技術：<br><strong>自動化和協調：</strong></p><ul><li><strong>政策引擎和自動化 (SOAR)：</strong> 這些術語用於定義處理威脅管理、事件響應、政策執行和安全政策自動化的技術。零信任 (ZT) 架構將需要動態政策執行和自動化。SOAR 將與分析和政策引擎協同工作，以發展信心水平並自動將政策傳遞到執行點。</li><li><strong>能力：</strong><ul><li><strong>軟體定義企業：</strong> 能夠在物理基礎架構上創建虛擬化層，並以自動化的方式在中心進行管理，利用基於政策的訪問控制動態創建、配置、提供和解除虛擬化網絡功能、系統功能、安全功能和工作流程。</li><li><strong>網絡安全協調：</strong> 能夠協調和自動化不同的零信任活動，並將它們與核心系統進行接口和協調。</li></ul></li></ul><div class="note info flat"><p>SOAR代表“Security Orchestration, Automation, and Response”的縮寫，翻譯成中文就是「安全協調、自動化與響應」。它是一種資訊安全技術，旨在將安全運營流程自動化、協調和優化，以更快速、更有效地應對安全事件和威脅。這種技術整合了自動化工具、流程協調和威脅情報，使組織能夠更迅速地識別和應對安全威脅，同時降低人工干預的需要。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">Monitoring and Analysis Services 監控與分析服務</summary><div class="toggle-content"><p>這篇論文主要探討「監控與分析服務」，以下是其中重點的解釋：</p><p><strong>分析與信心評分：</strong></p><ul><li>這個系統通過對事件和事故日誌的系統性分析，使用<code>統計學或其他定義的功能性過濾器或計算方法，來獲取信心分數</code>。</li><li>這些分數表示在特定誤差範圍內，對於給定的分析數據集，對統計參數的估計被確定為真實的概率/百分比值。</li><li>在特定情況下，例如零信任環境中，這<strong>代表用戶或NPE（非人類實體）聲稱自己是誰的概率</strong>。</li><li>能力：<ul><li>分析：系統地應用<code>統計</code>和/或<code>邏輯技術</code>來描述、概括和評估數據。</li></ul></li></ul><p><strong>使用安全信息和事件管理的日誌記錄：</strong></p><ul><li>活動數據被匯總並存<code>儲在安全信息和事件管理（SIEM）系統</code>中，該系統提供安全信息管理（SIM）和安全事件管理（SEM）功能。</li><li>能力：<ul><li>審計/傳感器和遙測：直接<code>驗證（例如通過檢查、檢驗或計算）活動或設備</code>，以確保符合安全要求。實體包括用戶和NPE、傳感器可靠性、合規計劃和共享服務。</li></ul></li></ul></div></details><h1 id="DOD-Learn-from-Use-Case">DOD - Learn from Use Case</h1><div class="note warning flat"><p>主要能夠回答以下文題，才給予紀錄並筆記：</p><ol><li>怎麼確保AP與Database之間滿足零信任架構。</li><li>應該怎麼實現動態的Policy存取控制</li><li>在AP與DB之間如何做到持續性的驗證</li></ol></div><hr><blockquote><p>特色：說明針對 Data Center 應該注重的地方</p></blockquote><p><img src="https://i.imgur.com/j8vFKlW.png" alt=""><br>當今的資料安全方法建立在過時的、孤立的網絡中心策略和方法的基礎上。在這種網絡中心的安全模型中，數據容易受到威脅，因為<strong>僅通過基本的安全實踐（如用戶名/密碼、基於用戶/設備的訪問和僅在靜態時加密）以及標準的基於角色的訪問控制（RBAC）來保護數據，而這種控制很少被更新或驗證</strong>。威脅行為者可以迴避這些基本的保護措施。因此從上述來看，文中提到以下針對數據中心應該要實現的能力：</p><ul><li>Encryption: 數據中心的技術，主要在靜態時、字段和記錄內部、傳輸中數據要進行<code>加密</code>。</li><li>Policy Enforcement 中包含<code>數據標記</code>：<ul><li>用途1: 以提供數位版權管理（<code>DRM</code>）和數據丟失防護（<code>DLP</code>）解決方案的數據。</li><li>用途2: 從而允許創建使用<code>基於屬性的訪問控制（ABAC）</code>的額外動態策略。</li></ul></li></ul><blockquote><p>特色：說明貼標籤 和 其他存取動作應該做的時機點（圖片透過<code>禁止</code>來表達誰負責<code>阻止</code>工作）</p></blockquote><p><img src="https://i.imgur.com/cwTJoro.png" alt=""><br>從上圖中可以看到 PEP 中主要闡述以下幾點來<strong>保護數據存儲（Data Store）中的數據</strong>：</p><ul><li><strong>數據標記（Data Tagging）</strong><ul><li>時機：在創建或導入文檔時進行</li><li>工作：<ul><li>對於組織來說，<strong>了解擁有哪些資料</strong>，資料的特性，以及滿足適當資料保護標準所需的隱私和安全需求非常重要。</li><li>組織可以將數據分類並賦予各種屬性。這些屬性可以用於對數據進行分類，例如個人身份信息（PII）和敏感數據。</li></ul></li></ul></li><li><strong>數據權限管理（DRM）+ 數據遺失防止（DLP）+ 安全信息和事件管理（SIEM）+ 數據存儲 進行協作</strong><ul><li>時機：數據標記後</li><li>保護措施：以下這四種保護措施，再加上前面提到的加密等密碼技術，為資料中心的零信任架構提供了強大的資料保護。<ul><li>SIEM：<code>收集並分析</code>對任何被訪問的數據的<code>訪問和變更</code>。</li><li>DRM：可以<code>允許或阻止</code>對數據的訪問、編輯或複製，</li><li>DLP：可以<code>阻止</code>對數據的訪問和傳輸。</li><li>DDM：如果用戶/端點被認為是值得信賴的，並且已經獲得對數據的訪問權限，動態數據遮罩（DDM）將在訪問和傳輸數據時<code>對數據進行遮罩和修改</code>。</li></ul></li></ul></li></ul><div class="note info flat"><p>可能會好奇，DLP跟DRM都有阻止的作用，那他們的差異是？<br><code>DLP 主要針對未知來源的請求，而DRM則是針對已知來源的請求。</code></p></div><blockquote><p>特色：有提到SIEM跟SOAR的關係等監控機制</p></blockquote><p><img src="https://i.imgur.com/m8gsuSe.png" alt=""></p><ul><li>PEP: PEP 認證後，對加密資料進行解密工作，給請求的 user / device</li><li>SIEM: 任何請求都會被 SIEM 所紀錄，並且進行分析，一但發現可疑的地方就會觸發事件通知SOAR，由 SOAR (Security Orchestration, Automation, and Response) 處理。</li><li>SOAR: 遵循事件響應程序，可以<code>部署緩解策略</code>來<code>終止現有會話</code>、<code>重新加密數據</code>並<code>更新 PEP 上的策略</code>以拒絕未來的請求。</li></ul><blockquote><p>特色：主要提到 PDP，並說明PDP主要處理請求(標籤,DRM,DDM,DLP,加密連線相關)，PEP 則是即時保護資料和接收（加密,標籤,DRM 相關）。</p></blockquote><p><img src="https://i.imgur.com/KAmczyW.png" alt=""></p><ul><li>架構優勢：強調保護資料本身，而非僅限於資料邊界。</li><li>資料請求路由：透過政策決策點（PDP）進行，未滿足政策的請求無法訪問。</li><li>政策更新：PDP政策即時通過設備健康、特權訪問管理和分析保持更新。</li><li>連接管理：PDP政策變更時，PEP可終止現有連接。</li><li>資料保護：多個策略執行點（PEP）持續保護資料，並使用加密、標記、遮罩DDM和防止損失DLP等措施。</li><li>政策協調：ZT架構組件間的政策協調實現深度防禦，維護資料完整性、可用性和機密性。</li></ul><blockquote><p>特色：著重在 Analysis + AI/ML 對於 Policy 的應用。<br><img src="https://i.imgur.com/w48kovr.png" alt=""></p></blockquote><ul><li>ZT 模型中透過 AI 大幅提升環境的可見性、洞察力和自動化能力。</li><li>全面收集與分析：從環境的各個方面集中收集數據並進行分析。</li><li>透過 SIEM 分析，發現威脅則透過SOAR處理。</li><li>未來分析使用：這些信息將被記錄並存儲，以用於未來的機器學習和人工智慧，包括用戶/非特權實體的信心評分、高級威脅檢測、創建和修改基準線，以及與外部情報計劃和其他人工智慧一起進行自動化和編排。</li></ul><h1 id="DOD-零信任架構-Pattern">DOD - 零信任架構 Pattern</h1><div class="note warning flat"><p>應該要根據內容的章節7.1與7.2歸納出所有架構的pattern，並且指出研究適用的Pattern與說明原因。</p></div><h2 id="Domain-Policy-Enforcement-for-Resource-Access">Domain Policy Enforcement for Resource Access</h2><p><img src="https://i.imgur.com/bPpmMu1.png" alt=""></p><ul><li><strong>說明</strong>：主要架構分三段 Resource Domain：Secured User or Device / Secured Network / Secured Application and Data ，<code>每一段都有他們自己的 domain orchestrator 可以想像是設定 policies 的地方</code>，然後Controller進行控制，而做到統一的方式就是透過 Networ + application and data 的 orchestrator 收集資料，並傳送到 Cybersecurity Domain Orchestrator 近一步分析可疑的地方。一但發現威脅，就會透過 automated 調整 policies，以減少威脅。</li><li><strong>優點</strong>：可以根據不同的 Domain <code>精準設定</code> policies，並且透過 Controller 進行控制。這可能更像我的研究內容，針對AP與DB之間的控制措施。</li><li><strong>缺點</strong>：透過分成不同的 Domain Policy Enforcement 在資料傳輸的過程中，可能有<code>授權驗證的不一致性</code>。</li></ul><h2 id="Software-Defined-Perimeter">Software Defined Perimeter</h2><p><img src="https://i.imgur.com/Gip0hBe.png" alt=""></p><ul><li><strong>說明</strong>：其主要特性有二，一個可用來轉發 <code>end-to-end 之間訊息並進行攔截中斷以執行零信任授權的 gateway</code>。另一個主要是說需要在<code>端點上安裝代理</code>，執行身份驗證、健康狀態檢查、扮演類似PEP的角色。而這邊需要注意的是，會<code>透過Broker來進行端點註冊、授權</code>，作為PDP的角色存在。如果授權驗證通過，就會透過 Gateway 建立 Proxy 進行 Direct Link 連接兩個端點的連線。</li><li><strong>優點</strong>：容易做到<code>政策控制的統一性</code>，並且能夠確保所有連接的<code>裝置都是受管控</code>的，因為必須裝 Agent 才得以建立連線。</li><li><strong>缺點</strong>：<code>技術難度</code>感覺較高，需要有完整的註冊流程和建立連線流程，在連線上的考慮更多。</li></ul><h2 id="ZT-Broker-Integration">ZT Broker Integration</h2><p><img src="https://i.imgur.com/WLnOzP0.png" alt=""></p><ul><li><strong>說明</strong>：與Software Defined Perimeter有點類似，所有應用程序都對最終用戶網絡隱藏，並且所有連線都須透過信任代理進行連接。但這可能會與Software Defined Perimeter有一點混淆，他們都有Broker, Agent但是差在哪裡呢？差異大概有以下：<ul><li>Broker 同時作為 PDP 和 PEP ，PEP 和 PDP 可以成對分佈(可以多個)，由單個虛擬服務實現，並且可以進行load balancer實現。</li><li>Broker 可以分散在 edge, 中間層 mid-tier 或是 data center</li><li>Service Proxy 是裝在 Broker 裏面，不是 Resource Application</li><li>並沒有強調要透過 Gateway 來進行連接(Proxy連線)。</li></ul></li><li><strong>優點</strong>：PEP, PDP 可以在多個地方部署、load balancer，甚至是以單個虛擬服務實現，可以更普遍的設置存取控制點在不同的地方。</li><li><strong>缺點</strong>：但是在多個地方同時有PEP,PDP的情況下，可能會造成<code>授權驗證的不一致性</code>，並且 Resource Application 沒有安裝 Agent，<code>不能保證應用程式是受管控</code>的。</li></ul><h2 id="Micro-Macro-Segmentation">Micro / Macro  Segmentation</h2><p>Micro / Macro Segmenetaion 主要是透過第三層網路架構的方式實現ZTA，與本文章想要探討的主題有點不同，因此不會做太多說明與介紹。<br><img src="https://i.imgur.com/2f4DCSy.png" alt=""></p><ul><li><strong>說明</strong>：在這個架構中，主要角色是 Next Generation Firewall，在這種架構中，所有的流量在<code>到達其目的地微分區之前都必須通過NGFW</code>。在某些情境，微分區可以繼續分解成更小的組件，定義進程對進程的微分區，並<code>演變為API微分區</code>。當用戶對三層Web應用程序進行請求時，流量會先經過Web服務的PEP &gt; 再由應用程式PEP評估流量 &gt; 請求返回給用戶之間再進行評估一次。總共三層，這種方式確保了在多層應用架構中，每一個階段的流量都經過了嚴格的策略評估，從而增強了安全性。但是問題是，<code>應用程式到資料庫之間，並沒有任何評估，就變像是相信應用程式</code>。</li></ul><h1 id="DOD-成熟度模型">DOD - 成熟度模型</h1><div class="note warning flat"><p>這邊主要說明若要滿足ZTA的成熟度模型，需要做到哪些事情。</p></div><h2 id="Preparae-for-ZTA">Preparae for ZTA</h2><div class="note info flat"><p>關鍵字：辨識重要資源清單、資料流、網路流量Log</p></div><p>要做的事情主要有兩個部分：</p><ul><li><code>Discovery</code><ul><li>辨識 DAAS (數據、應用程序、資產和服務)</li><li>對照 data flows</li><li>建立 使用者 和 裝置清單</li><li>辨識特權帳戶</li><li>紀錄網路 traffic</li></ul></li><li><code>Assessment</code><ul><li>利用現有標準確定合規狀態</li><li>確定帳戶有適當的權限</li><li>確保網路/環境安全設定滿足最小權限原則</li></ul></li></ul><h2 id="ZTA-Baseline">ZTA Baseline</h2><div class="note info flat"><p>關鍵字：<code>網絡分段</code>、<code>最小權限原則</code>、<code>MFA</code>、<code>資料辨識標籤</code>、<code>加密</code></p></div><p>要做的事情主要有以下：</p><ul><li>確保存取 DAAS 的時候是經由 Cybersecurity policies 所決定的。</li><li>網絡採用拒絕全部/例外允許進行分段 （白名單）</li><li>裝置IT的安全政策要求並管理</li><li>實現最小權限存取</li><li>使用 MFA</li><li>進行 data 辨識，並標示敏感或關鍵資料</li><li>滿足加密要求</li></ul><h2 id="ZTA-Intermediate">ZTA Intermediate</h2><div class="note info flat"><p>關鍵字：<code>細顆粒度</code>、<code>Micro-Segementation</code>、<code>EFIS</code>、<code>PAM</code>、<code>DLP &amp; DRM</code>、<code>UEBA</code></p></div><p>要做的事情主要有以下：</p><ul><li>加強 cybersecurity 政策，基於細顆粒度(user and device attribute)進行控制</li><li>主要網路段使用 Micro-Segementation</li><li>User 基於 Enterprise Federated Identity Service 進行驗證</li><li>透過 Privileged access management (PAM) 增強最小特權</li><li>實施 DLP &amp; DRM</li><li>資料透過 flow analysis 和簡單的自動化進行標籤與分類</li><li>使用者和Entity的行為分析（UEBA, User and Entity Behavior Analytics）建立 baseline policy</li></ul><h2 id="ZTA-Advanced">ZTA Advanced</h2><div class="note info flat"><p>關鍵字：<code>動態決策</code>、<code>持續驗證與授權</code>、<code>user + device 滿足 EFIS</code></p></div><p>要做的事情主要有以下：</p><ul><li>可以做到動態的決定是否可以存取 DAAS，強大的實時分析驅動</li><li>完全的 micro-segmentation</li><li>持續性適應驗證與授權</li><li>User + Device 基於 Enterprise Federated Identity Service 進行驗證</li><li>完全的實施 Just-in-Time 和 Just-Enough 的存取政策</li><li>透過 machine learning 進行資料的標示與分類</li><li>進階分析技術，使威脅檢測能夠自動化並根據事先設計的策略進行協調</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Zero Trust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碩士論文 </tag>
            
            <tag> Zero Trust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIST SP 800-209 資料儲存安全指引 Security Guidelines for Storage (2) 安全指引</title>
      <link href="/posts/security-for-storage-infra-2/"/>
      <url>/posts/security-for-storage-infra-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因為之前的篇幅<a href="/security-for-storage-infra">NIST SP 800-209 資料儲存安全指引 Security Guidelines for Storage (1) 威脅與風險</a>擔心太長，因此再建立一的新的Post來進行整理。</p><div class="note info flat"><p>上一篇主要針對資料儲存基礎設施盤點相關的威脅、風險和攻擊面。<br>本篇則是主要整理儲存部署的安全建議。<code>論文的貢獻可以在於強調可以滿足零信任要求與資料儲存相關安全標準SP800-209的相關措施。</code></p></div><h1 id="4-儲存部署安全建議-Security-Guidelines-for-Storage-Deployments">4. 儲存部署安全建議 Security Guidelines for Storage Deployments</h1><p>第4.1至4.12節提供了<strong>存儲基礎架構安全的安全建議和指南</strong>，透過其命名和編號方案旨在確保每個指南都有獨特的識別號。主要的唯一識別號採用“<strong>xx-SS-Ry</strong>”的形式。</p><p>但是，因為本人的論文希望更著重在，AP(客戶端)與資料儲存裝置之間連線時和主機本身的安全措施，<code>因此本章節並不會列出所有的安全建議，僅列出與AP(客戶端)與儲存裝置之間，又或是「儲存基礎設施本身」的安全建議</code>。</p><div class="note info flat"><ol><li>“xx”是與節點標題相關的兩個字母組合：在第4.1節“物理存儲安全”中，主要識別號標記為PS-SS-R1，PS-SS-R2等</li><li>“SS”代表“Storage Security”</li><li>“y”是連續的數字識別號：如果有細項還會透過&quot;a&quot;, &quot;b&quot;表示，例如‘PS-SS-R1.a’（遵循NIST SP 800-53，第3.10節），‘PS-SS-R1.b’（供應鏈保護）等。</li></ol></div><div class="note warning flat"><p>我的感想：<strong>這個章節可以用來整理，如果要檢查AP、AP Host本身、儲存裝置Host本身、儲存裝置之間的安全措施，根據這些安全建立來進行檢查，並作為檢查項目之一，以此來進行授權與存取控制，避免可能的安全威脅</strong>。</p></div><h1 id="4-1-PS-實體儲存安全-Physical-Storage-Security">4.1 (PS) 實體儲存安全 Physical Storage Security</h1><p>實體安全是確保任何資訊科技「基礎建設安全」的「基本要素」。很多時候「<strong>儲存基礎建設的實體安全」要求與「其他基礎建設元素」</strong>（例如電腦和網路設備）<strong>相同（例如設施安全、監控、運輸等）</strong>。</p><ul><li><strong>基礎建設元素</strong>可以參考的相關標準包含：<code> NIST SP 800-53, Rev5 NIST SP 800-171</code> 。</li><li>有關<strong>媒體處置和銷毀</strong>可以參考：<code>ISO 27040, NIST SP 800-88</code> 有更近一步的討論。</li></ul><div class="note info flat"><p>因此本章節主要提供針對<code>儲存基礎建設獨有的實體安全</code>，或其他刊物中較少強調的方面進行條例介紹。</p></div><details class="toggle" ><summary class="toggle-button" style="">要求：PS-SS-R1 確保媒體安全 Media security measures</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px"><code>PS-SS-R1</code></div></th><th>確保媒體安全</th></tr></thead><tbody><tr><td><code>PS-SS-R1.a</code></td><td>建議<strong>遵循NIST SP 800-53, Rev5</strong> 的一些特定指導措施，包括制定政策、限制訪問權限、標記敏感信息、安全存儲、安全傳輸、確保數據</td></tr><tr><td><code>PS-SS-R1.b</code></td><td>建議購買擁有<strong>足夠供應鏈保護的媒體</strong>。</td></tr><tr><td><code>PS-SS-R1.c</code></td><td>對於敏感數據，<strong>「備份實體」媒體儲存與「主要數據儲存」地點應該足夠遠</strong>。</td></tr><tr><td><code>PS-SS-R1.d</code></td><td><strong>整理敏感數據的清單</strong>，並應紀錄的內容包含：敏感級別、分類(與哪些應用和服務相關)、加密級別、如果數據破壞或丟失可能對系統造成的影響、應急的措施與程序、數據與其他應用之間的依賴關係。</td></tr><tr><td><code>PS-SS-R1.e</code></td><td>敏感的<strong>可移動媒體，應使用高級追蹤控制措施</strong>，例如RFID標籤、GPS追蹤設備、防竄改保護。</td></tr><tr><td><code>PS-SS-R1.f</code></td><td><strong>極度敏感</strong>的資訊，應考慮使用自我激活或遠程控制的<strong>自我毀滅機制</strong>，同時應仔細考慮如何保護這些功能以避免被攻攻擊者作為攻擊目標，觸發設備毀損機制。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：PS-SS-R2 保護所有敏感管理裝置 Protect all sensitive administrative equipment</summary><div class="toggle-content"><p>可以**對儲存設施進行存取的「管理工作站」**應該要有以下措施：</p><ol><li><code>有組織批准之安全控制</code>：對於可以「獲取儲存基礎設施」的「敏感工作站」應進行管理訪問，使用經組織批准的安全控制，包含訪問、監控和審計。</li><li><code>與數據保護一樣嚴謹的安全等級</code>：保護「管理工作站」（包含家中所使用的工作站環境）的安全措施至少要與「保護數據」或「使用數據的系統」擁有一樣嚴格的安全措施。</li></ol></div></details><details class="toggle" style="border: 1px solid  including non-obvious storage components"><summary class="toggle-button" style="background-color:  including non-obvious storage components;">要求：PS-SS-R3 資料消除方法應該包括儲存基礎設施中的各個元件 Data sanitization approach should cover storage infrastructure in detail</summary><div class="toggle-content"><ul><li>資料消除方法應該包括儲存基礎設施中的各個元件，而這些元件可能包含敏感資訊，<strong>應確保儲存基礎設施中的元件間都納入組織的資料消除政策</strong>，這些元件包含以下：<ul><li>非揮發性記憶體</li><li>快取對象（儲存陣列、SAN交換器、路由器等）</li><li>韌體/BIOS設定和HBA級別的設置</li></ul></li></ul></div></details><h1 id="4-2-DP-資料保護-Data-Protection">4.2 (DP) 資料保護 Data Protection</h1><p>本章節主要探討資料保護的相關措施、角度、分離程度等進行探討。而相關要求應該要考慮到以下層次：</p><details class="toggle" ><summary class="toggle-button" style="">資料保護不同角度</summary><div class="toggle-content"><p>在這個章節中，主要討論資料保護的目標和相關活動，從不同的角度進行控制，包含以下：</p><ol><li><strong>資料備份和恢復（Data backup and recovery）</strong>：這是確保資料在<code>意外故障或災難性事件後復原</code>的重要控制措施。</li><li><strong>存檔（Archiving）</strong>：這是將資料保留在長期存儲中的控制措施，通常用於保存歷史資料或法規要求的資料。</li><li><strong>複製技術（Replication technologies）</strong>：這是在不同位置或系統之間建立資料複製的控制措施，以確保在主要<code>系統故障時能夠使用備用系統</code>。</li><li><strong>持續資料保護（Continuous data protection）</strong>：這是一種<code>持續監視資料變化</code>並<code>即時備份</code>的控制措施，能夠快速恢復到特定時間點的資料。</li><li><strong>點對點拷貝和快照（Point-in-time copies and snapshots）</strong>：這是在特定時間點上複製資料的控制措施，以便在<code>需要時進行還原或查詢</code>。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">識別區分數據平面</summary><div class="toggle-content"><p>當我們談論儲存管理和保護數據時，<strong>區分不同的數據平面</strong>對於<strong>更好地理解和管理儲存系統至關重要</strong>。這是因為數據平面提供了一種方式來組織和區分數據相關的存取方法、協議、操作和授權，從而確保系統可以在不同層面上有效運作並滿足不同的需求。數據平面的主要類型包含：</p><ol><li><strong>數據消費平面</strong>：該平面涉及<code>執行I/O操作</code>的存取方法和協議，以及相關的網絡連接。這是用戶和應用程序進行數據讀取和寫入的平面。</li><li><strong>數據管理平面</strong>：該平面<code>涉及創建、配置、映射設備</code>以及設備屬性的<code>管理</code>。它關注的是管理儲存系統中數據的元信息和配置信息。</li><li><strong>數據保護平面</strong>：該平面涉及<code>數據的保護和備份</code>。它包括複製、快照、備份、存檔等操作，以確保數據的持久性和容災能力。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">資料平面分離程度</summary><div class="toggle-content"><p>通常情況下，<strong>增加資料平面的細粒度和分離程度可以積極地影響資料資產的安全性</strong>，而設計和實施可能極大地影響，而這些設計和實施包含：</p><ol><li><strong>網路層兩層分離</strong>：例如使用不同的<code>VLAN</code>增加分離程度。</li><li><strong>網路邏輯分離</strong>：<code>獨立的IP子網路</code>增加分離程度。</li><li><strong>過濾和訪問控制列表ACL</strong>：在資料的<code>消費平面添加ACL</code>防止管理操作，增加「消費」與「管理」平面的分離程度。</li><li><strong>授權分離</strong>：限制每個角色的權限，<code>不同平面所使用的角色</code>不同。</li></ol></div></details><div class="note info flat"><p>在該節中，也提供了針對上述每個控制措施的實施相關的嚴謹建議。而且，<code>其他相關的需求還包含在第4.7節“隔離”和第4.8節“還原保證”中，這些需求與資料保護密切相關</code>。</p></div><h2 id="4-2-1-資料備份、恢復和儲存-Data-Backup-and-Recovery-and-Archiving">4.2.1 資料備份、恢復和儲存 Data Backup and Recovery, and Archiving</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R1 建立資料保護計劃或政策的文件</summary><div class="toggle-content"><p>這份文件旨在確保在<strong>部署系統或資料存儲解決方案之前，組織有一個完整的、安全的資料保護計劃</strong>，以應對可能出現的數據損壞、故障或安全問題。這些措施將<code>有助於保護數據的完整性和可用性</code>，同時確保遵守相關的法規要求。</p><table><thead><tr><th><div style="width:100px"><code>DS-SS-R1</code></div></th><th>建立資料保護計劃或政策的文件</th></tr></thead><tbody><tr><td><code>DP-SS-R1.a</code></td><td>層級、頻率和備份數量規格，以滿足組織的恢復目標。應包含如下：<br> - 頻率和保留期：例如，每48小時快照、每日30份備份。<br> - 類型：例如，完整備份、增量備份、連續備份（如文件版本控制、日誌或日誌運送和存檔）、複製、點對點備份等。</td></tr><tr><td><code>DP-SS-R1.b</code></td><td>要使用的媒體類型。</td></tr><tr><td><code>DP-SS-R1.c</code></td><td><strong>加密要求</strong>應用於「備份數據」的加密方法應至少<strong>與「受保護數據」的加密程度相同</strong>。</td></tr><tr><td><code>DP-SS-R1.d</code></td><td>其他保護要求，例如數位簽章、存檔、位置、設施安全（包括防火、防爆和磁干擾保護）、不可變性和鎖定、每個備份集的最低備份数量，以及這些備份的地理分佈。</td></tr><tr><td><code>DP-SS-R1.e</code></td><td>引用適用的法規框架以及相應的控制措施。</td></tr><tr><td><code>DP-SS-R1.f</code></td><td><strong>全面的生命周期管理</strong>，包括根據保護和保留政策跟踪數據副本和備份，包括積極刪除不再需要的數據副本。</td></tr><tr><td><code>DP-SS-R1.g</code></td><td><strong>恢復程序</strong>。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R2 資料保護計劃或政策應盡可能「全面」</summary><div class="toggle-content"><p>資料保護計劃或政策應盡可能「全面」，要求如下：</p><table><thead><tr><th><div style="width:100px"><code>DS-SS-R2</code></div></th><th>資料保護計劃或政策應盡可能「全面」</th></tr></thead><tbody><tr><td><code>DP-SS-R2.a</code></td><td>應<strong>包含企業所有資料資產，無論是本地或雲端</strong>：儘管對於那些沒有重要性的資料，或可以從其他受保護資料來源中，重新建立的資料資產，可以不進行保護，但這樣的例外應有文件紀錄。</td></tr><tr><td><code>DP-SS-R2.b</code></td><td>應<strong>以資料類型進行組織層級</strong>（第一層、第二層）。</td></tr><tr><td><code>DP-SS-R2.c</code></td><td>應考慮<strong>應用程式和業務流程層面的資料完整性</strong>：若是有兩個元件使用相同之資料，進行恢復時需要恢復到相同的時間點才能正常運作，則應該針對這種情境實施「聯邦一致性機制」等解決方案。</td></tr><tr><td><code>DP-SS-R2.d</code></td><td>應考慮到滿足業務或監管要求的<strong>恢復速度</strong>。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R3 對於備份相關的標準作業程序應包含的要求</summary><div class="toggle-content"><p>除了備份計畫或政策之外，與備份相關的標準作業程序應該包括以下內容：</p><table><thead><tr><th><div style="width:100px"><code>DS-SS-R3</code></div></th><th>備份相關的標準作業程序要求</th></tr></thead><tbody><tr><td><code>DP-SS-R3.a</code></td><td>應該<strong>定期檢查備份的執行情況</strong>，並在需要時通知相關人員。</td></tr><tr><td><code>DP-SS-R3.b</code></td><td>定期測試備份：<br> 1. <strong>重要的資料備份可還原性</strong>：應至少每月一次，以驗證其完整性和可還原性。<br> 2. <strong>嚴格要求還原速度的應用程式可用性</strong>：應進行端對端測試環境（例如將數據集完整還原到一個模擬真實還原情況的測試環境中，稱為sandbox recovery environment）。</td></tr><tr><td><code>DP-SS-R3.c</code></td><td>1. <strong>應保持最新的恢復目錄</strong>：追蹤每個副本（包括備份、複製、時間點副本等）的相關資訊，資訊包含防毒工作掃描結果。<br> 2. <strong>對於敏感資料，應定期使用防毒工具</strong>：掃描至少一個過去副本的子集識別是否有被感染的副本。目錄需求可參考CM-SS-R2。</td></tr><tr><td><code>DP-SS-R3.d</code></td><td>定期審查（至少每年一次）<strong>備份計畫和操作程序</strong>，以確保其持續適應當前需求。</td></tr><tr><td><code>DP-SS-R3.e</code></td><td><strong>維護一份審計記錄</strong>，提供必要的資訊以確保操作符合政策要求。</td></tr><tr><td><code>DP-SS-R3.f</code></td><td>應包含必要時所採取<strong>特殊控制措施</strong>（例如，將舊的、有風險的或不再支援的媒體複製到新的媒體中，等等）。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R4 資料保護配置管理的要求</summary><div class="toggle-content"><p>以下要求旨在<strong>確保資料保護配置的安全性、穩定性和一致性</strong>，同時保障系統的高可用性和容錯性。</p><ol><li><strong>集中式管理</strong>：所有與資料保護相關的配置，包括備份、點對點時間複製和複寫等，應該由一個中央管理系統或管理員來統一管理，以確保一致性和效率。</li><li><strong>與資料使用層面分離</strong>：資料保護配置的管理應該與實際的資料使用層面分開。這意味著伺服器和客戶端不應該擁有更改自己資料保護配置的權限，這樣可以防止未經授權的變更和損害。</li><li><strong>防止自我配置</strong>：資料保護系統應該禁止伺服器和客戶端對其自身的資料保護配置進行修改，以保證配置的穩定性和安全性。</li><li><strong>不排除冗余機制</strong>：這項要求明確表示，雖然要集中管理和防止自我配置，但不排除使用冗余機制來保護系統免受單點故障的影響。這樣，即使一部分系統出現故障，其他冗余的部分還可以保持運作。</li></ol></div></details><h2 id="4-2-2-複製和鏡像-Replication-and-Mirroring">4.2.2 複製和鏡像 Replication and Mirroring</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R5 主要與次要儲存的資料保護需一致</summary><div class="toggle-content"><ul><li>同步和非同步「複製」都需要<strong>與主要儲存相同層次的資料保護</strong>。</li><li>包括加密資料在靜止時，以及設定存取限制。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R6 消除不必要的儲存裝置間複製信任</summary><div class="toggle-content"><ul><li>當陣列之間沒有共用複製的卷時，應<strong>禁用它們之間的複製信任</strong>關係。</li><li>陣列之間有共用複製的卷時，應限制它們相互之間的特權，僅限於共用的卷上。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R7 資料在複製和鏡像「傳輸中」的保護</summary><div class="toggle-content"><ul><li>複製和鏡像期間，資料在<strong>傳輸中</strong>的機密性和完整性需要<strong>使用加密保護</strong>。</li><li>當適當的緩解控制措施存在時，可以放寬加密要求（例如在相同機櫃或伺服器房間內進行鏡像）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R8 同步複製的自動I/O暫停</summary><div class="toggle-content"><ul><li>次要儲存伺服器的同步進度落後於主要資料的更新時，應啟用<strong>自動I/O暫停功能</strong>，防止主要儲存裝置上的寫操作。如果繼續允許在主要儲存裝置上進行寫操作，可能會導致<ul><li>資料不一致性、資料遺失風險。</li></ul></li><li>但是<code>需注意</code>：<strong>啟用此功能增加主要儲存裝置受到攻擊的風險</strong>，因為敵對方可能攻擊複製網路路徑來觸發主要儲存裝置的拒絕服務。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R9 刪除過時複製品以減少攻擊面</summary><div class="toggle-content"><ul><li>定期<strong>刪除過時的複製品</strong>，以減少攻擊面。</li></ul></div></details><h2 id="4-2-3-時間點副本-Point-in-Time-Copies">4.2.3 時間點副本 Point-in-Time Copies</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R10 配置點對點複本時應滿足目標要求</summary><div class="toggle-content"><ul><li>確保點對點複本（例如快照）的配置符合<code>目標數據集的恢復點目標（RPO）</code>要求。</li><li>如果業務或合規標準要求在恢復時<strong>最多只能損失五分鐘的已提交數據</strong>，則<strong>快照間隔應為五分鐘或更短</strong>。<ul><li>確保配置足夠數量的每小時快照以滿足保留要求。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R11 刪除過時快照和克隆</summary><div class="toggle-content"><p>定期<strong>刪除過時的快照和克隆</strong>，以減少攻擊面。</p></div></details><h2 id="4-2-4-持續資料保護-Continuous-Data-Protection">4.2.4 持續資料保護 Continuous Data Protection</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R12 使用持續資料保護的安全考量</summary><div class="toggle-content"><ol><li>功能上的優勢：改進的<strong>恢復點目標</strong>（RPO）、更<strong>細緻的保留策略</strong>。</li><li>持續數據保護技術：包括持續數據保護（CDP）、在雲端檔案和對象存儲中對「源數據或副本」進行「<strong>版本控制</strong>」，以及「<strong>事務日誌運送</strong>」。</li><li>協助<strong>改善敏感數據的取證</strong>：回溯到之前的版本可以幫助了解攻擊的特徵、時間等，但可能非常耗時。</li></ol></div></details><h1 id="4-3-AC-身份驗證與數據訪問控制-Authentication-and-Data-Access-Control">4.3 (AC) 身份驗證與數據訪問控制 Authentication and Data Access Control</h1><p><strong>管理用戶及其管理主機</strong>是攻擊者可以利用的攻擊面，特權使用者的不當使用可能導致存儲系統失敗或遭受侵害。實施&quot;<strong>最小權限模型</strong>&quot;並利用特定角色進行管理是重要的。</p><p>根據ISO/IEC 27040標準，應該實施以下角色並在存儲技術中使用：安全管理員、存儲管理員和安全審計員，這些角色的設計有助於確保儲存技術的安全性，並限制特權訪問，降低了存儲系統受到攻擊的風險。<br>好的，我可以幫您做一個表格，來整理這些角色的擁有權限和工作內容。以下是表格的內容：</p><details class="toggle" ><summary class="toggle-button" style="">安全管理員 Security Administrator</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>查看和修改權限</td><td>- 建立和管理<code>帳戶</code><br>- 設置和管理用戶和管理操作的<code>角色和權限</code><br>- 制定與<code>驗證器、憑證和密鑰</code>相關的<code>政策</code><br>- 管理加密和密鑰<br>- 管理<code>審計和日誌記錄</code></td><td>無</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">存儲管理員 Storage Administrator</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>存儲管理員</td><td>查看和修改權限</td><td>- 訪問和管理存儲系統的所有方面</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">安全審計員 Security Auditor</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>安全審計員</td><td>查看權限</td><td>- 進行<code>授權審查</code><br>- <code>驗證安全參數</code>和配置<br>- 檢查<code>審計日誌</code></td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">存儲審核員 Storage Auditor</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>安全審計員</td><td>查看權限</td><td>- 進行<code>授權審查</code><br>- <code>驗證安全參數</code>和配置<br>- 檢查<code>審計日誌</code></td></tr></tbody></table></div></details><h2 id="4-3-1-身份驗證建議-Authentication-Recommendations">4.3.1 身份驗證建議 Authentication Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R1 應確保使用者的唯一識別符號 Unique Identifier for all users</summary><div class="toggle-content"><ol><li>所有使用者（包括管理員）應該擁有一個僅供個人使用的唯一識別符號。</li><li>指派給管理員的識別符號，至少應該符合 NIST 文件 SP800-63A [35] 第 4.2 和 4.5 節中所指定的身份保證級別 3 (IAL 3)。</li><li>唯一的例外是緊急使用帳戶，其安全使用方式在 AC-SS-R16 中有所規定。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R2 集中式認證解決方案 A centralized authentication solution</summary><div class="toggle-content"><ol><li>在大型環境中，應該部署一個集中式認證解決方案（例如 Active Directory、輕量級目錄訪問協議 [LDAP]、單一登錄 [SSO]、經組織批准的雲認證服務），以便密切監控和控制使用者對存儲資源的訪問。</li><li>確保組織的認證政策得到統一執行。</li><li>應該避免使用內建的認證和權限管理功能，最好將其停用。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R3 認證伺服器的配置 Configuration of authentication servers</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px"><code>DS-SS-R3</code></div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R3.a</code></td><td><strong>嚴格控制執行認證服務的伺服器的指派</strong>：將執行認證服務（Authentication Service）的伺服器指定給特定的伺服器，並確保這樣的指派是經過嚴格管理和控制的。</td></tr><tr><td><code>AC-SS-R3.b</code></td><td><strong>應該擁有多個認證伺服器</strong>：以確保可用性，避免單一故障點。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R4 安全連接到集中式身份驗證伺服器 Secure connection to centralized authentication server</summary><div class="toggle-content"><ol><li>集中式身份驗證伺服器與驗證客戶端之間的通訊都應使用最新的安全協議</li><li>例如Transport Layer Security (TLS) 1.2或更高版本。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R5 使用多因素驗證 Use of multi-factor authentication</summary><div class="toggle-content"><ol><li>對於存儲重要數據的基礎架構組件的訪問配置，應該使用至少兩因素驗證</li><li>這些驗證器至少應符合NIST文件SP800-63B [36]第5.1.9節中指定的要求。這項要求對於擔任安全管理員和存儲管理員角色的使用者的訪問應該是強制性的。</li></ol></div></details><h2 id="4-3-2-密碼建議-Password-Recommendations">4.3.2 密碼建議 Password Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R6 安全密碼政策應涵蓋服務帳戶 Secure password policies should cover service accounts</summary><div class="toggle-content"><ol><li>個人張戶與服務帳戶應滿足安全的密碼政策：不僅應用於個人帳戶，還應應用於服務帳戶（例如，簡單網路管理協定（SNMP）、網路資料管理協定（NDMP））和自動化工具使用的帳戶。</li><li>這些密碼<strong>至少應滿足NIST文件SP800-63B</strong> [36]中第5.1.1節所述的記憶的秘密memorized secrets的要求。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R7 密碼長度 Password Length</summary><div class="toggle-content"><ul><li>一個好的密碼應該至少有15個字符，最好是20個字符。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R8 密碼複雜性 Password complexity</summary><div class="toggle-content"><ul><li>一個好的密碼應該結合大寫和小寫字母、數字和特殊字符。它不應該與用戶名相似，也不應包含重複的字符序列。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R9 密碼到期 Password expiration</summary><div class="toggle-content"><ul><li>所有密碼應該設置到期時間。管理員帳戶的到期時間應該比普通用戶帳戶更短。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R10 密碼重複使用 Password reuse</summary><div class="toggle-content"><ul><li>用戶不應該重複使用最近的至少四個（或更多）密碼，根據組織風險因素來設定這樣的限制。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R11 密碼緩存 Password caching</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px">標準</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R11.a</code></td><td>密碼不應該被緩存在伺服器、桌面或任何其他系統中。</td></tr><tr><td><code>AC-SS-R11.b</code></td><td>應該使用足夠短的生存時間(Time to Live, TTL)或等效的控制機制。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R12 儲存密碼 Saving Passwords</summary><div class="toggle-content"><ul><li>密碼<strong>不應該明文保存在任何地方（例如文件）或腳本</strong>中。</li><li>即使密碼以加密形式儲存，也絕<strong>不能啟用</strong>存儲管理應用程序來本地<strong>記住用戶和密碼以實現自動登錄</strong>，除非通過授權的中央身份驗證服務（如LDAP SSO）管理。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R13 刪除或更改默認密碼 Eliminate or change default passwords</summary><div class="toggle-content"><ul><li>系統安裝或部署時附帶的默認密碼應該立即更改。</li></ul></div></details><h2 id="4-3-3-帳戶管理建議-Account-Management-Recommendations">4.3.3 帳戶管理建議 Account Management Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R14 不與系統使用者關聯的帳戶 Use of accounts not associated with system users</summary><div class="toggle-content"><ul><li>應該<strong>禁用與任何無關聯的帳戶</strong>（例如不在Active Directory中的帳戶，如&quot;guest&quot;，“anonymous”，“nobody”）。</li><li>它們的所有默認配置（例如密碼、權限）應該按照組織範圍的政策進行更改。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R15 帳戶鎖定 Account lockout</summary><div class="toggle-content"><ul><li>在一<strong>定次數的失敗登錄嘗試</strong>後，應該<strong>將使用者鎖定</strong>。</li><li>某些帳戶鎖定的實現包括<strong>在一定時間或電源循環後自動重置（帳戶解鎖）</strong>。</li><li>在<strong>敏感的存儲系統上不應允許自動重置</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R16 用於緊急情況的本地使用者帳戶 A local user account for emergency purposes</summary><div class="toggle-content"><ul><li>應該保留一個單獨的本地使用者帳戶，以便在「<strong>中央身份驗證系統」「不可用時」提供僅限緊急情況的存儲資源訪問</strong>。</li><li>這個帳戶應該符合：<ul><li>所有組織政策（例如密碼長度）</li><li>它的使用應該僅限於特殊受保護的位置</li><li>遵循完善的文件程序，其中包括<strong>相關利益相關者的適當批准和使用通知</strong>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R17 消除或禁用預設使用者帳戶 Eliminate or disable default user accounts</summary><div class="toggle-content"><ul><li>存儲系統安裝時附帶的<strong>預設使用者帳戶</strong>，如果有相關功能，<strong>應立即被消除或禁用</strong>。</li><li>儘管消除或停用預設使用者帳戶功能不存在，或者有正當理由保留其中任何帳戶時，<strong>應滿足AC-SS-R18要求</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R18 – 限制本地和預設使用者帳戶 Limit local and default user accounts</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R18.a</code></td><td><strong>限制</strong>使用此類帳戶及其<strong>擁有的權限</strong>。</td></tr><tr><td><code>AC-SS-R18.b</code></td><td><strong>密碼策略</strong>應適用於所有使用者、本地和預設帳戶，包括具有管理權限的帳戶。</td></tr></tbody></table></div></details><h2 id="4-3-4-權限和會話管理建議-Privilege-and-Session-Management-Recommendations">4.3.4 權限和會話管理建議 Privilege and Session Management Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R19 角色和責任配置</summary><div class="toggle-content"><ol><li>至少應該對所有儲存資源的訪問實施<strong>ISO標準ISO/IEC 27040</strong> [10] 中的四個角色（即<strong>安全管理員，存儲管理員，安全審核員和存儲審核員</strong>）。</li><li>要確保存儲產品在存儲敏感信息時，具備足夠細緻的角色控制機制，若存儲產品原本沒有這樣的功能，則可以透過補償控制方式來達到相似的效果。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R20 遵循“職責分離”原則</summary><div class="toggle-content"><p>遵循“職責分離”原則來分配特權給角色和將角色分配給用戶。應該至少包含以下：</p><table><thead><tr><th><div style="width:100px">標準</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R20.a</code></td><td>分配給「數據管理」的特權和「數據保護」的特權應分配給不同的角色，這兩個角色不應該指派給同一用戶。</td></tr><tr><td><code>AC-SS-R20.b</code></td><td>分配給「數據管理」的特權和「主機管理」的特權應分配給不同的角色，這兩個角色不應該指派給同一用戶。</td></tr></tbody></table><p>此外：</p><ul><li>數據管理：創建新的儲存卷、或共享資源給用戶等<strong>讓儲存資源正常運作之權限</strong>。</li><li>數據保護：配置、停止或刪除備份，確保<strong>儲存資料的安全與預防數據損失有關之權限</strong>。</li><li>主機管理：在存儲控制器中創建/刪除對象等任務，<strong>管理存儲系統的硬體和基礎架構有關之權限</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R21 最小特權原則</summary><div class="toggle-content"><ul><li>任何角色被指派的特權都應遵循&quot;最小特權&quot;原則</li><li>分配給角色的權限不應該超過其執行的功能所需的權限。在這個情境中，這些權限涉及訪問特定存儲資源，例如塊設備、文件、對象等。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R22 - 安全的會話管理</summary><div class="toggle-content"><ul><li>客戶端和存儲基礎架構系統之間的所有會話都應該根據所需的認證保證等級進行管理，符合[63B]第7節的要求，包括終止和自動登出。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R23 - 實施“每日消息”和“登錄橫幅”通知</summary><div class="toggle-content"><ul><li>在通過用戶界面（UI）、命令行界面（CLI）或應用程序編程接口（API，如果適用）<strong>「登錄」到「任何存儲基礎架構組件」或「系統」之前，應該顯示“每日消息”或“登錄橫幅”通知</strong>。該消息應該包括法律聲明：<ul><li>「<code>警告用戶正在訪問具有敏感數據的受限系統</code>」</li><li>以及「根據組織的安全和隱私政策<code>提供任何其他警告和有意義的消息</code>。」</li></ul></li></ul></div></details><h2 id="4-3-5-SAN-特定建議-SAN-Specific-Recommendations">4.3.5 SAN 特定建議 SAN-Specific Recommendations</h2><div class="note info flat"><ul><li>SAN代表Storage Area Network，翻譯為「儲存區域網路」。簡單來說他用來連接儲存設備與伺服器之間的資料傳輸。</li><li>通常由專門的硬體和軟體組成，並使用光纖通道（Fibre Channel）或者乙太網（Ethernet）等高速連接技術，以實現高效率、低延遲的資料傳輸。</li><li>SAN的儲存資源在伺服器上被視為本地的硬碟，使得伺服器能夠透過SAN存取和管理這些儲存裝置。</li></ul></div><p>與SAN相關的存取控制主題涉及多個方面。有些方面與<strong>網絡配置和管理訪問</strong>有重疊，在其他章節中已經涵蓋了。<br>為了避免重複討論，要全面了解所有存取控制方面，請參考這三節的內容。</p><ul><li>與「網絡基礎設施」（例如交換機、端口、主機緘閉器和網絡接口卡）以及「協議」相關的<strong>存取控制建議</strong>，可以參考第4.6節中有詳細討論</li><li>資料在<strong>傳輸過程中的加密</strong>（存取控制的其中一種機制），可以參考第4.9節中有詳細討論。</li><li><strong>管理訪問</strong>在第4.10節中有詳細討論。</li></ul><p>而本節主要討論「與資料相關」的「存取控制」，涵蓋塊「設備」相關的存取控制、「實施區劃」（zoning）以及加入「光纖通道」的存取控制規範。</p><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R24 - 區塊設備(HDD、SSD、etc)的存取控制</summary><div class="toggle-content"><p>一組主機對於一組存儲區域網（SAN）設備的存取應該透過zoning（軟體或硬體）和masking來限制，以達到最小所需存取權限。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R25 - 區塊設備複製和複本的存取控制</summary><div class="toggle-content"><ul><li>一組主機對於一組經SAN複製的區塊設備、快照和其他類型的時間點複本的存取應該透過分區zoning和masing來限制，以達到最小所需存取權限。</li><li>在許多情況下，被授予存取權限的主機不應該被允許存取複本。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R26 - 默認分區的權限</summary><div class="toggle-content"><ul><li>默認zoning的權限（可能是產品特定的）應該始終配置為“全部拒絕”。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R27 - 分區實施</summary><div class="toggle-content"><p>分區應該在交換式SAN架構中基於合理的邏輯來實施，特別是與「環境」和「流量」類型的相關性，這些應該盡可能地分開：</p><table><thead><tr><th><div style="width:100px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R27.a</code></td><td>環境：開發、測試、生產等。</td></tr><tr><td><code>AC-SS-R27.b</code></td><td>流量類型：數據存取、管理、複製、備份等。</td></tr><tr><td><code>AC-SS-R27.c</code></td><td>主機類型：虛擬化、物理主機。</td></tr><tr><td><code>AC-SS-R27.d</code></td><td>存儲設備類型：磁帶、磁碟。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R28 - 軟體分區實施</summary><div class="toggle-content"><p>當實施軟<strong>體分區時，只允許主機通過簡單名稱服務器（SNS）連接到存儲設備</strong>，通過查閱軟體分區表，而<strong>不是直接使用設備探索</strong>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R29 - 控制可以加入SAN的裝置</summary><div class="toggle-content"><ul><li>在SAN中，有一個政策規範的功能，可以「創建白清單」，<strong>列出可加入該存儲區域網的交換機、數據存儲設備以及主機</strong>，建議在適用的情況下充分利用這一功能。</li></ul></div></details><h2 id="4-3-6-檔案和物件存取建議-File-and-Object-Access-Recommendations">4.3.6 檔案和物件存取建議 File and Object Access Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R30 - 限制所有類型的「物件存儲數據」到最低限度</summary><div class="toggle-content"><p>限制所有類型的物件存儲數據（例如，檔案、物件）遵循“最小權限”原則，包括：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R30.a</code></td><td>透過任何協議進行物件儲存數據的存取時，應該基於客戶端的IP和/或相關子網路進行限制，同時要求指定端口/協議。</td></tr><tr><td><code>AC-SS-R30.b</code></td><td>使用更精細的存取控制機制（例如，按角色、ID、標籤、帳戶、虛擬私有雲（VPC）、VPC 端點等）。</td></tr><tr><td><code>AC-SS-R30.c</code></td><td>存取權限只應授予集中管理的用戶和角色，例如企業<strong>目錄中的用戶</strong>或<strong>經批准的商業服務</strong>，而<code>不應授予特定系統的本地用戶</code>。</td></tr><tr><td><code>AC-SS-R30.d</code></td><td>對於任何共享，**默認存取權限應設置為“全部拒絕”**或等效設置。</td></tr><tr><td><code>AC-SS-R30.e</code></td><td><strong>默認共享應禁用或刪除</strong>。如果有特定用途需要使用它們，存取權限應限制為<strong>最低要求</strong>。</td></tr><tr><td><code>AC-SS-R30.f</code></td><td>存取權限（例如讀取、寫入、執行、修改、刪除、查看ACL、更改ACL）應<strong>根據“Need to Know”原則進行個別分配</strong>。</td></tr><tr><td><code>AC-SS-R30.g</code></td><td>如果可用，應使用定義物件存儲ACL的功能，以及使用本地操作系統的用戶、組或管理員權限模型。</td></tr><tr><td><code>AC-SS-R30.h</code></td><td>如果有定義文件級別存取模式的策略定義功能，應加以利用，並且應<strong>實現檢測違規模式的功能，可以發送通知</strong>。</td></tr></tbody></table><div class="note warning flat"><p>補充：“Need to know” 是一個信息安全原則，強調只有在某人必須知道或具有執行特定任務的需求下，他們才能取得相關的敏感信息或資源。這個原則適用於各種情況，包括數據存取權限、網絡訪問權限、機密文件存取等。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R31 - 禁用需要驗證的用戶</summary><div class="toggle-content"><ul><li><strong>需要驗證的用戶應該被禁用（例如，匿名、空、訪客或“公共訪問”用戶）</strong>。</li><li>可以提供例外，以允許組織關鍵功能，例如網絡發現，但在這些情況下，這些用戶應映射到“nobody”用戶組，而不是“ID 0”。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R32 - 定期審核安全設置</summary><div class="toggle-content"><ul><li>定期<strong>審核所有上述存儲數據的安全設置</strong>，包括各種類型的數據（例如文件、對象），以確保沒有偏離。</li><li>審核結果應予以記錄。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R33 - 使用反惡意軟體掃描工具</summary><div class="toggle-content"><ul><li>使用反惡意軟體工具對敏感信息文件進行掃描。</li><li>每當「訪問」包含「敏感信息」的「文件」時，應首<strong>先使用經組織批准的反惡意軟體工具進行掃描</strong>，以確保文件未遭受破壞。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R34 - 進行細粒度的權限分配</summary><div class="toggle-content"><ul><li>進行細粒度的權限分配：<ul><li>對於文件和對象共享系統（例如NFS、CIFS、雲對象存儲），應採用<strong>較細粒度的權限授予</strong>。</li><li>不應使用較粗粒度的方式（例如<strong>對文件或對象進行控制，而非對整個文件夾進行控制</strong>，或者對共享或存儲桶進行控制）。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R35 - 限制root訪問以保護NFS</summary><div class="toggle-content"><ul><li>限制root訪問以保護NFS，這包括使用“nosuid”選項。</li><li>避免使用“no_root_squash”來<strong>防止客戶端上的程序以root用戶身份運行</strong>。</li><li>並且<strong>避免遠程root用戶修改共享文件</strong>。一般情況下，<code>不應允許</code>NFS客戶端在已導出的文件系統上<code>運行“suid”和“sgid”程序</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R36 - 設置noexec設定防止可執行文件執行</summary><div class="toggle-content"><ul><li>要求確保那些被<strong>設置為&quot;read only&quot;模式的NFS共享</strong>，在其<code>掛載配置中添加&quot;noexec&quot;選項</code>，以<strong>防止在該共享上執行可執行文件</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R37 - 不允許導出管理文件系統</summary><div class="toggle-content"><ul><li><strong>不允許導出管理文件系統</strong>：包括<code>‘/’文件系統</code>和<code>受限的操作系統</code>或<code>存儲數組系統文件夾</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R38 - 不應向任何用戶授予完全控制權限</summary><div class="toggle-content"><ul><li>在使用CIFS時，不應向任何用戶授予“完全控制”權限，因為接收者可能使用該權限來修改權限，從而導致特權泄露。</li></ul><div class="note info flat"><p>CIFS代表Common Internet File System（通用互聯網文件系統）。它是一種用於在計算機網絡上分享文件和資源的協議。CIFS最初是由微軟開發的，用於Windows操作系統中的文件共享。</p><p>CIFS協議允許不同的計算機之間進行文件共享，使得用戶可以在網絡上訪問和操作其他計算機上的文件，就像訪問本地文件一樣方便。這使得用戶能夠在不同的計算機之間共享資源，例如文檔、圖片、音頻和視頻等。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R39 - 使用對象保護來防止未經授權的刪除</summary><div class="toggle-content"><ul><li>對於<strong>敏感信息</strong>，如果支持的話，應<code>使用高級控制</code>來防止<code>未經授權的對象刪除</code>。</li><li>（例如對象<strong>刪除時需要多重身份驗證</strong>，或對對象進行鎖定防止刪除）。</li></ul></div></details><h1 id="4-4-AL-審計日誌-Audit-Log">4.4 (AL) 審計日誌 Audit Log</h1><p>儲存基礎架構元件會生成大量的交易或事件的事件日誌記錄。這些事件日誌記錄必須以某種方式進行記錄，以進行事件記錄。</p><ul><li>從<code>安全</code>或<code>合規性</code>的角度來看，重要的是捕獲那些必要的事件日誌記錄，以<strong>證明操作的證據</strong>。</li><li><code>強制說明責任</code>和<code>可追溯性</code>，滿足證據要求，以及對系統進行充分監控。</li></ul><p>以下是與安全相關的審計日誌事件：</p><ol><li><code>管理事件</code> - 與系統權限管理相關知識間。<ul><li>例如，重設使用者密碼，帳戶的創建/刪除，權限修改，角色變更，群組成員變更，特權操作，配置的建立/更改。</li></ul></li><li><code>安全相關事件</code> - 系統安全費制的更改、授權錯誤訊息等可能導致安全事件發生的事件。<ul><li>例如，使用者配置和安全配置的更改，對儲存的失敗/阻塞嘗試，被阻止的登錄嘗試。這些事件通常是有興趣的，儘管其中一些事件可能與管理事件重疊。</li></ul></li><li><code>資料存取事件</code> - 資料存取的相關事件，存取信息對於監控敏感信息（例如，確定對手可能接觸了什麼）是有幫助的。</li></ol><p>以下是審制日誌不檔可能導致的後果：</p><ul><li>安全日誌和分析的不足，使攻擊者能夠隱藏其位置、惡意軟體以及在受害者機器上的活動。</li><li>缺乏可靠的審計日誌，<strong>攻擊可能會長期不被察覺</strong>，而實際造成的損害可能是不可逆轉的。</li><li>由於日誌分析流程的不善或不存在，攻擊者有時可以在目標組織中控制受害者的機器數月或數年，而目標組織中的任何人都不知道，即使可以在未審查的日誌文件中獲取攻擊的證據。</li></ul><p>基於事件日誌數據對於攻擊檢測和鑒識調查的關鍵性，以下是實施審計日誌功能的安全建議：</p><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R1 - 儲存基礎架構的組件應啟用審計記錄</summary><div class="toggle-content"><ul><li>是一個資訊安全要求，指出<code>所有儲存基礎架構的組件應啟用審計記錄</code>，並且<strong>使用可靠的傳送方式和安全的通訊協議</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R2 - 可靠的外部時間同步的要求</summary><div class="toggle-content"><ul><li>Network Time Protocol (NTP)服務對於時間同步至關重要。</li><li>如果NTP服務被停用:<ul><li>相依的系統可能會受到不準確的訊息、事件和警示的時間戳記</li><li>不同裝置之間的時間不一致，以及因此無法進行日誌分析、相關性分析、異常檢測或取證。</li></ul></li><li>在整個環境中建立和<code>使用一個共同且準確的時間來源</code>，有助於確保來自不同來源的事件記錄能夠相關聯。</li><li>以下是有關部署和整合NTP與儲存相關裝置的建議：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>AL-SS-R2.a</code> | 所有裝置（包括日誌伺服器和儲存基礎架構）都應<strong>啟用NTP服務</strong>。|<br>| <code>AL-SS-R2.b</code> | <strong>有裝置</strong>應配置為與<strong>時間來源伺服器</strong>（例如NTP伺服器）進行<strong>時間同步。</strong>|<br>| <code>AL-SS-R2.c</code> | 存取權限只應授予集中管理的用戶和角色，例如企業<strong>目錄中的用戶</strong>或<strong>經批准的商業服務</strong>，而<code>不應授予特定系統的本地用戶</code>。|<br>| <code>AL-SS-R2.d</code> | 建立<strong>至少三個地理位置不同的獨立時間伺服器</strong>，以確保即使其中某個伺服器發生故障或無法使用，其他伺服器仍能提供正確的時間資訊。|<br>| <code>AL-SS-R2.e</code> | 應<strong>使用憑證</strong>來驗證時間來源伺服器的身份已確保時間同步服務的安全性。|<br>| <code>AL-SS-R2.f</code> | - 可以利用存取控制選項，例如 “ntpd” 存取限制，來限制對時間來源伺服器的存取。<br> - 您可以設定存取控制清單，列出被允許或禁止存取時間伺服器的裝置。(例如設定<code>restrict 192.168.2.10</code>只允許此ip進行存取。)|</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R3 - 以集中的方式收集日誌並確保可靠性</summary><div class="toggle-content"><ul><li>通過將日誌寫入<strong>中央日誌伺服器</strong>（例如，syslog 伺服器、雲端日誌服務），降低了日誌丟失或被更改的風險，因為它們在<strong>內部網路中更安全</strong>。以下是有關部署和集成與存儲相關設備的中央日誌記錄的建議：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>AL-SS-R3.a</code> | 應「<code>定義</code>」存儲設備的組織日誌記錄「<code>標準</code>」並以<strong>指定所需的日誌記錄級別</strong>。（更具體的建議請參見AL-SS-R4）|<br>| <code>AL-SS-R3.b</code> | 「所有設備」應根據適用的「組織日誌記錄標準」，配置「<strong>傳輸日誌事件數據」至組織核准的「中央日誌伺服器</strong>」。|<br>| <code>AL-SS-R3.c</code> | 應在所有設備上<strong>監控中央日誌配置</strong>的<code>有效性</code>（例如，日誌服務保持啟動狀態、日誌記錄級別配置符合組織標準、每個設備都配置了經核准的日誌伺服器），對檢測到的異常進行高優先級處理。|<br>| <code>AL-SS-R3.d</code> | 應部署多個syslog伺服器，以<strong>實現連續記錄，並防止單一故障點</strong>。|<br>| <code>AL-SS-R3.e</code> | 每個日誌應至少<strong>保留一份離線副本</strong>。|<br>| <code>AL-SS-R3.f</code> | 為防止在停止並重新啟動所有記錄條目寫入之前丟失條目，應<strong>配置日誌記錄實時寫入磁碟</strong>，並且<strong>不使用緩衝區</strong>，並<strong>使用可靠的協議傳送</strong>。|</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R4 - 日誌記錄等級</summary><div class="toggle-content"><p>存儲審計日誌應包含（但不限於）與所有與「存儲相關」的object、sites和accounts的保護相關的以下事件：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AL-SS-R4.a</code></td><td>敏感環境中，Read-only的API Calls。</td></tr><tr><td><code>AL-SS-R4.b</code></td><td>所有對服務、端口、文件、對象或設備的<code>拒絕訪問嘗試</code>應記錄下來。</td></tr><tr><td><code>AL-SS-R4.c</code></td><td>涵蓋整個<code>密鑰生命周期操作</code>（尤其是加密密鑰）的<code>加密密鑰管理操作</code>，例如密鑰生成、密鑰刪除、證書管理等，尤其是關於密鑰銷毀等事件皆應該紀錄。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R5 - 有關審計日誌保留和保護</summary><div class="toggle-content"><p>有關審計日誌保留和保護，應採取以下措施：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AL-SS-R5.a</code></td><td>需要<strong>足夠長的時間保留日誌數據</strong>，因為通常需要一段時間才能察覺到已發生或正在發生的入侵事件。</td></tr><tr><td><code>AL-SS-R5.b</code></td><td><strong>分配足夠的存儲空間</strong>，主動監控日誌數據的剩餘空間和異常增長速率，<strong>以防止日誌目的地充滿</strong>。（已知的攻擊模式包括先<strong>充滿日誌以阻礙取證</strong>，適當的監控有助於即時識別此類攻擊。）</td></tr><tr><td><code>AL-SS-R5.c</code></td><td>涵存檔的日誌數據<code>應受到防篡改保護</code>（例如使用WORM或不可變存儲、對象鎖定、多因素身份驗證（MFA）批准刪除）。如果支持，中央日誌服務器也應使用這些存儲選項。</td></tr><tr><td><code>AL-SS-R5.d</code></td><td>通過<strong>指定角色和帳戶</strong>來限制對日誌數據和服務器的訪問。</td></tr><tr><td><code>AL-SS-R5.e</code></td><td><strong>啟用加密</strong>，因為訪問日誌數據可能會為攻擊者提供有關資產和可能攻擊向量的有價值的見解。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R6 - SIEM整合</summary><div class="toggle-content"><ul><li>如果支持，應將<strong>存儲基礎架構日誌</strong>與安全信息和<strong>事件管理SIEM</strong>整合，以進行潛在的威脅檢測。</li></ul></div></details><h1 id="4-5-IR-數據事件應急響應和網絡復原的準備-Preparation-for-Data-Incident-Response-and-Cyber-Recovery">4.5 (IR) 數據事件應急響應和網絡復原的準備 Preparation for Data Incident Response and Cyber Recovery</h1><p>有關事件響應的作用與建立，可以參考NIST的架構來改進關鍵基礎設施的安全[40]。與<code>存儲相關</code>的事件應該作為<strong>組織事件響應流程的一部分來處理</strong>，其中包括隔離、根本原因分析、定義和管理響應計劃、測試以及定期流程審查和更新。以下的建議涵蓋了應考慮的特定方面，涉及存儲基礎設施和數據資產。</p><div class="note info flat"><p>[40] National Institute of Standards and Technology (2018) Framework for Improving Critical Infrastructure Cybersecurity, Version 1.1. (National Institute of Standards and Technology, Gaithersburg, MD). <a href="https://doi.org/10.6028/NIST.CSWP.04162018">https://doi.org/10.6028/NIST.CSWP.04162018</a></p></div><details class="toggle" ><summary class="toggle-button" style="">要求：IR-SS-R1 – 開發針對儲存元件遭到入侵的響應計畫</summary><div class="toggle-content"><p>在組織風險分析、隔離、修復、恢復和測試程序中，應考慮以下要素：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>IR-SS-R1.a</code></td><td>整個<strong>存儲數組</strong>或整個<strong>基於雲的存儲資產</strong>（例如，SAN、NAS、對象存儲、彈性文件系統）的入侵。</td></tr><tr><td><code>IR-SS-R1.b</code></td><td><strong>備份系統</strong>的入侵響應計畫。</td></tr><tr><td><code>IR-SS-R1.c</code></td><td><strong>單個存儲元素</strong>（例如，共享、塊設備）的入侵響應計畫。</td></tr><tr><td><code>IR-SS-R1.d</code></td><td>FC SAN網絡的入侵（包括單個交換機和SAN服務）。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IR-SS-R2 – 在事件管理期間確保恢復資產不可變性</summary><div class="toggle-content"><ul><li>結合下面第4.7節提供的有關<strong>保護網絡復原副本</strong>的建議，這些副本在<strong>事件管理期間</strong>應<code>保持隔離</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IR-SS-R3 – 驗證恢復的計算組件的衛生狀況</summary><div class="toggle-content"><ul><li>確保在將恢復的可執行文件、應用程序、容器和操作系統映像<strong>部署到生產環境之前，它們是不受感染的</strong>。</li></ul></div></details><h1 id="4-6-NC-網路設定指引-Guidelines-for-Network-Configuration">4.6 (NC) 網路設定指引 Guidelines for Network Configuration</h1><p>與存儲相關的網絡主題涉及多個方面，其中一些與數據訪問控制、管理訪問和加密有重疊之處，這些已在其他部分中涵蓋。為了全面了解所有網絡配置方面，請參考所有節的內容。：</p><ol><li>第4.3節中，與<code>數據訪問控制</code>密切相關的某些網絡建議；</li><li>第4.9節中，與<code>網絡和協議</code>相關的<code>加密建議</code>；</li><li>第4.10節中，與<code>管理訪問</code>密切相關的某些網絡建議；</li></ol><div class="note info flat"><p>而本節主要涵蓋的<strong>網絡基礎設施（例如交換機、端口、HBA和NIC配置、分區指南等）和協議</strong>。</p></div><h2 id="4-6-1-FC-SAN-和-NVMEoF">4.6.1 FC SAN 和 NVMEoF</h2><div class="note info flat"><ul><li>FC SAN：是一種存儲區域網絡技術，它使用<strong>光纖通道協議</strong>來連接<strong>主機和存儲設備</strong>。它是一個高性能、可靠且擴展性良好的解決方案，通常用於連接企業級的存儲系統和主機。</li><li>NVMEoF (NVME over Fabric)目的在使用NVMe協議通過網絡訪問遠程存儲設備，而無需通過本地線路直接連接。<ul><li>NVMe（Non-Volatile Memory Express）是一種高效的存儲訪問協議，專門設計用於<strong>快閃存儲器（例如SSD）等非易失性存儲設備</strong>。</li><li>NVMeoF 則是在現有網絡架構上<strong>將NVMe協議擴展到Fabrics</strong>（例如Ethernet或InfiniBand等）的技術。</li><li>這樣，NVMeoF允許主機<strong>使用NVMe協議通過網絡訪問遠程存儲設備</strong>，而無需通過本地線路直接連接。</li><li>這種技術可以在數據中心和雲環境中實現高效、低延遲的存儲訪問，並提供更好的可擴展性和靈活性。</li></ul></li></ul></div><details class="toggle" ><summary class="toggle-button" style="">注意：NC-SS-R1 - 主機和交換機身份驗證</summary><div class="toggle-content"><ul><li>每個<code>主機</code>和<code>存儲交換機</code>應該具有獨特的身份，在加入網絡之前應該<code>進行身份驗證</code>（例如，FC-SP-2 AUTH-A）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：NC-SS-R2 - 使用經批准的PKI機制</summary><div class="toggle-content"><ul><li>使用組織批准且經過認證的<strong>集中式PKI系統來管理交換機證書</strong>（例如，Fibre-Channel Certificate Authentication Protocol或FCAP），而<code>不是使用設備自簽名的證書</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：NC-SS-R3 - 使用混合方法進行zoning</summary><div class="toggle-content"><p>實施一種結合不同類型區域劃分機制的方法，而不僅僅是使用單一類型的劃分（即主機、交換機和存儲設備）：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>NC-SS-R3.a</code></td><td>基於<code>主機</code>的分區機制，主機上的應用程式可以存取和看到可存取的設被或儲存資源有哪些。</td></tr><tr><td><code>NC-SS-R3.b</code></td><td>基於<code>交換機</code>的分區機制，這是指<strong>使用交換機</strong>來<strong>控制設備之間的通信</strong>，使得只有特定的設備可以與其他特定的設備進行交互。</td></tr><tr><td><code>NC-SS-R3.c</code></td><td>基於<code>存儲設備</code>的分區機制，這是指在儲存系統中，<strong>存儲陣列會根據特定的設定</strong>，決定哪些主機（或者更具體地說，哪些主機的HBA端口）可以訪問哪些塊設備，而<strong>其他未列出的主機將被拒絕訪問</strong>。</td></tr><tr><td><code>NC-SS-R3.d</code></td><td>基於<code>功能性</code>的分區機制，區域集合功能就像在存儲網絡中建立了幾個專用的區域，每個區域都有特定的用途，這樣就能更好地管理和控制存儲資源的訪問。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R4 - 遮罩建議</summary><div class="toggle-content"><ul><li>遮罩指的是使block-device對<strong>主機可見或不可見</strong>。</li><li>優先將<strong>遮罩放置在盡可能靠近數據的位置</strong>，盡可能<strong>遠離數據使用者或客戶端</strong>（例如，優先使用數組遮罩而不是交換器遮罩，核心交換器而不是邊緣交換器，以及交換器而不是HBA）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R5 - 交換器配置數據備份</summary><div class="toggle-content"><ul><li>創建<strong>交換器配置數據</strong>的備份，包括區域配置文件。</li><li>該備份應保留在SAN交換器之外，以便在發生錯誤或惡意損壞或刪除時能夠<strong>重新部署</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R6 - 將交換器管理功能限制為最小必要</summary><div class="toggle-content"><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>NC-SS-R6.a</code></td><td>在實施SAN（Storage Area Network）結構時，應該<code>制定明確的政策</code>，指定並<code>最小化授權</code>用於分發配置數據的交換器集合（同時提供可接受的冗餘性）。</td></tr><tr><td><code>NC-SS-R6.b</code></td><td><code>不應啟用</code><strong>不必要的配置管理許可權</strong>和服務，例如密碼分發，將密碼發送給相應的用戶或設備的過程。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R7 - 使用軟性（Soft zoning）與硬性（Hard zoning）區域劃分的考慮</summary><div class="toggle-content"><ul><li>軟性區域劃分：依靠主機的身份來限制存儲區域的訪問，相對不夠安全，但在跨設施且存在物理安全風險的情況下可能更合適。</li><li>硬性區域劃分：則使用物理端口號碼，不依賴主機身份，較為安全，特別適用於物理訪問受到嚴格保護的情況。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R8 - 限制執行管理任務的特定的光纖通道埠</summary><div class="toggle-content"><ul><li><code>限制</code>哪些儲存區域網路（SAN）的<code>光纖通道物理</code>和邏輯埠可以用於管理。</li><li>只有<code>特定的光纖通道埠</code>能夠<code>執行管理任務</code>，例如設置、配置或監控SAN。其他的光纖通道埠則被關閉或限制其功能，以確保它們不能被用來進行管理任務。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R9 - 限制交換器之間的通信</summary><div class="toggle-content"><ul><li>限制<strong>交換器之間的通信</strong>。</li><li>確保只<strong>有必要的交換器之間可以相互通信</strong>。這有助於降低未經授權設備進入儲存區域網路的風險。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R10 - 停用未使用的儲存區域網路（SAN）埠</summary><div class="toggle-content"><ul><li><strong>停用未使用的儲存區域網路</strong>（SAN）埠，以防止意外或有意連接未經授權的設備。</li></ul></div></details><h2 id="4-6-2-IP-儲存網路-IP-Storage-Networking">4.6.2 IP 儲存網路 IP Storage Networking</h2><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R11 – IP儲存網路分隔</summary><div class="toggle-content"><p>本節主要討論IP存儲網絡的分隔原則，旨在保障存儲相關通信在IP網絡上的安全性。以下是該段落的重點總結：</p><ol><li>在存儲相關通信中，應該根據不同的流量類型，在<strong>Network Layer第2層和第3層進行環境和流量的分隔</strong>，以保障安全。</li><li>對於敏感環境，應該最大限度地進行分隔，分隔的依據包括以下：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>NC-SS-R11.a</code> | 流量類型：數據訪問協議、管理、複製、備份、主機和應用網絡等。|<br>| <code>NC-SS-R11.b</code> | 進一步區分不同解決方案、供應商和技術的管理流量。如果使用了兩個或更多的存儲解決方案（例如不同的數組技術、基於伺服器的SAN產品、交換機技術、存儲虛擬化等），每個環境的管理流量應該與其他環境分隔。|<br>| <code>NC-SS-R11.b</code> | 數據訪問協議（例如iSCSI、NFS、特有供應商協議等）。|<br>| <code>NC-SS-R11.b</code> | 訪問數據的伺服器或主機類型：虛擬化主機 vs. 實體主機。|</li></ol><p>這些分隔原則旨在確保IP存儲網絡的安全性，使不同類型的流量和敏感信息在網絡中得到適當的隔離，從而減少潛在的安全風險。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R12 - 子網的分隔</summary><div class="toggle-content"><ul><li>在SAN交換機的IP或是乙太網路管理ports應該要位於獨立的子網中，包含與主機和儲存之間的數據訪問子網，主機間通信子網都要分隔開。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R13 - 啟用設備IP訪問控制</summary><div class="toggle-content"><p>應啟用<code>設備IP訪問控制</code>，在存儲設備上配置相關的安全功能，例如內建防火牆規則、IP過濾和存取控制清單，以實現：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>NC-SS-R13.a</code></td><td>控制和限制<code>僅允許所需主機</code>或<code>應用</code>訪問其使用的存儲對象。</td></tr><tr><td><code>NC-SS-R13.b</code></td><td>獨立控制管理主機和管理應用程序之間的<code>IP流量</code>，以及相關的存儲管理界面。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R14 - 在網絡層面應用IP訪問控制</summary><div class="toggle-content"><ul><li>使用<strong>路由、防火牆、存取控制清單、虛擬私有雲（VPC）安全組</strong></li><li>基於服務器的SAN客戶端來限制所有流量類型（如數據訪問和管理流量）僅限於允許的IP地址和TCP/UDP端口和協議之間：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>NC-SS-R14.a</code> | 主機或應用程序和它們使用的存儲對象之間。|<br>| <code>NC-SS-R14.b</code> | 管理主機和應用程序與它們管理的相關存儲對象的存儲管理界面之間。|</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R15 - 封鎖網際網路或公網的訪問</summary><div class="toggle-content"><ul><li>應封鎖從網際網路或其他公共網路對非公開存儲對象的訪問。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R16 - 對於需要公開訪問的存儲對象，應實施足夠的控制措施</summary><div class="toggle-content"><p>(a) 最小化訪問。<br>(b) 使用物理和邏輯上分隔的存儲子網，最好是與非公開存儲對象使用不同的存儲設備和池。<br>© 考慮防止拒絕服務攻擊。<br>(d) 緩存副本（例如使用內容傳遞網絡（CDN）、副本和代理），至少保留與源數據相同的安全特性。<br>(e) 考慮法規要求（例如機密性、存儲位置限制）。<br>(f) 任何其他適用的安全控制措施（例如加密、身份驗證）。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R17 - 配置SNMP時，所有流量應導向有效的組織內部IP地址作為目的地</summary><div class="toggle-content"><p>在配置SNMP時，所有流量應導向有效的組織內部IP地址作為目的地，應定期審查配置的有效性。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R17 - 考慮使用隔離的不可路由VLAN</summary><div class="toggle-content"><p>對於基於服務器的SAN部署，考慮使用隔離的不可路由VLAN，以保護數據存儲環境並減輕安全擔憂。</p></div></details><h2 id="4-6-3-Protocols-協定">4.6.3 Protocols 協定</h2><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R19 - 禁用不安全的檔案訪問協議版本</summary><div class="toggle-content"><ul><li>需要封鎖過時、不推薦或不安全的協議版本，如SMB v1、NFS 1和2。</li><li>建議在客戶端和伺服器端都停用這些協議，以增加安全性。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R20 - SNMP安全性設定</summary><div class="toggle-content"><p>(a) 如果不使用SNMP，應禁用它。<br>(b) 修改預設的已知社群字串，即使未啟用SNMP。所設定的字串應符合組織的密碼政策。<br>© 對於具有不同機密性的設備，使用不同的社群字串。<br>(d) 使用至少SNMP版本3。<br>(e) 強制執行SNMP的身份驗證和加密功能。<br>(f) 如果不是絕對必要，不要配置具有讀寫訪問權限的SNMP。如果確實需要，要限制和控制讀寫SNMP的使用。<br>(g) 使用存取控制清單來控制通過SNMP對設備的訪問。<br>(h) 定期驗證SNMP陷阱是發送到授權的管理者。<br>(i) 參考美國國土安全部(CISA)的TA17-156A指南，以獲得額外的指導。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R21 - 目錄、域和相似服務的真實性</summary><div class="toggle-content"><ul><li>需要定期審查所有儲存元素（如設備、交換機、管理工作站、管理軟體）中服務的配置，確保只使用核准的配置，並修復任何不一致之處。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R22 - 使用標準和非標準的TCP/IP或UDP埠的考慮</summary><div class="toggle-content"><ul><li>考慮使用非標準埠，可以<strong>隱藏應用程式或服務</strong>，使駭客難以找到正確的埠號。</li><li>使用非標準埠的缺點是安全掃描工具<strong>可能無法識別非標準埠上的可疑活動</strong>，因為這些工具預期在標準埠上有特定行為。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R23 - 啟用FCoE初始化協議（FIP）監聽過濾器</summary><div class="toggle-content"><ul><li>FIP監聽是<strong>防止未經授權的訪問和數據傳輸到FC網絡</strong>的安全機制。</li><li>FCoE轉接器將FC發起器（伺服器）連接到FCoE轉發器（FCF）以啟用相關VLAN上的FIP欺騙。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R24 - 限制iSCSI埠</summary><div class="toggle-content"><p>需要防止iSCSI網絡上的主機訪問除該網絡上為iSCSI指定的TCP埠之外的任何TCP埠。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R25 - 使用iSCSI身份驗證</summary><div class="toggle-content"><ul><li>在建立會話時，使用支援的方法對iSCSI發起者進行身份驗證（例如CHAP、SRP、Kerberos、SPKM1/2）。</li><li>使用雙向驗證而不是單向驗證的CHAP。請注意，身份驗證不提供通道的加密或完整性保護。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R26 - 使用NDMP安全功能</summary><div class="toggle-content"><p>當使用NDMP時，應配置以下安全功能：<br>(a) 控制哪些主機可以啟動NDMP會話。<br>(b) 使用挑戰-回應身份驗證（不使用明文身份驗證選項）。<br>© 記錄NDMP連接嘗試。<br>(d) 符合組織密碼政策的NDMP密碼（例如，長度、複雜性等）。<br>(e) 僅需要使用者的受限NDMP相關權限。<br>(f) 加密的NDMP控制連接。<br>(g) 會話或伺服器的NDMP限流。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R27 - 在LDAP中使用TLS</summary><div class="toggle-content"><ul><li>在設定儲存系統的Active Directory選項時，使用TLS來保護LDAP連接。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R28 - 其他協議建議</summary><div class="toggle-content"><ul><li>當使用其他協議（如SymAPI、SMI-S、GNS等）時，應考慮適應第4.6.2和4.6.3節中的建議。</li><li>特別是：<ul><li>(a) 將數據訪問和管理的流量與其他環境隔離。</li><li>(b) 限制TCP和UDP埠。</li><li>© 啟用加密。</li></ul></li></ul></div></details><h1 id="4-7-IS-隔離-Isolation">4.7 (IS) 隔離 Isolation</h1><p>當生產數據損壞或丟失時，組織應該能夠通過複製或備份的數據副本來恢復數據。如果損害是惡意攻擊的結果，攻擊者也能夠破壞備份數據副本，那麼對生產環境的攻擊將產生災難性影響，因為組織將無法進行恢復。為了提高備份副本的彈性，<strong>應確保數據資產及其恢復副本之間具有足夠的隔離</strong>。在這個背景下，組織應該區分至少兩種不同的數據保護場景：</p><ol><li><strong>非惡意恢復</strong> - 需要數據副本，以應對<code>自然災害、硬件故障、人為錯誤</code>等情況。這些可以包括本地副本（例如，在進行維護之前拍攝的快照）、災難恢復副本（DR副本）、備份以及長期存檔。這些副本與生產環境越接近，越有可能被映射到計算系統進行測試和災難恢復。</li><li><strong>防止網絡攻擊的恢復</strong> - 需要<code>硬化、鎖定並保持隔離的數據副本</code>。設計應該努力實現這樣一個狀態，即這些副本不受任何影響，包括與其相關聯的生產數據卷或其他類型的副本已被破壞的情況。</li></ol><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R1 – 儲存系統的分隔</summary><div class="toggle-content"><p>(a) 在<strong>私有雲中</strong>，應在指定的<strong>獨立儲存環境中建立防範網絡攻擊的備份副本</strong>。在<strong>公有雲</strong>中，則需要<strong>使用單獨的帳戶（或等效帳戶）來創建這些備份副本</strong>。<br>(b) 長期的備份和儲存系統應該與生產數據儲存系統分開。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R2 – 管理系統的分隔</summary><div class="toggle-content"><ul><li>儲存系統中存儲網絡攻擊恢復副本的管理應該來自<strong>指定的管理系統</strong>，該系統<strong>與生產環境以及與生產相連的其他系統</strong>（包括數據保護機制）<code>分隔</code>。</li><li>生產和常規備份不應該能夠訪問這些管理系統。該系統應該托管在一個僅與隔離網絡相連的專用環境中。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R3 – 網絡攻擊恢復系統和長期備份的存取限制</summary><div class="toggle-content"><p>(a) 對於敏感信息，網絡攻擊<strong>恢復副本</strong>及其系統<strong>不應該對常規的IT人員可見</strong>，<strong>僅應該讓單一人員（如CISO），或非常有限的高管或安全經理使用特別的憑證來訪問</strong>。這確保如果IT管理員的憑證被入侵，攻擊者無法使用這些憑證來訪問網絡攻擊恢復副本。這個受限制的團隊可以訪問網絡攻擊恢復副本，但管理權限只會授予更小的子集，用於授予其他使用者權限。<br>(b) 訪問長期備份的權限應該與用於執行其他儲存管理任務（例如SAN管理、儲存分配）的權限分開，並應包括使用不同的使用者ID、帳號和憑證。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R4 – 離線儲存</summary><div class="toggle-content"><ul><li>網路攻擊恢復的備份應該<code>儲存在離線的地方</code>，而<strong>不是和生產數據存放在同一地點</strong>。</li><li>這樣做可以確保即使攻擊者物理上進入生產地點，或者成功侵入物理位置，也無法訪問或破壞網路攻擊恢復的備份。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R5 – 獨立的完整基準備份</summary><div class="toggle-content"><ul><li>備份系統通常使用增量備份，相對於基準備份捕獲數據的變化。這些增量備份在恢復時必須與基準備份一起使用。對於某些備份方案（如快照），只使用增量備份（即基準備份是生產數據本身）。</li><li>為了正確處理恢復情景，必須**考慮備份之間的依賴關係，並保持不同類型備份之間的充分隔離。**具體來說：</li><li>(a) 複製的災難恢復備份不應依賴於生產基準數據。</li><li>(b) 網路攻擊恢復備份不應依賴於生產基準數據。只有在這些備份從生產基準數據中得到充分隔離並符合IS-SS-R1、IS-SS-R2和IS-SS-R3的建議時，才允許依賴於災難恢復基準數據。</li><li>© <strong>長期儲存的歸檔數據</strong><code>不應依賴於生產和災難恢復基準數據</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R6 – 停用所有不必要的服務和協議</summary><div class="toggle-content"><p>在網路攻擊恢復儲存系統上應停用所有不必要的服務和協議。在只需要應用程序編程接口（API）或命令行界面（CLI）進行管理的環境中，建議也禁用任何交互式網頁界面。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R7 - 從主機或應用程式獨立</summary><div class="toggle-content"><p>(a) 在進行資料恢復時，不應將資料副本掛載、匯出或映射到主機或應用程式，而應該將其還原到隔離的臨時環境（例如離線環境），而不是直接還原到目標主機或應用程式。或者，較不安全的方法是允許目標主機或應用程式在還原過程中有有限的唯讀訪問權限（例如映射或掛載），但在還原完成後應立即移除此類訪問權限。<br>(b) 長期備份的資料副本不應直接掛載、匯出或映射到主機或應用程式。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R8 - 考慮設定空氣隔離 Air Gap</summary><div class="toggle-content"><ul><li>組織應考慮在<code>敏感資料</code>的資料<strong>恢復副本</strong><code>周圍建立空氣隔離</code>（air gap）。</li><li>嚴格的空氣隔離應提供完全的<strong>物理和網路層面分離</strong>。</li><li>某些存儲技術引入較不嚴格的隔離技術，也被稱為&quot;空氣隔離&quot;，可在<strong>定期與生產系統進行同步時關閉數據端口並在有限的時間內打開</strong>。應根據資料的價值和對手的能力來衡量每種技術的有效性。選擇嚴格實施時，應注意繞過已知的空氣隔離系統漏洞，包括：</li><li>(a) 防止空氣隔離系統與其他設備之間的視覺、聽覺和熱信號傳輸（例如保持足夠距離或使用減震和/或足夠的物理距離）。</li><li>(b) 防止空氣隔離設備中的任何潛在無線傳輸功能。</li><li>© 禁用暴露的數據端口（例如USB、網路）。</li><li>(d) 使用電源調節或分離的電路。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R9 - 執行定期隔離審核</summary><div class="toggle-content"><p>應<strong>每年至少一次對上述隔離建議進行檢查</strong>，作為定期審計的一部分，以確保沒有可能犧牲資料恢復副本的隔離性的配置差距或偏差。對於敏感和高價值的存儲系統，可能需要至少每季審計一次，以及在每次重大更改後進行審計，視哪個較先發生。審計結果應該被記錄下來。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R10 - 考慮使用不可變存儲技術</summary><div class="toggle-content"><p>考慮使用不可變存儲技術，這可以進一步隔離和保護恢復資料（例如保留鎖定、保險庫鎖定、不可變性策略）。</p></div></details><h1 id="4-8-RA-恢復保證-Restoration-Assurance">4.8 (RA) 恢復保證 Restoration Assurance</h1><ul><li>主要在談&quot;恢復保證&quot;，<strong>確保在業務中斷、災難恢復事件或資安攻擊後，能夠成功地復原。</strong></li><li>僅僅擁有恢復流程是不夠的，組織還需要確保所有<code>關鍵資料元件都能夠被保護</code>，並能夠忠實、一致、完整地恢復。</li><li><code>恢復的速度和更新程度</code>也應符合業務和監管要求。</li><li>很多情況下，組織備份了重要系統，但並<strong>不經常檢查這些備份是否能夠實際恢復系統</strong>。然而，由於配置漂移、環境變化，甚至是惡意攻擊導致備份受到破壞，他們最終無法使用備份數據來進行恢復。以下是確保恢復保證的安全建議：</li></ul><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R1 - 確保恢復副本的完整性</summary><div class="toggle-content"><p>所有包含關鍵資料元件的存儲元素應<code>受到保護並備份</code>，以支持災難恢復和資安攻擊恢復。這包括存儲卷、關鍵文件系統、數據庫、軟件映像、證書、加密密鑰、啟動文件、目錄信息、存取控制列表（ACLs）、虛擬化設置和配置文件。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R2 - 保護所有依賴元件</summary><div class="toggle-content"><ul><li>依賴元件，例如<code>Active Directory和DNS，外部密鑰管理系統</code>，應受到保護，以實現完整恢復。</li><li>如果使用自動化構建流程來配置存儲、源代碼存儲庫、構建環境和構建程序，這些應該也要受到保護。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R3 - 所有相關軟件和硬件元件的可用性</summary><div class="toggle-content"><p>用於運行系統的所有相關軟件和硬件元件（例如驅動程序、固件）都應該備份、保護並可供恢復操作使用。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R4 - 選擇備份和數據複製技術 應符合組織的RTO要求</summary><div class="toggle-content"><ul><li>RTO是<code>恢復時間目標</code>，用來衡量期望的恢復速度。</li><li>要全面考慮滿足RTO的能力，包括所有相關的組件（如數據恢復、配置文件、加密密鑰）。</li><li>同時要平<strong>衡實際恢復所需的速度和調整所有相關組件以實現期望恢復速度所需的成本。</strong></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R5 - 進行定期測試恢復以確保達到所需的RTO</summary><div class="toggle-content"><p>定期進行測試恢復操作，確保成功完成並滿足所需的時間範圍。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R6 - 設定回復點目標（RPO）</summary><div class="toggle-content"><ul><li>為每個資料資產<code>設定回復點目標</code>，即在發生故障後可以容忍的資料損失量，以時間來衡量。</li><li>備份和數據複製技術的設計和實施應該支持在這個目標下進行數據恢復。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R7 - 滿足組織的資料資產的數據保留和複製頻率需求</summary><div class="toggle-content"><p>應該確定<code>每個資料資產的數據保留和複製頻率需求</code>（詳見DP-SS-R1以獲取更多細節）。備份和數據複製技術的設計和實施應該支持這些需求。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R8 - 確保遠程副本備份和數據複製處於良好狀態</summary><div class="toggle-content"><ul><li><code>定期驗證備份副本的狀態</code>。</li><li>這包括<strong>檢查是否有相關的錯誤記錄</strong>，以及備份和數據複製媒體是否處於良好狀態。</li><li>驗證頻率應該符合受保護數據的敏感性和價值，但<code>不應少於每年一次</code>。</li><li>將樣本比率保持在備份頻率的1到1.5個數量級較低的範圍內，可以作為一個可靠的基準（例如，每小時備份的樣本每日驗證，每日備份每兩週到每月驗證等）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R9 - 分離數據與應用程式的還原</summary><div class="toggle-content"><p>為了在還原數據時避免恢復受感染的代碼或軟體，應該<code>將數據與應用程式進行分離</code>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R10 - 文件化災難復原計劃</summary><div class="toggle-content"><p>必須<strong>撰寫儲存基礎架構的災難復原計劃</strong>，包括所有資源、與正式生產環境的映射、流程和測試程序。同時也應備份這些文件。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R11 - 數據副本的網路安全措施</summary><div class="toggle-content"><ul><li>對於關鍵任務的資訊，災難復原副本應該<code>使用各種反惡意軟體掃描工具進行掃描</code>，以檢測已知的漏洞和異常。</li><li>最理想情況下，應<code>對所有副本進行掃描</code>。如果不可能，至少<code>對其中一部分副本進行掃描</code>，並記錄這些已經進行掃描且安全的副本。網路安全工具包括防病毒軟體、防惡意軟體、漏洞掃描和安全分析工具。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R12 - 定期進行審計</summary><div class="toggle-content"><ul><li>述建議應該作為<code>定期審計的一部分進行回顧</code>，以檢查副本的完整性、重新評估依賴性、軟體和硬體要求、支援復原速度的技術適用性、復原點目標 (RPO)、保存期限、健康檢查、災難復原計劃和網路安全措施。</li><li>應該確定並追蹤問題，並進行修復。</li><li>審計的頻率應與所保護數據的敏感性和價值相符，但不得少於每年一次。</li><li>對於敏感和高價值的儲存系統，可能需要每季度進行審計，以及每次進行重大變更後進行審計 - 以先到者為準。</li><li>審計結果應予以文件化。</li></ul></div></details><h1 id="4-9-EN-加密-Encryption">4.9 (EN) 加密 Encryption</h1><div class="note info flat"><p>加密是將數據從<code>可讀形式（明文）轉換為不易被未經授權的人理解的不可讀形式</code>（密文）的過程。這樣可以確保敏感信息不會被未經授權的人存取或理解。</p></div><p>在存儲系統中，加密應該實施<code>端到端</code>，包括：</p><ol><li><code>靜態數據（Data at rest）</code>：物理或邏輯進行儲存的相關設施（例如磁帶、磁盤、光盤等），其<strong>數據應該進行加密</strong>。這不僅包括數據本身，還應該加密元數據，如訪問權限、標籤、路徑和日誌信息等。</li><li><code>數據傳輸（Data in transit）</code>：在<strong>存儲元素之間傳輸</strong>的數據，無論是客戶端讀寫、存儲設備或存儲池之間的複製，或在網絡中傳輸的數據，都應該進行加密，除非整個通信媒介都處於受保護的環境（例如數據中心）。</li><li><code>管理訪問（Administrative access）</code>：包括通過標準和專有協議和API對<strong>存儲元素、存儲網絡和數據</strong>進行<strong>配置或控制</strong>的連接。</li></ol><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R1 - TLS、雜湊 hashing 和 加密 encryption</summary><div class="toggle-content"><ul><li>為了支援存儲客戶端與伺服器之間的加密通信，應該<strong>使用Transport Layer Security (TLS)協議</strong>。</li><li>選擇和配置TLS協議的<strong>實現應遵循相關指南</strong>，包括TLS版本的選擇以及選擇雜湊和加密算法。<ul><li>指南來源包括<code>NIST SP800-52 Rev2</code>和<code>SNIA TLS Specification for Storage Systems Version 1.1</code>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R2 - 不應使用明文協議，如HTTP，Telnet，FTP或RSH</summary><div class="toggle-content"><ul><li>明文協議容易遭受竊聽、攔截等攻擊，因為它們不加密流量或登錄詳細信息。</li><li>在敏感的存儲環境中，<strong>不應允許將HTTP用於重定向到HTTPS的情況</strong>，除非只用於處理錯誤輸入的URL。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R3 - 存儲管理 API 會話加密</summary><div class="toggle-content"><ul><li>應該對所有API和CLI客戶端會話進行加密，可以利用<code>管理軟件</code>或<code>API/CLI軟體組件內的特定配置</code>選項來實現加密。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R4 - 管理員訪問會話的加密</summary><div class="toggle-content"><ul><li>使用HTTP的管理員會話應該<code>使用TLS（HTTPS）來進行加密</code>。</li><li><code>命令列介面（CLI）</code>訪問應該<code>使用SSH而不是Telnet進行加密</code>。</li><li>API訪問期間的身份驗證不應使用明文，<strong>會話本身也應該進行加密</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R5 - 在FIPS環境中啟用FIPS模式</summary><div class="toggle-content"><ul><li>FIPS 140-3規定加密模塊應該是一組硬體、軟體、韌體或其組合，用於實現加密功能或過程，包括加密算法，並可選擇性地進行金鑰生成，並且在定義的加密邊界內。</li><li><strong>FIPS規定某些加密算法是安全</strong>的，並確定在加密模塊稱為符合FIPS標準時<strong>應該使用哪些算法</strong>。</li><li>符合FIPS標準的組織應確保在其符合FIPS標準的存儲基礎設施組件中啟用FIPS模式。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R6 - 敏感數據的靜態加密</summary><div class="toggle-content"><p>靜態加密保護數據免受各種與數據相關的風險（包括未經授權的訪問，媒體丟失或被盜等）。對於敏感數據應該啟用靜態加密。應考慮以下幾點：</p><ol><li><code>使用基礎設施加密</code>：<strong>使用磁碟、存儲陣列或雲存儲提供的內建加密功能</strong>，無論使用供應商提供的金鑰還是組織提供的金鑰，可以保護免受設備丟失、錯置或被盜的威脅。但是，這並不能對抗以下情況：<ol><li><strong>帶內攻擊</strong> - 當攻擊者入侵到已經與存儲關聯的主機（或當可以通過合法方式將存儲映射到未經授權的主機）。</li><li><strong>權限升級攻擊</strong> - 管理員或攻擊者獲得高級權限後可能關閉加密或解密數據。</li></ol></li><li><code>使用端到端加密</code>：數據在其源頭（例如應用程序、數據庫、卷）處進行加密，對存儲基礎設施和管理員只呈現密文。這顯著增加了安全性，但有時會帶來相當大的成本：<ol><li><strong>數據減少機制受影響</strong> - 例如，壓縮和去重可以變得非常不有效。</li><li><strong>管理更加複雜</strong>。</li></ol></li><li><code>使用雙獨立層加密</code>：在可能的情況下，應考慮對敏感數據存儲使用雙獨立層加密。這種配置提高了金鑰被破壞時的韌性，尤其是如果使用不同的加密服務。</li><li><code>應考慮數據保留要求</code>：如果<strong>加密數據被備份或存檔，相關的金鑰應該受到保護</strong>，保護時間應與數據相似。或者，備份數據應重新生成新的密鑰。無論哪種情況，<strong>數據和加密金鑰不應保持在一起</strong>。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R7 - 在傳輸過程中的資料加密</summary><div class="toggle-content"><ul><li>(a) <code>Fibre-Channel上的區塊傳輸</code>：儘管在ANSI/INCITS 545-2019標準中有定義Fibre-Channel的連結加密，但目前大多數主機緘點適配器（HBA）和存儲供應商並不支援。<strong>針對敏感信息，應該使用端到端（主機到存儲）加密</strong>。</li><li>(b) <code>IP區塊傳輸</code>：IP存儲流量面臨與常規IP網絡相同的安全風險。默認情況下，IP區塊傳輸協議不會為每個數據包提供數據保密性、完整性或驗證。類似於連結加密，雖然有IP存儲流量加密的技術規範，但目前的技術並不原生支援。在使用IP區塊傳輸協議（例如iSCSI、FCIP、專有協議）時，應<strong>考慮使用IPsec隧道對暴露在網絡上的段進行保護</strong>。此外，針對敏感信息，應該使用端到端（主機到存儲）加密。</li><li>© <code>檔案和對象存儲訪問</code>：應該在支援的情況下為備份系統和遠程複製啟用傳輸時的資料加密。對於檔案訪問，應該使用SMB加密等機制來加密敏感數據，還可以利用由雲服務提供商提供的NFS加密選項，或者<strong>使用通道加密（例如 ‘stunnel’）的NFS over TLS。確保對象通過HTTPS與TLS進行訪問</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R8 - 存儲系統組件之間的通信應該加密</summary><div class="toggle-content"><ul><li>應該審查<strong>存儲系統組件的交互作用</strong>，並<strong>使用可用的加密選項</strong>。</li><li>應該使用加密來保護存儲<strong>節點和管理器之間的通信</strong>，主動存儲節點與見證設備之間的通信，以及與策略伺服器和防病毒伺服器之間的通信。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R9 - 加密金鑰管理要求</summary><div class="toggle-content"><ul><li>遵循<code>NIST SP 800-57</code>部分1-3中的一般建議進行金鑰管理，特別是:<ul><li>壽命</li><li>金鑰可以保護的最大數據量</li><li>金鑰管理基礎設施</li><li>重新生成金鑰</li><li>審計</li><li>金鑰的備份和恢復。</li></ul></li></ul></div></details><h1 id="4-10-AA-管理者訪問權限-Administrative-Access">4.10 (AA) 管理者訪問權限 Administrative Access</h1><ul><li>這一節重點關注儲存元素的<code>管理者訪問權限</code>，包括<strong>陣列、網路和架構、管理工具、備份、複寫和雲端儲存</strong>等。</li><li>管理者訪問可以通過<code>直接連接到儲存元件</code>或者<code>透過管理軟體</code>來實現。這兩種連接方式都可以使用不同的界面，包括管理用戶介面（UI）、命令列介面（CLI）和應用程式介面（API）等。</li></ul><p>這一章的某些其他節點涵蓋了與管理者訪問重疊的方面。為了避免重複，額外的相關建議可以在以下兩個部分找到：</p><ul><li>在上面的第4.9 Encryption 中，涉及到加密的相關建議。</li><li>在上面的第4.3 Authentication and Data Access Control 中，涉及到與資料相關的訪問控制，其中的一部分可能也適用於管理者訪問。</li></ul><p>此節提供了有關管理訪問配置的安全指南，以下是重點摘要：</p><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R1 - 限制對SAN交換機管理端口的網絡訪問</summary><div class="toggle-content"><ul><li>將對<code>SAN交換機管理端口</code>的<strong>網絡訪問</strong>限制在<strong>特定指派的設備和管理員</strong>上，通過訪問控制清單（ACL）等機制實現。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R2 - 控制和限制具有管理權限的設備和組件至最低限度</summary><div class="toggle-content"><p>包括CLI服務器、管理控制台、API閘道、見證主機和具有控制權限的存儲設備。特別是：<br>(a) 積極發現具有存儲管理權限的組件，<strong>確保只有被授權的組件擁有這些權限</strong>。如果發現不必要的組件，應立即移除並彙報。<br>(b) 從<strong>被授權的設備中移除不必要的權限和能力</strong>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R3 - 實施最小權限原則</summary><div class="toggle-content"><ul><li>將<code>擁有管理權限的用戶</code>的<strong>權限限制到最低限度</strong>。</li><li>這包括用戶可以執行的最小操作，並且將這些權限的範圍限制在僅涵蓋相關系統或區域。</li><li>完全的管理權限應僅授予需要這些權限的用戶。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R4 - 限制服務帳戶的訪問權限</summary><div class="toggle-content"><ul><li>服務帳戶（例如<code>監控工具使用的帳戶</code>）應限制為<code>僅具有read-only</code>和<code>僅metadata-only訪問權限</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R5 - 對所有CLI/API訪問進行身份驗證和授權</summary><div class="toggle-content"><ul><li>對<code>CLI/API</code>使用應<code>進行身份驗證和授權</code>。</li><li>如果無法進行身份驗證或授權，則應通過額外的安全措施保護未經授權的訪問，例如使用特權管理工具來限制控制到最低必要的命令和對象。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R6 – 優先使用API存取控制，而非CLI/shell存取控制</summary><div class="toggle-content"><ul><li>應該<code>優先使用API存取控制</code>，因為<strong>CLI/shell存取具有訪問作業系統和檔案系統</strong>（包括配置文件）的能力。</li><li>若<strong>只有CLI/shell存取選項</strong>，則應<strong>使用安全協定，如SSH</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R7 – 限制管理控制台的作業系統權限</summary><div class="toggle-content"><ul><li>只能通過指定的存儲帳戶提供對管理控制台的訪問，<code>不能使用作業系統管理帳戶</code>（另見AC-SS-R20）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R8 – 管理Web使用者介面</summary><div class="toggle-content"><ul><li>提供管<code>理控制台訪問的 Web</code> 服務應該得到強化，以<strong>滿足或超過組織中其他 Web 應用程序服務器的最低標準</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R9 – 限制主機存儲控制權限</summary><div class="toggle-content"><ul><li>在某些共享數據計算集群配置中（例如集群、地理集群、規模集或存儲虛擬化基礎設施），主機被授予存儲的管理權限，以便控制共享集群數據資源的分配和行為。</li><li>當需要此管理訪問時，應限制授予主機的範圍和權限，僅限於主機需要控制的特定元素（例如LUN、共享、檔案、物件）和需要執行的特定操作。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R10 – 命令裝置或閘控配置</summary><div class="toggle-content"><p>某些存儲數組<strong>允許主機對具有訪問特殊區塊設備的控制權</strong>（例如某些供應商稱為「命令裝置」和「閘控」的設備）進行管理控制。當使用時，<strong>建議遵循以下安全指南</strong>：<br>(a) <code>限制對控制裝置的使用</code>：如果可行，應完全<strong>消除對這些裝置的使用（例如改用API存取）</strong>。如果不能消除，則應<strong>確保它們僅映射到必要的主機（例如管理主機）</strong>。<br>(b) <code>掃描控制裝置</code>：進行網<strong>路掃描以發現控制裝置，並確保它們僅映射到必要且經授權的主機</strong>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R11 – 禁用或限制call home 或 遠端存取</summary><div class="toggle-content"><p>通常call home 或 remote access 被用於收集遙測和診斷數據，供製造商分析和解決技術問題，以及進行自動軟件更新。然而，這些功能也可能成為黑客攻擊的目標，因此<code>如果不需要的話應該禁用</code>，<strong>如果需要的話則應該限制和控制</strong>。<br>(a) 修改默認憑據 - 改變遠端連接的默認憑據。<br>(b) 限制權限 - 只授予必要的最低權限。<br>© 強制加密 - 使用TLS/SSH/IPSEC等安全協議，並使用FIPS批准的加密算法。<br>(d) 使用&quot;允許清單&quot;限制訪問 - 使用允許清單限制特定IP和特定用戶的訪問。<br>(e) 完整記錄遠端訪問 - 為了審計目的，應該完整記錄所有遠端訪問。<br>(f) 啟用內建數據混淆功能 - 對於允許混淆敏感數據（如IP地址，WWN，設備名稱和用戶名）的存儲設備，應該啟用此功能。<br>(g) 限制發送的數據範圍 - 將發送的數據範圍限制為最低要求。<br>(h) 定期審查和批准 - 定期評估定期或自動發送給供應商的數據，確保其中不包含敏感信息，如IP地址，用戶名或實際存儲設備的內容。同時，審查確保連接是通往有效的供應商IP地址的。<br>(i) 授權每個連接 - 如果可能，實施一個在允許每個連接之前請求許可的機制。<br>(j) 限制對網關系統的訪問 - 當供應商通過網關設備、服務器或設備進行遠程訪問時，特別注意保護和限制對網關系統的訪問。<br>(k) 禁用供應商遠程訪問鏈路上的軟件更新 - 在敏感環境中，不應該允許通過供應商遠程連接鏈路進行軟件組件和更新的下載和部署（無論是手動還是自動）。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R12 - 管理網路訪問的限制 Limit network access for management</summary><div class="toggle-content"><ol><li>建議將<code>管理網路與其他流量分開</code>（參見第4.6節和第4.7節）。</li><li>進一步<code>加強管理網路的存取控制</code>，可使用以下機制：<br>(a) 虛擬私人網路（VPN）、IPsec或一個或多個「跳板伺服器」：使用VPN、IPsec或一個或多個「跳板伺服器」或「登入代理伺服器」，這些是位於管理網路中的專用伺服器，只能從網路外部訪問，並且在經過適當的身份驗證和授權後，可以用於連接其他伺服器。<br>(b) 增強日誌記錄和追蹤功能，例如會話記錄。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R13 - 安全保護核心儲存管理檔案和執行檔</summary><div class="toggle-content"><ol><li>儲存管理軟體通常包含<code>配置檔案</code>，<strong>用於控制儲存系統的運作方式</strong>，包括未記載的選項。</li><li>這些敏感目錄和檔案應該具有適當的<code>限制權限</code>，並<code>擁有正確的擁有者和群組成員</code>。</li><li>包括以下內容：<ul><li><code>配置檔案</code>：記錄用戶和角色、網路設定、一致性群組、裝置群組和其他儲存選項。定義一致性和裝置群組的配置檔案通常會從中央管理主機自動傳播到連接到受管理儲存系統的其他主機。因此，如果遭到入侵，可能會影響多個系統。</li><li><code>腳本</code>：用於控制啟動、監控和停止儲存管理服務和守護程序，以及本身的執行檔。應將這些腳本及其他重要的管理相關檔案進行安全保護。</li></ul></li><li>應對配置檔案、腳本和其他重要的管理相關檔案採取以下控制措施：<br>(a) <code>限制存取和權限</code>，並控制關鍵目錄和檔案的擁有權。<br>(b) 對於敏感環境，應考慮<code>監控這些檔案的內容變化</code>，以防止未經授權的更改。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R14 - 使用經核准的PKI機制進行管理訪問</summary><div class="toggle-content"><ul><li>在儲存設備管理和儲存管理控制台方面，建議使<code>用經組織核准並經認證的集中式PKI系統</code>，而不是使用設備或軟體自簽名憑證。</li></ul></div></details><h1 id="4-11-CM-配置管理-Configuration-Management">4.11 (CM) 配置管理 Configuration Management</h1><p>配置管理的目的是在「整個儲存設備」<code>生命周期</code>內提供對<strong>設定、行為、以及實體和邏輯屬性的可見性和控制</strong>。在儲存安全的背景下，這包括以下內容：</p><ul><li>維護全面且即時的<code>清單</code>，<code>管理變更</code>，以及<code>確保配置</code><strong>持續符合組織的安全基線和目前業界最佳實踐</strong>，同時確保其不受已知風險的影響。</li></ul><p>為了實現這一目標，需要適當的控制、政策、流程和工具。IT 配置管理的全面指南可參考 <code>NIST Special Publication (SP) 800-53</code> [28]。以下段落包含適用於儲存基礎架構的建議。</p><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R1：建立全面的存儲設備清單，包括識別以下所有存儲組件的名稱、地址、位置和軟件、固件或驅動程序版本</summary><div class="toggle-content"><ol><li>數組(Array)</li><li>存儲虛擬化系統(Storage virtualization systems)</li><li>管理控制台(Management consoles)</li><li>監控存儲遠程網絡連接狀態的主機（例如Witness主機）</li><li>安裝了存儲管理軟件或插件的主機</li><li>數據保護設備(Data protection appliances)</li><li>備份客戶端和伺服器(Backup clients and servers)</li><li>存儲網路交換機(Storage network switches)</li><li>存儲適配器或&quot;主機總線適配器 (HBA)&quot;</li><li>I/O多路徑軟件(I/O multipathing software)</li><li>主存儲系統和（複製）目標存儲系統的配對情況</li><li>指定的主機備份伺服器或離地備份的情況</li><li>磁帶庫和磁帶驅動器</li><li>磁碟驅動器和可移動媒體</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R2：建立全面的資料和配置資產清單，包括通過以下資產識別邏輯數據組件和數據訪問配置</summary><div class="toggle-content"><ol><li>存儲池、LUNs、遮罩和分區</li><li>發起者和發起者組</li><li>文件共享和存取控制列表(ACLs)</li><li>物件存儲池、桶等</li><li>備份複本和快照(Replicas and snapshots)</li><li>備份目錄和訪問權限</li><li>備份集（本地、存檔、雲端虛擬化、磁帶、存檔設備等）</li><li>用戶、群組、角色和權限</li><li>主機訪問配置到存儲資產（例如LUNs、文件共享、全局文件系統、物件存儲）</li><li>存儲軟件、虛擬設備等的映像</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R3 - 創建全面的存儲安全策略</summary><div class="toggle-content"><ul><li>存儲安全策略可以作為專用策略，或者作為組織安全策略的一部分。</li><li>策略應基於以下來源：<ul><li>來自該出版物和<code>引用來源</code>的建議。</li><li>內部組織相關的存儲相關安全標準。</li><li>相關供應商的<code>最佳安全實踐</code>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R4 - 保持存儲安全策略的更新</summary><div class="toggle-content"><ul><li>存儲安全策略應該<code>定期進行審查和更新</code>（至少每年一次）。</li><li>安全基線應根據可用的存儲系統和/或特定存儲設備的<code>最新供應商和行業建議進行更新</code>（最好每季度進行，至少也要每年）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R5 - 定期主動評估存儲安全策略的配置合規性</summary><div class="toggle-content"><ul><li>(a) 確保實際配置<code>符合存儲安全基線</code>，並識別差距。</li><li>(b) 及時<code>追蹤差距</code>的整改。</li><li>© 考慮制定基於數據類型、組織功能和敏感性的存儲安全基線合規性的關鍵績效指標（KPI）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R6 - 創建「存儲變更」管理流程</summary><div class="toggle-content"><ul><li>可以作為專用流程或組織的一般變更管理流程的一部分。</li><li>涵蓋：</li><li>(a) 規劃、審查和批准存儲配置變更。</li><li>(b) 更新環境文檔和庫存（例如基礎設施、數據、配置）。</li><li>© 在對敏感存儲環境進行任何變更後評估合規性。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">CM-SS-R7 - 檢測未經授權的存儲安全變更</summary><div class="toggle-content"><ul><li>應建立<code>檢測未經授權的存儲配置變更的流程</code>，可以使用日誌記錄、將配置存儲資產與過去狀態進行比較，或者與組織批准的基線進行比較。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R8 - 軟體更新和修補</summary><div class="toggle-content"><p>(a) <code>確保儲存軟體版本更新</code>：應建立定期更新儲存軟體至最新穩定且安全版本的流程。這包括管理軟體、API和CLI套件、數組和HBA固件版本以及作業系統驅動程式。<br>(b) <code>安裝重要的安全更新和修補程式</code>：應建立主動且頻繁地安裝重要和緊急的儲存安全修補程式的流程。<br>© <code>無法取得修補程式的緩解計劃</code> - 如果某些儲存組件存在重要漏洞，而供應商尚未提供更新或修補程式，應暫停使用這些組件，除非可以定義適當的緩解計劃。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R9 - 網路拓撲文件</summary><div class="toggle-content"><p>保持儲存相關的網路文件最新，包括光纖通道（FC）和IP的繪圖。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R10 - 審核FC SAN安全配置</summary><div class="toggle-content"><p>隨著時間推移，某些安全變更可能無法可靠地傳播到整個光纖通道交換機(fabric)。</p><ul><li><code>應定期審核FC SAN</code>（就像IP和以太網網路一樣），以評估其安全性，識別和優先處理漏洞，並<code>定義改進計劃</code>。</li><li><code>安全審核</code>應至少每年進行一次，在敏感環境中，至少每季進行一次或在任何重大更改後進行 - 以先到者為準。</li><li>審核結果應予以記錄。</li></ul></div></details><h1 id="4-12-ST-存儲安全培訓-Training">4.12 (ST) 存儲安全培訓 Training</h1><details class="toggle" ><summary class="toggle-button" style="">ST-SS-R1：存儲安全培訓計畫</summary><div class="toggle-content"><p>應制定一個存儲安全培訓計畫，並<strong>納入現有的組織培訓活動和時間表</strong>，以滿足以下目標受眾：</p><ol><li><code>資訊安全專業人員</code>：為他們提供存儲安全的基本背景知識。</li><li><code>存儲管理員</code>：讓他們熟悉存儲安全原則，以及組織的政策和安全基準。</li><li><code>管理者</code>：理解數據保護的基本原則。</li></ol></div></details>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Database </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> 碩士論文 </tag>
            
            <tag> Cloud Storage </tag>
            
            <tag> Security </tag>
            
            <tag> NIST SP 800-209 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIST SP 800-209 資料儲存安全指引 Security Guidelines for Storage (1) 威脅與風險</title>
      <link href="/posts/security-for-storage-infra/"/>
      <url>/posts/security-for-storage-infra/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://csrc.nist.gov/publications/detail/sp/800-209/final">NIST SP800-209 Security Guidelines for Storage Infrastructure</a></li><li><a href="https://owasp.org/API-Security/editions/2023/en/0x11-t10/">OWASP API Top 10, 2023</a></li><li><a href="https://owasp.org/Top10/">OWASP Top 10, 2021</a></li><li><a href="https://ithelp.ithome.com.tw/m/articles/10294214">OWSP Top 10,2021</a>：別人整理的，內容簡短。</li><li><a href="https://s.itho.me/ccms_slides/2022/9/29/6f51c8e9-67ba-4267-913d-d4461bba3894.pdf">OWSP Top 10,2021</a>：簡報更加清楚裡面的具體採取措施與威脅。</li></ul><h1 id="前言">前言</h1><p>根據上一篇的內容和研究議題，應該要先了解，本篇主要目的在整理：</p><ul><li>[x] <code>資料儲存的相關威脅與風險有哪些？</code></li><li>[ ] 零信任怎麼預防這些威脅與風險？</li></ul><hr><p>為了能夠整理儲存安全的相關威脅與風險，我整理了NIST所發布針對Cloud Stoage的相關安全標準，NIST SP 800-209的本文檔概述了：</p><ul><li><strong>存儲技術格局的演變、當前的安全威脅以及由此產生的風險</strong>。</li><li>並主要提供<strong>一套全面的安全建議</strong>來應對威脅，涵蓋…<ul><li>信息技術 (IT) 基礎設施常見的安全管理領域: 例如物理安全、身份驗證和授權、變更管理、配置控制以及事件響應和恢復）</li><li>存儲基礎設施特有的安全管理領域: 例如存儲基礎設施、數據保護、隔離、恢復保證和加密。</li></ul></li></ul><div class="note warning flat"><p>我只會挑<code>我覺得有用或是可用的資料進行整理，不會放全部的內容上來，並且會有一些個人的觀點或說法</code>，因此本篇參考即可，<strong>正確內容還是請參考NIST SP800-209為主</strong>。</p></div><h1 id="重點整理">重點整理</h1><p>以下也是我針對這個章節的重點整理，如果想要快速了解，可以閱讀這個章節即可。</p><blockquote><p>Mapping Threats and Risks 總結第三章內容</p></blockquote><table><thead><tr><th><div style="width:130px">威脅</div></th><th>可能的風險</th><th>威脅程度</th></tr></thead><tbody><tr><td><code>後門和未修補的漏洞</code></td><td>- 依據「<strong>弱點類型</strong>」不同有不同風險。<br> -「<strong>憑證被盜或洩露</strong>」威脅所帶來的風險都適用。</td><td>高</td></tr><tr><td><code>特權升級</code></td><td>- 依據「管理者」或「使用者」憑證是否被盜或洩露。 <br>  -「<strong>憑證被盜或洩露</strong>」威脅所帶來的風險都適用。</td><td>高</td></tr><tr><td><code>人為錯誤與故意配置失誤</code></td><td>- 依據人為或配置錯誤的「<strong>種類</strong>」和「<strong>影響範圍</strong>」造成的風險不同。 <br> - 如果是錯誤的配置，<strong>章節3.2所有風險</strong>皆可能發生。</td><td>高</td></tr><tr><td><code>實體媒體的物理偷竊</code></td><td>- 依據竊盜「<strong>範圍</strong>」有不同的風險。<br> - 「<strong>資料洩露和資料曝露</strong>」、「<strong>資料損毀</strong>」、「<strong>備份受損</strong>」、「<strong>數據不可用和阻斷服務</strong>」為可能因偷竊導致的風險。</td><td>中</td></tr><tr><td><code>不安全的映像、軟體和韌體</code></td><td>- 依據影響「<strong>種類</strong>」和「<strong>影響範圍</strong>」造成的風險不同。<br>  - 如果是錯誤的配置，<strong>章節3.2所有風險</strong>皆可能發生。</td><td>高</td></tr><tr><td><code>惡意軟體與勒索軟體的感染</code></td><td>- 惡意軟體可能導致「<strong>權限提權</strong>」、「<strong>憑證被盜或洩露</strong>」威脅。<br> - 依據惡意軟體「<strong>出現的地點</strong>」像是應用系統或是管理系統，都可以影響導致<strong>章節3.2所有風險</strong>皆可能發生。</td><td>高</td></tr><tr><td><code>加密破解</code></td><td>- 可能導致「<strong>數據洩露和暴露</strong>」於 (a) 靜態數據、(b) 傳輸中的數據和 © 用戶/管理員會話中的數據</td><td>中</td></tr><tr><td><code>憑證被盜或洩露</code></td><td>1. <strong>應用系統</strong>(Application System)：「資料洩露和暴露」、「未經授權的數據更改和新增」、「資料損毀」等風險皆有可能。<br> 2. <strong>管理系統</strong>(Administrative System)：「備份損毀」(Compromise of existing and future backups)、「惡意數據混淆和加密」(ransomware attack)、「數據不可用和阻斷服務」(DDOS Attack)、「存儲相關日誌和審計數據的篡改」、不安全的儲存設定參數，皆有可能發生。</td><td>高</td></tr></tbody></table><h1 id="2-11-儲存和資料管理-Storage-and-Data-Management">2.11 儲存和資料管理 Storage and Data Management</h1><p>在裡面提到了，以下的內容，<strong>主要關注的是儲存和資料管理的其他方面，而不是直接涉及「資訊安全」的控制措施</strong>。因此只會簡單介紹一下，以下內容在NIST SP 800-209稍微提到的內容。</p><div class="note info flat"><p>我的感想：上述中，有探討意義的是「資料保護」，裡面提到的三個面向，在information assurance/security的部分可以好好探討。也可以思考「資料分類」與「資料保護」的結合。像是，透過資料分類，來進行存取控制的資料保護。</p></div><details class="toggle" ><summary class="toggle-button" style="">儲存資源配置和資源管理 Storage Resource Configuration and Resource Management</summary><div class="toggle-content"><ul><li>內容：主要說明進行儲存資源配置或管理時生命週期要注意的點，像是針對「物理裝置」的管理與控制，跨多「資產」的變更協調、效能管理和最佳化、資產的管理、事件管理，都是被歸類於此。</li><li>感想：非論文主軸</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料分類或分類 Data Classification or Categorization</summary><div class="toggle-content"><ul><li>提到可以參考資料法規像是PII, PCI-DSS, HIPAA等，針對資料做更細緻的分類，並且針對不同的資料做不同的保護。</li><li>主要可以分以下幾類：<ul><li>敏感性（例如，敏感 vs. 非敏感）</li><li>頻率（例如，經常訪問 vs. 不經常訪問）</li><li>環境（例如，生產環境 vs. 開發環境 vs. 測試環境 vs. 演示環境）。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料消除 Data Sanitization</summary><div class="toggle-content"><ul><li>說明需要根數據的類型和特定，使用適當的資料消除方式。</li><li>提到，資料消除主要可以分以下幾類：<ul><li>Clearn：例如，覆蓋現有數據；</li><li>Purge：例如，對於磁性媒體，使用強磁場進行消磁，對於加密數據，使用密碼擦除；</li><li>Destruct：例如，對媒體進行物理破壞，如燃燒，粉碎等。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料保留 Data Retention</summary><div class="toggle-content"><ul><li>說明在某些情況下，可能需要將特定資料保存一段短期、中期（即少於10年）或長期的時間。</li><li>資料保留通常是透過將資料副本備份至某個媒介來實現的。這可能是為了滿足運營、法律、監管或法定要求。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料保護 Data Protection</summary><div class="toggle-content"><ul><li>是一個綜合性術語，指的是所有「確保資料可訪問、可用、不受損壞、並可供所有經授權的目的使用，且性能達到可接受水平的活動」。</li><li>這些活動需要符合合規要求，包括隱私保護，以及所有物理、管理和技術手段，以確保資料不會被意外或未經授權地洩露、修改或破壞。</li><li>資料保護所涉及的生命周期。這些階段包括：<ul><li>（儲存）靜態資料／端點上的資料 - 存儲於伺服器或用戶端設備上的資料。</li><li>（傳輸過程）過程中的資料 - 在存儲設備之間、用戶端到伺服器或伺服器之間傳輸的資料。</li><li>（正在使用）使用中的資料 - 在查看、修改或在設備之間進行同步時的資料。</li><li>（離開安全範圍）超越安全範圍的資料 - 下載、物理媒體運送等過程中的資料。</li></ul></li><li>資料保護可以分為三個面相：<ol><li>storage: 主要探討「儲存」本身的相關保護，像是備份、恢復、複製、不可變、持續資料保護、snapshot等。</li><li>privacy: 主要探討「資料本身的隱私」但是這個每個地區規則不同，在此不討論。</li><li>information assurance/security: 主要是技術控制措施，每個措施都需要專門的部分來討論其細節。所以也先不討論。</li></ol></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料壓縮 Data Reduction</summary><div class="toggle-content"><ul><li>資料壓縮有兩個常見的方法，這兩種方法可以結合使用。<ul><li>資料去重：資料去重試圖將多個資料副本替換為指向共享副本的引用。有點像是都是相同檔案的話，就把他們指向同一個source就不用複製多個相同的資料了。</li><li>資料壓縮：使用已知的演算法對資料進行編碼，以產生一種使用比未編碼表示法更少的儲存空間的資料表示形式</li></ul></li></ul></div></details><h1 id="3-儲存基礎設施的相關威脅-Threats-Risks-and-Attack-Surfaces">3. 儲存基礎設施的相關威脅 Threats, Risks, and Attack Surfaces</h1><div class="note info flat"><p>威脅 - 潛在引起不需要的事件的原因，可能對系統或組織造成損害。</p></div><p>第三章節主要提供有關存儲系統「安全威脅」、「風險」和「攻擊面」（可能使用的手段手段）的背景資訊。</p><h2 id="3-1-Threat-威脅">3.1 Threat 威脅</h2><p>主要提到九個威脅是Storage Infrastruture可能會碰到的：</p><details class="toggle" ><summary class="toggle-button" style="">3.3.1 憑證被盜或洩露 Credential Theft or Compromise</summary><div class="toggle-content"><ul><li>最常用且<strong>最容易被入侵的是登錄密碼證書</strong>。</li><li>內文指出，有效的憑證盜用都是「<strong>直接取得使用者的密碼，而非猜測</strong>」，因此僅僅依靠密碼的長度和複雜性通常不足以保護系統免受攻擊。舉例來說以下情境皆不適用密碼的複雜度：<ul><li>現代勒索軟件通常會從其捕獲的數據集中收集密碼。</li><li>鍵盤記錄也是一種不受密碼複雜性影響的證書盜竊方法，其中恶意软件可以虛擬地監視使用者輸入密碼[23]。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.2 加密破解 Cracking Encryption</summary><div class="toggle-content"><ul><li>加密金鑰生成利用「隨機性」來建立金鑰。但是仍有各種弱點，從「<strong>弱的加密算法」和「弱的金鑰生成器」到「服務器端的漏洞」、金鑰泄露、基本設計缺陷或漏洞</strong>，以及後門等等 [24]。</li><li>簡單來說就是要注意：使用強大的加密方法很重要，同時也要妥善保護加密金鑰。積極更換加密金鑰可以成為一種策略，以防止金鑰被破解或不夠強大。在金鑰生成方面，金鑰的強度、質量和熵都起著重要作用，且金鑰不應重複使用。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.3 惡意軟體與勒索軟體的感染 Infection of Malware and Ransomware</summary><div class="toggle-content"><ul><li>文中提到，往往攻擊「存儲管理系統」比攻擊「存儲裝置」本身更容易。</li><li>因此<strong>惡意軟體可能因安裝在存儲管理主機上</strong>，造成傷害，如竊取憑證、提升特權、資料損壞、損失或更改，以及破壞未來的備份等。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.4 後門未修補的漏洞 Backdoors and Unpatched Vulnerabilities</summary><div class="toggle-content"><ul><li>後門：通常是軟體機制或功能，由供應商、個別貢獻者（在罕見情況下，可能是國家或惡意行為者）故意創建，原因通常被作者認為是合理的（例如為了改進支援、調試、國家安全等）。</li><li>由於門後具有潛在的危害性，它們並不在官方文檔中記錄，只有被限定的一組人才知道其存在。然而，隨著時間的推移，門後的存在可能會被故意或無意間洩露或被公眾發現。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.5 特權升級 Privilege Escalation</summary><div class="toggle-content"><ul><li>特權升級只利用軟體漏洞、設計或部署缺陷，或是配置錯誤，以至於<strong>獲得對於應用程式或使用者取得受保護資源的訪問權限</strong>。</li><li>特權升級與後門漏洞有很高的關聯，特權升級有兩種形式：<ol><li>垂直特權升級（特權提升）：<strong>低特權</strong>使用者或應用程式訪問<strong>高特權</strong>使用者或應用程式的功能或內容。</li><li>水平特權升級：<strong>普通</strong>使用者訪問為其他<strong>普通</strong>使用者所保留的功能或內容。</li></ol></li><li>對資料庫的影響：<ul><li>在儲存系統中，這種威脅可能導致各種風險，包括資料損壞、資料更改、資料丟失等。</li><li>例如，攻擊者可以使用提升的特權來進入儲存系統，刪除儲存卷，並修改訪問配置。</li><li>這種攻擊還可能危及資料的備份副本（例如，同步/非同步複本、快照）或未來備份的生成。</li><li>特權升級本身可以在各種級別上發生，例如儲存元件（例如，儲存陣列、主機或客戶端）、網路設備或管理系統。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.6 人為錯誤與故意配置失誤 Human Error and Deliberate Misconfiguration</summary><div class="toggle-content"><ul><li>即使存在安全控制，<strong>使用者可能會進行技術上支援的儲存配置更改</strong>，但仍然會造成無法接受的風險。</li><li>可能的人為錯誤包含以下：<ul><li>打字錯誤。</li><li>缺乏對內部安全基準和供應商最佳實踐的了解或熟悉。</li><li>個人或團隊之間的溝通失誤。</li><li>儲存基礎架構的指導或自動化相關的錯誤：<ul><li>直接錯誤，例如腳本和配置文件中的缺陷。</li><li>間接錯誤，例如未意識到的軟體依賴性。</li></ul></li><li>將受限制的物件儲存池映射到公共網路，停止複製或備份進行維護，卻未在之後重新啟用</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.7 實體媒體的物理偷竊 Physical Theft of Storage Media</summary><div class="toggle-content"><ul><li>所有的<strong>數據最終都儲存在一個或多個實體媒體上，而這些媒體容易受到偷竊的威脅</strong>。</li><li>這些媒體，無論是在線或離線，都可能被從其指定的（固定）位置上移除，或者在實體運輸過程中被竊取（例如，正在運輸用於備份的媒體進行歸檔，或者作為數據中心遷移項目的一部分而運送存儲設備。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.8 網路竊聽資料 Network Eavesdropping</summary><div class="toggle-content"><ul><li><strong>資料在傳輸時可能會被攔截</strong>。</li><li>傳輸可以涵蓋許多組件：網路卡（有線或無線）、傳輸電纜（傳輸電力或光線）、中繼器、交換器、路由器等。這些<strong>組件中的任何一個都可能受到破壞</strong>，而且很多形式的破壞是難以或不可能用最先進的工具和方法來檢測的。</li><li>可能針對資料的相關工作：<ul><li>某些傳輸破壞可能可以進行資料的截取（也稱為被動竊聽）</li><li>還可能涉及對傳輸的資料、元數據或控制流量進行插入、刪除或修改</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.9 不安全的映像、軟體和韌體 Insecure Images Software and Firmware</summary><div class="toggle-content"><ul><li>對手可能試圖<strong>干擾儲存設備的軟體分發、更新或安裝過程</strong>，以引入不正確、過時或惡意修改的程式碼（例如二進位檔案、映像、韌體、驅動程式等）。</li><li>軟體更新過程可能依賴於複雜的傳遞鏈路：鏈路中的每個環節都可能成為引入被篡改軟體的目標。<ul><li><strong>發行者（例如供應商、第三方、開源社區）</strong>: 發行者可能被滲透，以感染源碼庫、獲取註冊軟體或設備的存取權限，將經過修改的簽署二進位檔案發布在下載站點或更新伺服器上，</li><li><strong>傳遞方法（例如傳輸或下載、安裝媒體的運送、供應商員工的檔案複製）</strong></li><li>**個別組織保存的本地副本（例如代理伺服器、內部檔案伺服器）**等。</li></ul></li><li>受影響的儲存元件包括: 磁碟驅動器、磁帶驅動器和磁帶庫、網路卡和控制器（例如HBA、網路介面卡或NIC、FCoE適配器等）、交換機和其他網路設備、儲存機箱和陣列、儲存作業系統、用戶端作業系統的儲存元件等。</li></ul></div></details><h2 id="3-2-Risk-風險">3.2 Risk 風險</h2><p>這這章節描述了安全風險的定義，這邊與3.1 Threat相比的差異像是：</p><div class="note warning flat"><p>Threat: 是一些可能會發生的攻擊的地方，或是造成Risk的可能原因，還沒做出傷害使用者或組織名譽的行為（Risk）。<br>Risk: 對資料的機密性 完整性 可用性 已經造成損害，而影響組織的使命、形象、資產和其他相關利益。</p><p>舉例來說，<strong>Threat包含一些「弱密碼、人為設定錯誤」（Threat）等，來造成「資料外洩」（Risk）</strong>。</p></div><div class="note info flat"><p>安全風險被定義為：一個<strong>實體（可能是組織、系統或資訊）受到潛在情況或事件的威脅的程度（影響x機率）</strong>。而這些風險主要涵蓋了<strong>機密性、完整性和可用性</strong>三個方面，這些風險可能影響到。<strong>組織的使命、形象、資產和其他相關利益</strong></p></div><p>相關的安全風險有以下幾點：</p><details class="toggle" ><summary class="toggle-button" style="">資料洩露和資料曝露 Data Breach and Data Exposure</summary><div class="toggle-content"><ul><li>資料洩露是指涉及<strong>敏感且受保護的資訊被複製、傳輸、查閱、故意</strong>向公眾公開，或被未經授權的個人或實體使用的事件。料洩漏的影響可以是廣泛的，從給使用者帶來不便，到將敏感或機密數據暴露出來，導致對組織的聲譽和運營健康造成不可挽回的損害。</li><li>資料洩漏可能是由以兩種所引起：<ul><li><strong>外部來源</strong>引起的，例如黑客或網絡犯罪分子。</li><li><strong>內部人員</strong>引起的，比如惡意內部人員或不滿的員工。</li></ul></li><li>可能的根本原因包括：上述的Threat就有一些包含在內。<ul><li>資料在儲存或傳輸過程中的弱加密（或完全未加密）</li><li>軟體漏洞</li><li>可拆卸媒體的遺失</li><li>媒體的被竊</li><li>錯誤或過於寬鬆的訪問限制</li><li>不正確或不完整的資料清除實施（包括刪除的物件、退休或重新利用的媒體等）</li><li>將資訊發送給錯誤的收件人</li><li>將資料以不正確的方式上傳（例如，將受保護的資料上傳至公開的資料儲存庫）。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">未經授權的數據更改和新增 Unauthorized Data Alteration and Addition</summary><div class="toggle-content"><ul><li><strong>攻擊者獲取了訪問數據存儲基礎設施的權限</strong>，以一種影響未來應用交易或影響數據其他用途的方式<strong>修改數據</strong>。</li><li>數據更改和新增可能來自外部或內部來源，並且可能以隱蔽或容易識別的方式進行。</li><li>這種風險可以使用 “salami attack” 方法實現: 即攻擊者在長時間內從大量交易中偷取少量數據或資金。</li><li>數據更改和新增的影響可能從損失資金到對聲譽和信任的永久損害不等。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料損壞 Data Corruption</summary><div class="toggle-content"><ul><li>資料損壞指的是在<strong>寫入、讀取、儲存、傳輸或處理過程中，資料遭受損壞或產生錯誤，導致原始資料出現意外變化</strong>。</li><li>通常情況下，當<strong>資料損壞發生</strong>時，包含該資料的物件在<strong>系統或相關應用程式存取時會產生意外結果(Exception)</strong>。<ul><li>這些結果可能從輕微的資料損失到系統崩潰不等。</li></ul></li><li>具體的情境如下：<ul><li>如果一個文件檔案遭受損壞，使用者可能無法打開它，或者它可能打開時其中一部分或全部資料變得無法理解。</li><li>有些類型的惡意軟體可能會故意損壞或摧毀檔案，通常是透過覆寫檔案內容為無效或垃圾程式碼，或以其他安全方式擦除其內容。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">備份受損 Compromising Backups</summary><div class="toggle-content"><ul><li>資料備份是非常重要的，這包括<strong>保存資料的複本、快照等。透過備份</strong>，當資料損壞或丟失時，我們能夠恢復這些資產。</li><li>備份有幾點是要注意的：<ul><li><strong>資料一致性：備份必須「正確生成」，並且要有適當的「保留頻率」和「更新頻率」</strong>。</li><li><strong>備份安全性：備份的存儲也必須安全，以防止未經授權的存取</strong>。</li></ul></li><li>備份不檔可能造成的故障原因如下。<ul><li>若備份時未考慮到一致性或寫入順序的完整性，可能會導致不正確的配置。</li><li>而保留期限不足或備份更新不及時，可能導致某些舊或新資料無法復原。</li></ul></li><li>攻擊策略：<ul><li><strong>干擾備份過程</strong>：當現有的備份無法受到威脅時，另一種可行的攻擊策略是<strong>干擾備份過程本身，逐漸&quot;毒化&quot;未來的備份</strong>。此時唯一可用的備份已經太老舊，導致無法完全恢復資料。</li><li><strong>專門感染系統或應用程式的備份複本</strong>：例如操作系統映像、軟體套件、韌體，甚至源代碼庫。這樣，當我們嘗試通過重建單個元件或整個環境來應對感染時，至少部分惡意程式碼會被還原到環境中，使攻擊者能夠迅速重新控制系統，或造成更多損害。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">惡意數據混淆和加密 Malicious Data Obfuscation and Encryption</summary><div class="toggle-content"><ul><li><strong>「可逆的數據混淆和/或加密」會使「數據」對用戶或組織「變得不可用」</strong>，除非使用僅由攻擊者持有的密鑰進行還原。</li><li>這種風險<strong>通常在勒索軟體攻擊中使用</strong> - 一種將受害者的數據進行加密並要求贖金來恢復對數據的訪問權限的惡意軟體。</li><li>近況：隨然最初是針對用戶裝置或企業伺服器上的數據或文件，但是最近已經發展到其他存儲組件，例如NAS和備份設備[30]。</li><li>影響：這些攻擊通常旨在被識別，並且通常伴隨威脅和贖金指示。數據混淆和加密的影響可能從損失資金到永久損害聲譽和信任。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">數據不可用和阻斷服務 Data Unavailability and Denial of Service</summary><div class="toggle-content"><ul><li><strong>數據客戶無法獲得對其部分或全部數據的訪問</strong>。儘管此類損害可能是可逆的（例如，通過還原被更改或刪除的設置），但它可能會導致系統或服務長時間的中斷和停機。</li><li>數據可用性中斷風險可能原因：<ul><li>由於有意或無意地對「通信路徑」或「訪問配置」造成的損害。</li><li>物理性損害：例如通信路徑中斷。</li><li>邏輯性損害：<ul><li>網絡組件的端點配置錯誤。</li><li>攻擊者可以修改或刪除塊存儲設備的存取控制（SAN）掩碼設置</li><li>暫停 NFS（Network File System）中的導出設置，以致客戶無法訪問其數據。</li></ul></li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">存儲相關日誌和審計數據的篡改 Tampering of Storage-Related Log and Audit Data</summary><div class="toggle-content"><ul><li>指攻擊者刪除或修改日誌數據（例如時間戳記），以<strong>阻止有效的審計軌跡，以掩蓋攻擊（實時或事後），或者向調查攻擊的人提供虛假信息</strong>。</li><li>攻擊行為：<ul><li><strong>禁用日誌系統</strong>：攻擊者可能試圖暫時或永久地關閉目標系統的日誌功能，從而讓其活動不留痕跡，使其攻擊行為更加不容易被發現和跟蹤。</li><li><strong>將所有空閒空間填滿合成信息</strong>：攻擊者可能會寫入大量的虛假日誌信息，將空閒的日誌空間填滿，使真實的日誌數據無法被正確記錄和存儲，以混淆安全人員的調查和追蹤。</li><li><strong>將日誌數據發送到流氓日誌服務器</strong>：攻擊者可能針對客戶或使用者進行社交工程或欺騙手段，讓客戶將寶貴的日誌數據發送到攻擊者控制的偽冒或流氓日誌服務器，使得攻擊者能夠更容易地掌控敏感信息。</li></ul></li><li>影響：這些行為的目的都是為了干擾、混淆和遮蓋攻擊活動，以保護攻擊者的身份，並阻礙安全人員對攻擊事件進行追蹤和調查。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存作業系統、二進位檔案、韌體和映像的侵入 Compromising Storage OS or Binaries、 Firmware and Images</summary><div class="toggle-content"><ul><li>針對儲存軟體的侵入，包括「<strong>儲存設備」的作業系統、韌體、映像等，所導致的不良後果，提供攻擊者進行遠端訪問的手段</strong>，讀取、複製、更改或摧毀數據及其副本，改變安全設定，暴露數據，改變儲存基礎架構的行為等。</li><li>可能造成的結果：<ul><li>儲存行為的改變可用於<strong>引入各種潛在且難以檢測的攻擊</strong>。</li><li>向儲存客戶端<strong>呈現不正確的數據</strong>（即使存儲的數據完好無損）</li><li>向儲存客戶端提供<strong>不正確的狀態</strong>（例如，對快照和安全設定的存在或狀態進行虛假報告）</li></ul></li></ul></div></details><h2 id="3-3-Attack-Surface-攻擊面">3.3 Attack Surface 攻擊面</h2><div class="note info flat"><p>攻擊面被定義為“未經授權的使用者（攻擊者）可以嘗試「進入環境」並進行「數據輸入」(編輯或添加數據)或「提取數據」(數據竊取)等不同攻擊點（“攻擊向量”）的總和” [31]。</p><p>Attack surfaces are defined as “the sum of the different points (the “attack vectors”) where an unauthorized user (the “attacker”) can try to enter data into or extract data from an environment” [31].</p></div><p>本節將列出與儲存基礎架構相關的常見數位和實體攻擊面。</p><details class="toggle" ><summary class="toggle-button" style="">實體存取 Physical Access</summary><div class="toggle-content"><ul><li><strong>實體存取保護是最後防線</strong>，一但入侵者進入儲存基礎架構，那他們最終可能進行資料竊取、複製或毀損，甚至是修改存取配置已進行遠程存取。</li><li><strong>目標在於入侵實體設備</strong>：入侵資料中心、周邊區域、通訊基礎架構（纜線）、運輸實體物件（主機、磁碟等）。</li><li>進行實體存取的方法可分兩種：</li></ul><ol><li>「顯性存取」：攻擊者假裝成合法人員，進入受保護的實體裝置。</li><li>「尾隨」：攻擊者扮演合法訪客尾隨讓攻擊者進入受保護的實體裝置範圍進行實體存取。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存系統的存取 Access to Storage Operating System</summary><div class="toggle-content"><ul><li>這個攻擊的主要<strong>目標是透過操作「作業系統」來「入侵儲存設備」</strong>。</li><li>可能的威脅：<ul><li>「作業系統」都包含<strong>安全漏洞</strong>，因此應定期更新安全更新和補丁。</li><li>「作業系統」都可能因<strong>配置不檔影響安全性</strong>，攻擊者可以透過多種方法獲取對作業系統的存取，包含：本地登入過程（SSH, rshell, telnet）、通過TCP/IP遠程登入、利用系統漏洞。</li></ul></li><li>如果是「超融合基礎架構（HCI）」，攻擊面可能會更大，因為涉及多個主機作業系統。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">管理主機的存取 Access to Management Hosts</summary><div class="toggle-content"><ul><li>大多儲存元件主要透過「商用作業系統的主機」進行「管理或配置」。</li><li>攻擊者會以下方式滲透到管理主機中：</li></ul><ol><li><strong>透過惡意軟體</strong>，滲透到管理主機。</li><li><strong>操作作業系統的漏洞</strong>，進行攻擊。</li></ol><ul><li>可以進行的攻擊行為包含：入侵可執行檔案、讀取快取資料、安裝竊聽裝置讀取記憶體資料、安裝惡意軟體、獲取配置資訊等。</li><li>透過入侵管理主機可以實現的相關風險包含：資料損壞、資料丟失與竄改、備份破壞、竄改日誌和審計等，因此總結來說，<strong>入侵管理主機造成的損害可能是無限的</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">管理 API、管理軟體和帶內管理 Management APIs、 Management Software、 and In-Band Management</summary><div class="toggle-content"><ul><li>通常「儲存基礎架構元件」會公開軟體的相關「<strong>管理接口</strong>」像是「使用者介面UI」、「API」或相關管理協議來對相關設備進行管理。</li><li>舉例來說，可能會有「管理接口」包含：訪問協議（SOAP)、REST API等，與外部網路服務進行交互，用於密鑰管理、身份驗證和授權，</li><li>上述所提到的管理接口，接可能產生各種攻擊面，包含：</li></ul><ol><li>帽中管理主機或彖已透過「<strong>管理接口(API)」訪問儲存設備</strong>，就無須滲透管理軟體就可獲訪問權限。</li><li>透過<strong>數據鏈路(Data Link，例如光纖通道)進行Band-Access帶內訪問</strong>，冒充客戶端發送管理命令。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存客戶端 Storage Clients</summary><div class="toggle-content"><ul><li>儲存客戶端通常是「運算元件」或是安裝在運算元件的「應用程式」（<strong>那些會使用儲存協定對資源進行「讀取」</strong>）。</li><li>透過入侵客戶端可能的攻擊手法包含：</li></ul><ol><li>攻擊者可能會<strong>透過客戶端傳送管理命令</strong>對儲存裝置進行危害。</li><li>若客戶端是用來建立備份時，可能因被<strong>入侵而導致未來的備份㔯害</strong>。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存網路 Storage Network</summary><div class="toggle-content"><ul><li>主要是透過<strong>入侵網路元件</strong>（包含host adapter, switches, cables, extendsers），<strong>對資料傳輸路徑的入侵</strong>，可能採取的攻擊行為包含：</li></ul><ol><li><strong>資料</strong>：複製、檢視、重新導向、竊取。</li><li><strong>配置資料</strong>：讀取使用者認證、加密金鑰等。</li><li><strong>網路元件</strong>：透過破壞網路元件，修改有效載荷，對資料損毀或變更與添加。</li><li><strong>實施中間人攻擊MITM</strong>：進行嗅探資料、繞過加密和驗證機制。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">重要個人的計算環境 Compute Environment of Key Individuals</summary><div class="toggle-content"><ul><li>有些「<strong>關鍵用戶</strong>」擁有對「<strong>儲存基礎架構的管理權限</strong>」，例如可以對儲存管理主機進行遠程連線。</li><li><strong>關鍵用戶的電腦環境（例如筆記型電腦、桌機、家用網路等）皆可能被利用作為條版</strong>，以獲取儲存基礎設之的存取權限，對儲存基礎設施造成損害。</li><li>例如透過在孤艦用戶的裝置上安裝惡意軟體，該軟體再安裝鍵盤側錄，攔截登陸憑證。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">電力網絡及其他公用設施 Electrical Network and other Utilities</summary><div class="toggle-content"><ul><li><strong>儲存基礎設施與電力網路相連，因此電力網路可能成為潛在攻擊面</strong>。可能的攻擊包含：<ul><li>突然的電流暴增、閃電：造成的損壞，甚至抹除電磁碟片上的數據。</li><li>透過惡意軟體：（如PowerHammer)透過調節被感染的機器功耗(CPU工作負載)來進行數據外洩。或是透過改變電流流量盜取敏感資訊，例如密碼和加密密鑰。</li><li>線路級別攻擊：透過竊聽被感染計算機的店員電纜擷取惡意軟體外洩的數句。</li><li>非侵入式竊取：透過測量電源電纜上發射的信號，來進行解碼轉換二進位形式進行收集[33]。</li></ul></li><li><strong>其他公用事業、安全和環境控制系統</strong>，可能的攻擊包含：<ul><li>對系統造成風險（例如過熱、洪水、爆炸）</li><li>數據洩漏的風險（例如竊取視頻監控系統以攔截密碼輸入，或屏幕、面板、指示燈的內容，錄製聽覺信號）</li><li>試圖劫持環境系統的內部傳輸能力（例如WiFi、藍牙）以試圖規避空隙隔離和網絡控制。</li></ul></li></ul></div></details><h1 id="統整01：整理威脅與實體攻擊（參考OWASP）">統整01：整理威脅與實體攻擊（參考OWASP）</h1><p>在建立威脅模型之前，我們必須先將威脅中採取的攻擊手法整理得更加清楚，以便於進行威脅模型的建立。</p><p>API安全和資料庫之間有著密切的關聯。<code>OWASP Top 10</code>是由Open Web Application Security Project (OWASP) 發布的最常見的Web應用程式安全風險清單，而在2023年版本中，十大API安全風險被加入其中，反映了API安全在現代應用程式中的重要性。</p><p>另外，<code>NIST SP 800-209</code>提供了有關資料庫安全的指南，特別在<strong>第4.6節</strong>中，提及了與<strong>網絡基礎設施和協議</strong>相關的<code>存取控制建議</code>。這是因為資料庫涉及到數據的存儲、管理和訪問，而網絡基礎設施和協議則是支援數據傳輸和存取的重要組成部分。因此，這邊會參考：<code>OWASP Top 10 2021</code>, <code>OWASP Top 10 2023</code> 進行參考然後 將資料庫可能造成的威脅 與 NIST SP800-209 3.2節中談到真對資料庫的威脅，進行Mapping。</p><h2 id="1-憑證被盜或洩露-Credential-Theft-or-Compromise">1. 憑證被盜或洩露 Credential Theft or Compromise</h2><p>主要防禦方式：</p><ul><li>使⽤安全的加密傳輸協定如 TLS 1.2, TLS 1.3</li><li>使⽤具迭代⽅法之雜湊演算法如 Argon2, scrypt, bcrypt 或 PBKDF2 搭配加鹽來儲存密碼</li><li>以處理、儲存、傳輸⾏為模式分類，執⾏對應的控制措施</li><li>針對包含敏感資料的回應停⽤快取</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.1 憑證被盜或洩露 Credential Theft or Compromise</td><td>NIST SP 800-209 指出，有效的憑證盜用大多「直接取得使用者的密碼，而非猜測」，因此僅僅依靠密碼的長度和複雜性通常不足以保護系統免受攻擊。</td><td>- 章節 4.9 加密 <br> - 章節 4.3 身份驗證與數據訪問控制</td></tr><tr><td>OWASP 2023</td><td>API2:2023 Broken Authentication 無效身分認證</td><td>身份驗證機制若實施不當，能使攻擊者破壞或利用身份驗證權杖，暫時或永久地冒用其他用戶的身份。破壞系統識別用戶端/使用者的能力，會損害 API整體安全。</td><td>- 章節 4.9 加密 <br> - 章節 4.3 身份驗證與數據訪問控制</td></tr></tbody></table><h2 id="2-加密破解-Cracking-Encryption">2. 加密破解 Cracking Encryption</h2><p>主要防禦方式：</p><ul><li>使用強大的加密方法很重要</li><li>同時也要妥善保護加密金鑰。</li><li>積極更換加密金鑰可以成為一種策略，以防止金鑰被破解或不夠強大。</li><li>在金鑰生成方面，金鑰的強度、質量和熵都起著重要作用，且金鑰不應重複使用。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.2 加密破解 Cracking Encryption</td><td>使用 弱的加密算法 和 弱的金鑰生成器 到 服務器端的漏洞、金鑰泄露、基本設計缺陷或漏洞</td><td>- 章節 4.9 Encryption <br> - 要求：EN-SS-R9 - 加密金鑰管理要求 <br> - 要求：EN-SS-R6 - 敏感數據的靜態加密</td></tr><tr><td>OWASP 2021</td><td>A02:2021 加密機制失效 Cryptographic Failures</td><td>此類別通常因資料加密使用較弱的加密算法或弱的金鑰生成器的加密演算法，導致敏感性資料外洩或者系統被破壞。</td><td>- 章節 4.9 Encryption <br> - 要求：EN-SS-R9 - 加密金鑰管理要求 <br> - 要求：EN-SS-R6 - 敏感數據的靜態加密</td></tr></tbody></table><h2 id="3-惡意軟體與勒索軟體的感染-Infection-of-Malware-and-Ransomware">3. 惡意軟體與勒索軟體的感染 Infection of Malware and Ransomware</h2><p>主要防禦方式：</p><ul><li>對於關鍵任務的資訊，災難復原副本應該使用各種反惡意軟體掃描工具進行掃描，以檢測已知的漏洞和異常。</li><li>對於敏感資料，應定期使用防毒工具掃描至少一個過去副本的子集識別是否有被感染的副本。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.3 惡意軟體與勒索軟體的感染 Infection of Malware and Ransomware</td><td>往往攻擊「存儲管理系統」比攻擊「存儲裝置」本身更容易。因此惡意軟體可能因安裝在存儲管理主機上，造成傷害，如竊取憑證、提升特權、資料損壞、損失或更改，以及破壞未來的備份等。</td><td>- 要求 AC-SS-R33 - 使用反惡意軟體掃描工具 <br> - 要求 RA-SS-R11 - 數據副本的網路安全措施 <br> - 要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</td></tr></tbody></table><h2 id="4-後門未修補的漏洞-Backdoors-and-Unpatched-Vulnerabilities">4. 後門未修補的漏洞 Backdoors and Unpatched Vulnerabilities</h2><p>主要防禦方式：</p><ul><li>通常 call home 或 remote access 被用於收集遙測和診斷數據，供製造商分析和解決技術問題，以及進行自動軟件更新。然而，這些功能也可能成為黑客攻擊的目標，因此如果不需要的話應該禁用，如果需要的話則應該限制和控制。</li><li>確保儲存軟體版本更新</li><li>安裝重要的安全更新和修補程式</li><li>制定無法取得修補程式時應採取的緩解計劃</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.4 後門未修補的漏洞 Backdoors and Unpatched Vulnerabilities</td><td>通常是軟體機制或功能，由供應商、個別貢獻者（在罕見情況下，可能是國家或惡意行為者）故意創建，由於門後具有潛在的危害性，它們並不在官方文檔中記錄，只有被限定的一組人才知道其存在。然而，隨著時間的推移，門後的存在可能會被故意或無意間洩露或被公眾發現。</td><td>- 要求：NC-SS-R10 停用未使用的儲存區域網路（SAN）埠 <br> - 章節 4.6 網路設定指引 <br> - 要求：AA-SS-R11 禁用或限制 call home 或 遠端存取 <br> - 要求：CM-SS-R8 軟體更新和修補</td></tr></tbody></table><h2 id="5-特權升級-Privilege-Escalation">5. 特權升級 Privilege Escalation</h2><p>主要防禦方式：</p><ul><li>除公開的資源外，<code>預設為拒絕存取</code></li><li>建⽴<code>存取控制機制</code>，並重複套⽤</li><li>記錄存取控制失效，並設定告警（例如：重覆登⼊失敗）</li><li>對 API 存取進⾏流量限制，降低⾃動攻擊帶來的損害</li><li>具⾝份識別之 Cookie，於<code>登出、超時後被註銷</code></li><li>JWT 使⽤最<code>短存取時間</code>，若⻑時間存取 JWT 建議遵循 OAuth 標準使其失效</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.5 特權升級 Privilege Escalation</td><td>利用軟體漏洞、設計或部署缺陷，或是配置錯誤，以至於獲得對於應用程式或使用者取得受保護資源的訪問權限。</td><td>- 章節 4.3 身份驗證與數據訪問控制 <br> - 要求：AC-SS-R26 - 默認分區的權限</td></tr><tr><td>OWASP 2023</td><td>API3:2023 - Broken Object Property Level Authorization 物件屬性級別授權失效</td><td>物件屬性級別的授權驗證缺失或不當導致資訊外洩或被未授權者篡改。</td><td>同上</td></tr><tr><td>OWASP 2023</td><td>API5:2023 - Broken Function Level Authorization 無效功能權限控管</td><td>複雜的存取控制策略涉及不同的層級、組態和角色，並且在管理和常規功能之間沒有明確的分離，這可能讓攻擊者將APIf請求發送至不應該可存取的端點，且端點沒有設置存取控制所導致授權漏洞。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A01:2021  Broken Access Control 權限控制失效</td><td>控制措施失效會導致未經授權的資訊洩露、修改、毀損，或執⾏超出原權限的業務功能。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A07:2021-Identification and Authentication Failures 認證及驗證機制失效</td><td>以前被稱為Broken Authentication，常見的可能帳號登入登出的設計機制不完善，因此標準化的架構有協助降低次風險發生機率。</td><td>同上</td></tr></tbody></table><h2 id="6-人為錯誤與故意配置失誤-Human-Error-and-Deliberate-Misconfiguration">6. 人為錯誤與故意配置失誤 Human Error and Deliberate Misconfiguration</h2><p>主要防禦方式：</p><ul><li>⾃動化的流程，可以部署及<code>確認環境中各類的安全設定</code></li><li>開發及營運環境，都須有<code>⼀致相同的設定</code>，並且使⽤不同的認證資訊</li><li>伺服器的功能最⼩化、區域化</li><li>依據相關更新，來執⾏安全審視及更動 (請參照 A06:2021-危險或過舊的元件)</li><li>使⽤安全表頭</li><li>當生產數據損壞或丟失時，組織應該能夠通過複製或備份的數據副本來恢復數據，應確保數據資產及其恢復副本之間具有足夠的隔離。</li><li>確保在業務中斷、災難恢復事件或資安攻擊後，能夠成功地復原。</li><li>維護全面且即時的配置管理清單，管理變更，以及確保配置持續符合組織的安全基線和目前業界最佳實踐，同時確保其不受已知風險的影響。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.6 人為錯誤與故意配置失誤 Human Error and Deliberate Misconfiguration</td><td>因使用者進行技術上支援的儲存配置更改，導致無法接受的風險。</td><td>- 章節 4.7 隔離 <br> - 章節 4.8 恢復保證 <br> - 章節 4.11 配置管理</td></tr><tr><td>OWASP 2023</td><td>API4:2023 - Unrestricted Resource Consumption 不受限的資源消耗</td><td>API常設計用來供查詢回傳資料，因此API會請求需要的網路頻寬、CPU、記憶體和儲存等資源。其他資源，如電子郵件/SMS/電話或生物識別驗證，利用API整合由服務提供者提供，並按請求付費。成功的攻擊者可能利用這項風險，造成導致拒絕服務或增加營運成本。</td><td>同上</td></tr><tr><td>OWASP 2023</td><td>API8:2023 - Security Misconfiguration 安全組態錯誤</td><td>API和支援系統通常包含複雜的配置，主要讓API更具彈性及客製化。軟體和DevOps工程師可能會忽視這些配置，或在配置方面未遵循安全最佳實踐，因而打開攻擊大門。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A05:2021- 安全配置錯誤 Security Misconfiguration</td><td>在系統正式環境開了不必要功能、服務、Port，導致有安全風險，XML外部實體攻擊(XXE)目前也被歸類於此類。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A08:2021 Software and Data Integrity Failures 軟體及資料完整性失效</td><td>不安全的持續性整合/部署(CI/CD)流程、使⽤缺乏充⾜完整性驗證的⾃動更新。</td><td>同上</td></tr></tbody></table><h2 id="7-實體媒體的物理偷竊-Physical-Theft-of-Storage-Media">7. 實體媒體的物理偷竊 Physical Theft of Storage Media</h2><p>主要防禦方式：</p><ul><li>網路攻擊恢復的備份應該儲存在離線的地方，而不是和生產數據存放在同一地點。</li><li>這樣做可以確保即使攻擊者物理上進入生產地點，或者成功侵入物理位置，也無法訪問或破壞網路攻擊恢復的備份。</li><li>實體安全是確保任何資訊科技「基礎建設安全」的「基本要素」。很多時候「儲存基礎建設的實體安全」要求與「其他基礎建設元素」（例如電腦和網路設備）相同（例如設施安全、監控、運輸等）。<ul><li>基礎建設元素可以參考的相關標準包含： NIST SP 800-53, Rev5 NIST SP 800-171 。</li><li>有關媒體處置和銷毀可以參考：ISO 27040, NIST SP 800-88 有更近一步的討論。</li></ul></li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.7 實體媒體的物理偷竊 Physical Theft of Storage Media</td><td>所有的數據最終都儲存在一個或多個實體媒體上，而這些媒體容易受到偷竊的威脅。無論是在線或離線，都可能被從其指定的（固定）位置上移除，或者在實體運輸過程中被竊取（例如，正在運輸用於備份的媒體進行歸檔，或者作為數據中心遷移項目的一部分而運送存儲設備。</td><td>章節 4.1 實體儲存安全</td></tr></tbody></table><h2 id="8-網路竊聽資料-Network-Eavesdropping">8. 網路竊聽資料 Network Eavesdropping</h2><p>主要防禦方式：</p><ul><li>可以參考 NIST SP 800-209 章節 4.6 網路設定指引，該節主要涵蓋的網絡基礎設施（例如交換機、端口、HBA 和 NIC 配置、分區指南等）和協議。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.8 網路竊聽資料 Network Eavesdropping</td><td>資料在傳輸時可能會被攔截。傳輸可以涵蓋許多組件：網路卡（有線或無線）、傳輸電纜（傳輸電力或光線）、中繼器、交換器、路由器等。這些組件中的任何一個都可能受到破壞，涉及對傳輸的資料、元數據或控制流量進行插入、刪除或修改。</td><td>章節 4.6 網路設定指引</td></tr></tbody></table><h2 id="9-不安全的映像、軟體和韌體-Insecure-Images-Software-and-Firmware">9. 不安全的映像、軟體和韌體 Insecure Images, Software and Firmware</h2><p>從NIST SP 800-209中，較少有針對應用程式的相關安全建議，但是很多時候，資料的外洩也是因為應用程式的不安全所導致，但是裡面較少談論到如何針對應用程式AP與數據之間的安全性。</p><p>在標準中與應用程式相關的安全建議主要有以下：</p><ul><li>要求 4.2.1 資料備份、恢復和儲存<ul><li>提到資料備份、恢復和儲存方面，應考慮應用程式和業務流程層面的資料完整性</li><li>嚴格要求還原速度的應用程式可用性</li></ul></li><li>要求 NC-SS-R3 - 使用混合方法進行 zoning<ul><li>基於主機的分區機制，主機上的應用程式可以存取和看到可存取的設被或儲存資源有哪些。</li></ul></li><li>要求：RA-SS-R9 - 分離數據與應用程式的還原<ul><li>還原數據時避免恢復受感染的代碼或軟體，應該將數據與應用程式進行分離。</li></ul></li><li>章節 4.3 身份驗證與數據訪問控制<ul><li>應限制應用程式的特權訪問，降低了存儲系統受到攻擊的風險。</li></ul></li></ul><p>而不安全的映像或軟體及韌體方面則是參考以下建議：</p><ul><li>要求 AC-SS-R33 - 使用反惡意軟體掃描工具</li><li>要求 RA-SS-R11 - 數據副本的網路安全措施</li><li>要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</li></ul><table><thead><tr><th>威脅來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>應用程式（客戶端）</td><td>API1:2023 - Broken Object Level Authorization 不安全的物件授權</td><td>API 多半以公開方式處理物件識別，因此產生與物件存取控制相關的大範圍受攻擊面。OWASP建議物件授權應考慮在每項功能設計中，以防未授權的資訊洩露、資料被竄改或破壞。</td><td>- 要求 4.2.1 資料備份、恢復和儲存 <br> - 要求 NC-SS-R3 - 使用混合方法進行 zoning  <br> - 要求：RA-SS-R9 - 分離數據與應用程式的還原 <br> - 章節 4.3 身份驗證與數據訪問控制</td></tr><tr><td>應用程式（客戶端）</td><td>API6:2023 - Unrestricted Access to Sensitive Business Flows 不受限存取敏感商業流程</td><td>因應用程式流程上的問題所導致的威脅，受此影響的API可能是因為自動化流程過度使用所導致。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>API7:2023 - Server Side Request Forgery 伺服器端請求偽造</td><td>當API在未驗證使用者提供的 URI 的情況下獲取遠端資源時，可能會出現伺服器端請求偽造 (SSRF) 缺陷。這使攻擊者能夠強制應用程式將精心設計的請求發送到意想不到的目的地，即使受到防火牆或 VPN 的保護。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>API9:2023 - Improper Inventory Management 庫存管理不當</td><td>API通常比傳統Web應用程式暴露更多的端點，因此正確和更新文檔非常重要。對主機和API版本進行適當的管理也很重要，以減少如廢棄的API版本和暴露的測試端點等維護問題。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>A03:2021 Injection 注入式攻擊</td><td>XSS 攻擊、SQL Injection、Command Injection接屬於此類。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>A04:2021 Insecure Design</td><td>在設計系統及功能時，設計不完全導致產生的安全問題。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>A10:2021 SSRF 伺服端請求偽造</td><td>當網站伺服器取得遠端資源，卻未驗證由使⽤者提供的網址，此時就會發⽣偽造伺服端請求，即便有防⽕牆、VPN 或其他網路 ACL 保護的情況下，仍得以達成攻擊。雲端服務和其結構的複雜性，偽造伺服端請求的嚴重性將會愈來愈嚴峻。</td><td>同上</td></tr><tr><td>映像、軟體和韌體</td><td>3.3.9 不安全的映像、軟體和韌體 Insecure Images, Software and Firmware</td><td>可能試圖干擾儲存設備的軟體分發、更新或安裝過程，以引入不正確、過時或惡意修改的程式碼。軟體更新過程的每個環節都可能成為引入被篡改軟體的目標。包含：發行者（例如供應商、第三方、開源社區）、傳遞方法（例如傳輸或下載、安裝媒體的運送、供應商員工的檔案複製）、個別組織保存的本地副本（例如代理伺服器、內部檔案伺服器）等。</td><td>- 要求 AC-SS-R33 - 使用反惡意軟體掃描工具 <br> - 要求 RA-SS-R11 - 數據副本的網路安全措施 <br> - 要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</td></tr><tr><td>第三方套件</td><td>API10:2023 Unsafe Consumption of APIs API的不安全使用</td><td>開發人員一般會更信任來自thrid-party API的資料，因此對thrid-party API採取較弱的安全標準。而攻擊者往往會優先攻擊Thrid-Party服務，而不是直接嘗試破壞目標API。</td><td>- 要求 AC-SS-R33 - 使用反惡意軟體掃描工具 <br> - 要求 RA-SS-R11 - 數據副本的網路安全措施 <br> - 要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</td></tr><tr><td>第三方套件</td><td>A06:2021 Vulnerable and Outdated Components 危險或過舊的元件</td><td>在系統開發使用有已知弱點的元件(作業系統、軟體、套件、函示庫、框架)。</td><td>同上</td></tr><tr><td>第三方套件</td><td>A08:2021 Software and Data Integrity Failures 軟體及資料完整性失效</td><td>反序列化攻擊及第三⽅套件信任問題是此項⽬中之重點，這其中包含程式碼或基礎架構未能保護軟體及資料之完整性、不安全的反序列化、 使⽤不受信任來源之套件、函式庫、模組等。</td><td>同上</td></tr></tbody></table><h2 id="10-資安記錄及監控失效-Security-Logging-and-Monitoring-Failures">10. 資安記錄及監控失效 Security Logging and Monitoring Failures</h2><p>因為 NIST SP 800-209沒有針對資安紀錄有獨立列出威脅，然而在OWASP Top 10 2021的A09，有提及資安紀錄及監控失效的相關威脅，同時 NIST SP 800-209 第四章節中也有提及，針對資安紀錄及監控失效的重要性，而建議採取的相關措施，因此本節在此新添加一威脅面向。</p><table><thead><tr><th>相關威脅</th><th>說明</th><th>防禦方式</th></tr></thead><tbody><tr><td>AA09:2021 資安記錄及監控失效 Security Logging and Monitoring Failures</td><td>此類故障可能會直接影響可見性、事件警報和取證。</td><td>章節 4.4 (AL) 審計日誌</td></tr></tbody></table><h1 id="統整02：設計威脅模型">統整02：設計威脅模型</h1><p>以下威脅模型是<strong>參考NIST SP 800-209 和 OWASP Top 10的常見威脅</strong>，所整理出來的威脅模型。裡面的環境主要簡單描述在資料基礎架構中，系統邊界、資料傳輸、備份監控等，可能會面臨的威脅。可以根據以下威脅，於統整01中的威脅參考相關的威脅描述與相關的安全建議。</p><p><img src="https://i.imgur.com/HOvKOAN.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Database </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> 碩士論文 </tag>
            
            <tag> Cloud Storage </tag>
            
            <tag> Security </tag>
            
            <tag> NIST SP 800-209 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何介入 Connection Pool？</title>
      <link href="/posts/interupt-connection-pool/"/>
      <url>/posts/interupt-connection-pool/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://wearecommunity.io/communities/india-java-user-group/articles/2344">Hikari Connection Pooling with Spring Boot</a></li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html">AWS RDS Proxy</a></li><li><a href="https://github.com/brettwooldridge/HikariCP">Hikrai-Source Code</a></li><li><a href="https://www.ithome.com.tw/news/138554">AWS推出能提升關聯式資料庫應用可擴展性的代理服務</a></li><li><a href="https://blog.csdn.net/fly_duck/article/details/109755842?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109755842-blog-124268396.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109755842-blog-124268396.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=2">Hikrari配置設定</a></li><li><a href="https://blog.csdn.net/wangmx1993328/article/details/81865153?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=SpringBoot%20Hikari%20%E8%87%AA%E5%AE%9A%E7%BE%A9datasourc&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81865153.nonecase&amp;spm=1018.2226.3001.4187">注入是用於監控的Druid dataSource</a></li><li><a href="https://blog.51cto.com/boytnt/5794967">如何指定自己extends Hirkari的DataSource</a></li><li><a href="https://www.modb.pro/db/59110">如何构建实用的RDS Proxy? (一)</a>:有稍微提到怎麼使用Golang實作一個RDS Proxy</li><li><a href="https://github.com/ShannonHung/kingshard">kingshard</a>:一個開源的Mysql Proxy但是已經沒在維護了，是用GO寫的</li><li><a href="https://dev.mysql.com/doc/internals/en/connection-phase.html">MySQL官网连接过程介绍</a>:官方連線協議說明</li><li><a href="https://www.jianshu.com/p/af1c5406c737">mysql握手协议抓包</a>: 有大概說明mysql的協議抓包內容</li><li><a href="https://ithelp.ithome.com.tw/articles/10226783">30-25之資料庫層的擴展 - 讀寫分離架構</a>:資料庫的讀寫分離說明</li></ul><h1 id="前言">前言</h1><p>可以參考我的論文方向，是如何在資料庫中滿足零信任要求，<strong>零信任機制其實核心說白了就是存取控制機制</strong>，在Authentication驗證這個人是誰之時，取得所有相關的上下文，甚至是風險，經過多方考量後，最後做Authorization授權。那既然我們的目的在於，如何在資料庫中滿足零信任要求…</p><blockquote><p>就要去探討到，做驗證和授權的地方在資料庫的哪裡？非Connection莫屬了。<br>但是到底有哪些方式可以介入Connection呢？</p></blockquote><ol><li><p><strong>透過第三方介入connection Pool</strong></p><ul><li>講到驗證和授權，就會想到建立連線時，我們通常會提供driver, username, password, url來建立連線，而<strong>建立連線時最常提到的是Connection Pool，其實說白了就是一個application和datasource建立連線時的中間層，這個中間層可以做很多事情，像是連線池、讀寫分離、快取查詢結果等等</strong>。而我們就是要在這個中間層做驗證和授權。</li><li>簡單介入Connection Pool的方式，像可以改寫一些應用程式的第三方套件，像是Spring Boot使用的HikariDataSource</li></ul></li><li><p><strong>使用Database Proxy</strong></p><ul><li>我第一次看到這個詞是在看Hikari的Source Code時，發現有Proxy的連線設定。後來上網一查，立馬跳出來的就是AWS RDS Proxy。AWS RDS Proxy全名稱Relation Database。</li><li>透過Database Proxy也可以做到驗證和授權，簡單來說他就是介於多個應用程式跟資料庫的中間層。</li><li>與Connection Pool類似都是作為應用程式中間層的存在，但是應用面比較廣，因為他不是只有針對單一應用程式，而是作為所有應用程式的連線資料庫的入口。</li></ul></li></ol><h1 id="使用Database-Proxy">使用Database Proxy</h1><h2 id="AWS-RDS-Proxy">AWS RDS Proxy</h2><p><img src="https://i.imgur.com/N44uCbX.png" alt=""></p><p>AWS RDS Proxy是一個中間層的服務，可以讓應用程式與資料庫之間的連線更加穩定，並且提供了一些功能，像是連線池、讀寫分離、快取查詢結果等等。AWS有許多應用程式，像是AWS Lambda、Fargate、Amazon ECS或EKS，等多個<strong>應用程式中會有大量且快速地開啟或關閉，與資料庫伺服器間的連結的需求，而這樣的操作容易耗盡資料庫的記憶體和運算資源。</strong></p><blockquote><p>連接池：減輕建立新連接時，對資料庫記憶體和運算資源造成的影響</p></blockquote><p>因此才有了RDS Proxy，Amazon <strong>RDS Proxy的執行個體會維護與RDS資料庫執行個體間建立的連接池</strong>，減輕建立新連接時，對資料庫記憶體和運算資源造成的影響，並且在應用程式間共用這些連結，進而提高資料庫的效率以及應用程式的可擴展性。</p><blockquote><p>連線中斷：避免因為資料庫服務中斷，造成應用程式可用性問題</p></blockquote><p>而且RDS Proxy能夠在維持現有連接的狀態下，連接新的資料庫執行個體，因此可以最大程度<strong>減少因為資料庫服務中斷，所造成的應用程式可用性問題</strong>，當<strong>資料庫故障時，RDS Proxy會直接將請求路由到新的資料庫執行個體</strong>，這樣可以使得故障轉移時間減少66％。</p><blockquote><p>身份驗證：避免把權限寫死在程式碼中</p></blockquote><p>RDS Proxy讓使用者可強制資料庫存取使用IAM身份驗證，因此將能<strong>避免資料庫憑證被寫死在程式碼中的安全性風險</strong>，多增加了一道的安全性控制，而且藉由RDS Proxy，使用者還能以AWS Secrets Manager集中管理資料庫憑證。</p><h3 id="操作說明">操作說明</h3><p>其實做Database Proxy的好處就是，<strong>可以在不同應用程式中共享那個Connection來加快速度，在微服務的世界，不同應用存取一個database的需求很大</strong>，但是如果每個應用都要自己建立一個Connection，那麼就會造成資源的浪費，而且也不好管理。因此我們可以透過RDS Proxy來管理這些Connection，讓不同的應用程式共享同一個Connection。</p><p>可以參考以下影片了解Proxy怎麼建立和設定：</p><ul><li><a href="https://youtu.be/ZQOqmMn_8jw">https://youtu.be/ZQOqmMn_8jw</a></li></ul><h2 id="kingshard">kingshard</h2><p>kingshard是一個由Go開發高性能MySQL Proxy項目，可以做到以下幾點，也是可以作為零信任架構的可用功能：</p><ol><li><strong>SQL的讀寫分離</strong>：讀寫分離最簡單的就是所有寫入的都寫入到一台服務，讀取時讀取一台服務。通常是主從式master-slave架構，由master負責寫的服務，會與 slave 進行資料同步。slave主要用來讀的服務。</li><li><strong>透明的Connection Pool，不需要每次做連線</strong>: 透明的連線池，就是在應用程式中不需要額外的程式碼，就可以使用連線池的功能。</li><li><strong>SQL的日誌輸出</strong>：幾本上可以收集這些日誌，近一步做分析利用。</li><li><strong>SQL的黑白名單機制</strong>：支持客戶端IP訪問白名單機制，只有白名單中的IP才能訪問kingshard（支持IP 段）。甚至可以偵測SQL的內容，當偵測到有危險的SQL時，可以直接將該SQL拒絕執行。</li></ol><h3 id="架構說明">架構說明</h3><p><img src="https://i.imgur.com/sqZ62gq.png" alt=""><br>kingshard的整體工作流程如下所述：</p><ol><li>讀取<strong>配置文件並啟動</strong></li><li>在配置文件中<strong>設置的監聽端口監聽客戶端請求</strong></li><li><strong>收到客戶端連接請求後，啟動一個goroutine單獨處理該請求</strong>。</li><li>首選進行登錄驗證，<strong>驗證過程完全兼容MySQL認證協議</strong>，由於用戶名和密碼在配置文件中已經設置好，所以可以利用該信息驗證連接請求是否合法。</li><li>當<strong>用戶名和密碼都正確時，轉入下面的步驟</strong>，否則返回出錯信息給客戶端。</li><li>認證通過後，<strong>客戶端發送SQL語句</strong>。<ol><li>kingshard對<strong>客戶端發送過來的SQL語句，進行詞法和語義分析</strong>。識別出SQL的類型和生成SQL的路由計劃。如果有必要還會改寫SQL。然後<strong>轉發到相應的DB</strong>。</li><li>也有可能不做詞法和語義分析直接轉發到相應的後端DB。如果轉發SQL是分錶且跨多個DB，則每個DB對應啟動一個goroutine發送SQL和接收該DB返回的結果。</li></ol></li><li><strong>接收並合併結果</strong>，然後轉發給客戶端。</li></ol><h1 id="改寫-Hikari-Datasource">改寫 Hikari Datasource</h1><p>除了Proxy之外，如果是<strong>針對特定應用程式，希望連線可以共享，而非每次建立新的Connection則可以考慮改寫Hikari Datasource</strong>。但是這個就不像Proxy那樣方便並且使用廣泛。就像前一篇<a href="/posts/about-jdbc-connection-pool.html">Day09 - 淺入淺出 JDBC, Connection Pool</a>所提到的，有很多第三方套件實作，其中spring boot預設採用Hikari，因為他是效能之冠。但是如果我們希望在<code>getConnection()</code>的時候可以先驗證一下Application的身份，或是在<code>prepareStatement()</code>的時候可以先驗證一下Application的權限，免不了要自己重新定義裡面的實作方法。</p><p>具體來說，可以怎麼重新撰寫自己的實作呢？</p><ul><li>這個連結還算不錯：<a href="https://blog.51cto.com/boytnt/5794967">如何指定自己extends Hirkari的DataSource</a></li></ul><blockquote><p>繼承HikariDataSource</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHikariDataSource</span> <span class="keyword">extends</span> <span class="title class_">HikariDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 這裡可以做一些設定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在config中設定自己的class</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.type=com.test.dao.MyHikariDataSource</span>    <span class="comment">#指定自己的class</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/db</span></span><br><span class="line"><span class="string">spring.datasource.username=USERNAME</span></span><br><span class="line"><span class="string">spring.datasource.password=PASSWORD</span>    </span><br></pre></td></tr></table></figure><h1 id="我的下一步">我的下一步</h1><p>目前比較能知道的是，透過Proxy能夠介入Connection Pool的應用面向更廣，所以接下來幾天要先能夠深入了解：</p><ul><li>[ ] 目前保護資料庫的方式與實施ZTA於Database的必要與</li><li>[ ] 雲端不同proxy的功能比較，安全性的比較功能。<ul><li>[ ] 比較市面上目前有的solution，裡面缺了什麼樣的功能</li><li>[ ] cloudfare zta tunnel 目的是建立安全的database connection, cloudfare 是讓遠端工作者可以安全連線</li></ul></li><li>[ ] 清楚你做出內容的貢獻可以是什麼？</li></ul><p>在了解可以介入Connection Pool的方式後，決定要採用Proxy的方式進行研析，但是這就意味著要深入了解Mysql的連線協議，以及Proxy的實作方式。這個部分我會在下一篇文章中進行介紹。目前規劃如下：</p><ul><li>[ ] 深入了解Mysql協議</li><li>[ ] 學習 Go 語言</li><li>[ ] 深入了解Proxy的實作方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Connection Pool </tag>
            
            <tag> 碩士論文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 JDBC, Connection Pool</title>
      <link href="/posts/about-jdbc-connection-pool/"/>
      <url>/posts/about-jdbc-connection-pool/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://www.1ju.org/jdbc/jdbc-introduction">JDBC是什麼？</a></li><li><a href="https://medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50">(14) 深入 JDBC、Connection Pool，並導入 H2 DB</a></li><li><a href="https://medium.com/@sawomirkowalski/design-patterns-object-pool-e8269fd45e10">Design Pattern - Object Pool</a></li><li><a href="https://iter01.com/16624.html">深入瞭解資料庫連線池的實現及原理</a></li><li><a href="https://www.linqz.io/2019/03/why-to-use-hikari-connection-pool.html">為什麼hikari這麼快的原因</a></li><li><a href="https://blog.csdn.net/assember/article/details/121976290">spring-boot-starter-jdbc 和 spring-boot-starter-data-jdbc 的区别</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#data-properties">Spring Boot- Data properties</a></li></ul><h1 id="前言">前言</h1><p>JDBC的全名是Java DataBase Connectivity，主要適用於<strong>Java程式語言 和 資料庫 之間連接的API標準</strong>，你也可以說他是Library，這裡的API到底指哪些事情呢？</p><ol><li>連接到資料庫</li><li>創建, 執行 SQL</li></ol><h1 id="JDBC-架構">JDBC 架構</h1><p><img src="https://i.imgur.com/D1mM5vk.png" alt=""><br>JDBC API提供以下接口和類:</p><ul><li><code> Driver Manager</code>: 管理資料庫驅動程式的列表，可以將Java Application的連接請求，與資料庫驅動程式進行配對，以<strong>建立資料庫的連接</strong>。</li><li><code>Driver</code>: <strong>處理與資料庫的通信</strong>，很少會直接與Driver溝通，而是會透過Driver Manager來管理這個對象。</li><li><code>Connection</code>: <strong>連繫數據庫的方法</strong>。</li><li><code>Statement</code>: 用於<strong>執行SQL語句</strong>，並返回結果。</li><li><code>ResultSet</code>: 用於保存從數據庫中<strong>獲取的結果集</strong>。</li><li><code>SQLException</code>: 此類處理數據庫應用程序中<strong>發生的任何錯誤</strong>。</li></ul><blockquote><p>可以透過以下範例，來了解 JDBC API接口的用途：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參考 https://medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50</span></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLDatabaseConnection</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect to your database.</span></span><br><span class="line">  <span class="comment">// Replace server name, username, and password with your credentials</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 載入 SQLServer 的 JDBC Driver</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 編輯連線協定，</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">connectionUrl</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;jdbc:sqlserver://yourserver.database.windows.net:1433;&quot;</span></span><br><span class="line">        + <span class="string">&quot;database=AdventureWorks;&quot;</span></span><br><span class="line">        + <span class="string">&quot;user=yourusername@yourserver;&quot;</span></span><br><span class="line">        + <span class="string">&quot;password=yourpassword;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用來接住回傳結果</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">      <span class="comment">// 3. 建立連線</span></span><br><span class="line">      <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(connectionUrl);</span><br><span class="line">      <span class="comment">// 4. 建立Statement物件供提交SQL命令使用</span></span><br><span class="line">      <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create and execute a SELECT SQL statement.</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">selectSql</span> <span class="operator">=</span> <span class="string">&quot;SELECT TOP 10 Title, FirstName, LastName from SalesLT.Customer&quot;</span>;</span><br><span class="line">      <span class="comment">// 5. 提交SQL命令，並取得結果</span></span><br><span class="line">      resultSet = statement.executeQuery(selectSql);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Print results from select statement</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        System.out.println(resultSet.getString(<span class="number">2</span>) + <span class="string">&quot; &quot;</span> + resultSet.getString(<span class="number">3</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 結束工作</span></span><br><span class="line">      <span class="comment">// 6. 釋放資源，關閉Connection連線以及Statement</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDBC-連線">JDBC 連線</h1><p>通常要進行資料庫連線，需要以下步驟：</p><ol><li><strong>設定Driver</strong>: 載入 SQLServer 的 JDBC Driver</li><li><strong>建立連線</strong>: (需要呼叫 DriverManager.getConnection())，開啟 TCP socket</li><li><strong>提交SQL</strong>: 建立 Statement ，並提交 SQL 命令列</li><li><strong>關閉連線</strong>: 關閉 TCP socket</li></ol><p>然而每一次需要與資料庫進行溝通時，都要這樣開開關關，對於系統來說就會造成許多不必要的負擔。</p><div class="note info flat"><p>如果我們可以於每次連線時，將那些一直重複的動作提取出來，那麼就可以減少對系統的負擔，並且加快程式的執行效能。<strong>這就是我們接下來要談的Connection Pool</strong>。</p></div><h2 id="Connection-Pool">Connection Pool</h2><p>Connection Pool是使用「Object Pool Pattern」的設計模式來實現的。先讓我們來一段wiki的說明吧！</p><blockquote><p>物件池（英語：object pool pattern）是一種設計模式。<strong>一個物件池包含一組已經初始化過且可以使用的物件</strong>，而可以在有需求時創建和銷毀物件。池的用戶可以從池子中取得物件，對其進行操作處理，並在不需要時歸還給池子而非直接銷毀它。這是一種特殊的工廠物件。</p><footer><strong>wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F</a></cite></footer></blockquote><p>簡單來說，就是將一些常用的物件，事先建立好，並且放在一個池子裡面，當有需要時，就可以直接從池子裡面取出物件，而不需要每次都重新建立物件。<strong>使用物件池可以獲得顯著的效能提升。從池子中取得物件的時間是可預測的，但新建一個實例所需的時間是不確定。</strong></p><p>下圖顯示了客戶端如何使用池中的連接來連接到數據源。主要工作是：</p><ol><li>管理可用的connection</li><li>分配connection</li><li>關閉connection<br><img src="https://i.imgur.com/5NFJcwZ.png" alt=""></li></ol><p>那我們先來看UML圖吧！</p><ul><li><code>Object Pool Class</code>: 是Singleton，因此有一個private的constructor，並且有一個static的getInstance()方法，用來取得Object Pool的實例。</li><li><code>acquireReusable()</code>: 用來取得Object Pool中的物件，如果沒有物件可以取得，則會建立新的物件。</li><li><code>releaseReusable()</code>: 用來從client手中釋放Object物件，並且把該object拉回可用對象(avaliable)。</li><li><code>setMaxPoolSize()</code>: 用來設定Object Pool的最大容量。</li></ul><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram    class client    class ResuablePool{        - reusable        +BigDecimal balance        +static getInstance() ReusablePool        +acquireReusable() Reusable        +releaseReusable(Reusable reusable)        +setMaxPoolSize(int maxPoolSize)    }    client --&gt; ResuablePool : ResusablePool.getInstance().acquareReusable()  </pre></div><h2 id="JDBC-Connection-Pool-Example">JDBC Connection Pool Example</h2><p>一個簡單的 JDBC Connection Pool 可以參考<a href="https://github.com/MicrosoftDocs/azure-docs.zh-tw/blob/master/articles/mysql/sample-scripts-java-connection-pooling.md">Azure的做法</a>，你可以在裡面看到一個 Connection Pool 是怎麼實做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLConnectionPool</span> &#123;</span><br><span class="line">    <span class="comment">// 連線用的必要資訊</span></span><br><span class="line">    <span class="keyword">private</span> String databaseUrl;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// pool 的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 目前連線的數量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SQL_VERIFYCONN</span> <span class="operator">=</span> <span class="string">&quot;select 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前可用的Connection</span></span><br><span class="line">    Stack&lt;Connection&gt; freePool = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 目前正在使用的Connection</span></span><br><span class="line">    Set&lt;Connection&gt; occupiedPool = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor: 創建一個Connection Pool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseUrl</span></span><br><span class="line"><span class="comment">     *            The connection url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     *            user name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     *            password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize</span></span><br><span class="line"><span class="comment">     *            max size of the connection pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySQLConnectionPool</span><span class="params">(String databaseUrl, String userName,</span></span><br><span class="line"><span class="params">            String password, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseUrl = databaseUrl;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.maxPoolSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get an available connection</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> An available connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             Fail to get an available connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沒辦法在建立新的連線 (已達到最大連線數)</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The connection pool is full.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回傳freePool中的連線，並且標記該連線為occupied</span></span><br><span class="line">        conn = getConnectionFromPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果conn是空的表示freePool裡面沒有任何object，因此我們需要建立新的連線</span></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            conn = createNewConnectionForPool();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有些database一段時間沒使用會自動斷連線，所以我們可以確認一下從freePool取出的connection是否還有連線著</span></span><br><span class="line">        <span class="comment">// For Azure Database for MySQL, if there is no action on one connection for some</span></span><br><span class="line">        <span class="comment">// time, the connection is lost. By this, make sure the connection is</span></span><br><span class="line">        <span class="comment">// active. Otherwise reconnect it.</span></span><br><span class="line">        conn = makeAvailable(conn);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 這邊注意的是，要使用synchronized才會把singleton的object lock住，確保不會有多個thread同時還回去多個connection</span></span><br><span class="line"><span class="comment">     * client使用完，要還回去Pool中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Return a connection to the pool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     *            The connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             When the connection is returned already or it isn&#x27;t gotten</span></span><br><span class="line"><span class="comment">     *             from the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">returnConnection</span><span class="params">(Connection conn)</span></span><br><span class="line">            <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 如果conn是空的，表示client沒有使用connection，因此不需要回傳</span></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 檢查 conn 是否在 occupiedPool 中，並且可以從 occupiedPool 中移除，如果不是，則拋出 SQLException</span></span><br><span class="line">        <span class="keyword">if</span> (!occupiedPool.remove(conn)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(</span><br><span class="line">                    <span class="string">&quot;The connection is returned already or it isn&#x27;t for this pool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果沒跳Exception則已經從occupied移除，可以放回 freePool 中</span></span><br><span class="line">        freePool.push(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也要使用synchronized，確保資源被lock住，以正確做檢查freePool是否已經塞滿</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Verify if the connection is full.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if the connection is full</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((freePool.size() == <span class="number">0</span>) &amp;&amp; (connNum &gt;= maxPoolSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因為connection必須是singleton才不會無謂的一直建立資源</span></span><br><span class="line"><span class="comment">     * 因此有一個private的constructor，確保只有透過getInstance()才能取得實例</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Create a connection for the pool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new created connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             When fail to create a new connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">createNewConnectionForPool</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> createNewConnection();</span><br><span class="line">        connNum++;</span><br><span class="line">        occupiedPool.add(conn);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 創建連線，必須是private，確保只有透過createNewConnectionForPool()才能取得實例</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Crate a new connection</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new created connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             When fail to create a new connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">createNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        conn = DriverManager.getConnection(databaseUrl, userName, password);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 從freePool中取出一個連線，並且放入occupiedPool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Get a connection from the pool. If there is no free connection, return</span></span><br><span class="line"><span class="comment">     * null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">getConnectionFromPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先reset </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果有空閒的連線，就從freePool中取出，並且放入佔用中的occupiedPool</span></span><br><span class="line">        <span class="keyword">if</span> (freePool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn = freePool.pop();</span><br><span class="line">            occupiedPool.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回傳連線</span></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 檢查連線是否還連線著，如果沒有則重新連線</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Make sure the connection is available now. Otherwise, reconnect it.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     *            The connection for verification.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the available connection.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             Fail to get an available connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">makeAvailable</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 透過下Query來確認連線是否還連線著</span></span><br><span class="line">        <span class="keyword">if</span> (isConnectionAvailable(conn)) &#123;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果發現沒有連線，就把該連線從occupiedPool中移除，並且關閉該連線</span></span><br><span class="line">        occupiedPool.remove(conn);</span><br><span class="line">        connNum--;</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然後重新建立一個新的，並且放入occupiedPool</span></span><br><span class="line">        conn = createNewConnection();</span><br><span class="line">        occupiedPool.add(conn);</span><br><span class="line">        connNum++;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 確認一下目前連線是否還連線著，可以透過下Query來確認</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * By running a sql to verify if the connection is available</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     *            The connection for verification</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if the connection is available for now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isConnectionAvailable</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            st.executeQuery(SQL_VERIFYCONN);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Just an Example</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 建立資源池 </span></span><br><span class="line">        <span class="type">MySQLConnectionPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLConnectionPool</span>(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://mysqlaasdevintic-sha.cloudapp.net:3306/&lt;Your DB name&gt;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&lt;Your user&gt;&quot;</span>, <span class="string">&quot;&lt;Your Password&gt;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取得連線 </span></span><br><span class="line">            conn = pool.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 準備一個Query來執行</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;show tables&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;There are below tables:&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">tblName</span> <span class="operator">=</span> res.getString(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(tblName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 釋放連線</span></span><br><span class="line">                pool.returnConnection(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="關於第三方套件Connection-Pool">關於第三方套件Connection Pool</h1><p>現在我們可以理解 Connection Pool 的運作原理了，其實已經有許多的第三方套件供我們使用，而且這些第三方的 Connection Pool 套件也已經非常成熟，在效能上以及減少重工的基礎上。</p><blockquote><p>會發展出不同的第三方的 Pool 主要原因就是因為效能，因為 JDBC 針對JDBC Driver 的介面有做了規範，因此各家廠商做出來的 Connection Pool 也都會符合 JDBC Driver Interface 的 API，也就是 API 都相同，差別就在於不同第三方套件的內部實做所影響的效能。</p><footer><strong>Albert</strong><cite><a href="https://medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50">medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50</a></cite></footer></blockquote><p>目前最厲害效能最好的第三方Connection Pool是HikariCP，而且它的效能是其他的Connection Pool的兩倍以上。<br>下圖中：</p><ul><li><strong>Connection Cycle 比較連線速度</strong>，表示從 <code>DataSource.getConnection()</code> 到 <code>Connection.close()</code> 結束。Hikari可以在<strong>1毫秒內完成4萬到5萬次的連線</strong>。</li><li><strong>Statement Cycle 比較執行sql速度</strong>，表示 <code>Connection.prepareStatement()</code> 到 <code>Statement.execute()</code>到 <code>Statement.close()</code>。執行sql的速度上，在<strong>1毫秒內可以完成約1萬5000次的cycle</strong>。比較可以跟的上的大概就只有 Tomcat 的 JDBC Connection Pool ，其他的效能也就不值一提了。</li></ul><blockquote><p>想了解為什麼這麼快可以讀這篇：<a href="https://www.linqz.io/2019/03/why-to-use-hikari-connection-pool.html">為什麼hikari這麼快的原因</a></p></blockquote><p><img src="https://i.imgur.com/0d8CJ8e.png" alt=""></p><h1 id="關於Spring-boot使用的第三方套件">關於Spring boot使用的第三方套件</h1><p>前面說明了JDBC與資料庫進行連線的方式，也說明了 Connection Pool 的重要性。而在 Spring Boot 他幫我們整合了一系列最常使用的工具，當然對於 JDBC 或是 Connection Pool 或是 JPA 等等相關的內容也是一併的簡化配置作業。</p><p>因此現在只需要簡單的 Import Dependencies 並加上 Properties 的設定，就可以快速又方便的與資料庫進行連線。我們如果要透過Java的應用程式跟資料庫做溝通，通常一定會import這個套件<code>spring-boot-starter-jdbc</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是現在主要使用 <code>spring-boot-starter-data-jdbc</code>，多了一個data的單字！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring-boot-starter-data-jdbc">spring boot starter (data) jdbc</h2><p>如果我們使用 <code>spring-boot-starter-jdbc</code> 或 <code>spring-boot-starter-data-jpa</code> “starters”，我們會自動獲得對 HikariCP 的依賴關係。 （請參閱下面的快照）<br><img src="https://i.imgur.com/BO5bFfS.png" alt=""></p><p>有沒有data的套件到底差異在哪裡呢？如果你是使用JPA進行開發，那最常用的就是<code>spring-boot-starter-data-jdbc</code>。</p><ul><li><code>spring-boot-starter-jdbc</code>: 這個套件是最基礎的包，如果你只是要使用JDBC的話，那就只需要引入這個套件就可以了。</li><li><code>spring-boot-starter-data-jdbc</code>: 這個套件是在<code>spring-boot-starter-jdbc</code>的基礎上，還提供了<code>curdReporitory</code>的快速開發接口，如果你要使用JPA的話，那就需要引入這個套件。</li></ul><blockquote><p>spring-jdbc (from: <a href="https://blog.csdn.net/assember/article/details/121976290">https://blog.csdn.net/assember/article/details/121976290</a>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunAQuery</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只提供基本的連線</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from mytable&quot;</span>, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject(<span class="string">&quot;select name from mytable&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>spring-data-jdbc 除了基礎的資料庫連接還提供CrudReporitoy</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/08ZhuEH.png" alt=""></p><h2 id="properties設定">properties設定</h2><p>如果你有仔細去看看這個 Starter 的內容，會發現他其實主要包含兩個Dependency：</p><ol><li>spring-JDBC: Spring針對JDBC封裝後的Library，如果使用這個套件必須在Properties(<code>application.yml</code>)設定資料庫的連線資訊。</li><li>HikariCP: Spring Boot將HikariCP做為預設的Connection Pool，並包含在<code>spring-boot-starter-jdbc</code>中。(人家效率太高了)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以參考Spring Boot - Data Properties 的設定方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 如果想指定自己的ConnectionPool應該就要從這裡下手</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">設定ConnectionPool的DataSource</span> <span class="string">(或從classPath中自動檢測)</span> </span><br><span class="line">    <span class="attr">url:</span> <span class="string">設定jdbc連線至資料庫的url</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">設定jdbc連線至資料庫的帳號</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">設定jdbc連線至資料庫的密碼</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">設定JDBC的Driver</span> <span class="string">(或依照url自動檢測)</span></span><br></pre></td></tr></table></figure><h2 id="spring-datasource-type">spring.datasource.type</h2><p>因為導入了<code>spring-boot-starter-data-jdbc</code>，所以我們可以直接使用<code>spring.datasource.type</code>來設定我們要使用的Connection Pool，預設上spring boot會從classpath中自動檢測，如果沒有找到的話就會使用HikariCP。<br>如果你想要知道知道他是如何自動偵測的，或是可以自動偵測哪些 class name，可以參考 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/DataSourceBuilder.java">DataSourceBuilder.java — Source Code</a>，或參考下方程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">DataSource</span>&gt; MappedDataSourceProperties&lt;T&gt; <span class="title function_">lookupPooled</span><span class="params">(ClassLoader classLoader,</span></span><br><span class="line"><span class="params">Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">MappedDataSourceProperties&lt;T&gt; result = <span class="literal">null</span>;</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>,</span><br><span class="line">HikariDataSourceProperties::<span class="keyword">new</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;org.apache.tomcat.jdbc.pool.DataSource&quot;</span>,</span><br><span class="line">TomcatPoolDataSourceProperties::<span class="keyword">new</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>,</span><br><span class="line">MappedDbcp2DataSource::<span class="keyword">new</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;oracle.ucp.jdbc.PoolDataSourceImpl&quot;</span>,</span><br><span class="line">OraclePoolDataSourceProperties::<span class="keyword">new</span>, <span class="string">&quot;oracle.jdbc.OracleConnection&quot;</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>,</span><br><span class="line">ComboPooledDataSourceProperties::<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在這個片段程式碼中，我們可以看到 Spring Boot 會自動偵測如下幾個 Connection Pool，但是預設是HikariDataSource</p><ul><li><code>org.springframework.jdbc.datasource.SimpleDriverDataSource</code></li><li><code>com.zaxxer.hikari.HikariDataSource</code></li><li><code>org.apache.tomcat.jdbc.pool.DataSource</code></li><li><code>oracle.ucp.jdbc.PoolDataSourceImpl</code></li><li><code>oracle.jdbc.OracleConnection</code></li><li>etc.</li></ul><blockquote><p>If you use the spring-boot-starter-jdbc or spring-boot-starter-data-jpa “starters”, you automatically get a dependency to HikariCP.</p><footer><strong>spring-doc</strong><cite><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool">docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool</a></cite></footer></blockquote><div class="note danger flat"><p><code>org.springframework.jdbc.datasource.SimpleDriverDataSource</code> 查看他的<a href="https://mvnrepository.com/artifact/org.springframework/spring-jdbc">API說明文件</a>可以發現上面寫<strong>NOTE: This class is not an actual connection pool; it does not actually pool Connections</strong>表示：這個類別並不是真正的Connection Pool，他並不會真的去做Connection Pool的動作。</p></div>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Connection Pool </tag>
            
            <tag> 碩士論文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh Agent 透過 Wazuh API 來註冊於 Wazuh Server</title>
      <link href="/posts/wazuh-agent-install-api/"/>
      <url>/posts/wazuh-agent-install-api/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://documentation.wazuh.com/current/user-manual/agent-enrollment/via-manager-API/index.html">Enrollment via manager API</a></li></ul><h1 id="前言">前言</h1><p>會想要做這一篇的需求是因為，當有受接管的裝置時，我們<strong>為了讓服務得知請求從哪一個裝置發送的</strong>，所以我們會在每一個<strong>裝置上安裝 Wazuh Agent和自己的用來做裝置綁定的Agent</strong>。裝置綁定的Agent負責在請求內放裝置資訊，並透過數位簽章進行認證，這個裝置綁定的Agent是透過ASP.net去撰寫，而Wazuh Agent則是可以協助我們對裝置的狀態進行監控。</p><div class="note warning flat"><p>我們希望自己製作的Agent自動化的方式來安裝 Wazuh Agent，這時候我們需要透過 Wazuh API 來達成這個需求。然後可以滿足以下要求：</p><ol><li>可以自動註冊</li><li>並且取得agent id</li></ol></div><h1 id="Wazuh-API-Enrollment">Wazuh API Enrollment</h1><blockquote><p>The Wazuh manager API allows users to make an agent enrollment request to the Wazuh manager. This request returns a unique key for the agent, which must be manually imported to the agent.</p><footer><strong>官方原文</strong><cite><a href="https://documentation.wazuh.com/current/user-manual/agent-enrollment/via-manager-API/index.html">documentation.wazuh.com/current/user-manual/agent-enrollment/via-manager-API</a></cite></footer></blockquote><p>簡單來說，如果透過wazuh manager API 來進行註冊，他會<strong>回傳一個唯一的key，這個key必須要手動的匯入到agent裡面</strong>。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant U as User     participant A as Device Agent    participant M as Manager Manager    A-&gt;&gt;+M: API request to enroll    M--&gt;&gt;-A: Return authorization token    A-&gt;&gt;+M: API request with the authorization token    M--&gt;&gt;-A: Return agent key    U-&gt;&gt;A: Import agent key, config the wazuh manager ip.     U-&gt;&gt;A: Restart the agent.  </pre></div><h2 id="0-允許自簽憑證">0. 允許自簽憑證</h2><p>使用管理權限打開 PowerShell。如果管理器 API 通過 HTTPS 運行並且使用自簽名證書，則必須在 PowerShell 中執行以下函數。<strong>請注意，上面的函數僅存在於執行它的 PowerShell 實例中。</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寫function 允許自簽憑證</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ignore-SelfSignedCerts</span></span> &#123;</span><br><span class="line">    <span class="built_in">add-type</span> <span class="string">@&quot;</span></span><br><span class="line"><span class="string">        using System.Net;</span></span><br><span class="line"><span class="string">        using System.Security.Cryptography.X509Certificates;</span></span><br><span class="line"><span class="string">        public class PolicyCert : ICertificatePolicy &#123;</span></span><br><span class="line"><span class="string">            public PolicyCert() &#123;&#125;</span></span><br><span class="line"><span class="string">            public bool CheckValidationResult(</span></span><br><span class="line"><span class="string">                ServicePoint sPoint, X509Certificate cert,</span></span><br><span class="line"><span class="string">                WebRequest wRequest, int certProb) &#123;</span></span><br><span class="line"><span class="string">                return true;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&quot;@</span></span><br><span class="line">    [<span class="type">System.Net.ServicePointManager</span>]::CertificatePolicy = <span class="built_in">new-object</span> PolicyCert</span><br><span class="line">    [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.SecurityProtocolType</span>]::Tls12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫剛剛建立好的function </span></span><br><span class="line">Ignore<span class="literal">-SelfSignedCerts</span></span><br></pre></td></tr></table></figure><h2 id="1-取得auth-token">1. 取得auth token</h2><p>使用裝置管理員打開 powershell ，輸入以下指令，來產生跟 wazuh <strong>進行請求時所需要的 Basic Auth Token</strong>，這邊如果沒有修改wazuh的帳號密碼，預設是 wazuh/wazuh</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># powershell 輸入以下指令</span></span><br><span class="line"><span class="comment">## 建立一個環境變數，用來存放 base64 的帳號密碼</span></span><br><span class="line"><span class="variable">$base64AuthInfo</span>=[<span class="type">Convert</span>]::ToBase64String([<span class="type">Text.Encoding</span>]::ASCII.GetBytes((<span class="string">&quot;&#123;0&#125;:&#123;1&#125;&quot;</span> <span class="operator">-f</span> “&lt;API_username&gt;”, “&lt;API_password&gt;”)))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 透過 Invoke-WebRequest 來取得 Auth Token</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="literal">-Headers</span> <span class="selector-tag">@</span>&#123;Authorization=(<span class="string">&quot;Basic &#123;0&#125;&quot;</span> <span class="operator">-f</span> <span class="variable">$base64AuthInfo</span>)&#125; <span class="literal">-Method</span> POST <span class="literal">-Uri</span> https://&lt;MANAGER_IP&gt;:<span class="number">55000</span>/security/user/authenticate | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 會得到以下回應 response </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;token&quot;</span>: <span class="string">&quot;eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ3YXp1aCIsImF1ZCI6IldhenVoIEFQSSBSRVNUIiwibmJmIjoxNjg4NzAzODY3LCJleHAiOjE2ODg3MDQ3NjcsInN1YiI6IndhenVoIiwicnVuX2FzIjpmYWxzZSwicmJhY19yb2xlcyI6WzFdLCJyYmFjX21vZGUiOiJ3aGl0ZSJ9.ANmFStLa9Og5PVtz1U2birnOb8np8JEg1goG7FrhDBvrXkcPnEqtdZm3clpTrEZP2eHU7EFQbTKtwpaHksxzmq_kAMP9bgDX3wtkUFJObDDIT42oGF8g5Ik4ccGj6-BMAoJjmFR4TDYqd-Nm5D5sM--fbZUrdrG37Nofhb-aDiwPdWOo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面指令的請求curl的版本長這樣</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -u <span class="string">&quot;wazuh:wazuh&quot;</span> https://&lt;wazuh-manager-ip&gt;:55000/security/user/authenticate</span><br></pre></td></tr></table></figure><h2 id="2-取得-agent-id-和-key">2. 取得 agent id 和 key</h2><p>取得 Auth Token 後，我們就可以透過 Auth Token 來<strong>取得 agent-id 跟 key</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把剛剛取得的 token 存到環境變數</span></span><br><span class="line"><span class="variable">$TOKEN</span> = “&lt;token_generated&gt;”</span><br><span class="line"></span><br><span class="line"><span class="comment"># 幫你的 agent Name 命名 （這裡可以自定義）</span></span><br><span class="line"><span class="variable">$AgentName</span> = <span class="selector-tag">@</span>&#123;<span class="string">&quot;name&quot;</span>=<span class="string">&quot;&lt;agent_name&gt;&quot;</span>&#125; | <span class="built_in">ConvertTo-Json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 Invoke-WebRequest 來取得 agent-id 跟 key</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="literal">-Headers</span> <span class="selector-tag">@</span>&#123;Authorization=(<span class="string">&quot;Bearer &#123;0&#125;&quot;</span> <span class="operator">-f</span> <span class="variable">$TOKEN</span>)&#125; <span class="literal">-Method</span> POST <span class="literal">-ContentType</span> <span class="string">&quot;application/json&quot;</span> <span class="literal">-Uri</span> https://&lt;MANAGER_IP&gt;:<span class="number">55000</span>/agents <span class="literal">-Body</span> <span class="variable">$AgentName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 會得到以下回應 response </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;003&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>: <span class="string">&quot;MDAzIHRlc3QtYWdlbnQgYW55IDdmMDUxOTEyNjE2NzJkNTE0Njg5M2ExMjRkMDE4MWYzMTIzZGQ3YzQ1ZjMwZmJlZGU3N2FmYjgxNmNjYjQwZmM=&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面指令的請求curl的版本長這樣(json body的key是name)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Authorization: Bearer eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ3YXp1aCIsImF1ZCI6IldhenVoIEFQSSBSRVNUIiwibmJmIjoxNjg4NzAzODY3LCJleHAiOjE2ODg3MDQ3NjcsInN1YiI6IndhenVoIiwicnVuX2FzIjpmYWxzZSwicmJhY19yb2xlcyI6WzFdLCJyYmFjX21vZGUiOiJ3aGl0ZSJ9.ANmFStLa9Og5PVtz1U2birnOb8np8JEg1goG7FrhDBvrXkcPnEqtdZm3clpTrEZP2eHU7EFQbTKtwpaHksxzmq_kAMP9bgDX3wtkUFJObDDIT42oGF8g5Ik4ccGj6-BMAoJjmFR4TDYqd-Nm5D5sM--fbZUrdrG37Nofhb-aDiwPdWOo&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;test-agent&quot; </span></span><br><span class="line"><span class="string">  &#125;&#x27;</span> \</span><br><span class="line">  https://&lt;wazuh-manager-ip&gt;:55000/agents</span><br></pre></td></tr></table></figure><h2 id="3-編輯-agent-config">3. 編輯 agent config</h2><p>以下步驟可指導如何將密鑰導入 Windows 代理： Wazuh 代理安裝目錄取決於主機的體系結構：</p><ul><li>如果你是 64 位元系統，則設定檔位於 <code>C:\Program Files (x86)\ossec-agent</code></li><li>如果你是 32 位元系統，則設定檔位於 <code>C:\Program Files\ossec-agent</code></li></ul><p>使用裝置管理員打開 CMD 或 PowerShell 作為管理員，並導入金鑰。下面的<strong>執行檔會把Agent的資訊，放進去 client.keys 裡面</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 &amp; 運算子告訴 PowerShell 不要將該指令視為 PowerShell cmdlet 或函式</span></span><br><span class="line"><span class="comment"># 而是執行外部可執行程式或命令。這是為了區分 PowerShell 內部指令和外部指令，以確保正確執行外部程式。</span></span><br><span class="line"><span class="comment"># 把剛剛的 key 帶入並且執行 manage_agents.exe </span></span><br><span class="line">&amp; <span class="string">&quot;C:\Program Files (x86)\ossec-agent\manage_agents.exe&quot;</span> <span class="literal">-i</span> &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># The output should look like this: </span></span><br><span class="line">  Agent information:</span><br><span class="line">      ID:<span class="number">003</span></span><br><span class="line">      Name:<span class="built_in">test-agent</span></span><br><span class="line">      IP Address:any</span><br><span class="line">  Confirm adding it?(y/n): y</span><br><span class="line">  Added.</span><br></pre></td></tr></table></figure><p>編輯 <code>C:\Program Files (x86)\ossec-agent\ossec.conf</code>，並且wazuh manager ip 帶入。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;client&gt;</span><br><span class="line">   &lt;server&gt;</span><br><span class="line">     &lt;address&gt;MANAGER_IP&lt;/address&gt; <span class="comment"># 填入 wazuzh server ip 位置</span></span><br><span class="line">     ...</span><br><span class="line">   &lt;/server&gt;</span><br><span class="line"> &lt;/client&gt;</span><br></pre></td></tr></table></figure><h2 id="4-重啟-agent">4. 重啟 agent</h2><p>重新啟動</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># powershell </span></span><br><span class="line"><span class="built_in">Restart-Service</span> <span class="literal">-Name</span> wazuh</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd </span></span><br><span class="line">net stop wazuh</span><br><span class="line">net <span class="built_in">start</span> wazuh</span><br></pre></td></tr></table></figure><h1 id="Wazuh-PowerShell-Enrollment">Wazuh PowerShell Enrollment</h1><p>可以透過kibana的介面去產指令，或是透過powershell執行以下指令，也可以自動進行註冊，但是你不會知道agent id，除非去讀取 <code>.agent_info</code> 檔案裡面才會填寫 agent id。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分別填入</span></span><br><span class="line"><span class="comment"># wazuh_manager: wazuh manager 的 ip </span></span><br><span class="line"><span class="comment"># WAZUH_AGENT_NAME: agent 註冊的名稱</span></span><br><span class="line"><span class="comment"># WAZUH_AGENT_GROUP: 群組 預設default </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 範例如下</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://packages.wazuh.com/<span class="number">4</span>.x/windows/wazuh<span class="literal">-agent-4</span>.<span class="number">4.4</span><span class="literal">-1</span>.msi <span class="literal">-OutFile</span> <span class="variable">$</span>&#123;env:tmp&#125;\wazuh<span class="literal">-agent</span>.msi; msiexec.exe /i <span class="variable">$</span>&#123;env:tmp&#125;\wazuh<span class="literal">-agent</span>.msi /q WAZUH_MANAGER=<span class="string">&#x27;192.168.2.76&#x27;</span> WAZUH_REGISTRATION_SERVER=<span class="string">&#x27;192.168.2.76&#x27;</span> WAZUH_AGENT_GROUP=<span class="string">&#x27;default&#x27;</span> WAZUH_AGENT_NAME=<span class="string">&#x27;win10-ma&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the agent</span></span><br><span class="line">NET <span class="built_in">START</span> WazuhSvc</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><div class="note info flat"><p>如果你想要取得 agent id 並且儲存 agent id 於自己的服務中，在不同的enrollment要注意以下流程。</p></div><p>如果你想透過 API 並且取得 agentID:</p><ol><li>先取得 auth token</li><li>自定義 name，透過 token 開始註冊，取得 agent id, agent key</li></ol><ul><li><strong>這時候可以取得 agent id</strong></li></ul><ol start="3"><li>把 key 載入本地</li><li>修改 conf 設定 wazuh ip</li><li>重新啟動</li><li><strong>去讀取 <code>.agent_info</code>並且取得agent id</strong></li></ol><p>如果你想透過 shell 註冊：</p><ol><li>執行註冊指令</li><li>重新啟動</li><li><strong>去讀取 <code>.agent_info</code>並且取得agent id</strong></li></ol><h2 id="跟註冊agent的整合">跟註冊agent的整合</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant U as User     participant A as Device Agent    participant D as Device Register Server    participant M as Wazuh Manager    U-&gt;&gt;A: execute device agent     A-&gt;&gt;M: request for Enrollment    M--&gt;&gt;A: response agent id and key     A-&gt;&gt;A: start the wazuh Agent    A-&gt;M: check the agent is active or not     M--&gt;&gt;A: response active    A-&gt;&gt;D: regist device with agent id    D-&gt;&gt;D: save the agent id into database    D--&gt;&gt;A: response success  </pre></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> wazuh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wazuh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxmox - 開 windows vm</title>
      <link href="/posts/proxmox-window-install/"/>
      <url>/posts/proxmox-window-install/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://blog.sakamoto.cat/zai-proxmox-ve-zhong-an-zhuang-windows10-yu-xiang-guan-qu-dong/">在 Proxmox VE 中安裝 Windows10 與相關驅動</a>: 這篇寫得挺清楚，只是有些我不太確定為什麼要選那個設定，因此有多做一些研究。</li></ul><h1 id="前言">前言</h1><p>在執行 wazuh的警告系統實作時，因為想要下載 Fiddler 來攔截 Alert 發送的訊息，查看是否有 Post 成功。<br>又或是想要安裝一台 windows 來當 wazuh</p><h1 id="下載iso檔案">下載iso檔案</h1><ol><li>需要先下載兩個iso</li></ol><ul><li>一個 windows 10 iso</li><li>一個 <a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.196-1/">驅動程式 iso</a><br><img src="https://i.imgur.com/T2r6DRa.png" alt=""></li></ul><h1 id="vm-規格">vm 規格</h1><ol><li><p>設定 OS 要選擇 GuestOS: Windows，Version: 10/2016/2019<br><img src="https://i.imgur.com/dvpxhtN.png" alt=""></p></li><li><p>設定 System 要<strong>特別勾選 Qemu Agent</strong><br><img src="https://i.imgur.com/MwLDrAW.png" alt=""></p></li><li><p>設定 Disk <strong>選用 SCSI</strong><br><img src="https://i.imgur.com/UVCQIIG.png" alt=""></p></li><li><p>設定 CPU, Memory，這邊可以自己按需求設定（我是設定4顆CPU跟16G RAM因為沒有要跑大服務）<br><img src="https://i.imgur.com/HRsa4V8.png" alt=""><br><img src="https://i.imgur.com/4S7MI0q.png" alt=""></p></li><li><p>Network 選擇 <code>VirtIO</code><br><img src="https://i.imgur.com/8Ad5qFp.png" alt=""></p></li></ol><h1 id="設定-驅動程式-iso">設定 驅動程式 iso</h1><ol><li><p>新增 CD/DVD Drive<br><img src="https://i.imgur.com/Nz1bft2.png" alt=""></p></li><li><p>指定為<a href="#%E4%B8%8B%E8%BC%89iso%E6%AA%94%E6%A1%88">下載iso檔案</a>裡面的驅動程式 iso，匯流排選擇 IDE 即可，並選擇 virtio ISO。<br><img src="https://i.imgur.com/HO4ElxT.png" alt=""></p></li></ol><h1 id="開始進入安裝windows">開始進入安裝windows</h1><ol><li><p>按照 Windows 的安裝進行，直到選擇在哪裡安裝 Windows ，你會發現找不到任何硬碟。<br><img src="https://i.imgur.com/73xNyOL.png" alt=""></p></li><li><p>這時選擇 <code>載入驅動程式</code> ，瀏覽剛剛掛載的 <code>virtio ISO</code> ，選擇 <code>vioscsi</code> -&gt; <code>w10</code> -&gt; <code>amd64</code> 按下確定，變會進行抓取相關驅動。<br><img src="https://i.imgur.com/nJvBe0S.png" alt=""></p></li><li><p>等待驅動載入完成後你就會發現已經找到硬碟了。便可繼續按照 Windows 繼續安裝。<br><img src="https://i.imgur.com/dUbr9h4.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> proxmox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxmox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh的告警系統實作 - ElastAlert 的 POST &amp; EMAIL 警報觸發 教學</title>
      <link href="/posts/elastic-alert-email-guide/"/>
      <url>/posts/elastic-alert-email-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://elastalert.readthedocs.io/en/latest/ruletypes.html#http-post">elastAlert - HTTP POST</a></li><li><a href="https://blog.alantsai.net/posts/2017/12/test-smtp-server-for-sending-mail-in-development">沒有mail server怎麼測試寄送email？快放過你的gmail來看看有那些可以測試用的smtp mail server</a></li><li><a href="https://blog.yowko.com/elastalert-alert/">在elastAlert透過mail發送訊息</a></li></ul><h1 id="前言">前言</h1><p>我們在<a href="elastic-alert-slack-guide">上一篇</a>說明完如何透過 slack 來發送告警通知，本篇的目的這次著重在。</p><ul><li>[x] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[x] 成功觸發發送 email 功能</li><li>[x] 把 Labeling Service 部署到 機器上</li><li>[x] 成功觸發發送 發api進行 labeling 功能</li></ul><h1 id="透過-post-來發送訊息">透過 post 來發送訊息</h1><ul><li>參考根據官方網站說明：<a href="https://elastalert.readthedocs.io/en/latest/ruletypes.html#http-post">https://elastalert.readthedocs.io/en/latest/ruletypes.html#http-post</a></li></ul><div class="note info flat"><p>如果你想要設定 Rule 是可以發送 HTTP POST 的，可以參考以下的設定方式。</p></div><p><strong>HTTP POST的設定Key意思:</strong></p><ul><li><code>http_post_url</code>：設定要發送請求的URL地址。</li><li><code>http_post_payload</code>（可選）：以键值對形式配置的POST请求的内容。<ul><li>例如，ip: clientip 會將Elasticsearch中clientip索引的值映射到名为ip的JSON键。</li><li>如果未定義，則會發送所有Elasticsearch的键值對。</li></ul></li><li><code>http_post_static_payload</code>（可選）：靜態参数的键值對（value不是參考elasticSearch是自己填寫），會跟<code>http_post_payload</code>Elasticsearch的结果一起發送。可以在這裡放是其他純文字的內容。</li><li><code>http_post_headers</code>（可選）：要作為請求的一部分發送header的键值對。</li><li><code>http_post_proxy</code>（可選）：代理的URL，如果需要的话。(前提是，<code>http_post_url</code>有proxy，可以方面查看風包內的訊息)</li><li><code>http_post_timeout</code>（可選）：POST請求的超時值，單位為秒，默認為10秒。如果超時發生將在下次ElastAlert訓環時重試警報。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Shannon-Alert-Test&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;frequency&quot;</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">&quot;wazuh-*&quot;</span></span><br><span class="line"><span class="attr">is_enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer_time:</span> <span class="comment"># 查詢 elasticsearch 的時間區間</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5分鐘內相同的報警不會重複發送</span></span><br><span class="line"><span class="attr">realert:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">terms_size:</span> <span class="number">50</span> <span class="comment"># 每個查詢返回的最大數量 default 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 頻率觸發設定</span></span><br><span class="line"><span class="comment"># 當 48 小時內，滿足 authorization </span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span> <span class="comment"># 將觸發警報的事件數量（含）</span></span><br><span class="line"><span class="attr">timeframe:</span> <span class="comment"># 在 timeframe 時間內內必須發生 num_events 次數</span></span><br><span class="line">  <span class="attr">hours:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">timestamp_field:</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">timestamp_type:</span> <span class="string">&quot;iso&quot;</span></span><br><span class="line"><span class="attr">use_strftime_index:</span> <span class="literal">false</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.description&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用於查找事件的 Elasticsearch 過濾器列表</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">query_string:</span></span><br><span class="line">        <span class="attr">query:</span> <span class="string">&quot;@timestamp:*&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">wildcard:</span></span><br><span class="line">        <span class="attr">rule.groups:</span> <span class="string">&quot;*authentication_fail*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過什麼方式進行通知</span></span><br><span class="line"><span class="attr">alert:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;post&quot;</span> <span class="comment"># 指定事件發生時要進行 Post </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># post 的相關設定</span></span><br><span class="line"><span class="comment">## 我有開一個 api 專門可以提供貼標籤使用 </span></span><br><span class="line"><span class="attr">http_post_url:</span> <span class="string">&quot;http://140.118.9.194:8087/api/risk/label&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">## post payload 會從 elastic field 去抓</span></span><br><span class="line"><span class="attr">http_post_payload:</span></span><br><span class="line">  <span class="attr">targetId:</span> <span class="string">agent.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## post static payload 會直接成為字串進行傳送</span></span><br><span class="line"><span class="attr">http_post_static_payload:</span></span><br><span class="line">  <span class="attr">targetType:</span> <span class="string">&quot;User&quot;</span></span><br><span class="line">  <span class="attr">riskType:</span> <span class="string">&quot;HostRisk&quot;</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;0.7&quot;</span></span><br><span class="line">  <span class="attr">generator:</span> <span class="string">&quot;DeviceRisk&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic Authorization </span></span><br><span class="line"><span class="attr">http_post_headers:</span></span><br><span class="line">  <span class="attr">authorization:</span> <span class="string">Basic</span> <span class="string">YWRtaW46MTIz</span> <span class="comment">#帳號:密碼 admin:123 </span></span><br></pre></td></tr></table></figure><p>上面發出的訊息類似下面的效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">     -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Authorization: Basic YWRtaW46MTIz&quot;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">           &quot;generator&quot;: &quot;DeviceRisk&quot;,</span></span><br><span class="line"><span class="string">           &quot;targetId&quot;: &quot;001&quot;,</span></span><br><span class="line"><span class="string">           &quot;targetType&quot;: &quot;User&quot;,</span></span><br><span class="line"><span class="string">           &quot;riskType&quot;: &quot;HostRisk&quot;,</span></span><br><span class="line"><span class="string">           &quot;value&quot;: &quot;0.7&quot;</span></span><br><span class="line"><span class="string">         &#125;&#x27;</span> \</span><br><span class="line">     http://140.118.9.195:8087/api/risk/label</span><br></pre></td></tr></table></figure><h1 id="透過-Email-來發送訊息">透過 Email 來發送訊息</h1><h2 id="MailTrap-申請">MailTrap 申請</h2><ul><li>參考：<a href="https://blog.alantsai.net/posts/2017/12/test-smtp-server-for-sending-mail-in-development">沒有mail server怎麼測試寄送email？快放過你的gmail來看看有那些可以測試用的smtp mail server</a></li><li>服務申請網址：<a href="https://mailtrap.io/">https://mailtrap.io/</a></li></ul><ol><li>一開始預設會有 Inboxes 那是收訊息的地方，還有關於我們要用的是 SMTP 的設定。<br><img src="https://i.imgur.com/ydiogOV.png" alt=""></li><li>可以看到以下訊息：</li></ol><ul><li>(1): SMTP HOST</li><li>(2): SMTP 帳號</li><li>(3): SMTP 密碼</li><li>(4): 可以切換不同的語言或是工具查看使用這個服務的方式</li><li>(5): 直接看到如何使用的範例程式碼</li><li>(6): 可以直接重新產生帳號和密碼<br><img src="https://i.imgur.com/IHjsMlO.png" alt=""></li></ul><h2 id="ElastAlert-設定">ElastAlert 設定</h2><div class="note info flat"><p>ElastAlert 使用 email 通知時，<strong>如果需要帳號密碼，需要另外用 yaml 檔案格式紀錄帳號與密碼，再將檔案位置指定給 rule 使用</strong>，以下延續之前筆記的路徑規則設定</p></div><ol><li>建立 <code>/opt/elastalert/config/emailauth.yaml</code>把剛剛在MailTrap產生的帳號密碼放入。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>調整 docker compoe，把剛剛的 yaml 檔案掛載到 container 裡面<code>/opt/elastalert/config/emailauth.yaml</code>的位置。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elastalert:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elastalert2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jertel/elastalert2</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/config/config.yaml:/opt/elastalert/config.yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/rules:/opt/elastalert/rules</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/certs:/opt/elastalert/certs</span></span><br><span class="line">    <span class="comment"># 差異在這裡</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/config/emailauth.yaml:/opt/elastalert/config/emailauth.yaml</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--verbose</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es_default</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3030:3030&quot;</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:3030&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">40s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">es_default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以查看一下 logs 確認是否有正常運行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f elastalert</span><br></pre></td></tr></table></figure><ol start="3"><li>更正 rule 的 email 通知方式，<code>/opt/elastalert/rules/a.yaml</code>，設定以下內容。更正完不用重新啟動，就會自動套用囉，因為我們有掛載 volume。Host的檔案更改時，container裡面的檔案也會跟著更改。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span> </span><br><span class="line"><span class="attr">alert:</span> <span class="comment"># 警示通知類型 (詳細內容可以參考 [Alerts](https://elastalert.readthedocs.io/en/latest/ruletypes.html#alerts))</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;email&quot;</span></span><br><span class="line"><span class="attr">email:</span> <span class="comment"># email 發送目標</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;b10709036@gapps.ntust.edu.tw&quot;</span></span><br><span class="line"><span class="attr">smtp_host:</span> <span class="string">sandbox.smtp.mailtrap.io</span> </span><br><span class="line"><span class="attr">smtp_port:</span> <span class="number">2525</span> </span><br><span class="line"><span class="attr">smtp_auth_file:</span> <span class="string">/opt/elastalert/config/emailauth.yaml</span> <span class="comment"># email 帳號密碼設定檔位置</span></span><br></pre></td></tr></table></figure><h1 id="補充：想要透過標籤Label來得知裝置使用者">補充：想要透過標籤Label來得知裝置使用者</h1><div class="note warning flat"><p>在wazuh註冊的話只能透過device id來知道裝置身份，<strong>但是我們根本不知道使用者身份呀？</strong>，所以可以透過wazuh的Agent Label設定於<code>ossec.conf</code>，每次發送Alert的時候，添加Label的訊息進去。</p></div><h2 id="設定wazuh的Agent-Label">設定wazuh的Agent Label</h2><div class="note info flat"><p>如果你是Windows可以直接在 <code>C://Program Files (x86)/ossec-agent/ossec.conf</code> 裡面設定，如果是Linux的話，可以在 <code>/var/ossec/etc/ossec.conf</code> 裡面設定。</p></div><ol><li>打開 ossec.conf<br><img src="https://i.imgur.com/bvFevPn.png" alt=""></li><li>在 ossec.conf 設定以下內容：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">labels</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">key</span>=<span class="string">&quot;user.account&quot;</span>&gt;</span>&#123;user.account.id&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">labels</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/9VBJJhj.png" alt=""></p><h2 id="怎麼在rules抓取label內容">怎麼在rules抓取label內容</h2><ol><li><p>先知道 label 會位於 fields 的哪一個位置，可以從 kiabana 的 Discover 看到，他在<code>agent.labels.user.account</code>。<br><img src="https://i.imgur.com/BXQAXix.png" alt=""></p></li><li><p>所以可以在 rule 做以下設定，使得在 alert 的發送訊息中包含使用者資訊，設定如下：</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! User: &#123;3&#125;, AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.labels.user.account&quot;</span> <span class="comment"># 也就是這裡可以抓取labels的訊息</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.description&quot;</span></span><br></pre></td></tr></table></figure><h1 id="結論">結論</h1><p>這樣這篇至少你知道該<strong>如何透過 Email 來發送警報通知</strong>。<br>目前的進度，完成前面兩者，明天會繼續完成email的警報教學：</p><ul><li>[x] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[x] 成功觸發 slack ，並發送訊息</li><li>[x] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[x] 成功觸發發送 email 功能</li><li>[x] 把 Labeling Service 部署到 機器上</li><li>[x] 成功觸發發送 發api進行 labeling 功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> elastic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> alert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh的告警系統實作 - ElastAlert 的 Slack 警報觸發 教學</title>
      <link href="/posts/elastic-alert-slack-guide/"/>
      <url>/posts/elastic-alert-slack-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html">ElastAlert - Writing Filters For Rules</a></li><li><a href="https://izsk.me/2020/05/29/EFLK-elastalert-rules/">寫了蠻多範例撰寫Rule</a></li><li><a href="https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html">elastAlert-Writing Filter</a></li></ul><h1 id="前言">前言</h1><p>根據<a href="/posts/elast-alert.html">前一篇</a>的內容，我們接下來打算做的事情如下</p><ul><li>[x] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[x] 成功觸發 slack ，並發送訊息</li></ul><h1 id="關於-Filters">關於 Filters</h1><p>參考：<a href="https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html">https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html</a></p><blockquote><p>Filters 是什麼？</p></blockquote><p><strong>可以想像是 elasticsearch 的查詢條件，如果滿足的話，就觸發 rule 並執行告警動作。</strong></p><p>在建立 rule 時可以設定 filters，filters 是作為 elasticsearch query DSL(Domain Specific Language) 的部分，DSL 提供基於 json 來定義查詢，</p><blockquote><p>DSL 大概就長這樣（可以透過點擊Filter/Edit Filter/Edit as Query DSL來查看）</p></blockquote><p><img src="https://i.imgur.com/BHRoZcm.png" alt=""><br><img src="https://i.imgur.com/GzBc9Ea.png" alt=""><br><img src="https://i.imgur.com/kEgeL3o.png" alt=""></p><h1 id="測試-Filter-Slack-發送通知功能">測試 Filter + Slack 發送通知功能</h1><p>我們這邊採用 <code>frequency</code> 來進行測試，並使用 wazuh 告警來當作範例。你可能不懂 <code>frequency</code> 可以參考<a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#frequency">官網</a>進行了解，或是這篇<a href="https://izsk.me/2020/05/29/EFLK-elastalert-rules/">寫了蠻多範例撰寫Rule</a>。</p><p>而這裡的前提是你已經透過<a href="/posts/elast-alert.html">Wazuh的告警系統實作 - Docker 安裝 elastAlert</a></p><h2 id="撰寫-yaml">撰寫 yaml</h2><div class="note info flat"><p>情境：如果使用者登入windows時，<strong>只要在64小時內輸入錯1次密碼，導致觸發Authentication_fail的相關alert</strong>，就發送訊息到Slack。</p></div><p>我們想要滿足上述情境，因此撰寫以下 yaml 我們的內容，你可以直接把 <code>a.yaml</code> 的內容做置換。webhook取得連結的方式請參考 <a href="https://api.slack.com/messaging/webhooks">slack 官方說明</a>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Shannon-Alert-Test&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;frequency&quot;</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">&quot;wazuh-*&quot;</span></span><br><span class="line"><span class="attr">is_enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer_time:</span> <span class="comment"># 查詢 elasticsearch 的時間區間</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5分鐘內相同的報警不會重複發送</span></span><br><span class="line"><span class="attr">realert:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">terms_size:</span> <span class="number">50</span> <span class="comment"># 每個查詢返回的最大數量 default 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 頻率觸發設定</span></span><br><span class="line"><span class="comment"># 當 48 小時內，滿足 authorization </span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span> <span class="comment"># 將觸發警報的事件數量（含）</span></span><br><span class="line"><span class="attr">timeframe:</span> <span class="comment"># 在 timeframe 時間內內必須發生 num_events 次數</span></span><br><span class="line">  <span class="attr">hours:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">timestamp_field:</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">timestamp_type:</span> <span class="string">&quot;iso&quot;</span></span><br><span class="line"><span class="attr">use_strftime_index:</span> <span class="literal">false</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.description&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用於查找事件的 Elasticsearch 過濾器列表</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">query_string:</span></span><br><span class="line">        <span class="attr">query:</span> <span class="string">&quot;@timestamp:*&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">wildcard:</span></span><br><span class="line">        <span class="attr">rule.groups:</span> <span class="string">&quot;*authentication_fail*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過什麼方式進行通知</span></span><br><span class="line"><span class="attr">alert:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;slack&quot;</span></span><br><span class="line"><span class="attr">slack_webhook_url:</span> <span class="string">&#x27;https://hooks.slack.com/services/xxxxx&#x27;</span> <span class="comment"># 請使用你自己的 webhook url </span></span><br><span class="line"><span class="attr">slack_msg_color:</span> <span class="string">&quot;warning&quot;</span></span><br><span class="line"><span class="attr">slack_parse_override:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>這邊值得一提的是， <code>alert_subject_args</code> 可以直接填寫 elasticsearch 看得到的 fields 內容。(如圖1)</p></div><p><img src="https://i.imgur.com/JMusCwQ.png" alt=""></p><h2 id="觸發-windows-登入失敗">觸發 windows 登入失敗</h2><ol><li><p>接下來，你需要一台裝好 wazuh agent 的電腦，這邊我使用 windows10 來進行。你可以透過 kibana 的 agent 註冊功能來快速註冊。<br><img src="https://i.imgur.com/jI22lEp.png" alt=""></p></li><li><p>然後按照指示進行註冊即可<br><img src="https://i.imgur.com/C1ZOoLC.png" alt=""></p></li><li><p>接下來故意登入時，輸入錯誤的密碼<br><img src="https://i.imgur.com/ooPVOud.png" alt=""></p></li><li><p>然後前往 wazuh，進入 agent 的 security events，<strong>確認的確有觸發Authentication failure的事件增加了</strong>。<br><img src="https://i.imgur.com/2xRU5AD.png" alt=""><br><img src="https://i.imgur.com/r0RQ8eo.png" alt=""></p></li><li><p>最後，你也可以透過<code>docker logs -f elastalert</code>查看logs是否有觸發，或是建立 index: <code>elastalert_*</code> 選取 <code>hit</code> field，來確認的確有觸發alert。<br><img src="https://i.imgur.com/5yIWuId.png" alt=""><br><img src="https://i.imgur.com/gJC6dMZ.png" alt=""></p></li></ol><h2 id="Slack-收到通知">Slack 收到通知</h2><p>透過以上設置，他會發送出以下訊息：</p><p><img src="https://i.imgur.com/IiKNMFp.png" alt=""></p><h1 id="結論">結論</h1><p>這樣這篇至少你知道該<strong>如何撰寫 frequent 的 Rule，並且透過 Slack 來發送警報通知</strong>。<br>目前的進度，完成前面兩者，明天會繼續完成email的警報教學：</p><ul><li>[x] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[x] 成功觸發 slack ，並發送訊息</li><li>[ ] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[ ] 成功觸發發送 email 功能</li><li>[ ] 把 Labeling Service 部署到 機器上</li><li>[ ] 成功觸發發送 發api進行 labeling 功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> elastic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> alert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh的告警系統實作 - ElastAlert Docker 安裝 elastAlert</title>
      <link href="/posts/elast-alert/"/>
      <url>/posts/elast-alert/</url>
      
        <content type="html"><![CDATA[<h1 id="參考的網站">參考的網站</h1><ul><li><a href="https://help.aliyun.com/document_detail/61336.html?spm=a2c4g.74927.0.0.57bc2193sMQ77k#task-2445099">elastic相關yml設定挺詳細，裡面有談到如何啟用watcher的設定</a></li><li>elasticAlert：<a href="https://github.com/Yelp/elastalert.git">https://github.com/Yelp/elastalert.git</a></li><li><a href="https://api.slack.com/messaging/webhooks">Slack webhook</a></li></ul><h1 id="前言">前言</h1><p>因為計畫需求，我們本有做一套基於風險的存取控制模型，但是該模型要滿足一個要求，需要能夠監控裝置，<strong>當裝置發現異常時，要能夠告警並通知一個貼標籤的服務，那存取控制模型就可以基於標籤和存取策略，適當的拒絕不滿足存取策略的請求</strong>。</p><p>本文章的前提</p><ul><li>對wazuh已經有一定的了解</li><li>並且已經安裝好wazuh, elasticSearch的工具，安裝可以參考:<a href="/posts/install-wazuh.html">Wazuh, elastic, kibana 的無腦串接與安裝教學</a></li></ul><p>因此本篇文章的目的如下：</p><ul><li>[ ] 了解wazuh這套工具是如何做告警？</li><li>[ ] 如果wazuh告警，發送請求該怎麼做？</li></ul><h1 id="關於可以作為告警的工具">關於可以作為告警的工具</h1><ul><li>我想要的功能是：如果滿足特定規則 (e.g. level5以上的alert) 可以做到發送 mail 和 call api</li><li>目前我找到的工具：<ul><li><strong>工具1 Watcher</strong> : elasticsearch 本身有 plugin 可以支援，稱為 elasticSearch Watcher 可以做到上述需求，但是並非開源。</li><li><strong>工具2 elastAlert</strong>: 所以目前想使用 <code>elasticAlert</code> <a href="https://github.com/Yelp/elastalert.git">這個開源</a>的的專案來進行。</li></ul></li></ul><div class="note default flat"><p>具體來說，做告警的方式，就是不斷地去問 elasticSearch 然後如果發現滿足的要求或是條件，就執行某些動作。因為 wazuh 是把 log 透過 filebeat 傳到 elasticSearch 進行儲存，因此我們可以著重在當收到 elasticSearch 的特定訊息時，執行某些動作。</p></div><h1 id="elasticAlert-介紹">elasticAlert 介紹</h1><div class="note info flat"><p>目前 elasticAlert 已經不再維護，以 elasticAlert2 為主，主要更可靠、高度模塊化且易於設置和配置。</p></div><p>參考：<a href="https://elastalert2.readthedocs.io/en/latest/elastalert.html">https://elastalert2.readthedocs.io/en/latest/elastalert.html</a></p><p>ElasticAlert 可以提供常見的監控規則，像是:</p><ul><li>特定時間內發生事件的頻率(<code>frequent</code> type)</li><li>當事件發出率提高或下降時(<code>spike</code> type)</li><li>事件在時間內觸發少於幾次(<code>filatline</code> type)</li><li>滿足白名單或黑名單時(<code>blacklist</code> and <code>whitelist</code> type)</li><li>滿足任何特定filter時(<code>any</code> type)</li><li>在特定時間內，某個欄位值改變時(<code>change</code> type)</li></ul><p>當滿足上述情境時，可以做到像是：Email, Http Post, Jira, Line Notify等等，並且在通知的告警中添加alert link、或是相關資料而我們想要的是Email和Http Post功能，因此本篇教學也會著重在實作這兩個部分。</p><h2 id="安裝教學：使用-docker-啟動">安裝教學：使用 docker 啟動</h2><p>參考官方： <a href="https://elastalert2.readthedocs.io/en/latest/running_elastalert.html#as-a-docker-container">https://elastalert2.readthedocs.io/en/latest/running_elastalert.html#as-a-docker-container</a></p><p>官方我認為沒寫到很完整，因為我還有設置 elasticSearch 需要透過 TLS/SSH 來進行連線，因此比起官網需要多一些設置。</p><div class="note warning flat"><p>請注意：在這邊你會需要使用到 elasticSearch 的 ca.crt，並且請確保該檔案的權限設定為任何人都可以讀取如下：<br>chmod 777 ca.crt</p></div><ol><li>首先你會先需要如下的檔案結構</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我是在 /opt/elastalert 底下進行</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/elastalert</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── certs</span><br><span class="line">│   └── ca.crt <span class="comment"># 這是 elasticSearch 的 ca.crt 請移動過來 並且進行 chmod 777 否則會出現</span></span><br><span class="line">├── elastalert.yaml </span><br><span class="line">└── rules</span><br><span class="line">    └── a.yml</span><br></pre></td></tr></table></figure><ol><li>開始建立 <code>/opt/elastalert/ealstalert.yaml</code> 檔案，我是參考官網建議的檔案：<a href="https://github.com/jertel/elastalert2/blob/master/examples/config.yaml.example">https://github.com/jertel/elastalert2/blob/master/examples/config.yaml.example</a></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is the folder that contains the rule yaml files</span></span><br><span class="line"><span class="comment"># This can also be a list of directories</span></span><br><span class="line"><span class="comment"># Any .yaml file will be loaded as a rule</span></span><br><span class="line"><span class="attr">rules_folder:</span> <span class="string">/opt/elastalert/rules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often ElastAlert will query Elasticsearch</span></span><br><span class="line"><span class="comment"># The unit can be anything from weeks to seconds</span></span><br><span class="line"><span class="attr">run_every:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ElastAlert will buffer results from the most recent</span></span><br><span class="line"><span class="comment"># period of time, in case some log sources are not in real time</span></span><br><span class="line"><span class="attr">buffer_time:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Elasticsearch hostname for metadata writeback</span></span><br><span class="line"><span class="comment"># Note that every rule can have its own Elasticsearch host</span></span><br><span class="line"><span class="attr">es_host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.71</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Elasticsearch port</span></span><br><span class="line"><span class="attr">es_port:</span> <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The AWS region to use. Set this when using AWS-managed elasticsearch</span></span><br><span class="line"><span class="comment">#aws_region: us-east-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The AWS profile to use. Use this if you are using an aws-cli profile.</span></span><br><span class="line"><span class="comment"># See http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html</span></span><br><span class="line"><span class="comment"># for details</span></span><br><span class="line"><span class="comment">#profile: test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional URL prefix for Elasticsearch</span></span><br><span class="line"><span class="comment">#es_url_prefix: elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional prefix for statsd metrics</span></span><br><span class="line"><span class="comment">#statsd_instance_tag: elastalert</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional statsd host</span></span><br><span class="line"><span class="comment">#statsd_host: dogstatsd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect with TLS to Elasticsearch</span></span><br><span class="line"><span class="attr">use_ssl:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify TLS certificates</span></span><br><span class="line"><span class="attr">verify_certs:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show TLS or certificate related warnings</span></span><br><span class="line"><span class="attr">ssl_show_warn:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GET request with body is the default option for Elasticsearch.</span></span><br><span class="line"><span class="comment"># If it fails for some reason, you can pass &#x27;GET&#x27;, &#x27;POST&#x27; or &#x27;source&#x27;.</span></span><br><span class="line"><span class="comment"># See https://elasticsearch-py.readthedocs.io/en/master/connection.html?highlight=send_get_body_as#transport</span></span><br><span class="line"><span class="comment"># for details</span></span><br><span class="line"><span class="comment">#es_send_get_body_as: GET</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Option basic-auth username and password for Elasticsearch</span></span><br><span class="line"><span class="attr">es_username:</span> <span class="string">elastic</span></span><br><span class="line"><span class="attr">es_password:</span> <span class="string">4RQwIyVNCBznV4zXGDhX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use SSL authentication with client certificates client_cert must be</span></span><br><span class="line"><span class="comment"># a pem file containing both cert and key for client</span></span><br><span class="line"><span class="attr">ca_certs:</span> <span class="string">/opt/elastalert/certs/ca.crt</span></span><br><span class="line"><span class="comment">#client_cert: /etc/elasticsearch/certs/elasticsearch.crt</span></span><br><span class="line"><span class="comment">#client_key: /etc/elasticsearch/certs/elasticsearch.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The index on es_host which is used for metadata storage</span></span><br><span class="line"><span class="comment"># This can be a unmapped index, but it is recommended that you run</span></span><br><span class="line"><span class="comment"># elastalert-create-index to set a mapping</span></span><br><span class="line"><span class="attr">writeback_index:</span> <span class="string">elastalert_status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If an alert fails for some reason, ElastAlert will retry</span></span><br><span class="line"><span class="comment"># sending the alert until this time period has elapsed</span></span><br><span class="line"><span class="attr">alert_time_limit:</span></span><br><span class="line">  <span class="attr">days:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="建立-opt-rules-a-yaml-檔案">建立 <code>/opt/rules/a.yaml</code> 檔案</h2><div class="note info flat"><p>在這之前你可能會好奇webhook要填寫什麼，你可以透過以下教學建立 webhook<br>可以參考這篇：<a href="https://api.slack.com/messaging/webhooks">https://api.slack.com/messaging/webhooks</a></p></div><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Shannon-Alert-Test&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;frequency&quot;</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">&quot;wazuh-*&quot;</span></span><br><span class="line"><span class="attr">is_enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer_time:</span> <span class="comment"># 查詢 elasticsearch 的時間區間</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5分鐘內相同的報警不會重複發送</span></span><br><span class="line"><span class="attr">realert:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">terms_size:</span> <span class="number">50</span> <span class="comment"># 每個查詢返回的最大數量 default 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 頻率觸發設定</span></span><br><span class="line"><span class="comment"># 當 48 小時內，滿足 authorization </span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span> <span class="comment"># 將觸發警報的事件數量（含）</span></span><br><span class="line"><span class="attr">timeframe:</span> <span class="comment"># 在 timeframe 時間內內必須發生 num_events 次數</span></span><br><span class="line">  <span class="attr">hours:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">timestamp_field:</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">timestamp_type:</span> <span class="string">&quot;iso&quot;</span></span><br><span class="line"><span class="attr">use_strftime_index:</span> <span class="literal">false</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;full_log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用於查找事件的 Elasticsearch 過濾器列表</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">query_string:</span></span><br><span class="line">        <span class="attr">query:</span> <span class="string">&quot;@timestamp:*&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">wildcard:</span></span><br><span class="line">        <span class="attr">rule.groups:</span> <span class="string">&quot;*authentication_fail*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過什麼方式進行通知</span></span><br><span class="line"><span class="attr">alert:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;slack&quot;</span></span><br><span class="line"><span class="attr">slack_webhook_url:</span> <span class="string">&#x27;https://hooks.slack.com/services/xxxxx&#x27;</span> <span class="comment"># 請使用你自己的 webhook url </span></span><br><span class="line"><span class="attr">slack_msg_color:</span> <span class="string">&quot;warning&quot;</span></span><br><span class="line"><span class="attr">slack_parse_override:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure><h2 id="透過-docker-指令啟動">透過 docker 指令啟動</h2><p>啟動，跟官方的有一點不一樣，因為我們需要把 <code>ca.crt</code> mount 到容器得的 <code>/opt/elastalert/certs/ca.crt</code>，因為 <code>ealstalert.yaml</code> 是這樣設定的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先前往 /opt/elastalert/ </span></span><br><span class="line"><span class="built_in">cd</span> /opt/elastalert </span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd 會直接帶目前路徑 </span></span><br><span class="line"><span class="comment"># 你會發現我們把3個部分mount進去，分別是 elastalert.yaml, rules, ca.crt </span></span><br><span class="line">docker run --net=es_default -d --name elastalert --restart=always \</span><br><span class="line">-v $(<span class="built_in">pwd</span>)/elastalert.yaml:/opt/elastalert/config.yaml \</span><br><span class="line">-v $(<span class="built_in">pwd</span>)/rules:/opt/elastalert/rules \</span><br><span class="line">-v $(<span class="built_in">pwd</span>)/certs:/opt/elastalert/certs \ </span><br><span class="line">jertel/elastalert2 --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 logs </span></span><br><span class="line">docker logs -f elastalert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 輸出結果應該要類似如下</span></span><br><span class="line">INFO:elastalert:Background configuration change check run at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Background alerts thread 0 pending alerts sent at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Disabled rules are: []</span><br><span class="line">INFO:elastalert:Sleeping <span class="keyword">for</span> 59.99996 seconds</span><br><span class="line">INFO:elastalert:Queried rule a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 / 0 hits</span><br><span class="line">WARNING:elasticsearch:DELETE https://192.168.2.71:9200/_search/scroll [status:404 request:0.001s]</span><br><span class="line">INFO:elastalert:Ran a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 query hits (0 already seen), 0 matches, 0 alerts sent</span><br><span class="line">INFO:elastalert:a range 900</span><br></pre></td></tr></table></figure><h2 id="透過-docker-compose-啟動">透過 docker-compose 啟動</h2><p>你也可以建立 <code>/opt/elastalert/docker-compose.yaml</code> 檔案，內容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elastalert:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elastalert2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jertel/elastalert2</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/config/config.yaml:/opt/elastalert/config.yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/rules:/opt/elastalert/rules</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/certs:/opt/elastalert/certs</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--verbose</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es_default</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3030:3030&quot;</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:3030&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">40s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">es_default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然後透過以下指令啟動</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先前往 /opt/elastalert/</span></span><br><span class="line"><span class="built_in">cd</span> /opt/elastalert</span><br><span class="line"><span class="comment"># 啟動 docker-compose.yaml 背景執行</span></span><br><span class="line">docker-compose up -d </span><br><span class="line"><span class="comment"># 查看 logs</span></span><br><span class="line">docker-compose logs -f elastalert</span><br><span class="line"><span class="comment"># 輸出結果應該要類似如下</span></span><br><span class="line">INFO:elastalert:Background configuration change check run at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Background alerts thread 0 pending alerts sent at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Disabled rules are: []</span><br><span class="line">INFO:elastalert:Sleeping <span class="keyword">for</span> 59.99996 seconds</span><br><span class="line">INFO:elastalert:Queried rule a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 / 0 hits</span><br><span class="line">WARNING:elasticsearch:DELETE https://192.168.2.71:9200/_search/scroll [status:404 request:0.001s]</span><br><span class="line">INFO:elastalert:Ran a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 query hits (0 already seen), 0 matches, 0 alerts sent</span><br><span class="line">INFO:elastalert:a range 900</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><p>回到文章的開頭想探討的，到目前為止總結如下：</p><ul><li>[x] 了解wazuh這套工具是如何做告警？<ul><li><strong>Ans: Wazuh 本身提供 mail 發訊息功能，但是如果要做更多還是使用 elastic 整合相關告警工具更好</strong></li></ul></li><li>[x] 如果wazuh告警，發送請求該怎麼做？<ul><li><strong>Ans: 目前看到的做法是 (1) elastic 內建的 watcher 但是因為非開源，加上還需要license，因此選擇 (2) elastAlert 開源工具。</strong></li></ul></li></ul><p>接下來東西串好了，elastAlert 可以正常使用，我會優先透過 slack 來測試 Alert 的相關功能</p><ul><li>[ ] <a href="https://blog.yowko.com/elastalert-alert/">寫成docker-compose，可以餐考這篇</a></li><li>[ ] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[ ] 成功觸發 slack ，並發送訊息</li><li>[ ] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[ ] 成功觸發發送 email 功能</li><li>[ ] 把 Labeling Service 部署到 機器上</li><li>[ ] 成功觸發發送 發api進行 labeling 功能</li></ul><h1 id="坑1-SSLError-Permission-Denied">坑1: SSLError Permission Denied</h1><div class="note info flat"><p>Ans: 本來一直出現以下問題，後來發現是ca.crt的權限讓elastAlert無法讀取。<br><strong>只需要進行 chmod 777 ca.crt 後 再mount到container即可解決</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/elasticsearch/connection/http_requests.py&quot;</span>, line 174, <span class="keyword">in</span> perform_request</span><br><span class="line">    raise SSLError(<span class="string">&quot;N/A&quot;</span>, str(e), e)</span><br><span class="line">elasticsearch.exceptions.SSLError: ConnectionError(HTTPSConnectionPool(host=<span class="string">&#x27;192.168.2.71&#x27;</span>, port=9200): Max retries exceeded with url: / (Caused by SSLError(PermissionError(13, <span class="string">&#x27;Permission denied&#x27;</span>)))) caused by: SSLError(HTTPSConnectionPool(host=<span class="string">&#x27;192.168.2.71&#x27;</span>, port=9200): Max retries exceeded with url: / (Caused by SSLError(PermissionError(13, <span class="string">&#x27;Permission denied&#x27;</span>))))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> elastic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> alert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh, elastic, kibana 的無腦串接與安裝教學</title>
      <link href="/posts/install-wazuh/"/>
      <url>/posts/install-wazuh/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li>參考wauzh官方安裝教學: <a href="https://documentation.wazuh.com/current/deployment-options/elastic-stack/all-in-one-deployment/index.html#installing-elasticsearch">https://documentation.wazuh.com/current/deployment-options/elastic-stack/all-in-one-deployment/index.html#installing-elasticsearch</a></li><li>參考filebeat安裝: <a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/setup-repositories.html">https://www.elastic.co/guide/en/beats/filebeat/7.17/setup-repositories.html</a></li></ul><h1 id="前言">前言</h1><div class="note danger flat"><p>請注意，我的安裝教學不是用正式環境，<strong>因為certs都是使用相同的，僅供教學快速安裝使用</strong>。</p></div><blockquote><p>注意：目前教學內所使用的wazuh-manager版本是4.4.4，所以如果你的wazuh-manager是其他版本像是4.5，請務必修改以下所有含有4.4的script內容為4.5</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本為4.4 </span></span><br><span class="line">curl -so /etc/elasticsearch/elasticsearch.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/elasticsearch_all_in_one.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 請更正為4.5</span></span><br><span class="line">curl -so /etc/elasticsearch/elasticsearch.yml https://packages.wazuh.com/4.5/tpl/elastic-basic/elasticsearch_all_in_one.yml</span><br></pre></td></tr></table></figure><div class="note default flat"><p>使用Proxmox開兩台VM規格如下：</p></div><p><img src="https://i.imgur.com/bkrxlnP.png" alt=""></p><p><img src="https://i.imgur.com/FlyHPuj.png" alt=""></p><h1 id="ElasticStack-安裝">ElasticStack 安裝</h1><blockquote><p>filebeat是跟wazuh安裝在一起</p></blockquote><ol><li>安裝需要一些額外的包，例如curl或unzip，將在後續步驟中使用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install apt-transport-https zip unzip lsb-release curl gnupg</span><br></pre></td></tr></table></figure><ol start="2"><li>Adding the Elastic Stack repository:這兩個指令是用於將Elasticsearch的GPG公鑰導入到系統中，以便於系統驗證Elasticsearch的APT軟件包。具體來說，這兩個指令完成了以下操作：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一個指令使用curl命令下載Elasticsearch的GPG公鑰，然後使用gpg命令將其導入到系統的密鑰環中。其中，--no-default-keyring選項表示不使用默認的密鑰環，--keyring選項表示將GPG公鑰導入到指定的密鑰環中，chmod命令用於修改/elasticsearch.gpg文件的權限，以使其只允許root用戶和群組讀取。</span></span><br><span class="line">curl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | gpg --no-default-keyring --keyring gnupg-ring:/usr/share/keyrings/elasticsearch.gpg --import &amp;&amp; <span class="built_in">chmod</span> 644 /usr/share/keyrings/elasticsearch.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二個指令使用echo命令在/etc/apt/sources.list.d/目錄下創建一個名為elastic-7.x.list的文件，並在該文件中寫入APT存儲庫的URL。其中，[signed-by=/usr/share/keyrings/elasticsearch.gpg]表示使用先前導入的Elasticsearch GPG公鑰對APT存儲庫進行數字簽名驗證，以確保軟件包的完整性和安全性。通過執行這兩個指令，系統可以驗證Elasticsearch APT存儲庫中的軟件包，確保其來源可信且未被修改。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/elasticsearch.gpg] https://artifacts.elastic.co/packages/7.x/apt stable main&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><ol start="3"><li>安裝elasticSearch package</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install elasticsearch=7.17.6</span><br></pre></td></tr></table></figure><ol start="4"><li>Download the configuration file /etc/elasticsearch/elasticsearch.yml as follows:<br><strong>如果要開放給外面的人使用要記得使用network.host=0.0.0.0，否則預設會拒絕一切非127.0.0.1的使用者</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -so /etc/elasticsearch/elasticsearch.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/elasticsearch_all_in_one.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 進去修改elasticsearch.yml </span></span><br><span class="line">vim /etc/elasticsearch/elasticsearch.yml</span><br><span class="line"><span class="comment"># 設定如下</span></span><br><span class="line"><span class="comment"># network.host=0.0.0.0</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Download the configuration file for creating the certificates:<br><strong>instances.yml裡面的ip記得要改成自己的實體ip，否則跨機器的連線會出錯</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這個命令是在Linux環境中使用curl命令下載名為&quot;instances_aio.yml&quot;的文件並將其保存到&quot;/usr/share/elasticsearch/instances.yml&quot;路徑中。</span></span><br><span class="line"><span class="comment"># &quot;-s&quot;表示&quot;silent&quot;模式，即curl命令不會顯示任何進度或錯誤信息</span></span><br><span class="line"><span class="comment"># &quot;-o&quot;表示指定輸出文件的位置和名稱，&quot;/usr/share/elasticsearch/instances.yml&quot;是指定的路徑和文件名</span></span><br><span class="line">curl -so /usr/share/elasticsearch/instances.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/instances_aio.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正 isntance.yml </span></span><br><span class="line">vim /usr/share/elasticsearch/instances.yml</span><br><span class="line"><span class="comment"># 如下</span></span><br><span class="line">instances:</span><br><span class="line">- name: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">  ip:</span><br><span class="line">  - <span class="string">&quot;&lt;elastic-ip&gt;&quot;</span> <span class="comment"># 改這裡</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具體地說，命令中的&quot;cert&quot;表示要生成一個自簽名憑證</span></span><br><span class="line"><span class="comment"># &quot;ca&quot;表示該憑證是一個CA憑證</span></span><br><span class="line"><span class="comment"># &quot;--pem&quot;表示生成PEM格式的憑證</span></span><br><span class="line"><span class="comment"># &quot;--in instances.yml&quot;表示要使用先前下載的instances.yml文件作為證書的配置文件</span></span><br><span class="line"><span class="comment"># &quot;--keep-ca-key&quot;表示保留CA憑證的私鑰</span></span><br><span class="line"><span class="comment"># &quot;--out ~/certs.zip&quot;表示將生成的證書和密鑰存儲在一個名為certs.zip的壓縮文件中，並存儲在當前用戶的家目錄中。</span></span><br><span class="line">/usr/share/elasticsearch/bin/elasticsearch-certutil cert ca --pem --<span class="keyword">in</span> instances.yml --keep-ca-key --out ~/certs.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解壓縮</span></span><br><span class="line">unzip ~/certs.zip -d ~/certs</span><br></pre></td></tr></table></figure><ol start="6"><li>The next step is to create the directory /etc/elasticsearch/certs, and then copy the CA file, the certificate and the key there:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir是一個用於在Linux中創建新目錄的命令，&quot;-p&quot;選項表示創建多層目錄，即如果上級目錄不存在，則會自動創建。</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/elasticsearch/certs/ca -p</span><br><span class="line"><span class="comment"># 將~/certs/ca/和~/certs/elasticsearch/中的所有文件和目錄複製到&quot;/etc/elasticsearch/certs/&quot;目錄中</span></span><br><span class="line"><span class="built_in">cp</span> -R ~/certs/ca/ ~/certs/elasticsearch/* /etc/elasticsearch/certs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;-R&quot;選項表示遞歸更改所有權和群組，&quot;elasticsearch&quot;表示新擁有者的用戶名，&quot;:&quot;表示分隔符，最後&quot;/etc/elasticsearch/certs&quot;是要更改所有權和群組的目標目錄。</span></span><br><span class="line"><span class="built_in">chown</span> -R elasticsearch: /etc/elasticsearch/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;500&quot;是要設置的權限值，其中&quot;5&quot;表示所有者有可執行和可讀權限，但沒有寫權限，其他用戶沒有任何權限。</span></span><br><span class="line"><span class="built_in">chmod</span> -R 500 /etc/elasticsearch/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;chmod 400&quot;通常用於限制敏感文件的訪問權限，只允許文件所有者讀取，其他人無權限訪問；而&quot;chmod 500&quot;通常用於限制目錄的訪問權限，只允許目錄所有者進入目錄，其他人無權限訪問。</span></span><br><span class="line"><span class="built_in">chmod</span> 400 /etc/elasticsearch/certs/ca/ca.* /etc/elasticsearch/certs/elasticsearch.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把檔案移除</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/certs/ ~/certs.zip</span><br></pre></td></tr></table></figure><ol start="7"><li>啟動服務並且Generate credentials for all the Elastic Stack pre-built roles and users:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> elasticsearch</span><br><span class="line">systemctl start elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># create pwd and role </span></span><br><span class="line">/usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto</span><br></pre></td></tr></table></figure><ol start="8"><li>就會看到以下角色與密碼被建立，類似下面的結果：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Changed password for user apm_system</span><br><span class="line">PASSWORD apm_system = rj5cEOP5ahI5lNNDVuG6</span><br><span class="line"></span><br><span class="line">Changed password for user kibana_system</span><br><span class="line">PASSWORD kibana_system = Jqi6Q0UKiOkntBikCBSe</span><br><span class="line"></span><br><span class="line">Changed password for user kibana</span><br><span class="line">PASSWORD kibana = Jqi6Q0UKiOkntBikCBSe</span><br><span class="line"></span><br><span class="line">Changed password for user logstash_system</span><br><span class="line">PASSWORD logstash_system = Y6NzFN8qelmUjEXIsBtr</span><br><span class="line"></span><br><span class="line">Changed password for user beats_system</span><br><span class="line">PASSWORD beats_system = 8Y7JmIyfgyfBvUduyYiM</span><br><span class="line"></span><br><span class="line">Changed password for user remote_monitoring_user</span><br><span class="line">PASSWORD remote_monitoring_user = XBXvJEu2PG5dD8H8L9X7</span><br><span class="line"></span><br><span class="line">Changed password for user elastic</span><br><span class="line">PASSWORD elastic = dWAntWBQeyMIuPNFxydS</span><br></pre></td></tr></table></figure><ol start="9"><li>To check that the installation was made successfully, run the following command replacing &lt;elastic_password&gt; with the password generated in the previous step for elastic user:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET https://localhost:9200 -u elastic:&lt;elastic_password&gt; -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># example </span></span><br><span class="line"><span class="comment"># 使用-u選項指定了用戶名和密碼</span></span><br><span class="line"><span class="comment"># -k 表示忽略SSL證書驗證</span></span><br><span class="line">curl -XGET https://localhost:9200 -u elastic:dWAntWBQeyMIuPNFxydS -k</span><br></pre></td></tr></table></figure><h1 id="安裝Wazuh">安裝Wazuh</h1><ol><li>adding wazuh repository</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | gpg --no-default-keyring --keyring gnupg-ring:/usr/share/keyrings/wazuh.gpg --import &amp;&amp; <span class="built_in">chmod</span> 644 /usr/share/keyrings/wazuh.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/wazuh.gpg] https://packages.wazuh.com/4.x/apt/ stable main&quot;</span> | <span class="built_in">tee</span> -a /etc/apt/sources.list.d/wazuh.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><ol start="2"><li>安裝wazuh manager</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get install wazuh-manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> wazuh-manager</span><br><span class="line">systemctl start wazuh-manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認版本 是否為 4.4.4，如果不是請記得更新所有4.4的相關包</span></span><br><span class="line">/var/ossec/bin/wazuh-control -j info</span><br></pre></td></tr></table></figure><ol start="3"><li>檢查服務是否有起來</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status wazuh-manager</span><br></pre></td></tr></table></figure><h1 id="安裝Filebeat">安裝Filebeat</h1><ol><li>安裝filebeat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/oss-7.x/apt stable main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install filebeat=7.17.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># filebeat 傳送至 elasticSearch的設定</span></span><br><span class="line">curl -so /etc/filebeat/filebeat.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/filebeat_all_in_one.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>Download the alerts template for Elasticsearch:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filebeat 傳送wazuh相關訊息的json</span></span><br><span class="line">curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/4.4/extensions/elasticsearch/7.x/wazuh-template.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># g表示群組（group）</span></span><br><span class="line"><span class="comment"># o表示其他人（others）</span></span><br><span class="line"><span class="comment"># 而+r表示添加讀取權限（read）。</span></span><br><span class="line"><span class="built_in">chmod</span> go+r /etc/filebeat/wazuh-template.json</span><br></pre></td></tr></table></figure><ol start="3"><li>Download the Wazuh module for Filebeat:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packages.wazuh.com/4.x/filebeat/wazuh-filebeat-0.2.tar.gz | tar -xvz -C /usr/share/filebeat/module</span><br></pre></td></tr></table></figure><ol start="4"><li>更改filebeat.yaml裡面elastic的ip和帳號密碼</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">/etc/filebeat/filebeat.yml</span></span><br><span class="line"><span class="comment"># Replace elasticsearch_password with the previously generated password for elastic user.</span></span><br><span class="line"><span class="attr">output.elasticsearch.password:</span> <span class="string">&lt;elasticsearch_password&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Copy the certificates into <code>/etc/filebeat/certs/</code> (我這邊是透過scp把vm2的certs.zip copy過去)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy 檔案 從 vm2 到 vm1</span></span><br><span class="line">scp &#123;vm2_user_name&#125;@&#123;vm2-ip&#125;:/home/user/certs.zip ~/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解壓縮</span></span><br><span class="line">unzip ~/certs.zip -d ~/certs</span><br><span class="line"><span class="comment"># mkdir是一個用於在Linux中創建新目錄的命令，&quot;-p&quot;選項表示創建多層目錄，即如果上級目錄不存在，則會自動創建。</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/elasticsearch/certs/ca -p</span><br><span class="line"><span class="comment"># 將~/certs/ca/和~/certs/elasticsearch/中的所有文件和目錄複製到&quot;/etc/elasticsearch/certs/&quot;目錄中</span></span><br><span class="line"><span class="built_in">cp</span> -R ~/certs/ca/ ~/certs/elasticsearch/* /etc/elasticsearch/certs/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把ca.crt放入filebeat的certs</span></span><br><span class="line"><span class="built_in">cp</span> -r /etc/elasticsearch/certs/ca/ /etc/filebeat/certs/</span><br><span class="line"><span class="comment"># 把elasticSearch的crt, key當作filebeat的 （正常應該要產filebeat的）</span></span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.crt /etc/filebeat/certs/filebeat.crt</span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.key /etc/filebeat/certs/filebeat.key</span><br></pre></td></tr></table></figure><ol start="6"><li>Enable and start the Filebeat service:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> filebeat</span><br><span class="line">systemctl start filebeat</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">filebeat <span class="built_in">test</span> output</span><br></pre></td></tr></table></figure><h1 id="安裝Kibana">安裝Kibana</h1><ol><li>要先安裝這些repository apt-get才會是安裝特定或是最新版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | gpg --no-default-keyring --keyring gnupg-ring:/usr/share/keyrings/elasticsearch.gpg --import &amp;&amp; <span class="built_in">chmod</span> 644 /usr/share/keyrings/elasticsearch.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/elasticsearch.gpg] https://artifacts.elastic.co/packages/7.x/apt stable main&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get install kibana=7.17.6</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>這邊我都是使用elasticSearch.key跟crt當作kibana的key還有crt，certs.zip就沿用elasticSearch的</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 把ca.crt放入filebeat的certs</span></span><br><span class="line"><span class="built_in">cp</span> -r /etc/elasticsearch/certs/ca/ /etc/kibana/certs/ca/</span><br><span class="line"><span class="comment"># 把elasticSearch的crt, key當作filebeat的 （正常應該要產filebeat的）</span></span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.crt /etc/kibana/certs/kibana.crt</span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.key /etc/kibana/certs/kibana.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改變一下檔案權限</span></span><br><span class="line"><span class="built_in">chown</span> -R kibana: /etc/kibana/certs</span><br><span class="line"><span class="built_in">chmod</span> -R 500 /etc/kibana/certs</span><br><span class="line"><span class="built_in">chmod</span> 400 /etc/kibana/certs/ca/ca.* /etc/kibana/certs/kibana.*</span><br><span class="line"><span class="built_in">rm</span> -rf ~/certs ~/certs.zip</span><br></pre></td></tr></table></figure><ol start="3"><li>幫kibana下載wazuh的模板</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -so /etc/kibana/kibana.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/kibana.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Edit the /etc/kibana/kibana.yml file:</span></span><br><span class="line">server.host: &lt;kibana_ip&gt; <span class="comment"># 改成裝kibana的實體機ip</span></span><br><span class="line"><span class="comment">#  # 改成裝elasticsearch的實體機ip或dns name</span></span><br><span class="line">elasticsearch.hosts: <span class="string">&quot;https://&lt;elasticsearch_DN&gt;:9200&quot;</span></span><br><span class="line">elasticsearch.password: &lt;elasticsearch_password&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the /usr/share/kibana/data directory:</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/share/kibana/data</span><br><span class="line"><span class="built_in">chown</span> -R kibana:kibana /usr/share/kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install the Wazuh Kibana plugin:</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/kibana</span><br><span class="line">sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/4.x/ui/kibana/wazuh_kibana-4.4.4_7.17.6-1.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">setcap</span> <span class="string">&#x27;cap_net_bind_service=+ep&#x27;</span> /usr/share/kibana/node/bin/node</span><br></pre></td></tr></table></figure><ol start="4"><li>啟動的時候就會開始把/usr/share/kibana裡面所需要的東西wazuh相關的plugin下載</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> kibana</span><br><span class="line">systemctl start kibana</span><br></pre></td></tr></table></figure><ol start="5"><li>等到啟動之後，就可以去修改wazuh.yml檔案，這樣才會call對，檔案位置在 <code>/usr/share/kibana/data/wazuh/config/wazuh.yml</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/kibana/data/wazuh/config/wazuh.yml</span><br><span class="line"><span class="comment"># 修改內容如下</span></span><br><span class="line">hosts:</span><br><span class="line">  - default:</span><br><span class="line">      url: https://localhost <span class="comment"># 把這裡改成 wazuh 的 ip </span></span><br><span class="line">      port: 55000</span><br><span class="line">      username: wazuh-wui</span><br><span class="line">      password: wazuh-wui</span><br><span class="line">      run_as: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="6"><li>Access the web interface using the password generated during the Elasticsearch installation process:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL: https://&lt;kibana_ip&gt;</span><br><span class="line">user: elastic</span><br><span class="line">password: &lt;PASSWORD_elastic&gt;</span><br></pre></td></tr></table></figure><h1 id="踩坑1-wazuh-版本太新-kibana-太舊的問題">踩坑1: wazuh 版本太新 kibana 太舊的問題</h1><div class="note info flat"><p>wazuh API 4.4.4 但是 App 是 4.3.10 的版本不對，這是因為 kibana 的 wazuh plugin</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用 su 權限</span></span><br><span class="line">sudo su </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前 kibana 有安裝的 plugin 看 wazuh 是否為 4.3.10 我們要更新為 4.4.4 </span></span><br><span class="line">/usr/share/kibana/bin/kibana-plugin list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是 4.3 的版本就太舊了，先移除</span></span><br><span class="line">/usr/share/kibana/bin/kibana-plugin remove wazuh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 再重裝</span></span><br><span class="line">sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/4.x/ui/kibana/wazuh_kibana-4.4.4_7.17.6-1.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">setcap</span> <span class="string">&#x27;cap_net_bind_service=+ep&#x27;</span> /usr/share/kibana/node/bin/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重啟</span></span><br><span class="line">systemctl restart kibana</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> wazuh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> wazuh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>簡單介紹Istio</title>
      <link href="/posts/istio-intro/"/>
      <url>/posts/istio-intro/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Istio">What is Istio?</h1><div class="note info flat"><p><strong>1. Is a service mesh, implement network mechanism</strong></p></div><ul><li>service mesh 基本上是透過在 Pod 上面做 Sidecar</li><li>把<strong>網路相關的工作剝離</strong>出來，讓工程師可以專注在開發上</li><li>而網路的控管像是 Gatewway，<strong>經過 pod 的 request 都是經由 Sidecar 轉發給 pod</strong>。</li></ul><div class="note info flat"><p><strong>2. Integrate with many observability tools</strong></p></div><ul><li>不只可以做網路，還可以整合各種第三方的觀察工具</li><li>(e.g. Prometheus, Kiali, Grafana, etc.)。</li></ul><div class="note info flat"><p><strong>3. Handle microservice challenges</strong></p></div><ul><li>在 microservice 架構下當 service/pod 一多，要去管控各個 service 間的網路連線是非常頭痛的</li><li>但是透過Istio可以負責解決網路的事情，並由control plane統一管理和設定。</li></ul><blockquote><p>可以從上方看到，每個Pod裡面有兩個container，一個是Service另一個是Proxy，而Istio主要就是透過Control Plane來控制Proxy進行網路流量的操控與設定。<br><img src="https://i.imgur.com/XregvWQ.png" alt=""></p></blockquote><div class="note danger flat"><p>注意：Sidecar不是只負責把網路相關的工作剝離，<strong>Sidecar是一種附加在Pod內的容器</strong>，用於提供額外的功能或服務，<strong>與主要應用容器共同運行並共享相同的生命周期</strong>。像是如果要收集pod的log，通常就會需要fluentd的Sidecar共享pod的產生log的資料夾，把log傳送給elasticSearch。</p></div><h1 id="Istio-的主要核心">Istio 的主要核心</h1><p>Istio 主要有兩個核心元件：</p><ol><li><strong>Envoy: 就在Proxy旁邊</strong><ul><li>目的：Istio使用Envoy Agent作為與data plane交互的Istio元件，被部署為服務的Sidecar。主要<strong>協調Service Mesh中所有服務進去和出去的流量</strong>。</li><li>功能：動態的service discover, load balance, TLS, Http/2和gRPC agent, health check, 金絲雀發布 等等。</li><li>貢獻：可以允許Istio執行決策並且提取豐富的數據，並發送數據到監控系統中提供整個Mesh的行為信息。</li></ul></li><li><strong>Istiod: 就在Control Plane</strong><ul><li>目的：<strong>提供service discover, 配置和憑證管理</strong>負責實現強大的服務隊服務的用戶認證，可以用來升級服務網格中未加密的流量，對不穩定的layer 3 (network)或是 layer 4 (Transport layer, TCP)來執行策略。</li></ul></li></ol><h1 id="Istio-如何做到安全">Istio 如何做到安全?</h1><p><img src="https://i.imgur.com/aSHY5pr.png" alt=""></p><ul><li>在 <code>Control Plane</code> 可以看到 <code>Istiod</code> 負責：<ul><li>憑證與授權管理</li><li>網路設定</li><li>授權政策設定</li></ul></li></ul><blockquote><p>使用Istio有以下特色</p></blockquote><ol><li><strong>Secure by default</strong> : 透過Sidecar的方式應用程式代碼和基礎設施不需更改。</li><li><strong>Defense in depth</strong>：與現有安全系統集成以提供多層防禦。</li><li><strong>Zero-trust network</strong>：在不受信任的網路上建構安全解決方案。</li><li><strong>Secure Endpoints, Communication, Platform, Data</strong></li><li><strong>Do Identity, Policy, AAA, Encryption</strong></li></ol><blockquote><p>Istio 的安全元件</p></blockquote><ol><li><strong>CA</strong>：用於密鑰和憑證管理的頒發機構CA。</li><li><strong>配置API服務器</strong>：把認證策略, 授權策略, 安全命名分發給agent。</li><li><strong>Sidecar和邊緣agent作為PEP</strong>：保護客戶端和服務之間的通信安全。而PEP用Envoy實現。</li><li><strong>一組Envoy Agent Extension</strong>：用於監控和審計。</li></ol><h2 id="Istio-身份和憑證管理">Istio 身份和憑證管理</h2><div class="note danger flat"><p>注意：以下內容的<code>istio-agent</code>是指Sidecar容器中的<code>pilot-agent</code> process。</p></div><p><img src="https://i.imgur.com/hNRESzY.png" alt=""></p><ol><li><code>Istio-agent</code> 在啟動時，創建pk 和 CSR 並且把 CSR和憑證送到 <code>istiod</code> 簽名。</li><li><code>Istiod CA</code> 驗證CSR裡面的憑證，在成功驗證後簽署CSR以生成證書。</li><li>當工作附載啟動時，Envoy 通過 <code>Secret Discover Service (SDS) API</code> 向同容器內的 <code>istio-agent</code> 發送憑證和pk請求。</li><li><code>Istio-agent</code>透過<code>Envoy SDS API</code> 將從 <code>istiod</code> 收到的證書和密鑰發送給Envoy。</li><li><code>Istio-agent</code> 監控工作負載憑證的過期時間，會定期重複做憑證和pk的輪換。</li></ol><h2 id="Istio-的政策授權">Istio 的政策授權</h2><p>畢竟Istio的重點在控制Pod服務的網路流量，因此要對於特定情況的流量應該作接受還是拒絕，仍然要政策的設置與規則引擎的判斷。<strong>Istio有提供政策的設置，若要建立授權策略需要創建 <code>AuthorizationPolicy</code> 的自定義資源</strong>。一個授權策略包含：</p><ul><li><code>Selector</code> 選擇器：用來指定策略的執行目標。</li><li><code>Action</code> 操作：指定允許還是拒絕請求。</li><li><code>Rules</code> 規則集：指定何時觸發動作。<ul><li><code>From</code>：指定請求的來源</li><li><code>To</code>：指定請求的操作</li><li><code>When</code>：指定規則所需的條件</li></ul></li></ul><blockquote><p>以下是策略設定的範例：</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">security.istio.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AuthorizationPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">httpbin</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">selector:</span></span><br><span class="line">   <span class="attr">matchLabels:</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">httpbin</span></span><br><span class="line">     <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"> <span class="attr">action:</span> <span class="string">ALLOW</span></span><br><span class="line"> <span class="attr">rules:</span></span><br><span class="line"><span class="string">//</span> <span class="string">允許兩個來源：服務帳戶</span> <span class="string">cluster.local/ns/default/sa/sleep</span> <span class="string">和命名空間dev</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">source:</span></span><br><span class="line">       <span class="attr">principals:</span> [<span class="string">&quot;cluster.local/ns/default/sa/sleep&quot;</span>]</span><br><span class="line">   <span class="bullet">-</span> <span class="attr">source:</span></span><br><span class="line">       <span class="attr">namespaces:</span> [<span class="string">&quot;dev&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">可以對</span> <span class="attr">namespace:</span> <span class="string">foo</span> <span class="string">中帶有標籤</span> <span class="attr">app:</span> <span class="string">httpbin</span> <span class="string">和</span> <span class="string">version:v1</span> <span class="string">進行GET動作</span></span><br><span class="line">   <span class="attr">to:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">operation:</span></span><br><span class="line">       <span class="attr">methods:</span> [<span class="string">&quot;GET&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">使用有效的JWT</span> <span class="string">Token發送請求時</span></span><br><span class="line">   <span class="attr">when:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">request.auth.claims[iss]</span></span><br><span class="line">     <span class="attr">values:</span> [<span class="string">&quot;https://accounts.google.com&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="Istio-的政策驗證流程">Istio 的政策驗證流程</h2><ul><li>在對Server端的Envoy Agent進入流量實施訪問控制，</li><li>每個Envoy Agent會運行一個授權的引擎，該引擎會根據當前的策略，評估上下文。</li><li>然後返回授權結果Allow或Deny。</li><li>而策略是使用<code>.yaml</code>文件指定Istio授權策略。</li><li>如果沒有相關的授權策略，Istio允許所有請求。</li><li>支援<code>Custom</code>操作，可以根據需求設定策略執行不同的操作。</li><li>檢查順序的匹配規則是：<code>Custom</code> &gt; <code>Deny</code> &gt; <code>Allow</code>，會先檢查是否有策略的操作被應用，檢查策略的規則是否滿足。如果其中一層的不匹配就執行到下一層(可以參考下圖)。</li></ul><p><img src="https://i.imgur.com/ke1kccL.png" alt=""></p><h1 id="參考資料">參考資料</h1><ul><li><a href="https://medium.com/hobo-engineer/%E7%AD%86%E8%A8%98-%E6%B7%BA%E5%85%A5%E6%B7%BA%E5%87%BA-istio-1-%E6%9E%B6%E6%A7%8B%E7%B0%A1%E8%AA%AA-a8d6aaf6977d">筆記 淺入淺出 Istio (1) — 架構簡說</a></li><li><a href="https://istio.io/latest/zh/docs/concepts/security/">Istio &gt; Security</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Istio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次搞懂Java中的equals()和hashCode()</title>
      <link href="/posts/equals-hashCode/"/>
      <url>/posts/equals-hashCode/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><div class="note info flat"><p>如果你想要自定義物件判斷是否相等的邏輯，就改<code>equals</code>吧！<br>如果你想要修改HashMap或是HashSet中，不重複物件的邏輯，那就修改<code>hashCode</code>吧！</p></div><p>在物件導向的世界裡面，勢必逃不了自己建立的物件（你可能把某些功能包起來，放在某個class裡面）又或是想要建立一個<code>Employee.class</code>這樣的類別，方便你建立員工的資料存入資料庫中。</p><p>而這些<code>xxxx.class</code>都其實繼承Object，可以說是Object是所有Java類別的超類(Abstract Class)，而我會想寫這篇的原因是因為，剛好碰到<strong>需要自定義<code>HashSet</code>的需求，修改放入Set的自定義物件時，判斷物件是否相等的邏輯</strong>。</p><p>什麼意思呢？簡單來說，在程式語言中，我希望不要採用Object本身的<code>hashCode</code>和<code>equals</code>方法，<strong>我希望只要某些屬性的值一樣，我就視這個物件已經存在於Set裡面</strong>。而不是比較記憶體中的位置、所有屬性的value都要一樣等，<strong>我希望自定義物件相等的邏輯判斷</strong>。</p><p>如果你好奇…</p><ol><li>我複寫equals的方法為什麼還要管hashCode?</li><li>equals跟hashCode的關係是什麼？</li></ol><p>那你可以參考這個篇文章，繼續看下去。</p><h1 id="equals-是什麼？">equals 是什麼？</h1><p>可以從原始碼中看到一長串的東西，沒關係你可以跳過，讓我來跟你娓娓道來 …<br><img src="https://i.imgur.com/bs2kH6g.png" alt=""></p><h2 id="equals-的特性">equals 的特性</h2><div class="note warning flat"><p>他裡面說了啥？面試這個應該要說得出來以下幾種特性呦！</p></div><p>簡單來說，equals主要遵循了以下規則來判斷物件的相等性：</p><ol><li><strong>自反性Reflexive</strong>： 我就是我<ul><li><code>x.equals(x)</code> 應該總是返回 true。</li></ul></li><li><strong>對稱性Symmetric</strong>： 我是你 你就是我 順序沒差<ul><li>如果 <code>x.equals(y)</code> 返回 <code>true</code>，則 <code>y.equals(x)</code> 也應返回 <code>true</code>。這意味著比較的順序不重要。</li></ul></li><li><strong>傳遞性Transitive</strong>: 爺爺的精神跟孫子是一樣的<ul><li>相較於Symmetric更深一層，如果 <code>x.equals(y)</code> 返回 <code>true</code>，且 <code>y.equals(z)</code> 返回 <code>true</code>，則 <code>x.equals(z)</code> 也應返回 <code>true</code>。</li><li>換句話說，如果兩個物件分別與第三個物件相等，則它們之間也應該相等。</li></ul></li><li><strong>一致性Consistent</strong>：只要內容不變還是一樣<ul><li>只要比較時使用的信息未被修改，多次調用 x.equals(y) 應始終返回相同的結果。</li></ul></li><li><strong>與 null 的比較</strong>：永遠不同<ul><li>對於任何非 null 的引用值 x，x.equals(null) 應該返回 false。物件不應該與 null 相等。</li></ul></li></ol><h2 id="到底怎麼樣算equals">到底怎麼樣算equals?</h2><div class="note info flat"><p>你說的我都懂：但是我怎麼知道 equals 到底是比什麼？</p></div><p>按照原本equals的內容，如果滿足下面三個條件的話，我就說<strong>這兩個物件是一樣的</strong>：</p><ol><li><strong>位置</strong> 一樣</li><li><strong>類別</strong> 一樣</li><li><strong>屬性</strong> 一樣</li></ol><p>上面的例子中，你可能最不懂的是<strong>比較位置</strong>…<br>舉例來說，下面有一個程式範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次 new 的時候就是 assign 一個新位置給他 </span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;shannon&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;shannon&quot;</span>);</span><br><span class="line">        <span class="comment">// 這時就會返回 false </span></span><br><span class="line">        System.out.println(emp1.equals(emp2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是這種感覺：當new一個物件的時候，就會給他安排在不同的位置，所以他們當然就是獨立的個體囉，<strong>就像是同名同姓的人住在不同地區一樣，但是他們還是不同人</strong>。<br><img src="https://i.imgur.com/KwIZqYj.png" alt=""></p><p>但是如果你把程式改成這樣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次 new 的時候就是 assign 一個新位置給他 </span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;shannon&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp2</span> <span class="operator">=</span> emp1;</span><br><span class="line">        <span class="comment">// 這時就會返回 true </span></span><br><span class="line">        System.out.println(emp1.equals(emp2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/4QAp0qe.png" alt=""></p><h2 id="為啥要改寫equals">為啥要改寫equals?</h2><div class="note info flat"><p>今天你不想要，判斷位置，我希望<strong>只要屬性值一樣，就識別這兩個物件是一樣的</strong><br>這時候你可以考慮override <code>equlas</code> 方法</p></div><ul><li>簡單來說，我有一個<code>IdNumber.class</code>，用來記錄身分證資料，因此我只需要知道<code>id</code>如果一樣的話，一定是同一個人，不用多說。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果“位置”一樣就不用看了 肯定同一個人</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果“類別”不可為null，同時如果&quot;類別&quot;不一樣，也太怪了，一定不是同個人</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 注意：上面這段絕對不要使用 instanceof !(o instanceof IdNumber) </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比較自定義類別的各種“屬性值”</span></span><br><span class="line">        <span class="comment">// 透過Objects.equals 判斷 就不用寫成這樣：(o.id != null &amp;&amp; o.id.equals(that.id))</span></span><br><span class="line">        <span class="type">IdNumber</span> <span class="variable">that</span> <span class="operator">=</span> (IdNumber) o</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id,that.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 這時候就能打破「位置」的框架了，只針對「屬性」還有「類別」來比較。</span></span><br><span class="line">        <span class="type">IdNumber</span> <span class="variable">id1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdNumber</span>(<span class="string">&quot;A123&quot;</span>);</span><br><span class="line">        <span class="type">IdNumber</span> <span class="variable">id2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdNumber</span>(<span class="string">&quot;A123&quot;</span>);</span><br><span class="line">        System.out.println(id1.equals(id2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>這時候你可能會不太了解為什麼不要使用<code>instanceof</code>來進行類別的比較？<br>因為在父類別層次進行比較時，會出現問題</p></div><p>Ans:<br><strong>違反對稱性</strong>：user 不是 employee 的子類，但是<code>employee</code>是<code>user</code>的子類，我們希望不管<code>employee</code>還是<code>user</code>放在被比較的那方，還是比較方，結果應該都要一樣！<br>因此才<strong>使用<code>getClass</code>來進行類別的比較，不考慮父類別之間的關係</strong>，反正class不一樣，我一率覺得這是不一樣的物件，拒絕！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// Parent class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// Child class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print: parent.getClass() = class Parent</span></span><br><span class="line">        System.out.println(<span class="string">&quot;parent.getClass() = &quot;</span> + parent.getClass());</span><br><span class="line">        <span class="comment">// print: child.getClass() = class Child</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child.getClass() = &quot;</span> + child.getClass());</span><br><span class="line">        <span class="comment">// print: child.getClass() == parent.getClass() ? false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child.getClass() == parent.getClass() ? &quot;</span> + (child.getClass() == parent.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="關於HashCode">關於HashCode ?</h1><p>hashCode也叫雜湊碼（雜湊碼），它用來計算物件中所有屬性的雜湊值，哪裡會使用到呢？從字面上就可以看到，<code>Hash</code>有關的，就會呼叫到這個函式。例如，<code>HashMap</code>或是<code>HashSet</code>。在 Java 或 Kotlin 語言中，<code>hashCode()</code> 方法的主要目的是用來在使用哈希表（如 <code>HashMap</code> 或 <code>HashSet</code>）時<strong>提供一種快速查找的方式</strong>。</p><h2 id="hash-的特性">hash 的特性</h2><p>在計算機科學中，雜湊（Hash）是一種特殊的函數，具有以下幾個主要特性：</p><ol><li>確定性（Deterministic）：<ul><li>對於<strong>同一個輸入，Hash 函數每次運算都將產生同一個輸出</strong>。也就是說，如果你有一個輸入 A，每次將 A 輸入 Hash 函數，你都會得到同樣的結果。</li></ul></li><li>快速計算（Fast to Compute）：<ul><li>對任何給定的輸入，計算其 Hash 值都應該是非常迅速的。</li></ul></li><li>不可逆性（Irreversibility）：<ul><li>當知道了 Hash 函數的輸出，<strong>我們卻無法推算出其對應的輸入。這是密碼學中特別重要的一個特性</strong>。</li></ul></li><li>隨輸入微小變化產生大變化（Avalanche Effect）：<ul><li>即使<strong>輸入的微小變化，也應該導致 Hash 值的劇烈變化</strong>。這有助於確保相似的輸入在經過雜湊後得到的結果將顯著不同。</li></ul></li></ol><h2 id="儲存物件於哈希表">儲存物件於哈希表</h2><p>當您在哈希表(<code>HashMap</code> 或是 <code>HashSet</code>)中存儲物件時，<code>hashCode()</code> 方法被用來<strong>確定物件應該被存放在哈希表的哪個位置</strong>。這通常通過將物件的 <code>hashCode()</code> 返回值對哈希表的大小進行取模運算來實現。</p><blockquote><p>透過hashCode檢索儲存於哈希表的物件</p></blockquote><ol><li>當您試圖<strong>從哈希表中檢索物件時，<code>hashCode()</code> 方法也會被調用以確定應該在哪裡查找該物件</strong>。</li><li>如果哈希碼與表中存儲的任何物件的哈希碼不匹配，那麼哈希表可以<strong>立即確定該物件不在表中，而無需進行進一步的比較</strong>。</li><li>如果在該哈希碼對應的位置找到了一個或多個物件，哈希表將使用 <code>equals()</code> 方法來確定哪一個物件（如果有的話）與查詢的物件匹配。這是因為多個不同的物件可能會有相同的哈希碼（也就是所謂的哈希碰撞）。</li></ol><p>這就是為什麼當我們在自定義類別中覆寫 <code>equals()</code> 方法時，<strong>我們應該始終確保也覆寫 <code>hashCode()</code> 方法，並確保如果兩個物件根據 <code>equals()</code> 方法是相等的</strong>，那麼它們的 <code>hashCode()</code> 方法也應該返回相同的值。如果這兩種方法之間的契約被違反，那麼依賴這些方法的資料結構（如 <code>HashMap</code> 和 <code>HashSet</code>）可能無法正確地工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Player(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> (Player) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, player.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 我們用 name 來進行 hash </span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Player&gt; players = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Charlie&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to add a new player with the same name as Alice</span></span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 這時候 players 只會有三個 因為 name 是一樣的</span></span><br><span class="line">        System.out.println(player.getSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="參考連結">參考連結</h1><ul><li><a href="https://tw511.com/a/01/30684.html">Java中的equals()和hashCode() - 超細節篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 物件導向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德國簽證教學, 可能碰到的問題, 要準備什麼文件？</title>
      <link href="/posts/germany-visa/"/>
      <url>/posts/germany-visa/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E7%B0%BD%E8%AD%89%E5%9C%B0%E9%BB%9E">簽證地點</a></li><li><a href="#%E5%BE%B7%E5%9C%8B%E7%B0%BD%E8%AD%89%E6%96%87%E4%BB%B6%E6%BA%96%E5%82%99">德國簽證文件準備</a><ul><li><a href="#q-%E7%95%99%E5%AD%B8%E7%94%9F%E9%9C%80%E8%A6%81%E6%BA%96%E5%82%99%E4%BB%80%E9%BA%BC%E8%B3%87%E6%96%99%E5%92%8C%E6%96%87%E4%BB%B6">Q: 留學生需要準備什麼資料和文件？</a></li><li><a href="#q-%E8%A6%AA%E8%87%AA%E5%89%8D%E5%BE%80%E7%94%B3%E8%AB%8B%E6%99%82%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E9%BA%BC">Q: 親自前往申請時要注意什麼？</a></li><li><a href="#q-%E7%B0%BD%E8%AD%89%E4%B8%AD%E9%97%9C%E6%96%BC%E4%BF%9D%E9%9A%AA%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E9%BA%BC">Q: 簽證中關於保險需要注意什麼？</a></li><li><a href="#q-%E9%97%9C%E6%96%BC%E7%B0%BD%E8%AD%89%E5%BE%8C%E5%B1%85%E4%BD%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85">Q: 關於簽證後居住的注意事項？</a></li><li><a href="#q-%E5%8F%AF%E6%8C%81%E5%AD%B8%E7%94%9F%E7%B0%BD%E8%AD%89%E6%96%BC%E6%B1%82%E5%AD%B8%E6%9C%9F%E9%96%93%E5%B7%A5%E4%BD%9C">Q: 可持學生簽證於求學期間工作？</a></li></ul></li><li><a href="#%E5%AF%A6%E9%9A%9B%E5%89%8D%E5%BE%80%E7%8B%80%E6%B3%81">實際前往狀況</a></li><li><a href="#%E7%95%B6%E5%A4%A9%E6%9C%89%E5%93%AA%E4%BA%9B%E7%83%8F%E9%BE%8D">當天有哪些烏龍</a></li><li><a href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%BA%90">參考資源</a></li></ul><h1 id="背景">背景</h1><blockquote><p>為什麼申請簽證？</p></blockquote><p>因為台科大資管系剛好2023/3月與德國HKAs談雙聯。申請上後，2023/9準備前往德國雙聯，大約為期一年的時間，因此需要申請大概為期一年的簽證，然後在這邊做記錄說申請簽證的整個準備過程和心得。</p><h1 id="簽證地點">簽證地點</h1><blockquote><p>💡 請注意以下資訊：</p></blockquote><ul><li><a href="https://goo.gl/maps/D19qwdiukaNkBea39">德國在台協會辦公時間、電話、地址及交通指南</a><ul><li>住址：11049臺北市信義路五段7號33樓 (33F, No. 7, Xinyi Rd., Sec.5, Taipei 11049)</li><li>時間：需提前30分鐘到101(算上迷路時間)</li><li>要帶錢：約3000台幣(當時付了$2450 NTD)</li><li>提前時間：三個月</li></ul></li></ul><h1 id="德國簽證文件準備">德國簽證文件準備</h1><h2 id="Q-留學生需要準備什麼資料和文件？">Q: 留學生需要準備什麼資料和文件？</h2><blockquote><p>切記注意：<strong>不要把以下文件訂起來</strong>，但是如果有把順序排好的話，作業流程會快很多。<br>順序大概是：申請表格 &gt; 護照影印 &gt; 德國學校入學通知（最好有開學日）&gt; 台灣學校相關文件 &gt; 保險+凍結帳戶 &gt; 自傳與動機</p></blockquote><p><a href="https://taipei.diplo.de/tw-zh-tw/service/visa-einreise/-/2453292">單國德國長期簽證 - 於德國境內就讀高等學院簽證 - 德國外交部 (diplo.de)</a></p><ul><li>[x]  0 預約好的email信件，要列印出來給他們看。（但實際前往，他們並無要求要，只是以防萬一）</li><li>[x]  1 <strong>有效護照</strong>正本(須於最近十年內核發，持照人已於簽名處簽名, 至少須有兩頁以上空白頁面)</li><li>[x]  2 完整填寫好的**申請表格 (<a href="https://videx-national.diplo.de/videx/visum-erfassung/#/videx-langfristiger-aufenthalt">表格</a>) (**兩份) 不用貼照片</li><li>[x]  3 <strong>護照個人基本資料頁影本</strong>，兩份</li><li>[x]  4 三張最新且符合生物特徵之<strong>證件照</strong>(須於三個月內拍攝)</li><li>[x]  5 <strong>德國高等學院入學許可</strong>, 兩份</li><li>[x]  6 (以防萬一) <strong>交換學生</strong>須額外 檢附：<ul><li>目前就讀之台灣學校所核發的<strong>英文版在學證明</strong>，<strong>兩份</strong></li><li>目前就讀之台灣學校所核發的<strong>英文版成績單</strong>，<strong>兩份</strong></li></ul></li><li>[x]  7 依據入學許可 - <strong>授課語言能力證明,</strong> 兩份<ul><li>德語能力證明：例如 DSH, Goethe-Zertifikat, TestDaF</li><li>英語能力證明：例如 , IELTS, TOEFL,TOEIC</li></ul></li><li>[x]  8 <strong>財力證明</strong> (需檢附第一年之財力證明。交換學生部份，請檢附總停留時間之財力證明)<ul><li><strong>每月</strong> 至少<strong>934</strong> 歐元，兩份</li><li>以簽證申請者為名開立之<strong>限制提領帳戶(Sperrkonto)</strong></li><li>存款金額至少11.208歐元(=12x934歐元)</li><li>如果是Expatro就要記得提供06的文件喔</li></ul></li><li>[x]  9 <strong>至目前為止之中學學歷證明/高等學院學歷證明/技職教育結業證明，及在特定狀況下，其他與德國學業相關之資格證明</strong>，(正本及影本兩份)<ul><li>(若您已於高等學院就讀，但尚未取得學位，請檢附：英文版註冊證明及成績單)</li><li>我猜：大學畢業證書</li></ul></li><li>[x]  10 <strong>德文</strong>或<strong>英文</strong>動機信,兩份 （Personal Statement)<ul><li>請詳細闡述至德國求學原因及該學業對於日後職業未來之影響</li></ul></li><li>[x]  11 <strong>唯簽證可被核發前，才會要求您提供</strong><ul><li>預計入境德國日期</li><li>適用於德國境內之保險證明</li></ul></li><li>[x]  12 (不確定以防萬一) 快遞免責同意出<ul><li><a href="https://taipei.diplo.de/blob/1988392/0335790923e5be9d5f6387262f1bea2a/haftungsausschlusserklaerung-data.pdf">haftungsausschlusserklaerung-data.pdf (diplo.de)</a></li></ul></li></ul><h2 id="Q-親自前往申請時要注意什麼？">Q: 親自前往申請時要注意什麼？</h2><ul><li><strong>請您不要將簽證申請文件釘在一起!</strong></li><li><strong>簽證處理費用</strong>為75歐元（<strong>2,544.73新臺幣</strong>），您可於面試當下以台幣現金支付。簽證申請一旦被受理，則費用將無法被退還 – 不論日後審核結果為何!</li><li><strong>處理完整簽證申請之工作天，基本上大約為五週</strong><br>；可能依個案不同而更久。德國在台協會無法干涉或是加快外事單位簽證審核程序。因此，德國在台協會請您於簽證申請過程中，不要詢問任何簽證進度相關問題。<strong>當您的簽證申請流程結束時，本會將立即以信件方式通知您</strong></li></ul><h2 id="Q-簽證中關於保險需要注意什麼？">Q: 簽證中關於保險需要注意什麼？</h2><ul><li>您的健保必須於入境德國那一天生效。最理想的狀況是，您購買所謂的Incoming保險，此類保險於您入境德國的那一天生效，在您生病或受傷時，提供足夠的保障。</li><li>並且在您正式註冊為學生後，直接自動轉換成德國境內的公立或私人學生健保，在這轉換的過程中，您的保險不會有任何的間斷。</li></ul><h2 id="Q-關於簽證後居住的注意事項？">Q: 關於簽證後居住的注意事項？</h2><ul><li>依據外事單位許可，我們可核發<strong>九十天或六個月不等</strong>之<strong>學生簽證</strong></li><li>入境德國後，您須持該簽證向當地外事單位提出長期居留證申請。</li><li>對於交換學生，大部份我們可核發停留德國總時間(一或兩個學期)簽證。</li><li>所有移居德國的人必須於兩週內於居住地所在之戶政單位辦理入戶登記。</li></ul><h2 id="Q-可持學生簽證於求學期間工作？">Q: 可持學生簽證於求學期間工作？</h2><ul><li>可以，於高等學院辦理註冊後，您可持學生簽證/居留證工作，或從事學生工讀，一年總計最多可達120個全天或240個半天。</li><li>該工作許可並不適用於學前準備課程(例如語言班)之停留。德國外事單位可額外增定限制條件，例如只能於學校放假期間(寒暑假期間)工作。</li></ul><h1 id="實際前往狀況">實際前往狀況</h1><ol><li>先去一樓，左轉機台<strong>領訪客證</strong>，可以上網查教學，但具體來說如下：<ul><li>會先透過機台找到德國在台協會的公司，然後點下去</li><li>會自動撥話，然後機台會直接聯絡他們，<strong>他們會問你：是誰？然後預約幾點的？</strong></li><li>確認完訊息之後，機台就會吐訪客證拉！</li></ul></li><li>因為德國在台協會在33樓，所以<strong>你要先去35樓，在轉電梯到33樓！</strong>（p.s. 101的電梯就跟迷宮一樣…）</li><li>開電梯門後，左轉走到底。就會看到一個警衛，警衛會要求你把手機關起來到保險箱，接下來就是等待。</li><li><strong>等待的過程中不會有號碼牌</strong>因為我是預約9:45a.m.，所以當他們如果叫10:45分有沒有預約的同學，你就要舉手讓他們知道！</li><li>輪到你的時候，他就會幫你檢查表格有沒有填錯，問一些問題拉～，基本上15分鐘就可以處理好。</li></ol><h1 id="當天有哪些烏龍">當天有哪些烏龍</h1><ol><li><p>問題：德國在台協會<strong>會把你的護照收走</strong>…</p><ul><li>因為他們需要把簽證貼在你的護照，所以會收走護照</li><li>剛好我下週要去日本，這嚇死我了！如果你有需要，一定要提前跟他們說，否則要重新等待（本來我15分鐘處理好，結果等了1小時才離開）</li><li>他們會要求你簽名同意書，然後就可以領走護照了。</li><li>之後回國後，要把護照寄回去德國在台協會，最好一起把編號（辦理完成他們會給你編號讓你知道進度）也給他們。</li></ul></li><li><p>問題：如果你還<strong>不確定錄取哪一間學校，真的不要去辦簽證</strong>…</p><ul><li>當天我看到一個女生，她申請了很多間學校，只有一間確定入取但是其他還不知道</li><li>但是，協會會把申請文件送到當地的特定州，所以如果你上A學校，但是Ｂ不確定，所以你簽證送到Ａ地，但是後續Ｂ錄取了，你想去Ｂ地，這是不可以的喔！你就要重新申請！</li></ul></li><li><p>問題：<strong>請務必提早預約</strong>，越早越好但是不要太早超過三個月喔！</p><ul><li>拜託，一定要提早預約！我自己是預計八月底過去，所以我四月就預約了，那時候空位超多的拉！</li><li>但是當五月底到的時候，基本上就沒有可以預約的時間了。</li></ul></li></ol><h1 id="參考資源">參考資源</h1><ul><li><a href="https://youtu.be/mFzOomf8FJg">德國簽證申請當天流程 ❗｜實際的情形如何? ｜學生簽證 &amp; 長期簽證｜該準備甚麼 ? ｜如何搶申請預約｜財務證明怎麼辦理｜德國在臺協會在 101 !? ｜需要會德文嗎？｜我沒有注意到的是 …</a></li><li><a href="https://jacky88210.wordpress.com/2017/09/17/%E6%BC%AB%E9%95%B7%E5%BE%B7%E5%9C%8B%E9%95%B7%E6%9C%9F%E7%B0%BD%E8%AD%89%E4%B9%8B%E8%B7%AF%F0%9F%87%A9%F0%9F%87%AA/">漫長德國長期簽證之路🇩🇪</a></li><li><a href="https://outgoing-iep.nccu.edu.tw/sites/default/files/109356007_ep1_%E9%9B%BB%E5%AD%90%E5%A0%B1%E4%B8%80_%E7%B0%BD%E8%AD%89%EF%BC%88%E5%90%AB%E8%BE%A6%E7%90%86%E6%99%82%E7%A8%8B%EF%BC%89.pdf">簽證教學(含辦理時程).pdf</a></li><li><a href="https://taipei.diplo.de/tw-zh-tw/service/visa-einreise/-/1695744?view=">單國德國長期簽證</a></li><li><a href="https://www.dcard.tw/f/studyabroad/p/236782389">2021德國交換簽證申請 - 留學板 | Dcard</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 簽證申請 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 簽證 </tag>
            
            <tag> 德國 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇blog - Hexo架設的樣式設計 - 基於Butterfly</title>
      <link href="/posts/first-blog/"/>
      <url>/posts/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><div class="note info flat"><p>這是我在建立過程中，設置的一些小細節，如果我的文章有幫助到你的話，希望可以在下面留言:D<br>給我一個“讚”～</p></div><h1 id="修改-home-aside-樣式">修改 home aside 樣式</h1><h2 id="整體寬度">整體寬度</h2><p>前往<code>themes/butterfly/source/css/_layout/aside.styl</code> 找到 <code>card-widget</code> 的樣式，然後修改成以下樣式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card-widget</span></span><br><span class="line">  <span class="keyword">@extend</span> .cardHover</span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line">  <span class="attribute">overflow</span>: hidden</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">20px</span></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">15px</span> # 添加這個</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">24px</span></span><br></pre></td></tr></table></figure><h2 id="tag">tag</h2><p>前往<code>themes/butterfly/source/css/_layout/aside.styl</code>找到 <code>card-tag-cloud</code> 的樣式，然後修改成以下樣式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card-tag-cloud</span></span><br><span class="line">  <span class="selector-tag">a</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0.2rem</span> <span class="number">0.2rem</span> <span class="number">0.2rem</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0.4rem</span>;</span><br><span class="line">    <span class="attribute">width</span>: fit-content;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f76b61</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0.8rem</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f76b61</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    -webkit-<span class="attribute">transition</span>: all <span class="number">0.2s</span> ease-in-out;</span><br><span class="line">    -moz-<span class="attribute">transition</span>: all <span class="number">0.2s</span> ease-in-out;</span><br><span class="line">    -o-<span class="attribute">transition</span>: all <span class="number">0.2s</span> ease-in-out;</span><br><span class="line">    -ms-<span class="attribute">transition</span>: all <span class="number">0.2s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.2s</span> ease-in-out;</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span></span><br><span class="line">      <span class="attribute">background</span>: <span class="number">#42d3d8</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#42d3d8</span>;</span><br><span class="line">      -webkit-<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">8px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">0.03</span>);</span><br><span class="line">      <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">4px</span> <span class="number">8px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">0.03</span>);</span><br><span class="line">      -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">      -moz-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">      -o-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">      -ms-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br></pre></td></tr></table></figure><h1 id="post-中把-tag-移動到上方">post 中把 tag 移動到上方</h1><p>原本文章內的 tags 是顯示在版權下方，如要好像我這樣顯示在正文上方，在 <code>.\themes\Butterfly\layout\post.pug</code> 這個文件中，搜尋下面這段，把它移到至 block content 的下一行插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">block content</span><br><span class="line">  #post</span><br><span class="line">    # ==== 移動到這裡 ====</span><br><span class="line">    .tag_share</span><br><span class="line">        if (theme.post_meta.post.tags)</span><br><span class="line">          .post-meta__tag-list</span><br><span class="line">            each item, index in page.tags.data</span><br><span class="line">              a(href=url_for(item.path)).post-meta__tags #[=item.name]</span><br><span class="line">    # ========End========</span><br><span class="line">    if top_img === false</span><br><span class="line">      include includes/header/post-info.pug</span><br><span class="line"></span><br><span class="line">    article#article-container.post-content!=page.content</span><br><span class="line">    include includes/post/post-copyright.pug</span><br><span class="line">    </span><br><span class="line">      include includes/third-party/share/index.pug</span><br><span class="line">        </span><br><span class="line">    if theme.reward.enable &amp;&amp; theme.reward.QR_code</span><br><span class="line">      !=partial(&#x27;includes/post/reward&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line"></span><br><span class="line">    //- ad</span><br><span class="line">    if theme.ad &amp;&amp; theme.ad.post</span><br><span class="line">      .ads-wrap!=theme.ad.post</span><br><span class="line"></span><br><span class="line">    if theme.post_pagination</span><br><span class="line">      include includes/pagination.pug</span><br><span class="line">    if theme.related_post &amp;&amp; theme.related_post.enable</span><br><span class="line">      != related_posts(page,site.posts)</span><br><span class="line"></span><br><span class="line">    if page.comments !== false &amp;&amp; theme.comments &amp;&amp; theme.comments.use</span><br><span class="line">      - var commentsJsLoad = true</span><br><span class="line">      !=partial(&#x27;includes/third-party/comments/index&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">      </span><br></pre></td></tr></table></figure><h1 id="VScode-in-snippet">VScode in snippet</h1><p>如果想要輸入特定符號，以快速輸入常用代碼。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 例如輸入：!note --&gt;</span><br><span class="line">!info  </span><br><span class="line"></span><br><span class="line">&lt;!-- 會自動出現以下 --&gt;</span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/TWJHytI.png" alt=""></p><p>可以輸入<code>ctrl[commend] + p</code> 叫出視窗，輸入<code>&gt;</code> 後搜尋功能 <code>snippet</code>，然後選擇 <code>Configure User Snippets</code> 後編輯 <code>markdown.json</code> 的相關設定。<br><img src="https://i.imgur.com/WRdQpZX.png" alt=""><br><img src="https://i.imgur.com/oQYrES7.png" alt=""></p><p>以下是我的設定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// Place your snippets for markdown here. Each snippet is defined under a snippet name and has a prefix, body and </span></span><br><span class="line"><span class="comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span></span><br><span class="line"><span class="comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span></span><br><span class="line"><span class="comment">// same ids are connected.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="string">&quot;NoteInfo&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!info&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&#123;% note info %&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;$1&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;% endnote %&#125;&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Note info&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;NoteWarning&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!warning&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&#123;% note warning %&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;$1&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;% endnote %&#125;&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Note info&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;NoteDanger&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!danger&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&#123;% note danger %&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;$1&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;% endnote %&#125;&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Note info&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;NotePrimary&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!primary&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&#123;% note primary %&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;$1&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;% endnote %&#125;&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Note info&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;mermaid sequence&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!sequenceDiagram&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;&#123;% mermaid info %&#125;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sequenceDiagram&quot;</span>,</span><br><span class="line">  <span class="string">&quot;    participant U as User &quot;</span>,</span><br><span class="line">  <span class="string">&quot;    participant A as Device Agent&quot;</span>,</span><br><span class="line">  <span class="string">&quot;    U-&gt;&gt;+A: request&quot;</span>,</span><br><span class="line">  <span class="string">&quot;    A--&gt;&gt;-U: response&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&#123;% endmermaid %&#125;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;mermaid sequence&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;mermaid&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!mermaid&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;&#123;% mermaid info %&#125;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;$1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&#123;% endmermaid %&#125;&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;mermaid sequence&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;hideToggle&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!toggle&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&#123;% hideToggle %&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;$1&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;% endhideToggle %&#125;&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;Hide toggle&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;quote&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;!quote&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"><span class="string">&quot;&#123;% quote author link %&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;$1&quot;</span>,</span><br><span class="line"><span class="string">&quot;&#123;% endquote %&#125;&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;quote&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="latex-Katex-in-Butterfly-Theme-Hexo">latex - Katex in Butterfly Theme Hexo</h1><ul><li>Ref: <a href="https://www.wzhecnu.cn/2021/08/31/blog/math-tex/">https://www.wzhecnu.cn/2021/08/31/blog/math-tex/</a></li></ul><p>因為撰寫ML的相關技術文章，但是碰了不少壁，最後終於成功可以在文章中使用Latex撰寫。</p><ol><li>先下載和解除相關套件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 卸载 marked 插件</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 卸载 kramed 插件</span></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 安装渲染插件</span></span><br><span class="line">npm install @neilsustc/markdown-it-katex --save <span class="comment"># 安装katex插件</span></span><br></pre></td></tr></table></figure><ol start="2"><li>設定<code>_config.butterfly.yml</code></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KaTeX</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span> <span class="comment"># 如果使用 false 就要在每個 post 的標頭添加 katex: true </span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>我是參考到github上的<a href="https://github.com/jerryc127/hexo-theme-butterfly/issues/515">issues</a>，裡面偶然看到<a href="https://github.com/hexojs/hexo-renderer-markdown-it#options">hexo-renderer-makrdown-it</a>，才發現需要在 <code>_config.yml</code> 追加以下設定：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Katex</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&#x27;language-&#x27;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">&#x27;@neilsustc/markdown-it-katex&#x27;</span></span><br><span class="line">     <span class="attr">options:</span></span><br><span class="line">       <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">anchors:</span> </span><br><span class="line">    <span class="attr">level:</span> <span class="number">1</span> <span class="comment"># 這底是最重要的不然一級毛點會失效 </span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&#x27;header-anchor&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">  <span class="attr">images:</span></span><br><span class="line">    <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">prepend_root:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">post_asset:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">inline:</span> <span class="literal">false</span>  <span class="comment"># https://markdown-it.github.io/markdown-it/#MarkdownIt.renderInline</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在文章中啟用katex可以設定如下，更詳細的使用可以參考<a href="https://katex.org/docs/supported.html">katex</a>。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span></span><br><span class="line">---</span><br><span class="line">title: All basic concept of Mechine Learning - ML 的重點知識整理</span><br><span class="line"><span class="built_in">date</span>: 2023-09-30 11:36:29</span><br><span class="line">abbrlink: <span class="string">&#x27;ML&#x27;</span></span><br><span class="line">katex: <span class="literal">true</span> <span class="comment"># 設定為true如果你的_config.yml設定per_page是false</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">$\bar&#123;y&#125;$ <span class="comment">#要使用 $ 把公式包圍起來</span></span><br></pre></td></tr></table></figure><h1 id="調整-blog-中圖片大小">調整 blog 中圖片大小</h1><ul><li>Ref: <a href="https://github.com/bobcn/hexo_resize_image.js">https://github.com/bobcn/hexo_resize_image.js</a></li><li>Ref: <a href="https://bobcn.github.io/2018/03/24/hexo_reset_image_size/">https://bobcn.github.io/2018/03/24/hexo_reset_image_size/</a></li></ul><ol><li>先在自己的 <code>/source/js/</code> 底下建立一個 <code>hexo_resize_image.js</code> 檔案。</li><li>貼上以下內容：</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set_image_size</span>(<span class="params">image, width, height</span>) </span><br><span class="line">&#123;</span><br><span class="line">    image.<span class="title function_">setAttribute</span>(<span class="string">&quot;width&quot;</span>, width + <span class="string">&quot;px&quot;</span>);</span><br><span class="line">    image.<span class="title function_">setAttribute</span>(<span class="string">&quot;height&quot;</span>, height + <span class="string">&quot;px&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hexo_resize_image</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = imgs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> img = imgs[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> src = img.<span class="title function_">getAttribute</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fields = src.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=\?)\d*x\d*/g</span>);</span><br><span class="line">        <span class="keyword">if</span> (fields &amp;&amp; fields.<span class="property">length</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> values = fields[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (values.<span class="property">length</span> == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> width = values[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">var</span> height = values[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(width.<span class="property">length</span> &amp;&amp; height.<span class="property">length</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> n_width = img.<span class="property">naturalWidth</span>;</span><br><span class="line">                    <span class="keyword">var</span> n_height = img.<span class="property">naturalHeight</span>;</span><br><span class="line">                    <span class="keyword">if</span> (width.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        height = n_height*width/n_width;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (height.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        width = n_width*height/n_height;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">set_image_size</span>(img, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fields = src.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=\?)\d*/g</span>);</span><br><span class="line">        <span class="keyword">if</span> (fields &amp;&amp; fields.<span class="property">length</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> scale = <span class="built_in">parseFloat</span>(fields[<span class="number">0</span>].<span class="title function_">toString</span>());</span><br><span class="line">            <span class="keyword">var</span> width = scale/<span class="number">100.0</span>*img.<span class="property">naturalWidth</span>;</span><br><span class="line">            <span class="keyword">var</span> height = scale/<span class="number">100.0</span>*img.<span class="property">naturalHeight</span>;</span><br><span class="line">            <span class="title function_">set_image_size</span>(img, width, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = hexo_resize_image;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>_config.butterfly.yml</code> 做以下設置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/hexo_resize_image.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="mermaid-循序圖繪製">mermaid 循序圖繪製</h1><blockquote><p>參考：<a href="https://butterfly.js.org/posts/4aa8abbe/#tag-hide">https://butterfly.js.org/posts/4aa8abbe/#tag-hide</a></p></blockquote><p>使用mermaid標籤可以繪製Flowchart（流程圖）、Sequence diagram（時序圖 ）、Class Diagram（類別圖）、State Diagram（狀態圖）、Gantt（甘特圖）和Pie Chart（圓形圖），具體可以查<a href="https://mermaid-js.github.io/mermaid/#/">mermaid文檔</a></p><p>主題配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail!</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    John-&gt;&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;&gt;John: Jolly good!</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant Alice    participant Bob    Alice-&gt;&gt;John: Hello John, how are you?    loop Healthcheck        John-&gt;&gt;John: Fight against hypochondria    end    Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail!    John--&gt;&gt;Alice: Great!    John-&gt;&gt;Bob: How about you?    Bob--&gt;&gt;John: Jolly good!  </pre></div><h1 id="hidden-toggle">hidden toggle</h1><blockquote><p>參考：<a href="https://butterfly.js.org/posts/4aa8abbe/#tag-hide">https://butterfly.js.org/posts/4aa8abbe/#tag-hide</a></p></blockquote><p>( display 不能包含英文逗號，可用‚)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% hideToggle Butterfly安裝方法 %&#125;</span><br><span class="line">在你的博客根目錄裏</span><br><span class="line"></span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"></span><br><span class="line">如果想要安裝比較新的dev分支，可以</span><br><span class="line"></span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"></span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><details class="toggle" ><summary class="toggle-button" style="">Butterfly安裝方法</summary><div class="toggle-content"><p>在你的博客根目錄裏</p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p><p>如果想要安裝比較新的dev分支，可以</p><p>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p></div></details><h1 id="URL網址連結-abbrlink">URL網址連結 abbrlink</h1><blockquote><p>hexo 默認生成的文章地址路徑是 【網站名稱／年／月／日／文章名稱】<br>這種鏈接對搜索爬蟲是很不友好的，第一它的 url 結構超過了三層，太深了。</p><footer><strong>@Qmike</strong><cite><a href="https://qmike.top/posts/2a1b5a62">參考連結</a></cite></footer></blockquote><p>Step1: 安裝 abbrlink 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>Step2: 修改 hexo 根目錄下 <code>config.yml</code> 中的 <code>permalink</code> 的值：</p><ul><li>插件可以參考<a href="https://github.com/rozbo/hexo-abbrlink">官方文檔</a>。</li><li>作用是將文章的鏈接轉換成數字後字母，即將博客網站的網頁轉成.html 永久鏈接的格式，有利於搜索引擎的收錄。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://shannonhung.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br></pre></td></tr></table></figure><p>Step3: 在 config.yml 最底下添加 abbrlink config</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment"># support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment"># support dec(default) and hex</span></span><br><span class="line"><span class="comment"># 不用添加其它代碼</span></span><br></pre></td></tr></table></figure><p>Check: 配置完成後，網站的鏈接應該類似這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qmike.top/posts/77940e6f.html        # 有.html後綴 </span><br></pre></td></tr></table></figure><h1 id="客製化css樣式設定">客製化css樣式設定</h1><blockquote><p>前提是你使用Butterfly的template</p></blockquote><ol><li>先於 專案的根目錄建立 /source/css/style.css (不是theme的喔，因為我希望盡量跟theme解開耦合，才方便更新)</li><li>建立好後，去 _config.butterfly.yml 檔案做以下設定，目的是為了引用剛剛建立的style.css</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/style.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>然後開始設定css</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>, <span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠標樣式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/default.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/pointer.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滾動條樣式 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">    transparent <span class="number">75%</span>,</span><br><span class="line">    transparent</span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="post-title">post/title</h1><h2 id="樣式設計">樣式設計</h2><ol><li>前往<code>_config.butterfly.yml</code>設置以下內容，<code>prefix-icon</code>可以參考<a href="https://fontawesome.com/v5/cheatsheet">fontawesome</a>網站，並且貼上unicode。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># site/post</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f52d&#x27;</span> <span class="comment"># &#x27;\f0c1&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&#x27;#F47466&#x27;</span>  <span class="comment"># &#x27;#F47466&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>就會有以下效果囉：滑鼠點擊過去會反白<br><img src="https://i.imgur.com/eT3MdCA.png" alt=""></li></ol><h1 id="複製連結-錨點">複製連結+錨點</h1><ol><li>如果想要title有錨點可以供別人進行複製，可以做以下設定</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="attr">anchor:</span></span><br><span class="line">  <span class="attr">button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">always_show:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">&#x27;\f0c1&#x27;</span> <span class="comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span></span><br><span class="line">  <span class="attr">auto_update:</span> <span class="literal">true</span> <span class="comment"># when you scroll in post, the URL will update according to header id.</span></span><br></pre></td></tr></table></figure><ol start="2"><li>就會有以下效果囉：可以複製當前的錨點<br><img src="https://i.imgur.com/Cn3qgYh.png" alt=""></li></ol><h1 id="留言板功能">留言板功能</h1><h2 id="github-建立-client-app">github 建立 client app</h2><ol><li>前往自己github頁面<code>/Setting/Developer Setting</code>(在旁邊sidebar最下面)</li><li>先去建立<code>OAuth Application</code><br><img src="https://i.imgur.com/82HFDmz.png" alt=""></li><li>創建完成，取得Client ID和Client secrets，第一次創建application需要點擊Generate a new client secret來生成第一個secret</li></ol><h2 id="config-butterfly-yml設定gitalk與啟用">_config.butterfly.yml設定gitalk與啟用</h2><ul><li>client_id—你的Client ID</li><li>client_secret—你的Client secrets</li><li>repo—你的公開靜態網頁repo名稱</li><li>owner—你的帳號名稱</li><li>admin—你的帳號名稱</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitalk</span></span><br><span class="line"><span class="comment"># https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">shannonhung.github.io</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">ShannonHung</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">ShannonHung</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><blockquote><p>以gitalk啟用留言系統</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Gitalk</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Pag</span></span><br></pre></td></tr></table></figure><h2 id="front-matter啟用留言板">front-matter啟用留言板</h2><p>在butterfly Front-matter的comments變數設定true or false(啟用/關閉)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="不同樣式的Quote">不同樣式的Quote</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>default 提示块标籤</p></div><div class="note primary no-icon flat"><p>primary 提示块标籤</p></div><div class="note success flat"><p>success 提示块标籤</p></div><div class="note info flat"><p>info 提示块标籤</p></div><div class="note warning flat"><p>warning 提示块标籤</p></div><div class="note danger flat"><p>danger 提示块标籤</p></div><h1 id="如何改變自己css？">如何改變自己css？</h1><ol><li><p>請在 <code>source</code> 底下建立 <code>style.css</code></p><ul><li>建立完後檔案會放置在： <code>source/css/style.css</code></li></ul></li><li><p>在 <code>_config.butterfly.yml</code> 中複寫以下資訊：</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/style.css&quot;&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>如果你想要我主體中的一些樣式可以參考…</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景渐变 */</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">225deg</span>, <span class="number">#edd5bd6f</span> <span class="number">0%</span>, <span class="number">#f9c7998d</span> <span class="number">48%</span>, <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>, <span class="number">0.149</span>) <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* footer */</span></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>, <span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 粗體字 特效 */</span></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 斜線 */</span></span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;light&quot;</span>]</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="comment">/* bold */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.3rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">180deg</span>, transparent <span class="number">50%</span>, <span class="number">#fdda5a</span> <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="comment">/* bold */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0.2rem</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">180deg</span>, transparent <span class="number">0%</span>, <span class="number">#fdda5a</span> <span class="number">0%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠標樣式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/default.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/pointer.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滾動條樣式 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">    transparent <span class="number">75%</span>,</span><br><span class="line">    transparent</span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="幫你的post添加背景">幫你的post添加背景</h1><ol><li><p>可以去 unsplash 找一張圖片!上面有圖片的 code<br><img src="https://i.imgur.com/m9AEQQK.png" alt=""></p></li><li><p>開新的分頁，輸入 <code>https://source.unsplash.com/圖片的code</code>，他會幫你引導到新的圖片網址，複製那個圖片網址。</p></li><li><p>貼上post上面的header</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 一次搞懂Java中的equals()和hashCode()</span><br><span class="line">abbrlink: equals-hashCode</span><br><span class="line">date: 2023-06-20 15:21:48</span><br><span class="line">cover: &#123;貼在這裡&#125; ＃貼這裡</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Java</span><br><span class="line"><span class="bullet">  -</span> 物件導向</span><br><span class="line"><span class="section">categories: [&quot;Code&quot;, &quot;Java&quot;]</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h1 id="主要參考了哪些網站">主要參考了哪些網站</h1><ul><li><a href="https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E5%BB%BA%E7%AB%8B-Hexo-%E5%B0%88%E6%A1%88-1">最一開始</a></li><li><a href="https://blog.boshkuo.com/hexo-advanced-supplementary-3/">用來設置butterfly的相關樣式</a></li><li><a href="https://israynotarray.com/hexo/20201012/473855281/">為了能方便用vscode貼上圖片</a></li><li><a href="https://hexo.io/zh-cn/docs/asset-folders.html">貼上相關圖片用</a></li><li><a href="https://blog.boshkuo.com/hexo-from-scratch-7/">Google Analysis</a><ul><li>需要注意的是因為我使用<a href="https://butterfly.js.org/">Butterfly Theme</a>所以設置相對簡單，只需要去<code>_config.butterfly.yml</code> 尋找key: <code>google_analytics</code> 並且把id貼上即可</li><li>設定_config.butterfly.yml 的教學可以<a href="https://butterfly.js.org/posts/21cfbf15/#%E5%8D%87%E7%B4%9A%E5%BB%BA%E8%AD%B0">參考這篇</a></li></ul></li><li>sitemap配置相關參考文章<ul><li><a href="https://qmike.top/posts/2a1b5a62">https://qmike.top/posts/2a1b5a62</a></li><li><a href="https://blog.boshkuo.com/hexo-advanced-supplementary-5/">https://blog.boshkuo.com/hexo-advanced-supplementary-5/</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料分析概念大全 - TF, IDF, TF-IDF, Text Classification 樣樣來</title>
      <link href="/posts/text-classification/"/>
      <url>/posts/text-classification/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>一句話解釋TF-IDF『<strong>用來從一段文字/一個語料庫中，給越重要的字詞/文檔，越高的加權分數</strong>』</p></div><h1 id="TF-IDF">TF-IDF</h1><p>你看，TF - IDF ，前面的TF是Term Frequency的縮寫，後面的IDF是Inverse Document Frequency的縮寫，合在一起則說明了它如何計算出誰是相對比較重要的字詞。</p><p><img src="https://i.imgur.com/FT5iUuJ.png" alt=""></p><ul><li><code>TF-IDF</code> 有點像是互相牽制的感覺，前面的TF是Term Frequency的縮寫，後面的IDF是Inverse Document Frequency的縮寫。</li><li>綜合兩個公式值相乘，便得到我們今天介紹的TF-IDF值</li></ul><p><img src="https://i.imgur.com/9fSEYIP.png" alt=""></p><div class="note info flat"><p>字詞的<strong>重要性</strong>隨著 在<strong>文本出現的頻率越高</strong>則越<strong>高</strong>(TF)；在<strong>不同文本檔案間出現的次數越高</strong>則反而<strong>降低</strong>(DF)。<br><code>更白話一點</code>：<em>一個單字在一篇文章中出現的次數越多，那麼這個單字就越重要，但是如果這個單字在其他文章中也出現很多次，那麼這個單字就越不重要</em>。</p></div><h2 id="Term-Frequency-tf">Term Frequency (tf)</h2><p><img src="https://i.imgur.com/834Qtdk.png" alt=""><br>上圖取自：<a href="https://medium.com/datamixcontent-lab/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90%E5%85%A5%E9%96%80-%E6%A6%82%E5%BF%B5%E7%AF%87-%E7%B5%A6%E6%88%91%E4%B8%80%E6%AE%B5%E8%A9%B1-%E6%88%91%E5%91%8A%E8%A8%B4%E4%BD%A0%E9%87%8D%E9%BB%9E%E5%9C%A8%E5%93%AA-%E5%B0%8D%E6%96%87%E6%9C%AC%E9%87%8D%E9%BB%9E%E5%AD%97%E8%A9%9E%E5%8A%A0%E6%AC%8A%E7%9A%84tf-idf%E6%96%B9%E6%B3%95-f6a2790b4991">【資料分析概念大全｜認識文本分析】對文本重點字詞加權的TF-IDF方法</a></p><p>我們先把拆解出來的每個詞在各檔案出現的次數，一一列出，組成矩陣。</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>t</mi><mo separator="true">,</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">{n_{t,d}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 是詞t在文件d中出現的次數</li></ul><div class="note info flat"><p>『詞1』在『文件1』的TF值算出來時<br><em>『詞1在文件1出現的次數』除以『文件1中所有詞出現次數的總和(可說是總字數)』</em><br>= <strong>這個<code>單字數量</code>在文件1中<code>所有的文字</code>，所佔的比例</strong>。</p></div><p><strong>可不可以把 TF 當作 Weight 來看呢？</strong></p><ul><li>當然可以，那我們還是仍要取 log 來避免極端值影響太大。<br><img src="https://i.imgur.com/7RQgStQ.png" alt=""></li></ul><h2 id="Inverse-Document-Frequency-IDF">Inverse Document Frequency (IDF)</h2><p><img src="https://i.imgur.com/Hl6XNf2.png" alt=""><br>上圖取自：<a href="https://medium.com/datamixcontent-lab/%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90%E5%85%A5%E9%96%80-%E6%A6%82%E5%BF%B5%E7%AF%87-%E7%B5%A6%E6%88%91%E4%B8%80%E6%AE%B5%E8%A9%B1-%E6%88%91%E5%91%8A%E8%A8%B4%E4%BD%A0%E9%87%8D%E9%BB%9E%E5%9C%A8%E5%93%AA-%E5%B0%8D%E6%96%87%E6%9C%AC%E9%87%8D%E9%BB%9E%E5%AD%97%E8%A9%9E%E5%8A%A0%E6%AC%8A%E7%9A%84tf-idf%E6%96%B9%E6%B3%95-f6a2790b4991">【資料分析概念大全｜認識文本分析】對文本重點字詞加權的TF-IDF方法</a></p><p><strong>如果經過TF的計算，此時發現有兩個單詞a, b兩個都在文件1中出現了相同的次數，我們該如何知道哪個單詞更重要呢？</strong></p><ul><li>其實，這時候就要用到IDF的概念了。</li><li>我們還要考慮到 a, b 兩個單詞<em>在其他文件中出現的次數</em>。</li><li>假設，檔案1 有兩個單字 “and” 跟 “company A” 兩個單字非常頻繁的在檔案1中出現，tf 值都相同。<ul><li>但是 “and” 不僅僅在 檔案 1 出現，基本上其他檔案都出現他的身影，所以 “and” 就不是一個重要的單字</li><li>而 “company A” 只在檔案1中出現，所以 “company A” 儘管與 “and” 數量相同，但是 “company A” 更為獨特，因為只出現在檔案1中。</li></ul></li></ul><p>如下圖：可以發現 calpurnia 這個單字指出現在某個特定檔案，所以代表他很特別，所以他的 IDF 值會很高。<br><img src="https://i.imgur.com/FBkgCZV.png" alt=""></p><div class="note info flat"><p>IDF 有點像是<strong>代表性</strong>的感覺<br><em>由『文章數總和(D)』除以『該字詞出現過的文章篇數(dt)』後，取log值</em><br>= <strong>這個單字在這個檔案中的獨特性，因為其他檔案很少出現</strong></p><p>Note: 實際應用中為了避免分母=0，因此通常分母會是dt+1。</p></div><div class="note warning flat"><p><em>IDF之所以取log的原因?</em><br>取log是為了<strong>不讓極端值影響太大</strong>，如果今天文章總和數D很大，而某個詞指出現在一篇文章中，那麼這個詞的IDF值就會很大，這樣的情況下，取log可以讓這個值變得更小，避免極端值影響太大。</p></div><h1 id="Text-Classification-TC">Text Classification (TC)</h1><p>文本分類的目標是通過學習算法，基於訓練數據中的<code>特徵</code>和<code>標籤</code>，構建一個能夠自動將新文檔正確<code>分類</code>的模型。<br><em>有些分類具階層性，有些可能屬多個分類</em> 這在信息檢索、情感分析、垃圾郵件過濾等眾多應用中具有廣泛的應用價值。分類的方式主要可以分為：</p><ul><li><strong>人工分類 Manual Classification</strong>：靠專家分類會很準，但是當資料量大的時候人工判斷會有主觀不同的問題。</li><li><strong>規則式分類 Rule-Based Systems</strong>：使用布林條件，例如 (文化創意 | 文創) → 歸於文化類</li><li><strong>統計機率式 Statistical/Probabilistic Methods</strong>：使用機率模型，例如 Naive Bayes、SVM、KNN、Decision Tree、Random Forest、XGBoost、LightGBM、CatBoost 等等。</li></ul><p>接下來我們會針對幾個常見的統計機率式方法來進行介紹。</p><h2 id="Naive-Bayes">Naive Bayes</h2><ul><li>Ref: <a href="https://medium.com/%E5%B1%95%E9%96%8B%E6%95%B8%E6%93%9A%E4%BA%BA%E7%94%9F/python%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92-110-%E5%96%AE%E7%B4%94%E8%B2%9D%E6%B0%8F%E5%88%86%E9%A1%9E%E5%99%A8-50cdd9ce16f7">【Python機器學習】110：簡單貝氏分類器介紹及其應用</a></li><li>Ref: <a href="https://youtu.be/O2L2Uv9pdDA?si=9Hc5wr-wUEVV8eI-">Youtube | Naive Bayes, Clearly Explained!!!</a></li></ul><p>我覺得直接看例子比較快，以下是一個簡單的例子：</p><ul><li>假設我們想要把垃圾郵件和非垃圾郵件分類</li><li>我們先收集垃圾郵件 跟 非垃圾 郵件的所有拆好的單字</li><li>然後我們要計算 每個單字 分別在 垃圾郵件 跟 非垃圾郵件 出現的機率</li></ul><p>從下圖可以看到，先計算每個單字在非垃圾郵件的機率 <code>P(Dear | N)</code> Dear 是出現的文字，N 是非垃圾郵件中，所有單字的總數。</p><ul><li>Dear 在非垃圾郵件中所有的單字裡面，出現了 8 次，表示 <code>P(Dear | N) = 8/20 = 0.4</code><br><img src="https://i.imgur.com/rrCyUG4.png" alt=""></li></ul><p>然後我們就可以獲得，每個單字，分別在垃圾郵件和非垃圾郵件中的機率。<br><img src="https://i.imgur.com/CX9Craj.png" alt=""></p><p><strong>那現在我們收到一個新的郵件，我們要判斷這個郵件是垃圾郵件還是非垃圾郵件。</strong></p><ul><li>新郵件的內容是 <code>Dear Friend</code></li><li>我們先計算這個郵件是非垃圾郵件的機率 <code>P(Normal | Dear Friend)</code> 跟 <code>P(Spam | Dear Friend)</code></li></ul><p>這邊我們就可以使用貝氏定理來計算<code>P(Normal | Dear Friend)</code>，我們看到<code>Dear Friend</code> 的信件他是<code>非垃圾</code>郵件的機率是多少？</p><ul><li><code>P(N) = 8 / 12 = 0.67</code></li><li><code>P(Normal | Dear Friend) = P(Dear | N) * P(Friend | N) * P(N) = 0.47 * 0.29 * 0.67 = 0.09</code><br><img src="https://i.imgur.com/HTgrJJ0.png" alt=""></li></ul><p>用同樣的方式，這邊我們也可以使用貝氏定理來計算<code>P(Spam | Dear Friend)</code>，我們看到Dear Friend 的信件他是<code>垃圾郵件</code>的機率是多少？</p><ul><li><code>P(S) = 4 / 12 = 0.33</code></li><li><code>P(Spam | Dear Friend) = P(Dear | S) * P(Friend | S) * P(S) = 0.29 * 0.14 * 0.33 = 0.013</code><br><img src="https://i.imgur.com/euzpebb.png" alt=""></li></ul><p>最後我們可以比較 <code>P(Normal | Dear Friend)</code> 跟 <code>P(Spam | Dear Friend)</code>，看哪個機率比較高，就可以判斷這封信是垃圾郵件還是非垃圾郵件。這裡的例子中，<code>P(Normal | Dear Friend)</code> 比 <code>P(Spam | Dear Friend)</code> 高，所以這封信是非垃圾郵件。</p><h3 id="注意事項">注意事項</h3><p>但是如果我們今天看到另一個例子<code>Lunch Money Money Money Money</code> 這封信是垃圾郵件還是非垃圾郵件？<br><em>用一樣的方式計算的話會發現，因為 <code>P(Lunch|S)</code> 是 0 所以會導致 <code>P(Spam | Lunch Money Money Money Money)</code> 也是 0</em><br><img src="https://i.imgur.com/xWMk1MO.png" alt=""><br><img src="https://i.imgur.com/FQG8pn3.png" alt=""></p><p>為了解決這個問題，<em>我們至少要把每個單字的機率設定一個最小值，這樣就不會出現 0 的情況</em>。<br><img src="https://i.imgur.com/l0Gvn4p.png" alt=""><br>然後重新計算每個單詞在不同類別時的機率。<br><img src="https://i.imgur.com/mVxs8OB.png" alt=""><br><img src="https://i.imgur.com/9t7h60a.png" alt=""></p><h3 id="優缺點">優缺點</h3><p><strong>使用 Naive Based 有什麼樣的問題？為什麼稱它為 Naive?</strong></p><ul><li><em>單字的組成順序不影響結果</em>，從下面例子可以看到 Dear Friend 跟 Friend Dear 他們的機率是一樣的。</li><li>這導致在處理一些需要文法規則的語言時，效果不佳。</li><li>因為 Naive Bayes 對待每個單字就像是獨立的一樣，<em>就是一個 a bag full of words 的概念</em>。</li><li>稱它為 Naive 是<em>因為他太過於簡單，對於一些複雜的問題，效果不佳</em>。</li></ul><p><img src="https://i.imgur.com/1MrfKjG.png" alt=""></p><p><strong>但是Naive Bayes 也並非如此 Naive</strong></p><ul><li>Naive Bayes 在某些競賽中獲勝（例如，KDD-CUP 97）</li><li>對非相關特徵的魯棒性強於一些更複雜的學習方法：Naive Bayes 能夠有效處理包含大量非相關特徵的數據集，這在某些情況下比更複雜的算法更具優勢。</li><li>對概念漂移（隨時間變化的類別定義）更具魯棒性：Naive Bayes 對於隨時間變化的數據（如類別定義變化）的適應能力較強，這使得它在動態環境中也能保持良好的性能。</li><li>Naive Bayes 對於具有多個同等重要特徵的數據集，比如決策樹這類方法更具優勢。</li><li>對於文本分類來說，<em>是一個可靠的基線（但不是最好的）</em></li><li><em>Naive Bayes 假設特徵之間是獨立的</em>，如果這個假設成立，則 Naive Bayes 算法是最優的。雖然這個假設在文本分類中通常不成立，但在其他一些領域中是成立的</li><li>Naive Bayes 算法學習過程非常高效，只需要一次遍歷數據即可完成。測試過程中的計算量與屬性數量和文檔集合大小呈線性關係，這使得它在大數據集上也能快速運行。</li><li>Naive Bayes 算法需要的存儲空間很少，這在資源有限的環境中是一個很大的優勢。</li></ul><h2 id="Gaussian-Naive-Bayes">Gaussian Naive Bayes</h2><p><strong>是 Naive Bayes 的一個變種，主要是用在連續型的資料上</strong>，例如身高、體重等等。<br>以下面的例子來說，我們有兩個全體的資料，一個是喜歡Troll，一個是不喜歡Troll。</p><ul><li>我們把喜歡Trolls的人，他們也喜歡Popcorn, Soda, Candy 的分佈畫出來 (下圖綠色的部分)</li><li>再來把不喜歡Trolls的人，他們也喜歡Popcorn, Soda, Candy 的分佈畫出來 (下圖紅色的部分)<br><img src="https://i.imgur.com/ycsfh5u.png" alt=""></li></ul><h3 id="例子">例子</h3><p>接下來有一個人，<em>他吃了 20g 的Popcorn, 500ml 的Soda, 25g 的Candy，我們要判斷他是喜歡Trolls還是不喜歡Trolls</em>。<strong>我們先假設這個人是喜歡Trolls，我們可以計算他的機率</strong></p><ul><li><code>P(Like Troll2 | Popcorn, Soda, Candy) = P(Popcorn | Like Troll2) * P(Soda | Like Troll2) * P(Candy | Like Troll2) * P(Like Troll2)</code>。</li><li><code>P(Like Troll2) = 8 / 16 = 0.5</code> (下圖1)</li><li>然後把 Popcorn, Soda, Candy 的機率帶入，但是因為 Candy 的機率非常非常小，小到會變成 0，所以<em>我們要使用 log 來避免Underflow</em>。<br><img src="https://i.imgur.com/zgl7nnG.png" alt=""><br><img src="https://i.imgur.com/zf1ciLp.png" alt=""><br><img src="https://i.imgur.com/TPH9yRv.png" alt=""><br><img src="https://i.imgur.com/1LlEMGZ.png" alt=""></li></ul><p><strong>我們先假設這個人是不喜歡Trolls，我們可以計算他的機率</strong></p><ul><li><code>P(Unlike Troll2 | Popcorn, Soda, Candy) = P(Popcorn | Unlike Troll2) * P(Soda | Unlike Troll2) * P(Candy | Unlike Troll2) * P(Unlike Troll2)</code>。</li><li><code>P(Unlike Troll2) = 8 / 16 = 0.5</code> (下圖1)</li><li>然後把 Popcorn, Soda, Candy 的機率帶入，但是因為 Candy 的機率非常非常小，小到會變成 0，所以我們要使用 log 來避免Underflow。<br><img src="https://i.imgur.com/E8Xk2ni.png" alt=""></li></ul><p><img src="https://i.imgur.com/RoeParA.png" alt=""></p><h2 id="NB-與-Gaussian-NB-差異">NB 與 Gaussian NB 差異</h2><table><thead><tr><th>特性</th><th>Naive Bayes</th><th>Gaussian Naive Bayes</th></tr></thead><tbody><tr><td>一般性</td><td>通用的分類器，適用於不同類型的特徵</td><td>Naive Bayes 的特例，專門用於連續型特徵</td></tr><tr><td>特徵類型</td><td>離散特徵或連續特徵</td><td>連續特徵</td></tr><tr><td>分佈假設</td><td>可以使用不同的概率分佈模型（如多項式、伯努利）</td><td>假設特徵值服從高斯分佈</td></tr><tr><td>常見應用</td><td>文本分類、垃圾郵件過濾等</td><td>根據連續特徵（如身高和體重）進行分類</td></tr></tbody></table><h1 id="K-Nearest-Neighbors-KNN">K Nearest Neighbors (KNN)</h1><p>簡單來說就是，<strong>挑最近的 k 個鄰居出來統計 (投票)，看最多人屬哪一類，自己標成那一類</strong><br><img src="https://i.imgur.com/ESGbkKH.png" alt=""></p><table><thead><tr><th><strong>特性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>類型</td><td>kNN 是一種<em>向量空間分類方法</em>。</td></tr><tr><td>簡單性</td><td>它非常簡單且易於實現。</td></tr><tr><td>準確性</td><td>在大多數情況下，<em>kNN 比 Naive Bayes 和其他方法更準確</em>。</td></tr><tr><td>迅速性</td><td>如果你需要在短時間內得到一個相當準確的分類器……</td></tr><tr><td>效率</td><td>……並且不太在乎效率的話可以使用kNN……</td></tr><tr><td><strong>時間複雜度</strong></td><td></td></tr><tr><td>測試時間</td><td><em>kNN 的測試時間與訓練集的大小成正比</em>。訓練集越大，分類測試文檔所需的時間越長。</td></tr><tr><td>效率</td><td>kNN 對於非常大的訓練集來說效率低下。</td></tr><tr><td>訓練需求</td><td>無需訓練。</td></tr><tr><td>預處理</td><td>但<em>文檔的線性預處理與訓練 Naive Bayes 同樣昂貴</em>。</td></tr><tr><td>訓練時間</td><td>我們總是對訓練集進行預處理，所以實際上 kNN 的訓練時間是線性的。</td></tr><tr><td>訓練集大小與準確性</td><td>如果<em>訓練集很大，kNN 非常準確。如果訓練集很小，kNN 可能非常不準確</em>。</td></tr><tr><td>概率轉換</td><td>kNN 的分數很難轉換為概率。</td></tr><tr><td>更穩健的替代方法</td><td>更穩健的替代方法是找到 k 個最相似的示例，並返回這些 k 個示例中的多數類別。k 的值通常取奇數以避免平局；3 和 5 是最常見的。</td></tr></tbody></table><h1 id="Support-Vector-Machine-SVM">Support Vector Machine (SVM)</h1><ul><li>Ref: <a href="https://medium.com/@elvennote/%E6%94%AF%E6%8F%B4%E5%90%91%E9%87%8F%E6%A9%9F-support-vector-machine-796cb18886eb">支援向量機(Support Vector Machine)</a><br>SVM的目標是<strong>找到一個最佳的超平面（在二維空間中就是一條直線），將不同類別的數據分開</strong>。這條超平面應該使得兩個不同類別的數據點距離超平面的間隔最大化，這些距離稱為邊界（margin），如下圖。<br><img src="https://i.imgur.com/V12HzXw.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
            <tag> Text Classification </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
