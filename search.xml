<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo - Butterfly 版本的語言切換功能設置</title>
      <link href="/posts/hexo-butterfly-lang-switch/"/>
      <url>/posts/hexo-butterfly-lang-switch/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因為求職需求，需要把網站轉換成英文，但是也想保留中文，開始尋找方法可以做中英文切換。<br>剛好看到 <a href="https://butterfly.js.org/">Hexo - Butterfly 官方網站</a>，發現他們的網站就有中英文切換的功能，但是找遍了各個網站都沒有人說明。<br>所以只好看source code來了解是怎麼做的。</p><p>奮鬥了 2 天，終於找到方法了，以下是我整理的方法。</p><h1 id="Step-1-開設一個-private-en-repository">Step 1. 開設一個 private en repository</h1><ul><li>參考：<a href="https://www.igerm.ee/experience/%E5%AE%8C%E7%BE%8E%E7%9A%84Hexo%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">完美的Hexo多语言解决方案</a></li></ul><p>靈感主要參考上述連結，主要運作原理就是透過<a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#">建立多個 GitHub Pages</a>，基本上會有一個專門運行中文的 repository，另外再開設一個專門運行英文的 repository，透過設定不同的 <code>config.yml</code> 和 <code>_config.butterfly.yml</code>來達到中英文切換的效果。</p><blockquote><p>以下是我建立的兩個 repository<br><img src="https://i.imgur.com/2D3inpr.png" alt=""></p></blockquote><blockquote><p>建立特定語言的 GitHub Pages<br><img src="https://i.imgur.com/6Q2AQkO.png" alt=""></p></blockquote><h1 id="Step-2-設置-config">Step 2. 設置 config</h1><p>先建立一個 <code>config-en.yml</code>，內容可以跟<code>_config.yml</code>一樣，只是要做以下設定。</p><blockquote><p>config-en.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定成英文</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 en </span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://butterfly.js.org/en</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/en/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定啟動的路徑</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source-en</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public-en</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把中文的 source 進行排除</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">source/</span></span><br></pre></td></tr></table></figure><blockquote><p>_config.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定成中文 </span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-TW</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用原本的url</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://shannonhung.github.io</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定啟動的路徑</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把英文的 source 進行排除</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line"><span class="attr">exclude:</span></span><br><span class="line"><span class="attr">ignore:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">source-en/</span></span><br></pre></td></tr></table></figure><h1 id="Step-3-設定-切換語言的-js">Step 3. 設定 切換語言的 js</h1><ul><li>參考：<a href="https://github.com/jerryc127/butterfly.js.org/blob/main/source/self/btf.js">https://github.com/jerryc127/butterfly.js.org/blob/main/source/self/btf.js</a></li></ul><p>我是在這個<a href="https://github.com/jerryc127/butterfly.js.org/blob/main/source/self/btf.js">btf.js</a>看到的，你可以在 <code>source/self</code> 中建立這個 <code>btf.js</code>，內容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判斷是否為英文</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isIncludeEN</span> = item =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">&#x27;/en/&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">includes</span>(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立 重新導向到不同語言的 url </span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">loadFullPage</span> = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = url</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新導向 </span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">eventFn</span> = (<span class="params">elements, includeEN</span>) =&gt; &#123;</span><br><span class="line">    elements.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!includeEN || !<span class="title function_">isIncludeEN</span>(item.<span class="property">href</span>)) &#123;</span><br><span class="line">        item.<span class="property">href</span> = <span class="string">`javascript:loadFullPage(&#x27;<span class="subst">$&#123;item.href&#125;</span>&#x27;);`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判斷目前是否為英文</span></span><br><span class="line">  <span class="keyword">const</span> nowIncludeEN = <span class="title function_">isIncludeEN</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 這邊記得改成你的 url</span></span><br><span class="line">  <span class="keyword">const</span> selector = nowIncludeEN</span><br><span class="line">    ? <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a[href^=&quot;https://ShannonHung.github.io&quot;]&#x27;</span>)</span><br><span class="line">    : <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;a[href^=&quot;/en/&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eventFn</span>(selector, nowIncludeEN)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h1 id="Step-4-建立-source-en-資料夾">Step 4. 建立 source-en 資料夾</h1><p>接下來很重要的一步，那就是把整個 source 資料夾複製，並且重新命名為 <code>source-en</code>，並且把 <code>btf.js</code> 放到 <code>source-en/self</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">├── source-en <span class="comment"># &lt;== here </span></span><br><span class="line">├── themes</span><br><span class="line">├── _config.butterfly.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── config-butterfly-en.yml </span><br><span class="line">├── config-en.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><h1 id="Step-5-設定-Butterfly-config">Step 5. 設定 Butterfly config</h1><p>請先複製 _config.butterfly.yml，並且重新命名為 <code>config-butterfly-en.yml</code>，並設定 Butterfly config 需要引入剛剛建立的 <code>btf.js</code>，還有網站的目錄：</p><blockquote><p>_config.butterfly.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">找文章||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="string">目錄:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">    <span class="string">標籤:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="string">文章:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">首頁:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">關於我:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="string">相關連結:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="comment"># 添加以下內容</span></span><br><span class="line">  <span class="string">語言||fas</span> <span class="attr">fa-language:</span> </span><br><span class="line">    <span class="attr">English:</span> <span class="string">/en/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-e</span></span><br><span class="line">    <span class="string">中文:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-c</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/btf.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>config-butterfly-en.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Archives: /archives/ || fas fa-archive</span></span><br><span class="line">  <span class="attr">Categroies:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">Find</span> <span class="string">Posts</span> <span class="string">||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="attr">By Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="attr">By Posts:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">Home Page:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">About Me:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br><span class="line">  <span class="attr">Links:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="comment"># 以下網址記得修改成你的</span></span><br><span class="line">  <span class="string">Language||fas</span> <span class="attr">fa-language:</span></span><br><span class="line">    <span class="attr">English:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-e</span></span><br><span class="line">    <span class="string">中文:</span>  <span class="string">https://ShannonHung.github.io/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-c</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/self/btf.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Step-6-更新-package-json">Step 6. 更新 package.json</h1><p>最後一步，就是更新 <code>package.json</code>，讓他可以產生<code>public-en</code>的資料夾，以便後續推到 repository en 中。</p><blockquote><p>pcakage.json</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;push&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo douban &amp;&amp; gulp &amp;&amp; hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;show&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;update&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git init &amp;&amp; git add . &amp;&amp; git commit -m &#x27;backup&#x27; &amp;&amp; git push origin main&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kk&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;en&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo g --config config-en.yml &amp;&amp; hexo s --config config-en.yml&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我們先執行以下指令，讓他基於 <code>config-en.yml</code> 的設定檔建立 <code>public-en</code> 資料夾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run en </span><br></pre></td></tr></table></figure><p>接著應該會有以下架構：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">├── public-en <span class="comment"># &lt;== here 這個要產生</span></span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">├── source-en</span><br><span class="line">├── themes</span><br><span class="line">├── _config.butterfly.yml</span><br><span class="line">├── _config.yml</span><br><span class="line">├── config-butterfly-en.yml</span><br><span class="line">├── config-en.yml</span><br><span class="line">├── db.json</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>我們先推目前的網站到 repository 中，但是注意的是，執行以下程式運行的是<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</code>，所以他的config是<code>_config.yml</code>，所以他會推到 repository <code>shannonhung.github.io</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run kk</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>如果你想要測試 English 的網站可以執行 <code>hexo clean &amp;&amp; hexo g --config config-en.yml &amp;&amp; hexo s --config config-en.yml</code> 讓他專門產生 <code>public-en</code> 的資料夾，並且基於 <code>config-en.yml</code> 的設定檔案執行。<strong>只是注意的是運行的還是_config.butterfly.yml，所以首頁目錄還是中文喔！</strong></p><p>但是不用擔心，因為如果我們要部署到 en repository 中，我們會把 <code>_config.butterfly.yml</code> 裡面的內容改成 <code>config-butterfly-en.yml</code>，這樣就可以讓首頁目錄變成英文了。</p></div><h1 id="Step-7-部署到-en-repository-中">Step 7. 部署到 en repository 中</h1><p>我們可以先開一個 branch 於本地端，並切換到 en 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b en</span><br></pre></td></tr></table></figure><p>接下來就是重頭戲了！請至 <code>_config.yml</code> 中，把 <code>config-en.yml</code> 的內容複製進去，並且更改以下設定：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 設定成 en repositoy 的 url 我們 Step 1 建立的那個 </span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:ShannonHung/ShannonHung.github.io.git</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>然後把  <code>config-butterfly.yml</code> 的內容複製進去<code>_config.butterfly.yml</code>，基本上就只有目錄文字不一樣而已。</p><p>好了之後，執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run kk</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>接著很重要的，請至 en repository 設定 GitHub Pages，並且選擇 <code>gh-pages</code> 分支，這樣才能正確部署到 GitHub Pages 中。</p></div><p><img src="https://i.imgur.com/AGWrRpJ.png" alt=""></p><p>你就可以前往 Action 查看，是否開始部署動作，部署完成就可以在 <code>&lt;username&gt;.github.io/en</code> 看到你的網站了。<br><img src="https://i.imgur.com/IaElbHi.png" alt=""></p><div class="note warning flat"><p><strong>之後如果想要建立任何中英文的文章，abbrlink 記得要一樣，這樣才能讓他們互相對應。</strong></p></div><h1 id="Finally：腳本部署">Finally：腳本部署</h1><p>你也可以寫腳本一次推送至兩個 repository 中<br>各自建立 中文語系 跟 英文語系 兩個不同的 <code>config-en.yml</code> 跟 <code>config-zh.yml</code> 還有 <code>config-butterfly-en.yml</code> 跟 <code>config-butterfly-zh.yml</code>。然後於跟目錄中建立一個 <code>deploy.sh</code>，內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        -h|--<span class="built_in">help</span>) </span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Usage: bash.sh [en|zh|all|show &lt;en|zh&gt;|-h]&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Options:&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [deploy|d] en   Deploy English configuration to GitHub Pages&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [deploy|d] zh   Deploy Chinese configuration to GitHub Pages&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [deploy|d] all  Deploy both English and Chinese configurations to GitHub Pages&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [show|s] en     Execute npm run show for English configuration&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  [show|s] zh     Execute npm run show for Chinese configuration&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;  -h, --help      Display this help message&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 0</span><br><span class="line">            ;;</span><br><span class="line">        d | deploy)</span><br><span class="line">            lang=<span class="variable">$2</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;en&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;zh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-<span class="variable">$lang</span>.yml&quot;</span> _config.yml</span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-butterfly-<span class="variable">$lang</span>.yml&quot;</span> <span class="string">&quot;_config.butterfly.yml&quot;</span></span><br><span class="line">                npm run kk</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Deploy <span class="variable">$1</span> success!&quot;</span></span><br><span class="line">            <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;all&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">for</span> lang_choice <span class="keyword">in</span> <span class="string">&quot;zh&quot;</span> <span class="string">&quot;en&quot;</span>; <span class="keyword">do</span></span><br><span class="line">                    <span class="built_in">cp</span> <span class="string">&quot;config-<span class="variable">$lang_choice</span>.yml&quot;</span> _config.yml</span><br><span class="line">                    <span class="built_in">cp</span> <span class="string">&quot;config-butterfly-<span class="variable">$lang_choice</span>.yml&quot;</span> <span class="string">&quot;_config.butterfly.yml&quot;</span></span><br><span class="line">                    npm run kk</span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">&quot;Deploy <span class="variable">$lang_choice</span> success!&quot;</span></span><br><span class="line">                <span class="keyword">done</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Error! Please input &#x27;en&#x27; or &#x27;zh&#x27; or &#x27;all&#x27;!&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            ;;</span><br><span class="line">        s | show)</span><br><span class="line">            lang=<span class="variable">$2</span></span><br><span class="line">            <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;en&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$lang</span>&quot;</span> = <span class="string">&quot;zh&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-<span class="variable">$lang</span>.yml&quot;</span> _config.yml</span><br><span class="line">                <span class="built_in">cp</span> <span class="string">&quot;config-butterfly-<span class="variable">$lang</span>.yml&quot;</span> <span class="string">&quot;_config.butterfly.yml&quot;</span></span><br><span class="line">                npm run show</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Running npm show!&quot;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Error! Please use &#x27;./bash.sh show en&#x27; or &#x27;./bash.sh show zh&#x27;!&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            <span class="built_in">shift</span> <span class="comment"># Move to the next argument after &#x27;show&#x27;</span></span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Error! Please input deploy &lt;en|zh|all&gt; or &#x27;show &lt;en|zh&gt;&#x27; or &#x27;-h&#x27; for help!&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> 1</span><br><span class="line">            ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>記得把它改成可執行檔後就可以執行囉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x deploy.sh</span><br><span class="line"><span class="comment"># 推送英文</span></span><br><span class="line">./deploy.sh deploy en </span><br><span class="line">./deploy.sh d en </span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送中文</span></span><br><span class="line">./deploy.sh deploy zh</span><br><span class="line">./deploy.sh d zh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地運行英文</span></span><br><span class="line">./deploy.sh show en</span><br><span class="line">./deploy.sh s en</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地運行中文</span></span><br><span class="line">./deploy.sh show zh</span><br><span class="line">./deploy.sh s z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尋求幫助</span></span><br><span class="line">./deploy.sh -h</span><br><span class="line">./deploy.sh --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="進階：不同文章切換中英文">進階：不同文章切換中英文</h1><p>如果你希望可以透過點擊 bottom 來達到中英文切換的效果如下：<br><img src="https://i.imgur.com/p9KnWUd.png" alt=""></p><p>那就繼續看下去吧！</p><h1 id="Step1-改寫-config-butterfly-lang-yml">Step1: 改寫 <code>config-butterfly-&lt;lang&gt;.yml</code></h1><blockquote><p>config-butterfly-zh.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="comment"># 開啟簡繁轉換 button </span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 預設繁體 </span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">繁</span></span><br><span class="line">  <span class="comment"># 如果是 `1` 就是中文 `3` 則是英文 </span></span><br><span class="line">  <span class="comment"># the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）/ 3 - English</span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>config-butterfly-zh.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Conversion between Traditional and Simplified Chinese (簡繁轉換)</span></span><br><span class="line"><span class="attr">translate:</span></span><br><span class="line">  <span class="comment"># 開啟簡繁轉換 button </span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 預設英文 </span></span><br><span class="line">  <span class="attr">default:</span> <span class="string">En</span></span><br><span class="line">  <span class="comment"># 如果是 `1` 就是中文 `3` 則是英文 </span></span><br><span class="line">  <span class="attr">defaultEncoding:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="撰寫-tw-en-js-檔案">撰寫 <code>tw-en.js</code> 檔案</h1><p>接下來我們要寫一個 js 檔案，在任意一個頁面時，點擊 bottom 就可以切換中英文，邏輯是：</p><ul><li>如果目前網站是：<code>https://&lt;rul&gt;/en/posts/&lt;post1&gt;</code><ul><li>當點擊 EN bottom 時，就會導向 <code>https://&lt;rul&gt;/posts/&lt;post1&gt; </code></li><li>簡單來說就是把 <code>/en</code> 移除</li></ul></li><li>如果目前網站是：<code>https://&lt;rul&gt;/posts/&lt;post1&gt;</code><ul><li>當點擊 EN bottom 時，就會導向 <code>https://&lt;rul&gt;/en/posts/&lt;post1&gt;</code></li><li>簡單來說就是在第一個 <code>/</code> 後面加上 <code>/en</code></li></ul></li></ul><p>因此我們把邏輯撰寫於 <code>source/self/tw-en.js</code> 與 <code>source-en/self/tw-en.js</code> 如下程式碼：</p><blockquote><p>tw-en.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; defaultEncoding, translateDelay, msgToTraditionalChinese &#125; =</span><br><span class="line">    <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">translate</span>;</span><br><span class="line">  <span class="keyword">const</span> msgToEnglish = <span class="string">&quot;EN&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> snackbarData = <span class="variable constant_">GLOBAL_CONFIG</span>.<span class="property">Snackbar</span>;</span><br><span class="line">  <span class="keyword">let</span> currentEncoding = defaultEncoding;</span><br><span class="line">  <span class="keyword">const</span> targetEncodingCookie = <span class="string">&quot;translate-en-cht&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> targetEncoding =</span><br><span class="line">    saveToLocal.<span class="title function_">get</span>(targetEncodingCookie) === <span class="literal">undefined</span></span><br><span class="line">      ? defaultEncoding</span><br><span class="line">      : <span class="title class_">Number</span>(saveToLocal.<span class="title function_">get</span>(<span class="string">&quot;translate-en-cht&quot;</span>));</span><br><span class="line">  <span class="keyword">let</span> translateButtonObject;</span><br><span class="line">  <span class="keyword">const</span> isSnackbar = snackbarData !== <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isIncludeEN</span> = (<span class="params">item</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">&quot;/en/&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> item.<span class="title function_">includes</span>(key);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nowIncludeEN = <span class="title function_">isIncludeEN</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">translatePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;translatePage trigger&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> currentUrl = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nowIncludeEN) &#123;</span><br><span class="line">      <span class="comment">// 把文字顯示成繁體中文</span></span><br><span class="line">      translateButtonObject.<span class="property">textContent</span> = msgToTraditionalChinese;</span><br><span class="line">      <span class="comment">// 然後導向繁體中文的網址 目前網址 /en/... =&gt; /...</span></span><br><span class="line">      <span class="keyword">let</span> newUrl = currentUrl.<span class="title function_">replace</span>(<span class="string">&quot;/en/&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Redirect to <span class="subst">$&#123;newUrl&#125;</span>`</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = newUrl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 把文字顯示成英文</span></span><br><span class="line">      translateButtonObject.<span class="property">textContent</span> = msgToEnglish;</span><br><span class="line">      <span class="comment">// 然後導向英文的網址 目前網址 /... =&gt; /en/...</span></span><br><span class="line">      <span class="keyword">let</span> newUrl = currentUrl.<span class="title function_">replace</span>(<span class="regexp">/^(https?:\/\/[^\/]+)(\/)?/</span>, <span class="string">&quot;$1/en/&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Redirect to <span class="subst">$&#123;newUrl&#125;</span>`</span>);</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = newUrl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">translateInitialization</span>(<span class="params"></span>) &#123;</span><br><span class="line">    translateButtonObject = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;translateLink&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (translateButtonObject) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nowIncludeEN) &#123;</span><br><span class="line">        translateButtonObject.<span class="property">textContent</span> = msgToTraditionalChinese;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        translateButtonObject.<span class="property">textContent</span> = msgToEnglish;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pjax:complete&quot;</span>, translateInitialization);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">translateFn</span> = &#123;</span><br><span class="line">    translatePage,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">translateInitialization</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="設定-js-於-config-中">設定 js 於 config 中</h1><p>打開 <code>config-butterfly-&lt;lang&gt;.yml</code>，並且設定 <code>inject</code> 如下：</p>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark and Pyspark Local Mode on Mac</title>
      <link href="/posts/pyspark-install-notebook/"/>
      <url>/posts/pyspark-install-notebook/</url>
      
        <content type="html"><![CDATA[<h1 id="Install-Java">Install Java</h1><p>Open a terminal and execute java. It should redirect you to a download site (if you haven’t installed it already)</p><p><img src="https://i.imgur.com/ZlLffKo.png" alt=""></p><h1 id="Python-3">Python 3</h1><div class="note warning flat"><p>如果你透過 homebrew 安裝，或 conda 可以跳過此步驟。</p></div><p>Browse to <a href="https://python.org/downloads">https://python.org/downloads</a>, get a 3.x version (latest is 3.12.0.). Install the pkg.</p><p><img src="https://i.imgur.com/tNa5lHd.png" alt=""></p><h1 id="Spark-Pyspark">Spark/Pyspark</h1><p>Go to <a href="https://spark.apache.org/downloads.html">https://spark.apache.org/downloads.html</a> and download Spark. Use Spark 3.5.0 for Hadoop 3.3</p><p><img src="https://i.imgur.com/zUkILNQ.png" alt=""></p><p>執行以下指令，我們把 spark 移動到 <code>/usr/local</code> 底下，通常 <code>/usr/local</code> 是使用者自己手動下載的非系統預設軟體，這個folder由用戶自己管理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Untar Archive with: </span></span><br><span class="line">tar xfz Downloads/spark-3.5.0-bin-hadoop3.tar.gz </span><br><span class="line">sudo <span class="built_in">mv</span> spark-3.5.0-bin-hadoop3 /usr/local</span><br></pre></td></tr></table></figure><p>然後設定環境變數，因為我是使用zsh作為shell，所以我們要設定 <code>~/.zshenv</code>，如果你是使用bash，請設定 <code>~/.bash_profile</code>。</p><div class="note danger flat"><p>注意的是，如果你是使用 conda 要把 python3 改成 python 因為你要使用 conda 的 python，而不是系統預設的 python。如下：<br><code>echo 'export PYSPARK_DRIVER_PYTHON=python' &gt;&gt; ~/.zshenv</code><br>會這樣改是因為，homebrew 的 python 指令是 python3 而不是 python。但是 conda 的 python 指令是 python，你可以透過 conda activate 來自由切換 python 版本。因此如果輸入pyspark的時候，就會根據 <code>PYSPARK_DRIVER_PYTHON</code> 所指定的指令進行啟動。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (zsh Version; for bash, use ~/.bash_profile instead of ~/.zshenv) </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYSPARK_DRIVER_PYTHON=python3&#x27;</span> &gt;&gt; ~/.zshenv </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export SPARK_HOME=/usr/local/spark-3.5.0-bin-hadoop3&#x27;</span> &gt;&gt; ~/.zshenv </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$&#123;SPARK_HOME&#125;/bin:$PATH&#x27;</span> &gt;&gt; ~/.zshenv</span><br></pre></td></tr></table></figure><p>最後嘗試啟動 Pyspark 看看<br><img src="https://i.imgur.com/VR4zKpu.png" alt=""></p><h1 id="安裝必要套件">安裝必要套件</h1><p>請根據你所使用的套件管理工具進行安裝，以下是兩種常見的套件管理工具。</p><blockquote><p>pip</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook </span><br><span class="line">pip install findspark </span><br></pre></td></tr></table></figure><blockquote><p>conda</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install -c conda-forge notebook</span><br><span class="line">conda install -c conda-forge findspark</span><br></pre></td></tr></table></figure><h1 id="測試Pyspark-on-notebook">測試Pyspark on notebook</h1><p>輸入以下指令，如果成功會看到以下畫面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> findspark </span><br><span class="line">findspark.init() </span><br><span class="line"><span class="keyword">import</span> pyspark <span class="comment"># only run after findspark.init() </span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession </span><br><span class="line">spark = SparkSession.builder.getOrCreate() </span><br><span class="line">df = spark.sql(<span class="string">&#x27;&#x27;&#x27;select &#x27;spark&#x27; as hello &#x27;&#x27;&#x27;</span>) </span><br><span class="line">df.show() </span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/fa56EZO.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyspark 的基本概念</title>
      <link href="/posts/pyspark-basic/"/>
      <url>/posts/pyspark-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本篇文章主要的目的是在整理 Spark: The Definitive Guide 這本書的內容，並且加上自己的理解，讓自己更加熟悉 Spark 的基本概念。</p><h1 id="Spark-Application">Spark Application</h1><p>取自：Spark: The Definitive Guide<br><img src="https://i.imgur.com/zVujAB9.png" alt=""></p><p>Spark Application mainly consist of two processes:</p><ol><li><strong>Driver process</strong>：<ul><li>executing main() function, sits on a node in the cluster</li><li>maintaining information about the Spark Application</li><li>responding to a user’s program or input</li><li>analyzing, distributing, and scheduling work across the executors</li></ul></li><li><strong>Executor process</strong>：<ul><li>executing code assigned to it by the driver</li><li>reporting the state of the computation on that executor back to the driver node</li></ul></li></ol><h1 id="Spark’s-APIs">Spark’s APIs</h1><p><img src="https://i.imgur.com/BAHyroO.png" alt=""></p><p>Spark’s language APIs 提供其他程式語言像是Python或是R等，執行Spark code的能力。有一個 SparkSession object 會被建立，SparkSession 你可以想像他是執行 Spark code 的入口，如果使用其他語言像是Python時，不需要撰寫JVM指令，可以<strong>透過 Spark’s Language API 將 Python code 轉換成可以在 JVMs 上面執行的程式</strong>。</p><h1 id="SparkSession">SparkSession</h1><div class="note info flat"><p>SparkSesion：透過 driver process 控制 Spark Application。</p></div><p><img src="https://i.imgur.com/Q3ttftn.png" alt=""></p><p>透過 PySpark （Spark API）來建立 SparkSession：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> findspark </span><br><span class="line">findspark.init() </span><br><span class="line"><span class="keyword">import</span> pyspark <span class="comment"># only run after findspark.init() </span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession </span><br><span class="line">spark = SparkSession.builder.getOrCreate() </span><br><span class="line">df = spark.<span class="built_in">range</span>(<span class="number">1000</span>).toDF(<span class="string">&quot;number&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Structured-API">Structured API</h1><p><img src="https://i.imgur.com/DbwJUEd.png" alt=""></p><h2 id="Datasets">Datasets</h2><ul><li><strong>差異</strong>：<ul><li>Datasets 是 Spark 中的類型安全 API，在 Java 和 Scala 中提供了靜態類型的支持。（也就是在編譯前就知道數據類型）</li><li>它允許將 Java/Scala 類型分配給 DataFrame 中的記錄，並以類似 Java ArrayList 或 Scala Seq 的方式操作它們。</li></ul></li><li><strong>使用時機</strong>：<ul><li>Datasets 適合於需要靜態類型支持的情況，特別是大型應用程序中，多個工程師通過明確定義的接口進行交互時。</li><li>就像Java中的Class，你會定義好他的屬性、名稱、函式等。</li></ul></li><li><strong>例子</strong>：<ul><li>如果你需要對數據進行較為複雜的操作，而且<code>需要保證類型安全</code>，那麼使用 Dataset 是個不錯的選擇。</li><li>例如，進行較複雜的業務邏輯，同時需要在數據處理中保持靜態類型檢查。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Scala</span></span><br><span class="line"><span class="comment">// 先定義好class 型別 </span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title class_">Flight</span>(<span class="attr">DEST_COUNTRY_NAME</span>: <span class="title class_">String</span>,</span><br><span class="line">                  <span class="attr">ORIGIN_COUNTRY_NAME</span>: <span class="title class_">String</span>,</span><br><span class="line">                  <span class="attr">count</span>: <span class="title class_">BigInt</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 讀取資料</span></span><br><span class="line">val flightsDF = spark.<span class="property">read</span></span><br><span class="line">  .<span class="title function_">parquet</span>(<span class="string">&quot;/data/flight-data/parquet/2010-summary.parquet/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轉換資料對應至型別中</span></span><br><span class="line">val flights = flightsDF.<span class="property">as</span>[<span class="title class_">Flight</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// in Scala</span></span><br><span class="line">flights</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">flight_row</span> =&gt;</span> flight_row.<span class="property">ORIGIN_COUNTRY_NAME</span> != <span class="string">&quot;Canada&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">flight_row</span> =&gt;</span> flight_row)</span><br><span class="line">  .<span class="title function_">take</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">flights</span><br><span class="line">  .<span class="title function_">take</span>(<span class="number">5</span>)</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">flight_row</span> =&gt;</span> flight_row.<span class="property">ORIGIN_COUNTRY_NAME</span> != <span class="string">&quot;Canada&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">fr</span> =&gt;</span> <span class="title class_">Flight</span>(fr.<span class="property">DEST_COUNTRY_NAME</span>, fr.<span class="property">ORIGIN_COUNTRY_NAME</span>, fr.<span class="property">count</span> + <span class="number">5</span>))</span><br></pre></td></tr></table></figure><h2 id="DataFrames">DataFrames</h2><ul><li><strong>差異</strong>：<ul><li>DataFrames 是分佈式的 Row 對象集合，用於處理各種類型的表格數據。</li><li>它提供了一個<code>更接近 SQL 操作的界面</code>(只是是透過函示呼叫)，並且是 Python、R 和 Scala 中使用最廣泛的 API。</li></ul></li><li><strong>使用時機</strong>：<ul><li>當你需要以類似於 SQL 的方式操作和轉換數據時，DataFrames 是一個很好的選擇。它的彈性和簡潔性使得能夠快速進行數據操作和轉換。</li></ul></li><li><strong>例子</strong>：<ul><li>例如，進行數據過濾、聚合、連接和簡單的轉換等操作時，DataFrames 是一個非常方便的選擇。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先讀取資料</span></span><br><span class="line">flight = spark.read\</span><br><span class="line">    .option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .csv(os.path.join(root, <span class="string">&quot;flight-data/csv/2015-summary.csv&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接近SQL操作介面，但是使用起來更加方便</span></span><br><span class="line">dataframeway = flight.groupBy(<span class="string">&quot;DEST_COUNTRY_NAME&quot;</span>).count()  </span><br></pre></td></tr></table></figure><h2 id="SQL">SQL</h2><ul><li><strong>差異</strong>：<ul><li>SQL 是一種結構化查詢語言，允許使用<code>類 SQL 的語法進行數據操作</code>。(可以直接寫SQL)</li><li>在 Spark 中，你可以使用 SQL 像操作關聯式數據庫一樣操作 DataFrame 和 TempView。</li></ul></li><li><strong>使用時機</strong>：<ul><li>當你更擅長於 SQL 語法，或者希望使用標準 SQL 操作數據時，SQL 是一個很好的選擇。它也能提供可讀性強、易於維護的優勢。</li></ul></li><li><strong>例子</strong>：<ul><li>如果你有大量的 SQL 經驗，或者希望通過使用 SQL 來表達數據操作，那麼在 Spark 中使用 SQL 是很直觀的。</li><li>舉例來說，對於熟悉 SQL 語法的用戶，將一些較複雜的數據操作轉化為 SQL 可能更為自然和高效。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先讀取資料</span></span><br><span class="line">flight = spark.read\</span><br><span class="line">    .option(<span class="string">&quot;inferSchema&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .csv(os.path.join(root, <span class="string">&quot;flight-data/csv/2015-summary.csv&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 註冊為一個名為 &quot;flight_data_2015&quot; 的暫時性視圖。</span></span><br><span class="line"><span class="comment"># 這意味著你可以使用 SQL 語法或 Spark 的 DataFrame API 在程式中直接查詢這個名為 &quot;flight_data_2015&quot; 的視圖。</span></span><br><span class="line">flight.createOrReplaceTempView(<span class="string">&quot;flight_data_2015&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這樣就可以透過 SQL 語法進行查詢</span></span><br><span class="line">sqlway = spark.sql(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT DEST_COUNTRY_NAME, count(1) </span></span><br><span class="line"><span class="string">                   FROM flight_data_2015 </span></span><br><span class="line"><span class="string">                   GROUP BY DEST_COUNTRY_NAME</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三者比較">三者比較</h2><ul><li><strong>效率</strong>：DataFrames 和 SQL 提供了簡潔、易讀且高效的數據操作方式，適用於快速開發和簡單轉換。</li><li><strong>類型安全</strong>：Datasets 提供了靜態類型支持，適用於對類型安全性要求較高的情況。</li></ul><h1 id="Structured-Streaming">Structured Streaming</h1><p>StreamingDataFrame 跟 staticDataFrame 有什麼差異呢？</p><h2 id="差異">差異</h2><ul><li><strong>StreamingDataFrame</strong>:<ul><li>用於處理流式數據，是基於連續到達的數據流進行操作。</li><li>使用 readStream 方法讀取流式數據。</li><li>可以通過在流式數據上應用操作和轉換來進行實時處理。</li></ul></li><li><strong>staticDataFrame</strong>:<ul><li>用於處理靜態、固定的數據集，是一次性加載整個數據集進行操作。</li><li>使用 read 方法從靜態數據源（如文件、資料庫等）讀取數據。</li><li>適用於批處理作業，對於靜態且不會變動的數據進行操作和分析。</li></ul></li></ul><p><strong>流式操作</strong></p><ul><li>它的目的是將數據寫入某個地方，而不僅僅是對數據進行計算或統計（例如 count 操作在流式上是沒有意義的）。</li><li>流式操作會將結果輸出到內存表，並在每次觸發（trigger）後更新該表。</li><li>在啟動了流式處理之後，可以使用透過儲存的內存 Table 使用 SQL 查詢來檢視內存表中的結果。</li><li>好處：這樣的操作讓你可以在將數據寫入最終目的地之前，先對計算結果進行預覽和檢查，以確保數據處理和計算的準確性和一致性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 讀取資料適用 load 而不是 read </span></span><br><span class="line"><span class="comment"># 2. maxFilesPerTrigger 代表每次觸發的檔案數量 也就是新的檔案進來時，會觸發一次</span></span><br><span class="line">streamingDataFrame = spark.readStream\</span><br><span class="line">    .schema(staticSchema)\</span><br><span class="line">    .option(<span class="string">&quot;maxFilesPerTrigger&quot;</span>, <span class="number">1</span>)\</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;csv&quot;</span>)\</span><br><span class="line">    .option(<span class="string">&quot;header&quot;</span>, <span class="string">&quot;true&quot;</span>)\</span><br><span class="line">    .load(<span class="string">&quot;/data/retail-data/by-day/*.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 當trigger發生時，會將結果輸出到內存表中，但是以下是lazy evaluation，所以不會真的執行</span></span><br><span class="line"><span class="comment"># 要透過 writeStream 來啟動</span></span><br><span class="line">purchaseByCustomerPerHour = streamingDataFrame\</span><br><span class="line">  .selectExpr(</span><br><span class="line">    <span class="string">&quot;CustomerId&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(UnitPrice * Quantity) as total_cost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;InvoiceDate&quot;</span>)\</span><br><span class="line">  .groupBy(</span><br><span class="line">    col(<span class="string">&quot;CustomerId&quot;</span>), window(col(<span class="string">&quot;InvoiceDate&quot;</span>), <span class="string">&quot;1 day&quot;</span>))\</span><br><span class="line">  .<span class="built_in">sum</span>(<span class="string">&quot;total_cost&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># writeStream 當每次 trigger 觸發的時候，會將結果輸出到內存表中</span></span><br><span class="line">purchaseByCustomerPerHour.writeStream\</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;memory&quot;</span>)\</span><br><span class="line">    .queryName(<span class="string">&quot;customer_purchases&quot;</span>)\</span><br><span class="line">    .outputMode(<span class="string">&quot;complete&quot;</span>)\</span><br><span class="line">    .start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過儲存的內存 Table 使用 SQL 查詢來檢視內存表中的結果</span></span><br><span class="line"><span class="comment"># 可以查看目前處理的狀況 </span></span><br><span class="line">spark.sql(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  SELECT *</span></span><br><span class="line"><span class="string">  FROM customer_purchases</span></span><br><span class="line"><span class="string">  ORDER BY `sum(total_cost)` DESC</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span>)\</span><br><span class="line">  .show(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通過使用 writeStream 方法，將結果輸出到控制台，這樣你可以在控制台上看到實時的結果變化。</span></span><br><span class="line">purchaseByCustomerPerHour.writeStream</span><br><span class="line">    .<span class="built_in">format</span>(<span class="string">&quot;console&quot;</span>)</span><br><span class="line">    .queryName(<span class="string">&quot;customer_purchases_2&quot;</span>)</span><br><span class="line">    .outputMode(<span class="string">&quot;complete&quot;</span>)</span><br><span class="line">    .start()</span><br></pre></td></tr></table></figure><p>他就會不斷跳出結果，只要讀取了新的檔案就會觸發一次，然後你就可以查看檔案的變化，跳出的結果如下<br><img src="https://i.imgur.com/KAh4yhF.png" alt=""></p><h2 id="使用時機">使用時機</h2><ul><li><strong>StreamingDataFrame</strong>:<ul><li>適用於處理連續到達的、持續變化的數據流，例如實時日誌、感測器數據等。</li><li>可以實時進行處理、分析和存儲。</li><li>優點是能夠處理動態數據，但也需要考慮流式處理的性能和延遲。</li></ul></li><li><strong>staticDataFrame</strong>:<ul><li>適用於一次性、靜態的數據集，例如批量文件、靜態數據庫內容等。</li><li>適用於批處理作業，例如數據清理、分析報告等。</li><li>優點是能夠<code>對整個數據集進行全局操作</code>和分析，但無法處理持續更新的數據。</li></ul></li></ul><h1 id="Machine-Learning-and-Advanced-Analytics">Machine Learning and Advanced Analytics</h1><p>Spark 有一個內建的機器學習算法庫（MLlib），這使其<strong>能夠執行大規模的機器學習任務</strong>。MLlib 包括了預處理、數據整理、模型訓練和在大規模數據上進行預測的功能。甚至可以在 Structured Streaming 中使用在 MLlib 中訓練過的模型進行預測。Spark 提供了一個複雜的機器學習 API，可用於執行各種機器學習任務，從分類到回歸，從聚類到深度學習等。</p><h2 id="資料清理">資料清理</h2><p>MLlib 中的機器學習演算法<strong>要求資料以數值表示</strong>。我們目前的資料由多種不同的類型表示，包括時間戳記、整數和字串。因此，我們需要將這些數據<strong>轉換為某種數字表示形式</strong>。那我們就來看看該怎麼做吧！</p><p>在本例中，我們將使用多個 DataFrame 轉換來操作日期資料：</p><ul><li>先把nan的資料填補成0</li><li>將日期轉換成星期幾</li><li><code>coalesce</code> 來減少分區數量，預設是200的分區，但是我們希望 staticDataFrame 只要分成 5 區即可。</li></ul><div class="note warning flat"><p><code>coalesce</code> 跟<code>spark.conf.set(&quot;spark.sql.shuffle.partitions&quot;, &quot;5&quot;)</code>有類似的效果，但是這個是針對所有的DataFrame，而coalesce是針對特定的DataFrame。</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.functions <span class="keyword">import</span> date_format, col</span><br><span class="line">preppedDataFrame = staticDataFrame\</span><br><span class="line">  .na.fill(<span class="number">0</span>)\</span><br><span class="line">  .withColumn(<span class="string">&quot;day_of_week&quot;</span>, date_format(col(<span class="string">&quot;InvoiceDate&quot;</span>), <span class="string">&quot;EEEE&quot;</span>))\</span><br><span class="line">  .coalesce(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output </span></span><br><span class="line">+---------+---------+--------------------+--------+-------------------+---------+----------+--------------+-----------+</span><br><span class="line">|InvoiceNo|StockCode|         Description|Quantity|        InvoiceDate|UnitPrice|CustomerID|       Country|day_of_week|</span><br><span class="line">+---------+---------+--------------------+--------+-------------------+---------+----------+--------------+-----------+</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">23084</span>|  RABBIT NIGHT LIGHT|      <span class="number">48</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.79</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">23077</span>| DOUGHNUT LIP GLOSS |      <span class="number">20</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.25</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">22906</span>|<span class="number">12</span> MESSAGE CARDS ...|      <span class="number">24</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.65</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">21914</span>|BLUE HARMONICA IN...|      <span class="number">24</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">1.25</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">|   <span class="number">580538</span>|    <span class="number">22467</span>|   GUMBALL COAT RACK|       <span class="number">6</span>|<span class="number">2011</span>-<span class="number">12</span>-05 08:<span class="number">38</span>:<span class="number">00</span>|     <span class="number">2.55</span>|   <span class="number">14075.0</span>|United Kingdom|     Monday|</span><br><span class="line">+---------+---------+--------------------+--------+-------------------+---------+----------+--------------+-----------+</span><br><span class="line">only showing top <span class="number">5</span> rows</span><br></pre></td></tr></table></figure><h2 id="資料切割trainning-and-testing">資料切割trainning and testing</h2><p>接著我們可以把資廖根據時間分成 trainning 跟 testing 的資料集，並且將資料轉換成機器學習演算法所需的格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line">trainDataFrame = preppedDataFrame\</span><br><span class="line">  .where(<span class="string">&quot;InvoiceDate &lt; &#x27;2011-07-01&#x27;&quot;</span>)</span><br><span class="line">testDataFrame = preppedDataFrame\</span><br><span class="line">  .where(<span class="string">&quot;InvoiceDate &gt;= &#x27;2011-07-01&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">trainDataFrame.count()</span><br><span class="line">testDataFrame.count()</span><br></pre></td></tr></table></figure><h2 id="資料轉換成-vector">資料轉換成 vector</h2><p>切割好資料後，我們建立一個 Spark MLlib 中的一個轉換器（transformer）：<code>StringIndexer</code>。</p><ul><li><code>StringIndexer</code> 是用於**將「字串類別」型特徵轉換為「數字類別」**型特徵的轉換器。</li><li>它將一列中的字串值按照它們在該列中<strong>出現的頻率或者字母表順序，映射為數字類別值</strong>。</li></ul><p>在這個例子中，這段程式碼創建了一個 StringIndexer 物件並進行了相關設定：</p><ul><li><code>.setInputCol(&quot;day_of_week&quot;)</code>：設置了輸入列（input column），即要轉換的列的名稱，在這裡是 “day_of_week”。</li><li><code>.setOutputCol(&quot;day_of_week_index&quot;)</code>：設置了輸出列（output column），指定轉換後數字類別值的存儲位置，這裡是 “day_of_week_index”。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># indexer </span></span><br><span class="line"><span class="comment">## setInputCol 針對 day_of_week 轉換成 day_of_week_index </span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> StringIndexer</span><br><span class="line">indexer = StringIndexer()\</span><br><span class="line">  .setInputCol(<span class="string">&quot;day_of_week&quot;</span>)\ </span><br><span class="line">  .setOutputCol(<span class="string">&quot;day_of_week_index&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># encoder </span></span><br><span class="line"><span class="comment">## 把 index 轉換成 one-hot encoding </span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> OneHotEncoder</span><br><span class="line">encoder = OneHotEncoder()\</span><br><span class="line">  .setInputCol(<span class="string">&quot;day_of_week_index&quot;</span>)\</span><br><span class="line">  .setOutputCol(<span class="string">&quot;day_of_week_encoded&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># vector </span></span><br><span class="line"><span class="comment">## 把所有的特徵轉換成一個向量</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml.feature <span class="keyword">import</span> VectorAssembler</span><br><span class="line">vectorAssembler = VectorAssembler()\</span><br><span class="line">  .setInputCols([<span class="string">&quot;UnitPrice&quot;</span>, <span class="string">&quot;Quantity&quot;</span>, <span class="string">&quot;day_of_week_encoded&quot;</span>])\</span><br><span class="line">  .setOutputCol(<span class="string">&quot;features&quot;</span>)</span><br></pre></td></tr></table></figure><p>準備好 indexer, encoder, vectorAssembler 之後，我們就可以建立一個 pipeline 來執行這些轉換。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pipeline</span></span><br><span class="line"><span class="keyword">from</span> pyspark.ml <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line">transformationPipeline = Pipeline()\</span><br><span class="line">  .setStages([indexer, encoder, vectorAssembler])</span><br></pre></td></tr></table></figure><p>接著我們就可以透過 pipeline 來轉換資料了。我們必須先透過 fit 來建立一個 pipeline model，因為當使用 StringIndexer 對類別型特徵進行轉換時，<strong>它需要將每個不同的類別值映射為一個唯一的數字</strong>。在這個過程中，<strong>需要確定要被索引的類別型特徵列中有多少個唯一的類別值</strong>。</p><p>例如，如果你有一列包含星期幾（Monday、Tuesday、Wednesday 等），<strong>StringIndexer 會將每個不同的星期幾映射為一個唯一的數字標識</strong>，例如 Monday: 0, Tuesday: 1, 等等。在訓練過程中，<strong>StringIndexer 需要看到整個訓練數據集中的所有不同的類別值，這樣它才能確保給每個類別值分配一個唯一的數字標識</strong>。</p><p>fittedPipeline，這是在訓練數據集上進行了訓練的 Pipeline。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fittedPipeline = transformationPipeline.fit(trainDataFrame)</span><br></pre></td></tr></table></figure><p>接著我們透過 fittedPipeline 的 transform 方法將這個訓練完的 Pipeline 應用於訓練數據集 trainDataFrame，<strong>對數據進行相同的轉換</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transformedTraining = fittedPipeline.transform(trainDataFrame)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用快取這種優化技術，該技術會將中間轉換後的數據集存儲到內存中</span></span><br><span class="line"><span class="comment"># 這樣就可以以更低的成本重複訪問它。</span></span><br><span class="line">transformedTraining.cache()</span><br></pre></td></tr></table></figure><h2 id="準備模型">準備模型</h2><p>在 MLlib 的 DataFrame API 中，每個算法都有兩種類型。</p><ul><li>未訓練的版本按照 Algorithm 命名模式，而訓練過的版本則是 AlgorithmModel。</li><li>在這個例子中，例如 KMeans 表示未訓練的版本，而 KMeansModel 則是經過訓練的版本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.clustering <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 還未訓練的版本</span></span><br><span class="line">kmeans = KMeans()\</span><br><span class="line">    .setK(<span class="number">20</span>)\</span><br><span class="line">    .setSeed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 訓練好的 model </span></span><br><span class="line">kmModel = kmeans.fit(transformedTraining)</span><br></pre></td></tr></table></figure><h2 id="計算-Loss">計算 Loss</h2><p>因為 3.0.0 的版本後，就把 <code>computeCost</code> 移除了，所以要使用 <code>ClusteringEvaluator</code> 來計算 Loss。這邊我們要計算的是 <code>Silhouette score</code>，他與 Loss 是用於不同類型的機器學習問題評估的指標。</p><ul><li><strong>Silhouette score</strong>：<ul><li>主要用於評估聚類（Clustering）的質量。</li><li>分數範圍在 -1 到 1 之間，分數越接近 1 表示聚類結果越好，表示樣本與自己的聚類比與其他聚類更相似，而分數越接近 -1 則表示聚類結果較差，樣本更可能被分配到錯誤的聚類中。</li></ul></li><li><strong>Loss</strong>：<ul><li>損失是在監督式學習（Supervised Learning）中使用的評估指標，用於衡量模型預測與實際目標值之間的差距。</li><li>損失的計算方式因問題而異，例如在回歸問題中可以使用均方誤差（Mean Squared Error），在分類問題中可以使用交叉熵損失（Cross-Entropy Loss）。損失值越小表示模型預測與實際值之間的差距越小，模型的性能越好。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.ml.evaluation <span class="keyword">import</span> ClusteringEvaluator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在訓練後使用訓練好的模型對測試數據進行預測</span></span><br><span class="line">predictions = kmModel.transform(transformedTest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 評估聚類模型的 Silhouette score</span></span><br><span class="line">evaluator = ClusteringEvaluator()</span><br><span class="line">silhouette = evaluator.evaluate(predictions)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Silhouette with squared euclidean distance = &quot;</span> + <span class="built_in">str</span>(silhouette))</span><br></pre></td></tr></table></figure><h1 id="Low-Level-APIs">Low-Level APIs</h1><p><img src="https://i.imgur.com/DbwJUEd.png" alt=""></p><p>RDD 是 Spark 中的一個基本抽象，它是一個具有容錯性和可並行處理的、分佈式的元素集合。<strong>RDD 提供了一種能夠在大規模集群上進行並行操作的抽象方式</strong>，它是 Spark 運行的核心基礎。事實上，幾乎所有 Spark 的操作都是建立在 RDD 之上的。</p><p>然而，<strong>DataFrame 是建立在 RDD 之上的更高級抽象</strong>，它提供了一種更方便、更高效的方式來進行分佈式數據操作。DataFrame 基於 RDD，但它提供了更高層次的抽象，隱藏了底層 RDD 的物理特性（例如分區等），使得用戶可以更方便地進行數據操作，並且能夠獲得更好的性能。</p><p>在 Spark 中，大部分情況下，<strong>建議使用 DataFrame 或 Structured APIs 進行數據操作，因為它們提供了更高層次的抽象和更好的性能</strong>。但是在某些情況下，仍然可能會使用到 RDD，例如在讀取或操作原始數據時。</p><p>下面的程式碼示例展示了如何使用 parallelize 方法將一組數據轉換為 RDD，然後將其轉換為 DataFrame，這是一種使用 RDD 創建 DataFrame 的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Python</span></span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line">spark.sparkContext.parallelize([</span><br><span class="line">  Row(<span class="number">1</span>),</span><br><span class="line">  Row(<span class="number">2</span>),</span><br><span class="line">  Row(<span class="number">3</span>)</span><br><span class="line">]).toDF()</span><br></pre></td></tr></table></figure><h2 id="RDD（Resilient-Distributed-Dataset）">RDD（Resilient Distributed Dataset）</h2><p>RDD 是 Spark 中的基本抽象，它代表一個分佈式的、不可變的集合，能夠容錯和並行處理。RDD 提供了對數據的精細控制，允許使用者管理數據分區、內存使用以及計算過程。</p><p><strong>適合的使用時機</strong>：</p><ul><li>當需要更精細的控制和低層次的操作時，例如需要手動控制數據分區、優化內存使用或者需要使用一些特定於 RDD 的操作時。</li><li>在一些需要自定義的計算邏輯或者在遷移舊有 Spark 代碼到新版本時，可以使用 RDD 以保持兼容性。</li></ul><p><strong>優缺點</strong>：</p><ul><li>優點：<ul><li>提供更多細節級別的控制，可以手動調整分區、緩存策略等。</li><li>在特定場景下可以更靈活，並提供一些 DataFrame 不具備的操作。</li></ul></li><li>缺點：<ul><li>較為低階，需要更多的手動管理和優化。</li><li>較 DataFrame 更複雜，需要更多的代碼量。</li></ul></li></ul><h2 id="與-DataFrame-的差異">與 DataFrame 的差異</h2><p><strong>與 DataFrame 的差異</strong></p><ul><li>DataFrame 是在 RDD 基礎上的高層次抽象，提供了更簡潔的 API 和更高效的優化。<br>DataFrame 提供了結構化數據處理的抽象，允許使用者進行類似 SQL 的操作。</li></ul><p><strong>相對於 RDD，DataFrame 適合的使用時機</strong>：</p><ul><li>當進行結構化數據處理時，例如進行篩選、聚合、排序等操作。</li><li>在需要高效並行處理和內建優化的情況下，DataFrame 更為適合。</li></ul><p><strong>相對於RDD的優缺點</strong>：</p><ul><li>優點：<ul><li>提供了更高級的抽象和更簡潔的 API，易於使用和理解。</li><li>具有內置的優化功能，能夠自動優化和提高效率。</li></ul></li><li>缺點：<ul><li>對於某些特定場景下的低層次操作，DataFrame 可能無法提供足夠的靈活性。</li></ul></li></ul><h1 id="補充：Spark’s-Interactive-Consoles">補充：Spark’s Interactive Consoles</h1><p>如果以 interactive mode 啟動 Spark，就是間接的建立管理 Spark Application 的SparkSession。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/pyspark <span class="comment"># Python console: starts an interactive Spark application </span></span><br><span class="line">./bin/spark-shell <span class="comment"># Scala Console: access the Scala console to start an interactive sesion</span></span><br><span class="line">./bin/spark-sql <span class="comment"># SQL console</span></span><br><span class="line">./bin/spark-submit <span class="comment"># submit an application to a cluster 他可以幫你把程式打包</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Twitter Dataset - 使用 LSTM 預測文章的情緒</title>
      <link href="/posts/nlp-twitter-emotion-diagnoise/"/>
      <url>/posts/nlp-twitter-emotion-diagnoise/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第六個作業，主要教授內容為以下主題：</p><ol><li>學會使用 LSTM</li><li>使用SpaCy</li></ol><h1 id="作業要求">作業要求</h1><p>Train a text classification on the <a href="https://github.com/cardiffnlp/tweeteval">TweetEval</a> emotion recognition dataset using LSTMs and GRUs.</p><ol><li><strong>建立LSTM模型</strong>：Follow the example described <a href="https://pytorch.org/tutorials/beginner/nlp/sequence_models_tutorial.html">here</a>. Use the same architecture, but:<ol><li>only use the last output of the LSTM in the loss function</li><li>use an embedding dim of 128</li><li>use a hidden dim of 256.</li></ol></li><li><strong>使用SpaCy切割字</strong>：Use spaCy to split the tweets into words.</li><li><strong>挑選Top5000的字</strong>：Limit your vocabulary (i.e. the words that you converted to an index) to the most frequent 5000<br>words and replace all other words with an placeholder index (e.g. 1001).</li><li><strong>訓練模型並計算準確度</strong>：Evaluate the accuracy on the test set. (Note: If the training takes to long, try to use only a fraction of the training data.)</li><li><strong>建立GRU模型，並訓練</strong>：Do the same, but this time use GRUs instead of LSTMs.</li></ol><h1 id="Task-0-下載資料集">Task 0: 下載資料集</h1><div class="note info flat"><p>在這個章節我們需要做的事有以下：</p><ol><li>下載資料集</li><li>使用 panda 將資料集轉換成我們需要的格式</li></ol></div><h2 id="下載資料集">下載資料集</h2><ol><li>可以參考此連結，下載所需要的資料：<a href="https://github.com/cardiffnlp/tweeteval">TweetEval</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cardiffnlp/tweeteval.git</span><br></pre></td></tr></table></figure><ol start="2"><li>下載完後，可以看到以下資料， <code>emotion</code> 資料夾中是我們這次會使用的資料：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── TweetEval_Tutorial.ipynb</span><br><span class="line">├── datasets</span><br><span class="line">│   ├── README.txt</span><br><span class="line">│   ├── emoji</span><br><span class="line">│   ├── emotion <span class="comment"># 這是我們需要的資料 </span></span><br><span class="line">│   │   ├── mapping.txt <span class="comment"># 情緒對應的數字 e.g. &#123;0:&#x27;angry&#x27;, 1:&#x27;happy&#x27;&#125;</span></span><br><span class="line">│   │   ├── test_labels.txt <span class="comment"># 測試資料的情緒標籤，也就是解答 e.g. 0 </span></span><br><span class="line">│   │   ├── test_text.txt <span class="comment"># 測試資料的內容 e.g. &quot;I&#x27;m so angry&quot;</span></span><br><span class="line">│   │   ├── train_labels.txt <span class="comment"># 訓練資料的情緒標籤，也就是解答 e.g. 0</span></span><br><span class="line">│   │   ├── train_text.txt <span class="comment"># 訓練資料的內容 e.g. &quot;I&#x27;m so angry&quot;</span></span><br><span class="line">│   │   ├── val_labels.txt <span class="comment"># 驗證資料的情緒標籤，也就是解答 e.g. 0</span></span><br><span class="line">│   │   └── val_text.txt <span class="comment"># 驗證資料的內容 e.g. &quot;I&#x27;m so angry&quot; </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="轉換資料格式">轉換資料格式</h2><p>我們先引入所需要的套件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CNN</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset</span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, models, transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> Flowers102</span><br><span class="line"></span><br><span class="line"><span class="comment"># read file </span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># label</span></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><p>接著我們將資料轉換成我們需要的格式，這邊我們使用 <code>panda</code> 來處理資料，並將資料讀取至變數中，方便我們之後使用。</p><div class="note warning flat"><p>記得修改 root 的路徑到你 git clone 的資料夾路徑喔！！</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先設定每個檔案的相對路徑 </span></span><br><span class="line">root = <span class="string">&#x27;../../Data/tweeteval/datasets/emotion/&#x27;</span></span><br><span class="line">mapping_file = os.path.join(root, <span class="string">&#x27;mapping.txt&#x27;</span>)</span><br><span class="line">test_labels_file = os.path.join(root, <span class="string">&#x27;test_labels.txt&#x27;</span>)</span><br><span class="line">test_text_file = os.path.join(root, <span class="string">&#x27;test_text.txt&#x27;</span>)</span><br><span class="line">train_labels_file = os.path.join(root, <span class="string">&#x27;train_labels.txt&#x27;</span>)</span><br><span class="line">train_text_file = os.path.join(root, <span class="string">&#x27;train_text.txt&#x27;</span>)</span><br><span class="line">val_labels_file = os.path.join(root, <span class="string">&#x27;val_labels.txt&#x27;</span>)</span><br><span class="line">val_text_file = os.path.join(root, <span class="string">&#x27;val_text.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用panda讀取資料 把標籤進行讀取 </span></span><br><span class="line">mapping_pd = pd.read_csv(mapping_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">test_label_pd = pd.read_csv(test_labels_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">train_label_pd = pd.read_csv(train_labels_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">val_label_pd = pd.read_csv(val_labels_file, sep=<span class="string">&#x27;\t&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把訓練用的內容和測試用的內容，透過 \n 進行切割，並且把最後一個空白的字去除  </span></span><br><span class="line"><span class="comment"># 因為 test_dataset[-1] 是空的，並且要去除 長度才會與 labels 的長度一致</span></span><br><span class="line">test_dataset = <span class="built_in">open</span>(test_text_file).read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>] <span class="comment"># remove last empty line </span></span><br><span class="line">train_dataset = <span class="built_in">open</span>(train_text_file).read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>] <span class="comment"># remove last empty line</span></span><br><span class="line">val_dataset = <span class="built_in">open</span>(val_text_file).read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>] <span class="comment"># remove last empty line</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列印看看資料的長度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(train_dataset)= <span class="subst">&#123;<span class="built_in">len</span>(train_dataset)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(train_label_pd)= <span class="subst">&#123;<span class="built_in">len</span>(train_label_pd)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;=== train_label_pd === \n<span class="subst">&#123;train_label_pd.value_counts()&#125;</span>&#x27;</span>) <span class="comment"># 查看train的情緒標籤資料分布</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(test_dataset)= <span class="subst">&#123;<span class="built_in">len</span>(test_dataset)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len(test_label_pd)= <span class="subst">&#123;<span class="built_in">len</span>(test_label_pd)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;=== test_label_pd === \n<span class="subst">&#123;test_label_pd.value_counts()&#125;</span>&#x27;</span>) <span class="comment"># 查看test的情緒標籤資料分布</span></span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(train_dataset)= <span class="number">3257</span></span><br><span class="line"><span class="built_in">len</span>(train_label_pd)= <span class="number">3257</span></span><br><span class="line">=== train_label_pd === </span><br><span class="line"><span class="number">0</span>    <span class="number">1400</span></span><br><span class="line"><span class="number">3</span>     <span class="number">855</span></span><br><span class="line"><span class="number">1</span>     <span class="number">708</span></span><br><span class="line"><span class="number">2</span>     <span class="number">294</span></span><br><span class="line">Name: count, dtype: int64</span><br><span class="line"><span class="built_in">len</span>(test_dataset)= <span class="number">1421</span></span><br><span class="line"><span class="built_in">len</span>(test_label_pd)= <span class="number">1421</span></span><br><span class="line">=== test_label_pd === </span><br><span class="line"><span class="number">0</span>    <span class="number">558</span></span><br><span class="line"><span class="number">3</span>    <span class="number">382</span></span><br><span class="line"><span class="number">1</span>    <span class="number">358</span></span><br><span class="line"><span class="number">2</span>    <span class="number">123</span></span><br><span class="line">Name: count, dtype: int64</span><br></pre></td></tr></table></figure><h1 id="Task-1-5-建立LSTM-GRU-模型">Task 1 + 5 : 建立LSTM, GRU 模型</h1><div class="note info flat"><ol><li><strong>建立LSTM模型</strong>：Follow the example described <a href="https://pytorch.org/tutorials/beginner/nlp/sequence_models_tutorial.html">here</a>. Use the same architecture, but:<ol><li>only use the last output of the LSTM in the loss function</li><li>use an embedding dim of 128</li><li>use a hidden dim of 256.</li></ol></li><li><strong>建立GRU模型，並訓練</strong>：Do the same, but this time use GRUs instead of LSTMs.</li></ol></div><p>從官網範例中我們可以學習到如何建置LSTM模型，基本上我們會有以下元素：</p><ul><li><code>hidden_dim</code>：隱藏層的維度，代表的是 hidden layer 的神經元數量</li><li><code>word_embeddings</code>：將輸入的句子中的每個詞都轉換成詞向量<ul><li><code>embedding_dim(vocab_size, embedding_dim)</code>：<ul><li><code>vocab_size</code>：字典的大小，也就是我們總共有多少個字，這個例子中我們之後會輸入 5001 個字，5000 常用字 ＋ 1 無法辨識的字</li><li><code>embedding_dim</code>：表示將每個詞或符號映射到固定大小的向量空間中。如果你的 <code>embedding_dim</code> 設定為 6，而你的 input 向量是 [1, 2, 3, 5]，模型會將每個數字映射到六維度的向量空間中，形成類似 [1, 2, 3, 5, 6, 4] 的表示。</li></ul></li><li><code>lstm(input_size, hidden_size, dropout)</code><ul><li><code>input_size</code>：輸入的維度，也就是我們的詞向量維度</li><li><code>hidden_size</code>：隱藏層的維度，代表的是 hidden layer 的神經元數量</li><li><code>dropout</code>：dropout的比例，預設為0，代表不使用dropout</li></ul></li><li><code>hidden2tag(in_features, out_features)</code><ul><li><code>in_features</code>：也就是 hidden_dim 輸入的維度，也就是我們的詞向量維度</li><li><code>out_features</code>：也就是 tagset_size 輸出的維度，也就是我們的情緒標籤維度</li></ul></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LSTMTagger</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_dim, hidden_dim, vocab_size, tagset_size, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(LSTMTagger, self).__init__()</span><br><span class="line">        self.hidden_dim = hidden_dim</span><br><span class="line">        <span class="comment"># 把每個詞都轉換成詞向量</span></span><br><span class="line">        self.word_embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The LSTM takes word embeddings as inputs, and outputs hidden states</span></span><br><span class="line">        <span class="comment"># with dimensionality hidden_dim.</span></span><br><span class="line">        self.lstm = nn.LSTM(embedding_dim, hidden_dim, dropout=dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The linear layer that maps from hidden state space to tag space</span></span><br><span class="line">        self.hidden2tag = nn.Linear(hidden_dim, tagset_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        embeds = self.word_embeddings(sentence) <span class="comment"># 將輸入的句子中的每個詞都轉換成詞向量 此時的 sentence 已經是 index 形式的向量</span></span><br><span class="line">        lstm_out, _ = self.lstm(embeds.view(<span class="built_in">len</span>(sentence), <span class="number">1</span>, -<span class="number">1</span>)) <span class="comment"># 將詞向量作為LSTM模型的輸入 得到LSTM曾的輸出和隱藏狀態</span></span><br><span class="line">        <span class="comment"># Take only the last output of the LSTM</span></span><br><span class="line">        last_output = lstm_out[-<span class="number">1</span>].view(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># Selecting the last output 為了滿足作業要求，我們只取最後一個輸出 </span></span><br><span class="line">        tag_space = self.hidden2tag(last_output) <span class="comment"># 將LSTM模型的最後輸出轉換成 詞標籤 空間</span></span><br><span class="line">        tag_scores = F.log_softmax(tag_space, dim=<span class="number">1</span>) <span class="comment"># 將詞標籤 空間 轉換成 機率空間 </span></span><br><span class="line">        <span class="keyword">return</span> tag_scores</span><br></pre></td></tr></table></figure><p>GRU 與 LSTM 類似，唯獨要修改的地方是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GRUTagger</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_dim, hidden_dim, vocab_size, tagset_size, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Here !!! 修改成 GRU </span></span><br><span class="line">        self.gru = nn.GRU(embedding_dim, hidden_dim, dropout=dropout)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Here !!! 這邊套用 gru </span></span><br><span class="line">        gru_out, _ = self.gru(embeds.view(<span class="built_in">len</span>(sentence), <span class="number">1</span>, -<span class="number">1</span>)) <span class="comment"># 將詞向量作為LSTM模型的輸入 得到LSTM曾的輸出和隱藏狀態</span></span><br><span class="line">        last_output = gru_out[-<span class="number">1</span>].view(<span class="number">1</span>, -<span class="number">1</span>) <span class="comment"># Selecting the last output 為了滿足作業要求，我們只取最後一個輸出 </span></span><br><span class="line">        ... </span><br></pre></td></tr></table></figure><p>完成的GRU程式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GRUTagger</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embedding_dim, hidden_dim, vocab_size, tagset_size, dropout=<span class="number">0.0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GRUTagger, self).__init__()</span><br><span class="line">        self.hidden_dim = hidden_dim</span><br><span class="line">        self.word_embeddings = nn.Embedding(vocab_size, embedding_dim)</span><br><span class="line">        self.gru = nn.GRU(embedding_dim, hidden_dim, dropout=dropout) <span class="comment"># &lt;== Here ! </span></span><br><span class="line">        self.hidden2tag = nn.Linear(hidden_dim, tagset_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        embeds = self.word_embeddings(sentence) </span><br><span class="line">        gru_out, _ = self.gru(embeds.view(<span class="built_in">len</span>(sentence), <span class="number">1</span>, -<span class="number">1</span>))  <span class="comment"># &lt;== Here ! </span></span><br><span class="line">        last_output = gru_out[-<span class="number">1</span>].view(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># &lt;== Here ! </span></span><br><span class="line">        tag_space = self.hidden2tag(last_output)</span><br><span class="line">        tag_scores = F.log_softmax(tag_space, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tag_scores</span><br></pre></td></tr></table></figure><h1 id="Task-2-3-使用SpaCy切割字-找出Top5000的字">Task 2 + 3 : 使用SpaCy切割字, 找出Top5000的字</h1><div class="note info flat"><p>我們已經在 Task0 把所需要的資料都放入變數list當中，每筆資料都是一個句子，我們現在要做幾件事情：<br>2. <strong>使用SpaCy切割字</strong>：Use spaCy to split the tweets into words.<br>3. <strong>挑選Top5000的字</strong>：Limit your vocabulary (i.e. the words that you converted to an index) to the most frequent 5000<br>words and replace all other words with an placeholder index (e.g. 1001).</p></div><h2 id="安裝-SpaCy">安裝 SpaCy</h2><p>我們要先執行以下指令，安裝 SpaCy 套件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你是 Python3 </span></span><br><span class="line">pip install -U spacy</span><br><span class="line"><span class="comment"># 如果你是 Anaconda </span></span><br><span class="line">conda install -c conda-forge spacy</span><br></pre></td></tr></table></figure><p>因為我們分析的是英文，所以我們需要下載英文用的模型，執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download en_core_web_sm</span><br></pre></td></tr></table></figure><p>這樣才可以在 notebook 中 import spacy 套件，並且使用英文模型。</p><div class="note warning flat"><p>如果沒有執行上述指令，這邊會出錯喔！！<br><code>nlp = spacy.load(&quot;en_core_web_sm&quot;)</code></p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># use spacy to tokenize the sentence with english model </span></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>) <span class="comment"># &lt;=== 如果沒有執行上述指令，這邊會出錯喔！！</span></span><br></pre></td></tr></table></figure><h2 id="準備-top-5000-常用字的字典">準備 top 5000 常用字的字典</h2><p>我們要先找出 top 5000 常用字，並且建立一個字典，為了做到這樣的事情：</p><ol><li>我們先準備好一個字串，把所有句子串起來。</li><li>然後把整個字串送入 spacy 進行資料切割，並且過濾掉<code>標點符號(punct)</code>和<code>停用字(stop word)</code>還有<code>空白(space)</code>。</li><li>使用 Counter 套件，把 word 進行計數，以方便找出 top 5000 常用字。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># join all the sentence together </span></span><br><span class="line"><span class="comment"># e.g. [&#x27;today is good&#x27;, &#x27;today is bad&#x27;] =&gt; [&#x27;today is good today is bad&#x27;]</span></span><br><span class="line">text = <span class="string">&#x27; &#x27;</span>.join(train_dataset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use spacy to tokenize the sentence </span></span><br><span class="line">doc = nlp(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter out the punctuation and stop words</span></span><br><span class="line">word_freq = Counter(token.text <span class="keyword">for</span> token <span class="keyword">in</span> doc \</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> token.is_punct <span class="keyword">and</span> \</span><br><span class="line">                        <span class="keyword">not</span> token.is_stop <span class="keyword">and</span> \</span><br><span class="line">                            <span class="keyword">not</span> token.is_space )</span><br><span class="line">word_freq</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Counter(&#123;<span class="string">&#x27;@user&#x27;</span>: <span class="number">2019</span>, <span class="comment">-- 光是 @user 就出現了 2019 次 </span></span><br><span class="line">         <span class="string">&#x27;like&#x27;</span>: <span class="number">212</span>,</span><br><span class="line">         <span class="string">&#x27;amp&#x27;</span>: <span class="number">148</span>,</span><br><span class="line">         <span class="string">&#x27;people&#x27;</span>: <span class="number">126</span>,</span><br><span class="line">         <span class="string">&#x27;know&#x27;</span>: <span class="number">96</span>,</span><br><span class="line">         <span class="string">&#x27;think&#x27;</span>: <span class="number">92</span>,</span><br><span class="line">         <span class="string">&#x27;sad&#x27;</span>: <span class="number">90</span>,</span><br><span class="line">         <span class="string">&#x27;got&#x27;</span>: <span class="number">85</span>,</span><br><span class="line">         <span class="string">&#x27;day&#x27;</span>: <span class="number">81</span>,</span><br><span class="line">         <span class="string">&#x27;u&#x27;</span>: <span class="number">80</span>,</span><br><span class="line">         <span class="string">&#x27;time&#x27;</span>: <span class="number">78</span>,</span><br><span class="line">         <span class="string">&#x27;✨&#x27;</span>: <span class="number">75</span>,</span><br><span class="line">         <span class="string">&#x27;😂&#x27;</span>: <span class="number">75</span>,</span><br><span class="line">         <span class="string">&#x27;want&#x27;</span>: <span class="number">74</span>,</span><br><span class="line">         <span class="string">&#x27;life&#x27;</span>: <span class="number">73</span>,</span><br><span class="line">         <span class="string">&#x27;going&#x27;</span>: <span class="number">69</span>,</span><br><span class="line">         <span class="string">&#x27;feel&#x27;</span>: <span class="number">67</span>,</span><br><span class="line">         <span class="string">&#x27;angry&#x27;</span>: <span class="number">66</span>,</span><br><span class="line">         <span class="string">&#x27;2&#x27;</span>: <span class="number">65</span>,</span><br><span class="line">         ...&#125;)</span><br></pre></td></tr></table></figure><p>接下來我們就可以根據 words 出現的次數，選出最多的前 5000 筆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 選擇最常見的 5000 個單詞作為詞彙表</span></span><br><span class="line">most_common_words = word_freq.most_common(<span class="number">5000</span>)</span><br><span class="line"><span class="comment"># 建立詞彙到索引的映射 e.g. &#123;&#x27;hello&#x27;:0, &#x27;like&#x27;:1 ...&#125;</span></span><br><span class="line">vocab = &#123;word[<span class="number">0</span>]: idx <span class="keyword">for</span> idx, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(most_common_words)&#125;</span><br></pre></td></tr></table></figure><h2 id="將句子轉換成-tensor">將句子轉換成 tensor</h2><p>有了 <code>vocab</code> 這個字典後，我們就可以基於這個字典，把句子轉換成 index 的形式。舉例來說：</p><ul><li>原本的句子：<code>I like apple</code></li><li>轉換成 index 的形式：<code>[100, 3923, 123]</code></li></ul><p>但是萬一出現了我們看不懂的單字，或是沒收錄的單字該怎麼辦？</p><ul><li>這邊我們還需要一個 <code>placeholder_index</code></li><li>當我們的句子中有字不在 <code>vocab</code> 字典中時，我們就把這個字轉換成 <code>placeholder_index</code></li><li>這邊我們設定為 5000，代表無法辨識的字，舉例來說：<ul><li>原本的句子：<code>I like jifw8evjk</code></li><li>轉換成 index 的形式：<code>[100, 3923, 5000]</code></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 轉換單詞為索引，超出詞彙表的單詞用佔位索引 5000 代替 因為我們會收集前 0-4999 index 的單詞</span></span><br><span class="line">placeholder_index = <span class="number">5000</span></span><br><span class="line"><span class="comment"># 存放整個 dataset 轉換成 index 的結果 </span></span><br><span class="line">indexed_dataset = []</span><br><span class="line"><span class="keyword">for</span> tweet <span class="keyword">in</span> train_dataset: <span class="comment"># 取出第一個句子 </span></span><br><span class="line">    indexed_words = [] <span class="comment"># 建立一個空的 list 存放當前句子的結果 (e.g. I like apple -&gt; [100, 3923, 123]) </span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> nlp(tweet): <span class="comment"># 透過 spacy 切割句子成單詞 </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token.is_punct <span class="keyword">and</span> <span class="keyword">not</span> token.is_stop <span class="keyword">and</span> <span class="keyword">not</span> token.is_space: <span class="comment"># 確保單字不是標點符號、停用字、空白 </span></span><br><span class="line">            word = token.text </span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> vocab: <span class="comment"># 如果該單字在我們的常見 5000 單字中，就把它轉換成 index </span></span><br><span class="line">                indexed_words.append(vocab[word])</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 否則 index 就是 placeholder_index </span></span><br><span class="line">                indexed_words.append(placeholder_index)</span><br><span class="line">    indexed_dataset.append(indexed_words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印轉換後的數據</span></span><br><span class="line"><span class="built_in">print</span>(indexed_dataset)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[2013, 3615, 269, 3616, 3617, 1426, 717, 86], [1069, 339, 2014, 2015, 44, 2016], ...] </span></span><br></pre></td></tr></table></figure><p>那根據上面的說明，我們可以把上面的程式碼包裝成一個 function，方便我們之後在進行訓練時，把句子轉換成 index list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for sentence to sequence </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_sentence_sequence</span>(<span class="params">seq, to_ix</span>):</span><br><span class="line">    idx = []</span><br><span class="line">    <span class="comment"># use spacy to tokenize the sentence </span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> nlp(seq):</span><br><span class="line">        <span class="comment"># filter out the punctuation and stop words and space </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token.is_punct <span class="keyword">and</span> <span class="keyword">not</span> token.is_stop <span class="keyword">and</span> <span class="keyword">not</span> token.is_space:</span><br><span class="line">            word = token.text</span><br><span class="line">            <span class="comment"># if the token is in the top 5000 words in the vocab, add its index to the list</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> to_ix:</span><br><span class="line">                idx.append(to_ix[word])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># else add the index of the placeholder token</span></span><br><span class="line">                idx.append(placeholder_index)</span><br><span class="line">    <span class="keyword">return</span> torch.tensor(idx, dtype=torch.long) <span class="comment"># 把 list 轉換成 tensor </span></span><br></pre></td></tr></table></figure><h2 id="將標籤轉換成-tensor">將標籤轉換成 tensor</h2><p>接下來，我們要處理標籤，標籤也需要轉換成向量，這樣 model 的 ouput 才可以與 正確解答 做比較：</p><ul><li>通常我們預期 model 的 output 會長這樣：<code>[0.1, 0.2, 0.3, 0.4]</code><ul><li>分別代表 <code>&#123;0: 'anger', 1: 'joy', 2: 'optimism', 3: 'sadness'&#125;</code>的機率</li></ul></li><li>當解答是 <code>anger</code> 時，我們希望 model 的 output 越接近 <code>[1, 0, 0, 0]</code> 越好<ul><li>也就是說，我們需要把 label 進行 one-hot-encoding 轉換成向量的形式，才可以進行比較</li><li>為了可以把「模型產生的結果」 <code>[0.1, 0.2, 0.3, 0.4]</code> 和 「正確解答」<code>[1,0,0,0]</code> 放入 loss function 中計算 loss</li><li>因此我們需要一個函式，把標籤轉換成向量的形式，這個函示就是 <code>one_hot_encode</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">one_hot_encode</span>(<span class="params">val, to_ix</span>): <span class="comment"># val 是標籤的 index (e.g. 2); to_ix 是標籤的字典 (e.g. &#123;0:&#x27;angry&#x27;, 1:&#x27;happy&#x27;&#125;) </span></span><br><span class="line">    result = [] <span class="comment"># 建立一個空的 list 儲存結果 </span></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> to_ix.items(): <span class="comment"># 我們把標籤的字典進行迭代</span></span><br><span class="line">        <span class="keyword">if</span> val == k: <span class="comment"># 一但發現，val 等於 k，代表我們找到了正確的標籤 </span></span><br><span class="line">            result.append(<span class="number">1</span>) <span class="comment"># 在這個位置我們要填上 1 </span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            result.append(<span class="number">0</span>) <span class="comment"># 其他位置都填上 0 </span></span><br><span class="line">    <span class="keyword">return</span> torch.tensor(result, dtype=torch.float32) <span class="comment"># 把 list 轉換成 tensor </span></span><br></pre></td></tr></table></figure><p>建立好上述的函示之後我們可以來實驗看看這個函示有沒有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因為 mapping_pd 是一個 dataframe，我們要把它轉換成字典，方便我們之後使用 </span></span><br><span class="line">mapping = <span class="built_in">dict</span>(<span class="built_in">zip</span>(mapping_pd[<span class="number">0</span>], mapping_pd[<span class="number">1</span>])) <span class="comment"># 回傳 &#123;0:&#x27;angry&#x27;, 1:&#x27;happy&#x27;, 2:&#x27;optimism&#x27;, 3:&#x27;sadness&#x27;&#125; </span></span><br><span class="line"><span class="built_in">print</span>(mapping)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;ans=2; vector=<span class="subst">&#123;one_hot_encode(<span class="number">2</span>, tag_to_ix)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下: 你看！我們把 2 成功轉換成 <code>[0, 0, 1, 0]</code> 的向量了！</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;anger&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;joy&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;optimism&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;sadness&#x27;</span>&#125;</span><br><span class="line">ans=<span class="number">2</span>; vector=tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure><h1 id="Task-4-訓練模型並計算準確度">Task 4: 訓練模型並計算準確度</h1><div class="note info flat"><ol start="4"><li><strong>訓練模型並計算準確度</strong>：Evaluate the accuracy on the test set. (Note: If the training takes to long, try to use only a fraction of the training data.)</li></ol></div><h2 id="小試身手">小試身手</h2><p>在開始訓練模型前，<strong>我們要先知道我們的模型的輸入和輸出長什麼樣子</strong>，在這邊我們試試看，模型還沒訓練前預測的結果吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># See what the scores are before training</span></span><br><span class="line"><span class="comment"># Here we don&#x27;t need to train, so the code is wrapped in torch.no_grad()</span></span><br><span class="line">sentence_idx = <span class="number">1</span> <span class="comment"># 拿第一個句子來測試</span></span><br><span class="line"><span class="comment"># 印出：My roommate: it&#x27;s okay that we can&#x27;t spell because we have autocorrect. #terrible #firstworldprobs </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;First Sentense = <span class="subst">&#123;train_dataset[sentence_idx]&#125;</span>&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="comment"># 這時候我們可以把第一個句子轉換成 index 的形式，並且把它轉換成 tensor </span></span><br><span class="line">    inputs = prepare_sentence_sequence(train_dataset[sentence_idx], word_to_ix)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Sentense to tensor = <span class="subst">&#123;inputs&#125;</span>&#x27;</span>) <span class="comment"># 印出：tensor([1070,  340, 2015, 2016,   45, 2017])</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 然後把解答轉換成 tensor </span></span><br><span class="line">    labels = one_hot_encode(train_label_pd[<span class="number">0</span>][sentence_idx], tag_to_ix)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Sentense of result to tensor = <span class="subst">&#123;labels&#125;</span>&#x27;</span>) <span class="comment"># 印出：tensor([1., 0., 0., 0.])</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 把 inputs 送入模型中，得到模型的預測結果 </span></span><br><span class="line">    outputs = model(inputs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;tag_scores = <span class="subst">&#123;outputs&#125;</span>&#x27;</span>) <span class="comment"># 印出：tensor([[-1.3280, -1.4272, -1.4998, -1.3026]])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取出最大的機率值，並且取出 index </span></span><br><span class="line">    _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;preds = <span class="subst">&#123;preds&#125;</span>&#x27;</span>) <span class="comment"># 印出：preds = tensor([3])  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 計算 loss 看看 output 跟 label 的差距，這邊 output[0] 是因為發現 output 多包一層 </span></span><br><span class="line">    result_idx = torch.argmax(outputs).item()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;result = <span class="subst">&#123;result_idx&#125;</span>, ans = <span class="subst">&#123;train_label_pd[<span class="number">0</span>][sentence_idx]&#125;</span>&#x27;</span>) <span class="comment"># 印出：result = 3, ans = 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 計算 loss 看看 output 跟 label 的差距，這邊 output[0] 是因為發現 output 多包一層</span></span><br><span class="line">    loss = loss_function(outputs[<span class="number">0</span>], labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss = <span class="subst">&#123;loss&#125;</span>&#x27;</span>) </span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">First Sentense = My roommate: it<span class="string">&#x27;s okay that we can&#x27;</span>t spell because we have autocorrect. <span class="comment">#terrible #firstworldprobs </span></span><br><span class="line">Sentense to tensor = tensor([<span class="number">1070</span>,  <span class="number">340</span>, <span class="number">2015</span>, <span class="number">2016</span>,   <span class="number">45</span>, <span class="number">2017</span>])</span><br><span class="line">Sentense of result to tensor = tensor([<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">tag_scores = tensor([[-<span class="number">1.3280</span>, -<span class="number">1.4272</span>, -<span class="number">1.4998</span>, -<span class="number">1.3026</span>]])</span><br><span class="line">loss = <span class="number">1.32795250415802</span></span><br><span class="line">preds = tensor([<span class="number">3</span>])</span><br><span class="line">result = <span class="number">3</span>, ans = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>看起來運行的還挺順暢的對吧？<br>那我們正式開始囉！</p><h2 id="準備-training-用的函示">準備 training 用的函示</h2><p>這邊我希望在 training 每次的 epoch 時：</p><ul><li>列印出 training 的 loss 和 accuracy 來確認模型的訓練狀況。</li><li>同時保留最好的model。</li><li>計算訓練時間。</li><li>我們預期輸出的結果會長這樣：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">29</span> </span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.2157</span> Acc: <span class="number">0.4642</span> Time elapsed: <span class="number">25</span> sec. <span class="comment">-- 列印出 training 的 accuracy 來確認模型的訓練狀況。</span></span><br><span class="line">test Loss: <span class="number">1.2095</span> Acc: <span class="number">0.4553</span> Time elapsed: <span class="number">32</span> sec. <span class="comment">-- 列印出 testing 的 accuracy 來確認模型的訓練狀況。</span></span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.1019</span> Acc: <span class="number">0.5333</span> Time elapsed: <span class="number">58</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1816</span> Acc: <span class="number">0.4708</span> Time elapsed: <span class="number">65</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.0151</span> Acc: <span class="number">0.5812</span> Time elapsed: <span class="number">92</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1603</span> Acc: <span class="number">0.4898</span> Time elapsed: <span class="number">99</span> sec.</span><br><span class="line">...</span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">17</span>m <span class="number">5</span>s <span class="comment">-- 列印出 訓練所有 epoch 的時間。 </span></span><br><span class="line">Best val Acc: <span class="number">0.599578</span> #  <span class="comment">-- 列印出並保留 最好的 accuracy 的 model </span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>有沒有覺得上述的程式碼很熟悉？沒錯！如果你有按照這篇<a href="https://shannonhung.github.io/posts/flower102-transfer-learning.html">Flower102 Dataset - 使用 Transfer Learning 訓練 + 使用 Batch Normalization 於 CNN</a>裡面也是用同一種training的方式。<br>因為它既可以同時觀察 training 的結果，還可以觀察 testing 的結果訓練狀況是否有過擬合的情況。<br>儘管過度擬合，這個方式也可以保存最佳的模型。</p></div><p>那我們就開始 <code>train_model</code> 的函式，我這邊會透過 <code>!!!</code> 來標示出我們需要修改的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, criterion, optimizer, scheduler, num_epochs=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># 開始訓練的時間 </span></span><br><span class="line">    since = time.time()</span><br><span class="line">    <span class="comment"># 建立一個暫存資料夾，用來存放最好的模型 </span></span><br><span class="line">    <span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> tempdir:</span><br><span class="line">        <span class="comment"># 把目前最好的模型存放的路徑 </span></span><br><span class="line">        best_model_params_path = os.path.join(tempdir, <span class="string">&#x27;best_model_params.pt&#x27;</span>)</span><br><span class="line">        <span class="comment"># 先把最好的模型存放起來 </span></span><br><span class="line">        torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line">        <span class="comment"># 當前最好的準確度，如果有更好的準確度就會更新 </span></span><br><span class="line">        best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 開始訓練 n 個 epoch </span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;num_epochs - <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Each epoch has a training and validation phase</span></span><br><span class="line">            <span class="keyword">for</span> phase <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]:</span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    model.train()</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    model.<span class="built_in">eval</span>()</span><br><span class="line">                </span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line">                running_corrects = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Iterate over data.</span></span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">input</span>, label <span class="keyword">in</span> <span class="built_in">zip</span>(dataloaders[phase], resultloaders[phase]):</span><br><span class="line">                    <span class="comment"># ===== !!! Here !!! ====== </span></span><br><span class="line">                        <span class="comment"># 這邊就會使用到我們Task 2+3 所建立的函式，把句子轉換成 index 的形式，還有把label轉換成向量的形式 </span></span><br><span class="line">                        <span class="comment"># e.g. tensor([1070,  340, 2015, 2016,   45, 2017])</span></span><br><span class="line">                    inputs_vector = prepare_sentence_sequence(<span class="built_in">input</span>, word_to_ix) </span><br><span class="line">                        <span class="comment"># e.g. tensor([1., 0., 0., 0.]) </span></span><br><span class="line">                    labels_vector = one_hot_encode(label, tag_to_ix) </span><br><span class="line">                    <span class="comment"># ===== !!! End !!! ====== </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># zero the parameter gradients </span></span><br><span class="line">                    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># forward</span></span><br><span class="line">                    <span class="comment"># track history if only in train</span></span><br><span class="line">                    <span class="keyword">with</span> torch.set_grad_enabled(phase == <span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">                        <span class="comment"># 以下就會跟小試身手類似</span></span><br><span class="line">                        <span class="comment"># 取得針對每個emotion的預測結果tensor  </span></span><br><span class="line">                        outputs = model(inputs_vector) <span class="comment"># (e.g. tensor([[-1.3948, -1.4476, -1.3804, -1.3261]]))</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># ===== !!! Here !!! ====== </span></span><br><span class="line">                            <span class="comment"># 取得最大值的index </span></span><br><span class="line">                        pred = torch.argmax(outputs).item() <span class="comment"># (e.g. 2)</span></span><br><span class="line">                            <span class="comment"># 外面還有一層，只需取得內層 [-1.3948, -1.4476, -1.3804, -1.3261] 與 [0, 0, 1, 0] 的計算loss </span></span><br><span class="line">                        loss = criterion(outputs[<span class="number">0</span>], labels_vector) <span class="comment"># </span></span><br><span class="line">                        <span class="comment"># ===== !!! End !!! ====== </span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># backward + optimize only if in training phase</span></span><br><span class="line">                        <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                            loss.backward()</span><br><span class="line">                            optimizer.step()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># statistics</span></span><br><span class="line">                    running_loss += loss.item()</span><br><span class="line">                    <span class="keyword">if</span> pred == label:</span><br><span class="line">                        running_corrects += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    scheduler.step()</span><br><span class="line">                <span class="comment"># 計算每個 epoch 的 loss 和 accuracy </span></span><br><span class="line">                epoch_loss = running_loss / dataset_sizes[phase]</span><br><span class="line">                epoch_acc = running_corrects / dataset_sizes[phase]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;phase&#125;</span> Loss: <span class="subst">&#123;epoch_loss:<span class="number">.4</span>f&#125;</span> Acc: <span class="subst">&#123;epoch_acc:<span class="number">.4</span>f&#125;</span> Time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - since))&#125;</span> sec.&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 如果發現 有更好的準確度，就把模型存起來 </span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;test&#x27;</span> <span class="keyword">and</span> epoch_acc &gt; best_acc:</span><br><span class="line">                    best_acc = epoch_acc</span><br><span class="line">                    torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        time_elapsed = time.time() - since</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Training complete in <span class="subst">&#123;time_elapsed // <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>m <span class="subst">&#123;time_elapsed % <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>s&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Best val Acc: <span class="subst">&#123;best_acc:4f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load best model weights 然後執行下一個 epoch </span></span><br><span class="line">        model.load_state_dict(torch.load(best_model_params_path))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p><strong>你會發現要改的地方沒幾個…頂多就是</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment"># input 跟 label 的轉換 </span></span><br><span class="line">        inputs_vector = prepare_sentence_sequence(<span class="built_in">input</span>, word_to_ix) </span><br><span class="line">        labels_vector = one_hot_encode(label, tag_to_ix) </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 然後取出 pred 的 index 才可以判斷預測是否正確 </span></span><br><span class="line">        pred = torch.argmax(outputs).item()</span><br><span class="line">        <span class="comment"># 計算 loss 時要特別取出內層的值</span></span><br><span class="line">        loss = criterion(outputs[<span class="number">0</span>], labels_vector)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那我們現在來準備訓練模型吧！</p><h2 id="訓練模型">訓練模型</h2><p>那我們先準備好訓練使用的dataset吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在這之前我們先準備好模型使用的dataset </span></span><br><span class="line">dataloaders = &#123;<span class="string">&#x27;train&#x27;</span>: train_dataset, <span class="string">&#x27;test&#x27;</span>: test_dataset&#125;</span><br><span class="line">resultloaders = &#123;<span class="string">&#x27;train&#x27;</span>: train_label_pd[<span class="number">0</span>].tolist(), <span class="string">&#x27;test&#x27;</span>: test_label_pd[<span class="number">0</span>].tolist()&#125;</span><br><span class="line">dataset_sizes = &#123;x: <span class="built_in">len</span>(dataloaders[x]) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure><p>首先建立 LSTM 的模型吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 model </span></span><br><span class="line"><span class="comment"># vocab_size 要添加 1 因為如果 sentence 中有出現沒在 vocab 中的單字，使用 5000 來代替，所以要加 1</span></span><br><span class="line">model_LSTM = LSTMTagger(EMBEDDING_DIM, HIDDEN_DIM, <span class="built_in">len</span>(word_to_ix)+<span class="number">1</span>, <span class="built_in">len</span>(tag_to_ix), dropout=<span class="number">0.5</span>)</span><br><span class="line">loss_function_LSTM = nn.CrossEntropyLoss()</span><br><span class="line">optimizer_LSTM = optim.SGD(model_LSTM.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">exp_lr_scheduler_LSTM = lr_scheduler.StepLR(optimizer_LSTM, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始訓練 </span></span><br><span class="line">modelLSTM = train_model(model_LSTM, loss_function_LSTM, optimizer_LSTM, exp_lr_scheduler_LSTM, num_epochs=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">2</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.9885</span> Acc: <span class="number">0.5840</span> Time elapsed: <span class="number">97</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1279</span> Acc: <span class="number">0.5236</span> Time elapsed: <span class="number">104</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.8893</span> Acc: <span class="number">0.6371</span> Time elapsed: <span class="number">132</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1053</span> Acc: <span class="number">0.5369</span> Time elapsed: <span class="number">139</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.7683</span> Acc: <span class="number">0.7003</span> Time elapsed: <span class="number">168</span> sec.</span><br><span class="line">test Loss: <span class="number">1.0772</span> Acc: <span class="number">0.5658</span> Time elapsed: <span class="number">175</span> sec.</span><br><span class="line">...</span><br><span class="line">test Loss: <span class="number">1.1330</span> Acc: <span class="number">0.6059</span> Time elapsed: <span class="number">1040</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">17</span>m <span class="number">20</span>s</span><br><span class="line">Best val Acc: <span class="number">0.610134</span></span><br></pre></td></tr></table></figure><p>然後建立 GRU 的模型吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vocab_size 要添加 2 因為如果 sentence 中有出現沒在 vocab 中的單字，使用 5001 來代替，所以要加 1</span></span><br><span class="line">modelGRU = GRUTagger(EMBEDDING_DIM, HIDDEN_DIM, <span class="built_in">len</span>(word_to_ix)+<span class="number">1</span>, <span class="built_in">len</span>(tag_to_ix), dropout=<span class="number">0.5</span>)</span><br><span class="line">loss_function_gru = nn.CrossEntropyLoss()</span><br><span class="line">optimizer_gru = optim.SGD(modelGRU.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">exp_lr_scheduler_gru = lr_scheduler.StepLR(optimizer_gru, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始訓練 </span></span><br><span class="line">modelGRU = train_model(modelGRU, loss_function_gru, optimizer_gru, exp_lr_scheduler_gru, num_epochs=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">3</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.8445</span> Acc: <span class="number">0.6702</span> Time elapsed: <span class="number">131</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1211</span> Acc: <span class="number">0.5327</span> Time elapsed: <span class="number">138</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">29</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">0.6843</span> Acc: <span class="number">0.7393</span> Time elapsed: <span class="number">166</span> sec.</span><br><span class="line">test Loss: <span class="number">1.1305</span> Acc: <span class="number">0.5707</span> Time elapsed: <span class="number">173</span> sec.</span><br><span class="line">...</span><br><span class="line">test Loss: <span class="number">1.3237</span> Acc: <span class="number">0.6073</span> Time elapsed: <span class="number">1003</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">16</span>m <span class="number">43</span>s</span><br><span class="line">Best val Acc: <span class="number">0.608726</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COCO Dataset - 使用 Faster RCNN + MobileNet 進行 Object Detection</title>
      <link href="/posts/coco-object-diagnoise/"/>
      <url>/posts/coco-object-diagnoise/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第四個作業，主要教授內容為以下主題：</p><ol><li>Download Coco dataset</li><li>User pre-trained version of Faster R-CNN to predict the bounding box</li><li>Calculate IoU</li></ol><h1 id="作業要求">作業要求</h1><ol><li><strong>下載coco資料集</strong>：Download the file „2017 Val images [5/1GB]“ and „ 2017 Train/Val annotations [241MB]“ from<br>the Coco page. You can use the library pycocotools to load them into your notebook.</li><li><strong>隨機從dataset選擇十張</strong>：Randomly select 10 images from this dataset.</li><li><strong>使用pre-trained模型FasterR-CNN預測bbox</strong>：Use a pre-trained version of Faster R-CNN (Resnet50 backbone) to predict the bounding box<br>of objects on the 10 images. Only keep regions that have a score &gt; 0.8.</li><li><strong>把模型跟解答視覺化擺在一起</strong>：Visualize the predicted bounding boxes and label together with the ground truth bounding<br>boxes and label. Show all 10 pairs of images side by side in the jupyter notebook.</li><li><strong>使用另一個pre-trained模型Mobilnet</strong>：Repeat the steps from above using a Mobilenet backbone for the Faster R-CNN.</li><li><strong>計算IoU比較模型</strong>：Wich backbone delivers the better results? Calculate the IoU for both approaches.</li></ol><h1 id="Task-1-下載coco資料集">Task 1: 下載coco資料集</h1><div class="note info flat"><p><strong>Task 1</strong></p><ol><li><strong>下載coco資料集</strong>：Download the file „2017 Val images [5/1GB]“ and „ 2017 Train/Val annotations [241MB]“ from the Coco page. You can use the library pycocotools to load them into your notebook.</li></ol></div><p>可以看照這個說明進行下載：<a href="https://jason-chen-1992.weebly.com/home/coco-dataset">https://jason-chen-1992.weebly.com/home/coco-dataset</a><br><img src="https://i.imgur.com/BieHtLG.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── annotations <span class="comment"># 這是標注資料</span></span><br><span class="line">│   ├── captions_train2017.json</span><br><span class="line">│   ├── captions_val2017.json</span><br><span class="line">│   ├── instances_train2017.json</span><br><span class="line">│   ├── instances_val2017.json</span><br><span class="line">│   ├── person_keypoints_train2017.json</span><br><span class="line">│   └── person_keypoints_val2017.json</span><br><span class="line">└── val2017 <span class="comment"># 這是圖片集 </span></span><br><span class="line">    ├── 000000000139.jpg</span><br><span class="line">    ├── 000000000285.jpg</span><br><span class="line">    ├── 000000000632.jpg</span><br><span class="line">    ├── 000000000724.jpg</span><br><span class="line">    ├── 000000000776.jpg</span><br><span class="line">    ├── 000000000785.jpg</span><br><span class="line">    ├── 000000000802.jpg</span><br><span class="line">    ... </span><br></pre></td></tr></table></figure><ul><li>去官網下載這兩個檔案如圖一</li><li>下載後資料夾解壓縮會如上面的檔案結構</li></ul><h1 id="Task-2-隨機選十張">Task 2: 隨機選十張</h1><div class="note info flat"><p><strong>Task 2</strong><br>2. <strong>隨機從dataset選擇十張</strong>：Randomly select 10 images from this dataset.</p></div><p>這邊我們主要會做幾件事情：</p><ul><li>匯入必要套件</li><li>設定coco api，讓他可以引入我們的資料集的相關資訊，像是預測框位置、標籤位置、圖片資訊</li><li>視覺化圖片並且進行標示</li><li>隨機選十個圖片</li></ul><p>我們先匯入必要的套件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># CNN </span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># torchvision</span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset </span></span><br><span class="line"><span class="keyword">from</span> pycocotools.coco <span class="keyword">import</span> COCO</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cudnn.benchmark = <span class="literal">True</span></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure><h2 id="設定coco-api">設定coco api</h2><p>coco 有提供獲取資料集的 api，只要給他json檔案，我們就可以輕易的我們可以透過這個 api 來根據json檔案，獲取我們需要的資料，像是圖片、標籤、預測框等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定資料集位置</span></span><br><span class="line">cocoRoot = <span class="string">&quot;../../Data/Coco/&quot;</span></span><br><span class="line">dataType = <span class="string">&quot;val2017&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定標註檔案位置</span></span><br><span class="line">annFile = os.path.join(cocoRoot, <span class="string">f&#x27;annotations/instances_<span class="subst">&#123;dataType&#125;</span>.json&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Annotation file: <span class="subst">&#123;annFile&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># # initialize COCO api for instance annotations</span></span><br><span class="line">coco=COCO(annFile)</span><br><span class="line">coco </span><br></pre></td></tr></table></figure><blockquote><p>結果如下</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Annotation file: ../../Data/Coco/annotations/instances_val2017.json</span><br><span class="line">## 表示成功讀取標註檔案</span><br><span class="line">loading annotations into memory...</span><br><span class="line">Done (t=<span class="number">0.35</span>s)</span><br><span class="line">creating index...</span><br><span class="line">index created!</span><br></pre></td></tr></table></figure><h2 id="標註視覺化">標註視覺化</h2><p>為了確保會使用coco所提供的API這邊有一個練習，主要學習以下內容：</p><ul><li>取得 image info by id</li><li>取得 annotation info by id</li><li>學會在 image 上畫 bounding box 並標籤</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Rectangle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做一個function，只要給他 image id 就可以畫出圖片並且標示出 bounding box和標籤</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_image_with_annotations</span>(<span class="params">coco, cocoRoot, dataType, imgId, ax=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># 取得圖片資訊  </span></span><br><span class="line">    imgInfo = coco.loadImgs(imgId)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取得圖片位置 準備拿來視覺化 </span></span><br><span class="line">    imPath = os.path.join(cocoRoot, dataType, imgInfo[<span class="string">&#x27;file_name&#x27;</span>])    </span><br><span class="line">    <span class="comment"># 讀取圖片</span></span><br><span class="line">    im = cv2.imread(imPath)</span><br><span class="line">    <span class="comment"># 轉換色彩空間 cv2 的預設色彩空間為 BGR，但是 matplotlib 的預設色彩空間為 RGB，因此這邊需要轉換一下</span></span><br><span class="line">    im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到圖片的所有標註 bounding boxes </span></span><br><span class="line">    annIds = coco.getAnnIds(imgIds=imgInfo[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    <span class="comment"># 取得所有標註資訊，回傳每個box的座標資訊, 標籤, 準確率</span></span><br><span class="line">    anns = coco.loadAnns(annIds)</span><br><span class="line">    all_labels = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 座標資訊, 標籤, 準確率 </span></span><br><span class="line">    <span class="keyword">for</span> ann <span class="keyword">in</span> anns:</span><br><span class="line">        <span class="comment"># 特別只選取 bbox 的資訊，會傳回 (x, y)圖片左下角, w（框寬）, h（寬高）</span></span><br><span class="line">        x, y, w, h = ann[<span class="string">&#x27;bbox&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取得標籤的文字資訊，load category name by category id </span></span><br><span class="line">        label = coco.loadCats(ann[<span class="string">&#x27;category_id&#x27;</span>])[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        all_labels.add(label)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提供坐標資訊畫出 bounding box</span></span><br><span class="line">        rect = Rectangle((x, y), w, h, linewidth=<span class="number">2</span>, edgecolor=<span class="string">&#x27;r&#x27;</span>, facecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 畫出圖片，因為我可能需要排序圖片，所以可以透過 ax 來指定圖片畫在哪個位置</span></span><br><span class="line">        <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># gca 可以取得目前的 axes，如果沒有就會自動創建一個，axes 你可以想像他是一個畫布，你可以在上面畫點,線,圖,文字等等</span></span><br><span class="line">            <span class="comment"># 然後透過 add_patch 把 預測框 畫上去 </span></span><br><span class="line">            plt.gca().add_patch(rect) </span><br><span class="line">            <span class="comment"># plt.text() 它會將文字標籤加入到目前的Axes物件中，會畫出標籤</span></span><br><span class="line">            plt.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="comment"># 如果沒有 ax 就直接畫在 plt 上 </span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ax.add_patch(rect)</span><br><span class="line">            ax.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=<span class="string">&#x27;r&#x27;</span> )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顯示圖片並給他一個標題</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        plt.imshow(im)</span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">f&#x27;Ans: <span class="subst">&#123;all_labels&#125;</span>&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&#x27;Ans: <span class="subst">&#123;all_labels&#125;</span>&#x27;</span>, color=<span class="string">&#x27;r&#x27;</span>,loc=<span class="string">&#x27;center&#x27;</span>, pad=<span class="number">20</span>)</span><br><span class="line">        ax.imshow(im)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取第十張圖片</span></span><br><span class="line">imgIds = coco.getImgIds()</span><br><span class="line">imgId = imgIds[<span class="number">10</span>]</span><br><span class="line"><span class="comment"># 繪製出來</span></span><br><span class="line">plot_image_with_annotations(coco, cocoRoot, dataType, imgId)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><p><img src="https://i.imgur.com/C0nZWY9.png" alt=""></p><h2 id="隨機選10張">隨機選10張</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">random_select</span>(<span class="params">coco, cocoRoot, dataType, num_images=<span class="number">10</span></span>):</span><br><span class="line">    <span class="comment"># 取得所有圖片的 id</span></span><br><span class="line">    imgIds = coco.getImgIds()</span><br><span class="line">    <span class="comment"># 從這些 id 中隨機選取 num_images 個 id </span></span><br><span class="line">    selected_imgIds = random.sample(imgIds, num_images)</span><br><span class="line">    <span class="comment"># 遞迴呼叫每個 id </span></span><br><span class="line">    <span class="keyword">for</span> imgId <span class="keyword">in</span> selected_imgIds:</span><br><span class="line">        <span class="comment"># 根據 id 繪製圖片</span></span><br><span class="line">        plot_image_with_annotations(coco, cocoRoot, dataType, imgId)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最後印出所有選取的 id</span></span><br><span class="line">    <span class="keyword">return</span> selected_imgIds</span><br><span class="line">    </span><br><span class="line">valid_ids = random_select(coco, cocoRoot, dataType, num_images=<span class="number">10</span>)</span><br><span class="line">valid_ids</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><p><img src="https://i.imgur.com/TUiI82h.png" alt=""></p><h1 id="Task-3-5-FasterR-CNN-v-s-Mobilnet">Task 3+5: FasterR-CNN v.s Mobilnet</h1><div class="note info flat"><p><strong>Task 3 &amp; 5</strong><br>3. <strong>使用pre-trained模型FasterR-CNN預測bbox</strong>：Use a pre-trained version of Faster R-CNN (Resnet50 backbone) to predict the bounding box<br>of objects on the 10 images. Only keep regions that have a score &gt; 0.8.<br>5. <strong>使用另一個pre-trained模型Mobilnet</strong>：Repeat the steps from above using a Mobilenet backbone for the Faster R-CNN.</p></div><h2 id="引用-pre-train-model">引用 pre-train model</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引用 pre-train model  (FasterR-CNN)</span></span><br><span class="line">model_res = torchvision.models.detection.fasterrcnn_resnet50_fpn(weights=<span class="string">&quot;FasterRCNN_ResNet50_FPN_Weights.DEFAULT&quot;</span>)</span><br><span class="line">model_res.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用 pre-train model  (Mobilenet)</span></span><br><span class="line">model_mobile = torchvision.models.detection.fasterrcnn_mobilenet_v3_large_fpn(weights=torchvision.models.detection.FasterRCNN_MobileNet_V3_Large_FPN_Weights)</span><br><span class="line">model_mobile.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><h2 id="圖片轉換成-tensor函式">圖片轉換成 tensor函式</h2><p>我們要先能夠根據圖片的位置，圖取圖片出來。然後把讀書來得圖片，轉換成 tensor，才能放入 model 中進行預測。所以我們做了兩個函式:</p><ul><li>一個是讀取圖片</li><li>一個是把圖片轉成 tensor。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_image</span>(<span class="params">imgIdx</span>):</span><br><span class="line">    <span class="comment"># 取得圖片資訊</span></span><br><span class="line">    imgInfo = coco.loadImgs(imgIdx)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 取得圖片位置 準備拿來視覺化</span></span><br><span class="line">    imPath = os.path.join(cocoRoot, dataType, imgInfo[<span class="string">&#x27;file_name&#x27;</span>])    </span><br><span class="line">    <span class="comment"># 印出圖片位置</span></span><br><span class="line">    <span class="built_in">print</span>(imPath)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 讀取圖片</span></span><br><span class="line">        <span class="keyword">return</span> Image.<span class="built_in">open</span>(imPath)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把圖片轉成 tensor 才可以放入 model 中</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pil2tensor</span>(<span class="params">pil_image</span>):</span><br><span class="line">    <span class="comment"># 使用 unsqueeze(0) 是因為 model 的 還包含 batch size 的維度，共四個維度 (batch_size, channel-RGB, height, width)</span></span><br><span class="line">    <span class="comment"># 但是圖片只有一張沒有batch size，圖片轉tensor會只有三個維度（channel-RGB, height, width），所以我們需要增加一個維度</span></span><br><span class="line">    <span class="comment"># /255 是因為 model 的輸入是 0~1 之間的數字，而圖片的數值是 0~255，所以需要除以 255 來做正規化</span></span><br><span class="line">    <span class="keyword">return</span> torchvision.transforms.PILToTensor()(pil_image).unsqueeze(<span class="number">0</span>) / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><h2 id="訓練模型">訓練模型</h2><p>前置作業都準備好了，我們就可以開始使用pre-trained好的模型進行預測，並儲存回傳的結果，等等視覺化使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用來存放預測結果</span></span><br><span class="line">predictions_res = []</span><br><span class="line">predictions_mobile = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遞迴呼叫每個 id，這些id是我們在上面隨機選取的10個id</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> valid_ids:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment"># transform to tensor from PIL image</span></span><br><span class="line">    img_as_tensor = pil2tensor(load_image(i))</span><br><span class="line">    <span class="comment"># put the tensor to resnet model</span></span><br><span class="line">    prediction = model_res(img_as_tensor)</span><br><span class="line">    <span class="comment"># 存放預測結果：預測結果是一個字典，裡面包含了預測的 bounding box, 標籤, 準確率</span></span><br><span class="line">    predictions_res.append(prediction)</span><br><span class="line">    <span class="comment"># put the tensor to mobilenet model</span></span><br><span class="line">    prediction = model_mobile(img_as_tensor)</span><br><span class="line">    <span class="comment"># 存放預測結果：預測結果是一個字典，裡面包含了預測的 bounding box, 標籤, 準確率</span></span><br><span class="line">    predictions_mobile.append(prediction)</span><br></pre></td></tr></table></figure><h2 id="只選擇-0-8的預測結果">只選擇&gt;0.8的預測結果</h2><p>在收集好所有的結果後，我們要特別從這一大堆預測框中，只挑選準確率大於 0.8 的預測框，這樣視覺化的時候才不會太亂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter_valid_boxes</span>(<span class="params">predictions, threshold=<span class="number">0.8</span></span>):</span><br><span class="line">    <span class="comment"># 用來存放過濾後的預測結果</span></span><br><span class="line">    valid_boxes_list = []</span><br><span class="line">    <span class="comment"># 遞迴呼叫每個預測結果</span></span><br><span class="line">    <span class="keyword">for</span> prediction <span class="keyword">in</span> predictions:</span><br><span class="line">        valid_boxes_for_this_prediction = []</span><br><span class="line">        <span class="comment"># 遞迴呼叫每個預測框</span></span><br><span class="line">        <span class="keyword">for</span> box, label, score <span class="keyword">in</span> <span class="built_in">zip</span>(prediction[<span class="number">0</span>][<span class="string">&quot;boxes&quot;</span>], prediction[<span class="number">0</span>][<span class="string">&quot;labels&quot;</span>], prediction[<span class="number">0</span>][<span class="string">&quot;scores&quot;</span>]):</span><br><span class="line">            <span class="comment"># 保留準確率大於 threshold 的預測框</span></span><br><span class="line">            <span class="keyword">if</span> score &gt;= threshold:</span><br><span class="line">                <span class="comment"># 把預測框, 標籤, 準確率存起來</span></span><br><span class="line">                valid_boxes_for_this_prediction.append((box, label, score))</span><br><span class="line">        <span class="comment"># 如果這張圖片沒有任何一個預測框的準確率大於 threshold，就存一個空的 list</span></span><br><span class="line">        valid_boxes_list.append(valid_boxes_for_this_prediction)</span><br><span class="line">    <span class="comment"># 回傳過濾後的預測結果</span></span><br><span class="line">    <span class="keyword">return</span> valid_boxes_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 threshold 設定為 0.8，並且獲取 resnet 與 mobilenet 的預測結果 </span></span><br><span class="line">valid_boxes_res = filter_valid_boxes(predictions_res, threshold=<span class="number">0.8</span>)</span><br><span class="line">valid_boxes_mobile = filter_valid_boxes(predictions_mobile, threshold=<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><h1 id="Task-4-6-視覺化-IoU">Task 4+6: 視覺化 + IoU</h1><div class="note info flat"><p><strong>Task 4 &amp; 6</strong><br>4. <strong>把模型跟解答視覺化擺在一起</strong>：Visualize the predicted bounding boxes and label together with the ground truth bounding<br>6. <strong>計算IoU比較模型</strong>：Wich backbone delivers the better results? Calculate the IoU for both approaches.</p></div><p>視覺話有很重要的幾點，步驟大概如下：</p><ul><li>要先知道圖片id，根據id取得annotation的資訊，這樣才可以計算 IoU</li><li>我們將ann的資訊跟model的資訊，進行 IoU 的計算</li><li>我們讀取圖片在電腦中的位置，根據圖片路徑，把圖片先透過plt畫出來</li><li>然後基於這個圖片，才可以在上面畫上預測框跟標籤還有 IoU 的平均值</li></ul><p>以下程式就是上述所描述的步驟，我們會把兩個模型的結果都畫出來，並且計算 IoU 的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以把不同 model 的結果放入此函式，並且會回傳 IoU 的平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_annotated_results</span>(<span class="params">imgId, valid_boxes, model_name, color=<span class="string">&#x27;g&#x27;</span>, ax=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="comment"># Load the image</span></span><br><span class="line">    imgInfo = coco.loadImgs(imgId)[<span class="number">0</span>]</span><br><span class="line">    image_path = os.path.join(cocoRoot, dataType, imgInfo[<span class="string">&#x27;file_name&#x27;</span>])</span><br><span class="line">    image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得正確的 bounding box 結果 </span></span><br><span class="line">    annIds = coco.getAnnIds(imgIds=imgInfo[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    anns = coco.loadAnns(annIds)</span><br><span class="line">    bbox_tlist_anns = torch.tensor([ann[<span class="string">&quot;bbox&quot;</span>] <span class="keyword">for</span> ann <span class="keyword">in</span> anns]) <span class="comment"># tensor.shape[2,4]</span></span><br><span class="line">    <span class="comment"># 因為我們的 bounding box 是 x,y,w,h 也就是 框框 左下角的座標(x,y) ＋ 框框的長與寬</span></span><br><span class="line">    <span class="comment"># 但是 torchvision 計算出 IoU 的 box_iou 必須給予 左下角的座標(x,y) 跟 右上角的座標(x2,y2)，所以要透過(x+w, y+h)來計算(x2,y2) 取得右上角的座標 </span></span><br><span class="line">    <span class="comment"># x,y,w,h -&gt; x1,y1,x2,y2 = x,y,x+w,y+h </span></span><br><span class="line">    bbox_tlist_anns[:, <span class="number">2</span>] = bbox_tlist_anns[:, <span class="number">0</span>] + bbox_tlist_anns[:, <span class="number">2</span>]</span><br><span class="line">    bbox_tlist_anns[:, <span class="number">3</span>] = bbox_tlist_anns[:, <span class="number">1</span>] + bbox_tlist_anns[:, <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 從結果valid_boxes中，我們只要box的部分，把label, score拿掉，因此我們使用(box, _, _) </span></span><br><span class="line">    <span class="comment"># 使用 stack 是因為我們要把所有的 box 疊起來，變成一個 tensor   </span></span><br><span class="line">    bbox_tlist_model = torch.stack([box <span class="keyword">for</span> box, _, _ <span class="keyword">in</span> valid_boxes]) <span class="comment"># turn [4] to tensor.shape[2,4]</span></span><br><span class="line">    <span class="comment"># 使用 box_iou 來計算 IoU </span></span><br><span class="line">    iou = torchvision.ops.box_iou(bbox_tlist_anns, bbox_tlist_model) <span class="comment"># get IoU </span></span><br><span class="line">    <span class="comment"># 取得ann每個預測框的最大值後（可以看補充IoU了解詳細），進行 IoU 的平均值</span></span><br><span class="line">    avg_iou = np.mean([t.cpu().detach().numpy().<span class="built_in">max</span>() <span class="keyword">for</span> t <span class="keyword">in</span> iou]) <span class="comment"># calculate the mean of IoU</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 顯示圖片標籤</span></span><br><span class="line">    all_labels = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 開始繪製預測框</span></span><br><span class="line">    <span class="keyword">for</span> boxes <span class="keyword">in</span> valid_boxes:</span><br><span class="line">        <span class="comment"># 取得預測框的資訊 包含 box, label, score </span></span><br><span class="line">        box, label, score = boxes</span><br><span class="line">        <span class="comment"># 取得標籤的文字資訊，load category name by category id </span></span><br><span class="line">        label = coco.loadCats(label.item())[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        <span class="comment"># 把標籤存起來後續顯示用</span></span><br><span class="line">        all_labels.add(label)</span><br><span class="line">        <span class="comment"># 模型回傳的結果是兩個座標，左下角與右上角，所以我們要把他們轉換成 x,y,w,h 的形式放入Rectangle </span></span><br><span class="line">        x, y, x2, y2 = box.detach().numpy() <span class="comment"># x,y,w,h -&gt; x,y,x2-x,y2-y</span></span><br><span class="line">        rect = Rectangle((x, y), x2 - x, y2 - y, linewidth=<span class="number">2</span>, edgecolor=color, facecolor=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 繪製圖片，因為我可能需要排序圖片，所以可以透過 ax 來指定圖片畫在哪個位置</span></span><br><span class="line">        <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># gca 可以取得目前的 axes，如果沒有就會自動創建一個，然後透過 add_patch 把 預測框 畫上去</span></span><br><span class="line">            plt.gca().add_patch(rect) </span><br><span class="line">            <span class="comment"># 在預測框上面畫上標籤</span></span><br><span class="line">            plt.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=color)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不用 gca 是因為我們已經有指定 ax 了，所以直接在 ax 上畫就好</span></span><br><span class="line">            ax.add_patch(rect)</span><br><span class="line">            <span class="comment"># 在預測框上面畫上標籤 </span></span><br><span class="line">            ax.text(x, y, <span class="string">f&#x27;<span class="subst">&#123;label&#125;</span>&#x27;</span>, fontsize=<span class="number">10</span>, color=<span class="string">&#x27;w&#x27;</span>, backgroundcolor=color)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 顯示圖片並給他一個標題，標題是這個圖片有出現過的標籤，以及 IoU 的平均值</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span>: <span class="subst">&#123;all_labels&#125;</span> \n IoU: <span class="subst">&#123;avg_iou:<span class="number">.4</span>f&#125;</span>&#x27;</span>, color=color)</span><br><span class="line">        plt.imshow(image)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        ax.set_title(<span class="string">f&#x27;<span class="subst">&#123;model_name&#125;</span>: <span class="subst">&#123;all_labels&#125;</span> \n I0U: <span class="subst">&#123;avg_iou:<span class="number">.4</span>f&#125;</span>&#x27;</span>, color=color)</span><br><span class="line">        ax.imshow(image)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> avg_iou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res_iou = []</span><br><span class="line">mobile_iou = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遞迴呼叫每個 id，id是我們在上面隨機選取的10個id </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(valid_ids)):</span><br><span class="line">    <span class="comment"># 建立一個 1x3 的圖片，每一張圖片的大小為 15x5 </span></span><br><span class="line">    fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">5</span>))   </span><br><span class="line"></span><br><span class="line">    <span class="comment"># draw truth image 繪製正確解答，並且把圖片畫在中間的圖片上</span></span><br><span class="line">    plot_image_with_annotations(coco, cocoRoot, dataType, valid_ids[i], ax=axs[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 繪製兩個不同模型的預測結果圖片，分別放在左右兩側，並回傳 IoU </span></span><br><span class="line">    i_mobil_iou = display_annotated_results(valid_ids[i], valid_boxes_mobile[i], <span class="string">&quot;mobile&quot;</span>, color=<span class="string">&#x27;g&#x27;</span>, ax=axs[<span class="number">0</span>])</span><br><span class="line">    i_res_iou = display_annotated_results(valid_ids[i], valid_boxes_res[i], <span class="string">&quot;ResNet&quot;</span>, color=<span class="string">&#x27;b&#x27;</span>, ax=axs[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 儲存每個圖片的 IoU 以得知整個模型的表現 </span></span><br><span class="line">    mobile_iou.append(i_mobil_iou)</span><br><span class="line">    res_iou.append(i_res_iou)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># organize the layout</span></span><br><span class="line">    plt.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the mean of IoU list </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ResNet: Avg.&quot;</span>, np.mean(res_iou), <span class="string">&quot;; each IoU:&quot;</span>, res_iou)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MobileNet: Avg.&quot;</span>, np.mean(mobile_iou), <span class="string">&quot;; each IoU:&quot;</span>, mobile_iou)</span><br></pre></td></tr></table></figure><blockquote><p>輸出結果</p></blockquote><p><img src="https://i.imgur.com/LjCVWdY.png" alt=""></p><h1 id="補充：IoU">補充：IoU</h1><ul><li>Ref: <a href="https://blog.csdn.net/IAMoldpan/article/details/78799857">https://blog.csdn.net/IAMoldpan/article/details/78799857</a></li><li>Ref: <a href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/">https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/</a></li></ul><div class="note info flat"><p>IoU (Intersection over Union) 是一個用來評估物件偵測演算法的指標，其定義為<code>預測框</code>與<code>真實框</code>其<code>交集面積</code> / <code>聯集面積</code>，其值介於 0 與 1 之間，值越大代表預測框與真實框的重疊程度越高，也就是預測框越準確。</p></div><p><img src="https://i.imgur.com/VzMudvr.png" alt=""><br><img src="https://i.imgur.com/OKroIoL.png" alt=""><br>取自：<a href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/">https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/</a></p><div class="note info flat"><p><strong>從上面的範例中，你可能會好奇，以下這段程式到底做了什麽？</strong></p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torchvision.ops.box_iou(bbox_tlist_anns, bbox_tlist_model) </span><br></pre></td></tr></table></figure><ul><li>其實基本上他就是把 解答的所有預測框，跟 model 的所有預測框，兩兩計算 IoU，並且回傳一個 tensor，其 shape 為 (解答的預測框數量, model 的預測框數量)，參考下圖。<br><img src="https://i.imgur.com/kQ6IVMY.png" alt=""><br><img src="https://i.imgur.com/lnjmgeD.png" alt=""></li></ul><p><strong>這邊我們只需要取得每個解答預測框的最大 IoU，並且計算平均值即可，因此我們使用以下程式碼</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得ann每個預測框的最大值後（可以看補充IoU了解詳細），進行 IoU 的平均值</span></span><br><span class="line">avg_iou = np.mean([t.cpu().detach().numpy().<span class="built_in">max</span>() <span class="keyword">for</span> t <span class="keyword">in</span> iou]) <span class="comment"># calculate the mean of IoU</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>你可能會好奇，使用 <code>max()</code>, <code>mean()</code>, <code>sum()</code> 這些函式，是否會影響我們的結果？</p></div><p><img src="https://i.imgur.com/lnQtu1r.png" alt=""><br><strong>可以從上圖看到其實會發現</strong></p><ul><li>使用 <code>sum()</code> 你會發現他有可能會超過1，這並不是 IoU 合理的數值範圍。</li><li>使用 <code>max()</code> 他會針對解答的預測框，從 model 選一個最接近的預測框，當作該預測框的IoU，之後就可以取得解答的<code>所有預測框</code>其最大值，並進行平均來獲得整體的 IoU。</li><li>使用 <code>mean()</code> 會有一個問題，這個 IoU的計算永遠不可能為1，因為你考慮到其他預測框的 IoU，這樣就會把 IoU 降低，舉例來說，解答預測框有兩個<code>[A1,A2]</code>，而模型也產生兩個<code>[B1,B2]</code>，一眼就知道，B1預測的是A1，而B2預測A2，而模型也預測的很準確。但是你卻透過 mean 把B1當作A2，B2當作A1，顯然是錯的，而且這兩組的 IoU 也很低，你如果透過 mean() 這樣就會把 IoU 降低，這樣就不合理了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flower102 Dataset - 使用 Transfer Learning 訓練 + 使用 Batch Normalization 於 CNN</title>
      <link href="/posts/flower102-transfer-learning/"/>
      <url>/posts/flower102-transfer-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第四個作業，主要教授內容為以下主題：</p><ol><li>Pick a dataset and train a model on it.</li><li>Transfer Learning - Fine Tuning.</li><li>Batch Normalization in CNN.</li></ol><p>主要參考以下網站：</p><ol><li><a href="https://pytorch.org/vision/stable/generated/torchvision.datasets.Flowers102.html#torchvision.datasets.Flowers102">Flower102 Dataset</a></li><li><a href="https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a></li><li><a href="https://pytorch.org/vision/stable/datasets.html">DataSet of Pytorch</a></li><li><a href="https://pytorch.org/vision/stable/models.html">Models for transfer learning</a></li><li><a href="/posts/ML.html#Transfer-Learning">Shannon’s Blog of Transfer Learning</a></li><li><a href="https://pytorch.org/vision/stable/models/generated/torchvision.models.resnet18.html#torchvision.models.resnet18">Resnet18</a></li></ol><h1 id="作業要求">作業要求</h1><p>Task:</p><ol><li><strong>選擇一個DataSet</strong>： Check out the torchvision <a href="https://pytorch.org/vision/stable/datasets.html">DataSet of Pytorch</a> and decide one dataset that you want to use (no<br>CIFAR, no ImageNet, no FashionMNIST).</li><li><strong>印出圖片和資料大小</strong>：Show some example images of the dataset in the notebook and print the dataset size.</li><li><strong>建構使用Batch Normalization的CNN</strong>：Design a CNN to predict on the dataset. Use a similar architecture like last time, but this time<br>also include batch normalization layers.</li><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li><li><strong>使用ResNet18來進行Transfer-Learning</strong>：Now use transfer learning to use a pre-trained ResNet18 on the dataset as follows:<ol><li><strong>不改變別人模型訓練好的權重</strong>：ResNet18 as fixed feature extractor.</li><li><strong>使用RestNet進行Fineturned</strong>：ResNet18 finetuned on the training data.</li></ol></li><li><strong>使用EfficientNet_B5進行Fineturned</strong>：Repeat step 4 but now use EfficientNet_B5 instead of RestNet18.</li><li><strong>比較這些不同的方法，並列印出準確度</strong>：Compare the accuracy of the different approaches on the test data and print out the training<br>times for each approach.</li></ol><h1 id="Task-0-import-package">Task 0 - import package</h1><p>先來導入所需的套件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CNN </span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"></span><br><span class="line"><span class="comment"># others</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset </span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, models, transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> Flowers102</span><br><span class="line"></span><br><span class="line"><span class="comment"># label </span></span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">cudnn.benchmark = <span class="literal">True</span></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure><h1 id="Task-1-選擇一個DataSet">Task 1 - 選擇一個DataSet</h1><ul><li>Ref: <a href="https://www.geeksforgeeks.org/how-to-normalize-images-in-pytorch/">為什麼是[0.485, 0.456, 0.406]進行Normalization</a></li></ul><div class="note info flat"><p><strong>選擇一個DataSet</strong>： Check out the torchvision <a href="https://pytorch.org/vision/stable/datasets.html">DataSet of Pytorch</a> and decide one dataset that you want to use (no<br>CIFAR, no ImageNet, no FashionMNIST).</p></div><p>為了體驗 Transfer Learning，並且快速訓練。我們這邊使用 flower102 來作為我們的資料集。因為 flower102 沒有提供中文的 Label，我網路上找大部分都是讀取已經寫好的 <code>.json</code> 或是 <code>.txt</code> 檔案，該檔案會描述每一個 label index 對應的中文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定你要下載的資料及路徑 和 btach size 一次訓練的量</span></span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line">data_dir = <span class="string">&#x27;../../Data/flowers-102&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 dataset 的 classes_name </span></span><br><span class="line">json_data = <span class="string">&#x27;&#123;&quot;21&quot;: &quot;fire lily&quot;, &quot;3&quot;: &quot;canterbury bells&quot;, &quot;45&quot;: &quot;bolero deep blue&quot;, &quot;1&quot;: &quot;pink primrose&quot;, &quot;34&quot;: &quot;mexican aster&quot;, &quot;27&quot;: &quot;prince of wales feathers&quot;, &quot;7&quot;: &quot;moon orchid&quot;, &quot;16&quot;: &quot;globe-flower&quot;, &quot;25&quot;: &quot;grape hyacinth&quot;, &quot;26&quot;: &quot;corn poppy&quot;, &quot;79&quot;: &quot;toad lily&quot;, &quot;39&quot;: &quot;siam tulip&quot;, &quot;24&quot;: &quot;red ginger&quot;, &quot;67&quot;: &quot;spring crocus&quot;, &quot;35&quot;: &quot;alpine sea holly&quot;, &quot;32&quot;: &quot;garden phlox&quot;, &quot;10&quot;: &quot;globe thistle&quot;, &quot;6&quot;: &quot;tiger lily&quot;, &quot;93&quot;: &quot;ball moss&quot;, &quot;33&quot;: &quot;love in the mist&quot;, &quot;9&quot;: &quot;monkshood&quot;, &quot;102&quot;: &quot;blackberry lily&quot;, &quot;14&quot;: &quot;spear thistle&quot;, &quot;19&quot;: &quot;balloon flower&quot;, &quot;100&quot;: &quot;blanket flower&quot;, &quot;13&quot;: &quot;king protea&quot;, &quot;49&quot;: &quot;oxeye daisy&quot;, &quot;15&quot;: &quot;yellow iris&quot;, &quot;61&quot;: &quot;cautleya spicata&quot;, &quot;31&quot;: &quot;carnation&quot;, &quot;64&quot;: &quot;silverbush&quot;, &quot;68&quot;: &quot;bearded iris&quot;, &quot;63&quot;: &quot;black-eyed susan&quot;, &quot;69&quot;: &quot;windflower&quot;, &quot;62&quot;: &quot;japanese anemone&quot;, &quot;20&quot;: &quot;giant white arum lily&quot;, &quot;38&quot;: &quot;great masterwort&quot;, &quot;4&quot;: &quot;sweet pea&quot;, &quot;86&quot;: &quot;tree mallow&quot;, &quot;101&quot;: &quot;trumpet creeper&quot;, &quot;42&quot;: &quot;daffodil&quot;, &quot;22&quot;: &quot;pincushion flower&quot;, &quot;2&quot;: &quot;hard-leaved pocket orchid&quot;, &quot;54&quot;: &quot;sunflower&quot;, &quot;66&quot;: &quot;osteospermum&quot;, &quot;70&quot;: &quot;tree poppy&quot;, &quot;85&quot;: &quot;desert-rose&quot;, &quot;99&quot;: &quot;bromelia&quot;, &quot;87&quot;: &quot;magnolia&quot;, &quot;5&quot;: &quot;english marigold&quot;, &quot;92&quot;: &quot;bee balm&quot;, &quot;28&quot;: &quot;stemless gentian&quot;, &quot;97&quot;: &quot;mallow&quot;, &quot;57&quot;: &quot;gaura&quot;, &quot;40&quot;: &quot;lenten rose&quot;, &quot;47&quot;: &quot;marigold&quot;, &quot;59&quot;: &quot;orange dahlia&quot;, &quot;48&quot;: &quot;buttercup&quot;, &quot;55&quot;: &quot;pelargonium&quot;, &quot;36&quot;: &quot;ruby-lipped cattleya&quot;, &quot;91&quot;: &quot;hippeastrum&quot;, &quot;29&quot;: &quot;artichoke&quot;, &quot;71&quot;: &quot;gazania&quot;, &quot;90&quot;: &quot;canna lily&quot;, &quot;18&quot;: &quot;peruvian lily&quot;, &quot;98&quot;: &quot;mexican petunia&quot;, &quot;8&quot;: &quot;bird of paradise&quot;, &quot;30&quot;: &quot;sweet william&quot;, &quot;17&quot;: &quot;purple coneflower&quot;, &quot;52&quot;: &quot;wild pansy&quot;, &quot;84&quot;: &quot;columbine&quot;, &quot;12&quot;: &quot;colt\&#x27;s foot&quot;, &quot;11&quot;: &quot;snapdragon&quot;, &quot;96&quot;: &quot;camellia&quot;, &quot;23&quot;: &quot;fritillary&quot;, &quot;50&quot;: &quot;common dandelion&quot;, &quot;44&quot;: &quot;poinsettia&quot;, &quot;53&quot;: &quot;primula&quot;, &quot;72&quot;: &quot;azalea&quot;, &quot;65&quot;: &quot;californian poppy&quot;, &quot;80&quot;: &quot;anthurium&quot;, &quot;76&quot;: &quot;morning glory&quot;, &quot;37&quot;: &quot;cape flower&quot;, &quot;56&quot;: &quot;bishop of llandaff&quot;, &quot;60&quot;: &quot;pink-yellow dahlia&quot;, &quot;82&quot;: &quot;clematis&quot;, &quot;58&quot;: &quot;geranium&quot;, &quot;75&quot;: &quot;thorn apple&quot;, &quot;41&quot;: &quot;barbeton daisy&quot;, &quot;95&quot;: &quot;bougainvillea&quot;, &quot;43&quot;: &quot;sword lily&quot;, &quot;83&quot;: &quot;hibiscus&quot;, &quot;78&quot;: &quot;lotus lotus&quot;, &quot;88&quot;: &quot;cyclamen&quot;, &quot;94&quot;: &quot;foxglove&quot;, &quot;81&quot;: &quot;frangipani&quot;, &quot;74&quot;: &quot;rose&quot;, &quot;89&quot;: &quot;watercress&quot;, &quot;73&quot;: &quot;water lily&quot;, &quot;46&quot;: &quot;wallflower&quot;, &quot;77&quot;: &quot;passion flower&quot;, &quot;51&quot;: &quot;petunia&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment"># load data </span></span><br><span class="line">cat_to_name = json.loads(json_data)</span><br><span class="line"><span class="comment"># 把 key 轉成 int，因為 dataset 的 label 從 0 開始。但是這個 json 從 1 開始，所以我們要 -1</span></span><br><span class="line">cat_to_name = &#123;<span class="built_in">int</span>(k)-<span class="number">1</span>:v <span class="keyword">for</span> k,v <span class="keyword">in</span> cat_to_name.items()&#125;</span><br><span class="line"><span class="comment"># 排序，轉換成 dic 並印出來</span></span><br><span class="line">class_names = <span class="built_in">dict</span>(<span class="built_in">sorted</span>(cat_to_name.items()))</span><br><span class="line"><span class="built_in">print</span>(class_names)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>: <span class="string">&#x27;pink primrose&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;hard-leaved pocket orchid&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;canterbury bells&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;sweet pea&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;english marigold&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;tiger lily&#x27;</span>, <span class="number">6</span>: <span class="string">&#x27;moon orchid&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;bird of paradise&#x27;</span>, <span class="number">8</span>: <span class="string">&#x27;monkshood&#x27;</span>, <span class="number">9</span>: <span class="string">&#x27;globe thistle&#x27;</span>, <span class="number">10</span>: <span class="string">&#x27;snapdragon&#x27;</span>, <span class="number">11</span>: <span class="string">&quot;colt&#x27;s foot&quot;</span>, <span class="number">12</span>: <span class="string">&#x27;king protea&#x27;</span>, <span class="number">13</span>: <span class="string">&#x27;spear thistle&#x27;</span>, <span class="number">14</span>: <span class="string">&#x27;yellow iris&#x27;</span>, <span class="number">15</span>: <span class="string">&#x27;globe-flower&#x27;</span>, <span class="number">16</span>: <span class="string">&#x27;purple coneflower&#x27;</span>, <span class="number">17</span>: <span class="string">&#x27;peruvian lily&#x27;</span>, <span class="number">18</span>: <span class="string">&#x27;balloon flower&#x27;</span>, <span class="number">19</span>: <span class="string">&#x27;giant white arum lily&#x27;</span>, <span class="number">20</span>: <span class="string">&#x27;fire lily&#x27;</span>, <span class="number">21</span>: <span class="string">&#x27;pincushion flower&#x27;</span>, <span class="number">22</span>: <span class="string">&#x27;fritillary&#x27;</span>, <span class="number">23</span>: <span class="string">&#x27;red ginger&#x27;</span>, <span class="number">24</span>: <span class="string">&#x27;grape hyacinth&#x27;</span>, <span class="number">25</span>: <span class="string">&#x27;corn poppy&#x27;</span>, <span class="number">26</span>: <span class="string">&#x27;prince of wales feathers&#x27;</span>, <span class="number">27</span>: <span class="string">&#x27;stemless gentian&#x27;</span>, <span class="number">28</span>: <span class="string">&#x27;artichoke&#x27;</span>, <span class="number">29</span>: <span class="string">&#x27;sweet william&#x27;</span>, <span class="number">30</span>: <span class="string">&#x27;carnation&#x27;</span>, <span class="number">31</span>: <span class="string">&#x27;garden phlox&#x27;</span>, <span class="number">32</span>: <span class="string">&#x27;love in the mist&#x27;</span>, <span class="number">33</span>: <span class="string">&#x27;mexican aster&#x27;</span>, <span class="number">34</span>: <span class="string">&#x27;alpine sea holly&#x27;</span>, <span class="number">35</span>: <span class="string">&#x27;ruby-lipped cattleya&#x27;</span>, <span class="number">36</span>: <span class="string">&#x27;cape flower&#x27;</span>, <span class="number">37</span>: <span class="string">&#x27;great masterwort&#x27;</span>, <span class="number">38</span>: <span class="string">&#x27;siam tulip&#x27;</span>, <span class="number">39</span>: <span class="string">&#x27;lenten rose&#x27;</span>, <span class="number">40</span>: <span class="string">&#x27;barbeton daisy&#x27;</span>, <span class="number">41</span>: <span class="string">&#x27;daffodil&#x27;</span>, <span class="number">42</span>: <span class="string">&#x27;sword lily&#x27;</span>, <span class="number">43</span>: <span class="string">&#x27;poinsettia&#x27;</span>, <span class="number">44</span>: <span class="string">&#x27;bolero deep blue&#x27;</span>, <span class="number">45</span>: <span class="string">&#x27;wallflower&#x27;</span>, <span class="number">46</span>: <span class="string">&#x27;marigold&#x27;</span>, <span class="number">47</span>: <span class="string">&#x27;buttercup&#x27;</span>, <span class="number">48</span>: <span class="string">&#x27;oxeye daisy&#x27;</span>, <span class="number">49</span>: <span class="string">&#x27;common dandelion&#x27;</span>, <span class="number">50</span>: <span class="string">&#x27;petunia&#x27;</span>, <span class="number">51</span>: <span class="string">&#x27;wild pansy&#x27;</span>, <span class="number">52</span>: <span class="string">&#x27;primula&#x27;</span>, <span class="number">53</span>: <span class="string">&#x27;sunflower&#x27;</span>, <span class="number">54</span>: <span class="string">&#x27;pelargonium&#x27;</span>, <span class="number">55</span>: <span class="string">&#x27;bishop of llandaff&#x27;</span>, <span class="number">56</span>: <span class="string">&#x27;gaura&#x27;</span>, <span class="number">57</span>: <span class="string">&#x27;geranium&#x27;</span>, <span class="number">58</span>: <span class="string">&#x27;orange dahlia&#x27;</span>, <span class="number">59</span>: <span class="string">&#x27;pink-yellow dahlia&#x27;</span>, <span class="number">60</span>: <span class="string">&#x27;cautleya spicata&#x27;</span>, <span class="number">61</span>: <span class="string">&#x27;japanese anemone&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;black-eyed susan&#x27;</span>, <span class="number">63</span>: <span class="string">&#x27;silverbush&#x27;</span>, <span class="number">64</span>: <span class="string">&#x27;californian poppy&#x27;</span>, <span class="number">65</span>: <span class="string">&#x27;osteospermum&#x27;</span>, <span class="number">66</span>: <span class="string">&#x27;spring crocus&#x27;</span>, <span class="number">67</span>: <span class="string">&#x27;bearded iris&#x27;</span>, <span class="number">68</span>: <span class="string">&#x27;windflower&#x27;</span>, <span class="number">69</span>: <span class="string">&#x27;tree poppy&#x27;</span>, <span class="number">70</span>: <span class="string">&#x27;gazania&#x27;</span>, <span class="number">71</span>: <span class="string">&#x27;azalea&#x27;</span>, <span class="number">72</span>: <span class="string">&#x27;water lily&#x27;</span>, <span class="number">73</span>: <span class="string">&#x27;rose&#x27;</span>, <span class="number">74</span>: <span class="string">&#x27;thorn apple&#x27;</span>, <span class="number">75</span>: <span class="string">&#x27;morning glory&#x27;</span>, <span class="number">76</span>: <span class="string">&#x27;passion flower&#x27;</span>, <span class="number">77</span>: <span class="string">&#x27;lotus lotus&#x27;</span>, <span class="number">78</span>: <span class="string">&#x27;toad lily&#x27;</span>, <span class="number">79</span>: <span class="string">&#x27;anthurium&#x27;</span>, <span class="number">80</span>: <span class="string">&#x27;frangipani&#x27;</span>, <span class="number">81</span>: <span class="string">&#x27;clematis&#x27;</span>, <span class="number">82</span>: <span class="string">&#x27;hibiscus&#x27;</span>, <span class="number">83</span>: <span class="string">&#x27;columbine&#x27;</span>, <span class="number">84</span>: <span class="string">&#x27;desert-rose&#x27;</span>, <span class="number">85</span>: <span class="string">&#x27;tree mallow&#x27;</span>, <span class="number">86</span>: <span class="string">&#x27;magnolia&#x27;</span>, <span class="number">87</span>: <span class="string">&#x27;cyclamen&#x27;</span>, <span class="number">88</span>: <span class="string">&#x27;watercress&#x27;</span>, <span class="number">89</span>: <span class="string">&#x27;canna lily&#x27;</span>, <span class="number">90</span>: <span class="string">&#x27;hippeastrum&#x27;</span>, <span class="number">91</span>: <span class="string">&#x27;bee balm&#x27;</span>, <span class="number">92</span>: <span class="string">&#x27;ball moss&#x27;</span>, <span class="number">93</span>: <span class="string">&#x27;foxglove&#x27;</span>, <span class="number">94</span>: <span class="string">&#x27;bougainvillea&#x27;</span>, <span class="number">95</span>: <span class="string">&#x27;camellia&#x27;</span>, <span class="number">96</span>: <span class="string">&#x27;mallow&#x27;</span>, <span class="number">97</span>: <span class="string">&#x27;mexican petunia&#x27;</span>, <span class="number">98</span>: <span class="string">&#x27;bromelia&#x27;</span>, <span class="number">99</span>: <span class="string">&#x27;blanket flower&#x27;</span>, <span class="number">100</span>: <span class="string">&#x27;trumpet creeper&#x27;</span>, <span class="number">101</span>: <span class="string">&#x27;blackberry lily&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>這邊我主要是參考官方網站<a href="hhttps://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a>的寫法，改成自己想要的 dataSet，並開始下載檔案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Data augmentation and normalization for training</span></span><br><span class="line"><span class="comment"># Just normalization for validation</span></span><br><span class="line">data_transforms = &#123;</span><br><span class="line">    <span class="string">&#x27;train&#x27;</span>: transforms.Compose([</span><br><span class="line">        <span class="comment"># 首先對圖像進行裁剪，然後再調整大小。它隨機選擇一個矩形區域並裁剪圖像</span></span><br><span class="line">        <span class="comment"># 然後將裁剪的圖像調整為指定的大小為 224x224 像素。</span></span><br><span class="line">        transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">        <span class="comment"># 設定圖像的翻轉機率，通常是一個 0 到 1 的數字，例如 0.5，表示有 50% 的機率翻轉圖像。Default value is 0.5</span></span><br><span class="line">        transforms.RandomHorizontalFlip(),</span><br><span class="line">        <span class="comment"># 將圖像轉換成 Tensor</span></span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        <span class="comment"># 用數值 normalize 的方式來正規化 image 的數值，第一參數是 mean，第二個參數是 std 標準差</span></span><br><span class="line">        <span class="comment"># 設定 [0.485, 0.456, 0.406] 的原因可參考：https://www.geeksforgeeks.org/how-to-normalize-images-in-pytorch/</span></span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ]),</span><br><span class="line">    <span class="string">&#x27;val&#x27;</span>: transforms.Compose([</span><br><span class="line">        <span class="comment"># 這個沒有隨機選擇區域，而是直接整圖像的尺寸，使其符合指定的大小</span></span><br><span class="line">        transforms.Resize(<span class="number">256</span>),</span><br><span class="line">        <span class="comment"># 將圖像的中心部分保留，然後調整尺寸以滿足指定的大小。</span></span><br><span class="line">        <span class="comment"># 用於驗證或測試數據，以確保測試圖像具有相似的特徵，並且不像 RandomResizedCrop 那樣具有隨機性</span></span><br><span class="line">        transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    ]),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 我們把 trainning 用的資料下載到 data_dir/train 資料夾，並且使用 data_transforms[&quot;train&quot;] 這個函式來做資料的轉換</span></span><br><span class="line">train_datasets = Flowers102(root=data_dir+<span class="string">&quot;/train&quot;</span>, split=<span class="string">&quot;train&quot;</span>, download=<span class="literal">True</span>, transform=data_transforms[<span class="string">&quot;train&quot;</span>])</span><br><span class="line"><span class="comment"># 我們把 validation 用的資料下載到 data_dir/val 資料夾，並且使用 data_transforms[&quot;val&quot;] 這個函式來做資料的轉換</span></span><br><span class="line">val_datasets = Flowers102(root=data_dir+<span class="string">&quot;/val&quot;</span>, split=<span class="string">&quot;val&quot;</span>, download=<span class="literal">True</span>, transform=data_transforms[<span class="string">&quot;val&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定下載 flowers102 的資料集，下載 train 和 val 的資料集</span></span><br><span class="line">image_datasets = &#123;x: Flowers102(root=data_dir, split=x, download=<span class="literal">True</span>, transform=data_transforms[x])</span><br><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 轉換成 DataLoader 的形式，並且指定 batch_size</span></span><br><span class="line">dataloaders = &#123;x: torch.utils.data.DataLoader(image_datasets[x], batch_size=batch_size,</span><br><span class="line">                                             shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line">              <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;device: &quot;</span>,device)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;image_datasets function call: &quot;</span>, <span class="built_in">dir</span>(image_datasets[<span class="string">&quot;train&quot;</span>]))</span><br></pre></td></tr></table></figure><div class="note info flat"><p>這樣我們就完成了第一個Task，也就是下載好我們想要的 dataset。</p></div><h1 id="Task-2-印出圖片和資料大小">Task 2 - 印出圖片和資料大小</h1><div class="note info flat"><ol start="2"><li><strong>印出圖片和資料大小</strong>：Show some example images of the dataset in the notebook and print the dataset size.</li></ol></div><p>參考官方網站<a href="hhttps://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a>的寫法，我們先建立</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">imshow</span>(<span class="params">inp, title=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Display image for Tensor.&quot;&quot;&quot;</span></span><br><span class="line">    inp = inp.numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    mean = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">    std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    inp = std * inp + mean</span><br><span class="line">    inp = np.clip(inp, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    plt.imshow(inp)</span><br><span class="line">    <span class="keyword">if</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        plt.title(title)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)  <span class="comment"># pause a bit so that plots are updated</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get a batch of training data</span></span><br><span class="line">inputs, classes = <span class="built_in">next</span>(<span class="built_in">iter</span>(dataloaders[<span class="string">&#x27;train&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a grid from batch</span></span><br><span class="line">out = torchvision.utils.make_grid(inputs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x.item() 取出 tensor 的值，通常是數字，然後在 class_names dic 找到該數字對應的英文名字</span></span><br><span class="line">imshow(out, title=[class_names[x.item()] <span class="keyword">for</span> x <span class="keyword">in</span> classes])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(inputs.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;dataset_sizes: &quot;</span>,dataset_sizes)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下：</p></blockquote><p><img src="https://i.imgur.com/dPGyFvN.png" alt=""></p><h1 id="Task-3-4-CNN-Batch-Normalization">Task 3 &amp; 4 - CNN + Batch Normalization</h1><div class="note info flat"><ol start="3"><li><strong>建構使用Batch Normalization的CNN</strong>：Design a CNN to predict on the dataset. Use a similar architecture like last time, but this time also include batch normalization layers.</li><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li></ol></div><p><strong>根據李鴻毅教授在 Transfer Learning 提到…</strong><br>通常會在 <code>Activation Function</code> 之前執行 <code>Batch Normalization</code>，有興趣可以參考這個<a href="/posts/ML.html#Feature-Normalization">章節</a>。<code>Batch Normalization</code> 簡單來說就是以 <code>Batch</code> 的方式，執行 <code>feature normalization</code>。</p><p><strong>為什麼要做 feature normalization ?</strong><br>他就是為了讓不同的 feature 有類似接近的數值範圍，這樣模型在執行Gradient Descent的時候，w1, w2 對 loss 的影響才不會太大，他們擁有相似的數值範圍，才能夠平均的影響 loss，而不是某個 w1 對 loss 的影響遠大於 w2。</p><blockquote><p>大概是下圖這種效果。</p></blockquote><p><img src="https://i.imgur.com/RB51XXy.png" alt=""></p><h2 id="建立-Network">建立 Network</h2><div class="note warning flat"><p>請注意，根據不同的 dataset 其尺寸大小還有 hidden layer的數量，你要做兩個調整！！</p><ol><li>在 fully connection layer 中，input 要根據你的 hidden layer 執行 <code>max-pooling</code> 跟 <code>convolution</code> 的次數來決定。</li><li>然後你要根據你 dataset 的 categories 數量，調整最後一層 output layer 的output數量。</li></ol><p>請注意程式碼中標示註解箭頭<code>&lt;====</code> 的部分</p></div><p>所以我們這邊的 CNN 架構如下，<code>你可以根據需求決定是否要執行 dropout，來解開註解</code>。<br>但是在我的情境中，我測試 dropout 並沒有帶來比較高的準確率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NewNet, self).__init__()</span><br><span class="line">        <span class="comment"># Layer 1: 3x3 kernel，depth = 32，224-3+1=222 =&gt; 222x222 pixel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">3</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        <span class="comment"># self.dropout1 = nn.Dropout(0.5) # 可根據需求套用 dropout</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 2: Max pooling with 2x2 kernel，222/2=111 =&gt; 111x111 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 3: 3x3 kernel，depth = 64，111-3+1=109 =&gt; 109x109 pixel</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        <span class="comment"># self.dropout2 = nn.Dropout(0.5) # 可根據需求套用 dropout</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 4: Max pooling with 2x2 kernel，109/2=54 =&gt; 54x54 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 5: 3x3 kernel，depth = 128，54-3+1=52 =&gt; 52x52 pixel</span></span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(<span class="number">128</span>)</span><br><span class="line">        <span class="comment"># self.dropout3 = nn.Dropout(0.5) # 可根據需求套用 dropout  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Layer 6: Max pooling with 2x2 kernel，52/2=26 =&gt; 26x26 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Final input is 512，pixel is 26*26 =&gt; 128*26*26</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">128</span> * <span class="number">26</span> * <span class="number">26</span>, <span class="number">2048</span>) <span class="comment"># &lt;==== 128 * 26 * 26 根據 hidden layer 來調整</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">2048</span>, <span class="number">1024</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">1024</span>, <span class="number">512</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">512</span>, <span class="number">102</span>)<span class="comment"># &lt;==== 102 根據 dataset 的種類數量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># We put the batch normalization before the activation function. </span></span><br><span class="line">        x = F.relu(self.bn1(self.conv1(x)))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        <span class="comment"># x = self.dropout1(x) # 可根據需求套用 dropout </span></span><br><span class="line">        x = F.relu(self.bn2(self.conv2(x)))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        <span class="comment"># x = self.dropout2(x) # 可根據需求套用 dropout  </span></span><br><span class="line">        x = F.relu(self.bn3(self.conv3(x)))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        <span class="comment"># x = self.dropout3(x) # 可根據需求套用 dropout  </span></span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">128</span> * <span class="number">26</span> * <span class="number">26</span>) <span class="comment"># &lt;==== 128 * 26 * 26 根據 hidden layer 來調整</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = F.relu(self.fc3(x))</span><br><span class="line">        x = self.fc4(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = NewNet()</span><br><span class="line">net.to(device)</span><br></pre></td></tr></table></figure><p>並且指定 optimizer 和 loss function：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><h2 id="建立-Training-Func">建立 Training Func</h2><p>我們需要建立一個fucntion來執行訓練模型的動作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch, start_time</span>):</span><br><span class="line">    net.train()</span><br><span class="line">    cur_count = <span class="number">0</span> </span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> batch_idx, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloaders[<span class="string">&quot;train&quot;</span>], <span class="number">0</span>):</span><br><span class="line">        cur_count += <span class="built_in">len</span>(data)</span><br><span class="line">        inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        outputs.to(device)</span><br><span class="line">        </span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.to(device)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> batch_idx % <span class="number">100</span> == <span class="number">99</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch&#125;</span>, <span class="subst">&#123;batch_idx + <span class="number">1</span>:5d&#125;</span>] loss: <span class="subst">&#123;running_loss / <span class="number">100</span>:<span class="number">.3</span>f&#125;</span> time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time))&#125;</span> sec.&#x27;</span>)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br></pre></td></tr></table></figure><h2 id="建立-Testing-Func">建立 Testing Func</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(): </span><br><span class="line">    net.<span class="built_in">eval</span>()  <span class="comment"># set model to evaluation mode</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    class_correct = [<span class="number">0</span>] * <span class="built_in">len</span>(class_names)  </span><br><span class="line">    class_total = [<span class="number">0</span>] * <span class="built_in">len</span>(class_names)  </span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> dataloaders[<span class="string">&quot;val&quot;</span>]:</span><br><span class="line">            images, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line">            outputs = net(images) </span><br><span class="line"></span><br><span class="line">            <span class="comment"># select top 3 predictions</span></span><br><span class="line">            _, predicted = torch.topk(outputs, <span class="number">1</span>, dim=<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># check if predicted labels are in true labels</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">                total += <span class="number">1</span></span><br><span class="line">                class_total[labels[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> labels[i] <span class="keyword">in</span> predicted[i]:</span><br><span class="line">                    correct += <span class="number">1</span></span><br><span class="line">                    class_correct[labels[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    class_accuracies = [class_correct[i] / class_total[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(class_names))]</span><br><span class="line">    accuracy = correct / total</span><br><span class="line">    <span class="keyword">return</span> accuracy, class_accuracies</span><br></pre></td></tr></table></figure><h2 id="執行-Training">執行 Training</h2><p>為了讓訓練過程中，我們可以看到訓練的狀況，所以我們每 100 個 batch 就印出一次訓練的狀況，並且每 5 個 epoch 就印出一次 test 的狀況。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">num_epochs = <span class="number">100</span> </span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line">accuracy, class_accuracies = test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test data (top-1): <span class="subst">&#123;<span class="number">100</span> * accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_epochs - <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;============ Epoch: <span class="subst">&#123;epoch&#125;</span> ==========&quot;</span>)</span><br><span class="line">    train(epoch, start_time)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 每 5 個 epoch 執行一次 test，看一下訓練狀況</span></span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        accuracy, class_accuracies = test()</span><br><span class="line">        <span class="comment"># print accuracies</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test data (top-1): <span class="subst">&#123;<span class="number">100</span> * accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Finished Training. Total elapsed time: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>, <span class="number">1</span>)&#125;</span> min&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Accuracy on test data (top<span class="number">-1</span>): <span class="number">0.0019</span>%</span><br><span class="line">============ Epoch: <span class="number">0</span> ==========</span><br><span class="line">[<span class="number">0</span>,   <span class="number">100</span>] loss: <span class="number">4.984</span> <span class="built_in">time</span> elapsed: <span class="number">40</span> sec.</span><br><span class="line">[<span class="number">0</span>,   <span class="number">200</span>] loss: <span class="number">4.876</span> <span class="built_in">time</span> elapsed: <span class="number">47</span> sec.</span><br><span class="line">...</span><br><span class="line">Accuracy on test data (top<span class="number">-1</span>): <span class="number">35.59</span>%</span><br><span class="line">Finished Training. Total elapsed <span class="built_in">time</span>: <span class="number">67</span> <span class="built_in">min</span></span><br></pre></td></tr></table></figure><h1 id="Task-5-4-Transfer-Learning：Resnet18">Task 5 &amp; 4 - Transfer Learning：Resnet18</h1><div class="note info flat"><ol start="4"><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li><li><strong>使用ResNet18來進行Transfer-Learning</strong>：Now use transfer learning to use a pre-trained ResNet18 on the dataset as follows:<ol><li><strong>把參數fixed</strong>：ResNet18 as fixed feature extractor.</li><li><strong>使用RestNet進行Fineturned</strong>：ResNet18 finetuned on the training data.</li></ol></li></ol></div><h2 id="建立-Trainning-Testing-Func">建立 Trainning &amp; Testing Func</h2><p>根據官方的範例<a href="https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html">Transfer Learning</a>，我是直接複製過來的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, criterion, optimizer, scheduler, num_epochs=<span class="number">25</span></span>):</span><br><span class="line">    <span class="comment"># 設定開始時間，用於log印出以看每個Epoch的訓練時間</span></span><br><span class="line">    since = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建立一個暫存的資料夾，用於存放最好的模型參數</span></span><br><span class="line">    <span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> tempdir:</span><br><span class="line">        best_model_params_path = os.path.join(tempdir, <span class="string">&#x27;best_model_params.pt&#x27;</span>)</span><br><span class="line">        <span class="comment"># 還沒訓練，但是我們先存當前的模型</span></span><br><span class="line">        torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line">        best_acc = <span class="number">0.0</span> <span class="comment"># 設定目前最佳的 accuracy 是 0，一但比這個數字大，就會更新該數值以判斷目前最好的模型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;num_epochs - <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 每一個 epoch 一但 train 完，就會進行 validation</span></span><br><span class="line">            <span class="keyword">for</span> phase <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 判斷目前應該是 training 還是 validation </span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    model.train()  <span class="comment"># Set model to training mode</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    model.<span class="built_in">eval</span>()   <span class="comment"># Set model to evaluate mode</span></span><br><span class="line"></span><br><span class="line">                running_loss = <span class="number">0.0</span></span><br><span class="line">                running_corrects = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Iterate over data.</span></span><br><span class="line">                <span class="keyword">for</span> inputs, labels <span class="keyword">in</span> dataloaders[phase]:</span><br><span class="line">                    <span class="comment"># 放到 gpu 中</span></span><br><span class="line">                    inputs = inputs.to(device)</span><br><span class="line">                    labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 歸零梯度</span></span><br><span class="line">                    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 執行 forward propagation</span></span><br><span class="line">                    <span class="comment"># track history if only in train</span></span><br><span class="line">                    <span class="keyword">with</span> torch.set_grad_enabled(phase == <span class="string">&#x27;train&#x27;</span>):</span><br><span class="line">                        outputs = model(inputs)</span><br><span class="line">                        _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>) <span class="comment"># 選最大的那個數字當作預測的 label </span></span><br><span class="line">                        loss = criterion(outputs, labels) <span class="comment"># 計算答案和預測的差距 </span></span><br><span class="line"></span><br><span class="line">                        <span class="comment"># backward + optimize only if in training phase</span></span><br><span class="line">                        <span class="comment"># 執行 backward propagation</span></span><br><span class="line">                        <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                            loss.backward()</span><br><span class="line">                            optimizer.step()</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 因為 batch_size 是 4，所以 loss 乘上 4，才是一個 batch 的 loss</span></span><br><span class="line">                    running_loss += loss.item() * inputs.size(<span class="number">0</span>)</span><br><span class="line">                    <span class="comment"># 算出一個 batch 中，有多少答對的</span></span><br><span class="line">                    running_corrects += torch.<span class="built_in">sum</span>(preds == labels.data)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 只有在 training 的時候，才會調整 learning rate</span></span><br><span class="line">                <span class="comment"># scheduler 是學習率lr調整器 用於在模型訓練過程中調整學習率lr 的值</span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">                    scheduler.step()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 一整個 epoch 訓練完後，算出該 epoch 的 loss 和 accuracy</span></span><br><span class="line">                <span class="comment"># Avg. loss = 全部的 loss / 正個 dataset 的大小 </span></span><br><span class="line">                epoch_loss = running_loss / dataset_sizes[phase]</span><br><span class="line">                <span class="comment"># Avg. Acc = 全部的答對數 / 正個 dataset 的大小</span></span><br><span class="line">                epoch_acc = running_corrects.<span class="built_in">float</span>() / dataset_sizes[phase]</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;phase&#125;</span> Loss: <span class="subst">&#123;epoch_loss:<span class="number">.4</span>f&#125;</span> Acc: <span class="subst">&#123;epoch_acc:<span class="number">.4</span>f&#125;</span> Time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - since))&#125;</span> sec.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果在 validation 的時候，一但發現 accuracy 比目前最好的還要好，就把模型參數存起來</span></span><br><span class="line">                <span class="keyword">if</span> phase == <span class="string">&#x27;val&#x27;</span> <span class="keyword">and</span> epoch_acc &gt; best_acc:</span><br><span class="line">                    <span class="comment"># 更新目前最好的 accuracy</span></span><br><span class="line">                    best_acc = epoch_acc</span><br><span class="line">                    <span class="comment"># deep copy the model</span></span><br><span class="line">                    torch.save(model.state_dict(), best_model_params_path)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        time_elapsed = time.time() - since</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Training complete in <span class="subst">&#123;time_elapsed // <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>m <span class="subst">&#123;time_elapsed % <span class="number">60</span>:<span class="number">.0</span>f&#125;</span>s&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Best val Acc: <span class="subst">&#123;best_acc:4f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load best model weights</span></span><br><span class="line">        <span class="comment"># 以目前最好的 model 取出來，繼續下一個 epoch 的訓練</span></span><br><span class="line">        model.load_state_dict(torch.load(best_model_params_path))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><h2 id="使用-Transfer-Learning">使用 Transfer Learning</h2><p>根據老師的要求，要使用 resnet18 來進行 Transfer Learning，目前根據<a href="https://pytorch.org/vision/stable/models/generated/torchvision.models.resnet18.html#torchvision.models.ResNet18_Weights">官方說明</a>，<code>resent18</code> 如果不給予參數，則預設就是 <code>IMAGENET1K_V1</code>，為了清楚我們到底使用哪一個 model 的參數，我們還是給予參數。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">model_ft = models.resnet18(weights=<span class="string">&#x27;IMAGENET1K_V1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># num_ftrs is the number of input features for the last layer. </span></span><br><span class="line"><span class="comment"># 抓取最後一層的輸入數量</span></span><br><span class="line">num_ftrs = model_ft.fc.in_features</span><br><span class="line"></span><br><span class="line"><span class="comment"># Here the size of each output sample is set to 102.</span></span><br><span class="line"><span class="comment"># model_ft.fc is the final layer of the model, and used for classification.</span></span><br><span class="line"><span class="comment"># 自己建立最後一層 layer，並且把輸入數量設定為 num_ftrs，輸出數量設定為 102（因為這個case有102個）</span></span><br><span class="line">model_ft.fc = nn.Linear(num_ftrs, <span class="number">102</span>)</span><br><span class="line">model_ft = model_ft.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss function 使用 CrossEntropyLoss </span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Observe that all parameters are being optimized</span></span><br><span class="line"><span class="comment"># optimizer 使用 SGD，learning rate = 0.001，momentum = 0.9</span></span><br><span class="line">optimizer_ft = optim.SGD(model_ft.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decay LR by a factor of 0.1 every 7 epochs</span></span><br><span class="line"><span class="comment"># 每 7 個 epoch 就把 learning rate 乘上 0.1 來對 lr 進行 decay</span></span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><p>大概是這種感覺來進行Transfer Learning<br><img src="https://i.imgur.com/rygK4KS.png" alt=""></p><div class="note warning flat"><p><strong>為什麼要調整lr?</strong><br>將學習率每隔一定的 epoch 進行調整是一種常見的學習率調整策略，稱為學習率衰減（learning rate decay）或學習率調度（learning rate scheduling）。這樣的效果是：</p><ol><li><p>提高模型的穩定性：在訓練過程中，<code>一開始使用相對較大的學習率，有助於快速收斂</code>。但當訓練<code>靠近最佳解時，較大的學習率可能導致模型在最佳解附近震盪或過度調整</code>。透過週期性地降低學習率，模型在訓練的後期會更穩定，更接近最佳解。</p></li><li><p>防止過度擬合：<code>週期性地降低學習率有助於防止模型在訓練集上過度擬合</code>。當學習率降低時，模型更謹慎地調整參數，不太容易陷入訓練集中的噪聲。</p></li></ol><p>在實際應用中，學習率調整策略的具體設置（例如，<code>step_size</code> 和 <code>gamma</code> 的值）通常是根據試驗和經驗來調整的，以達到最佳性能。通常，這些參數的設置取決於你的數據集大小、模型架構、問題的難度和其他因素。</p></div><h2 id="開始訓練">開始訓練</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model_ft = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,</span><br><span class="line">                       num_epochs=<span class="number">25</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下: 準確率 89.41% 挺好的</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.4280</span> Acc: <span class="number">0.0657</span> Time elapsed: <span class="number">33</span> sec.</span><br><span class="line">val Loss: <span class="number">2.9901</span> Acc: <span class="number">0.3118</span> Time elapsed: <span class="number">58</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.3046</span> Acc: <span class="number">0.2353</span> Time elapsed: <span class="number">87</span> sec.</span><br><span class="line">val Loss: <span class="number">1.6604</span> Acc: <span class="number">0.5941</span> Time elapsed: <span class="number">112</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">2.5080</span> Acc: <span class="number">0.4029</span> Time elapsed: <span class="number">141</span> sec.</span><br><span class="line">val Loss: <span class="number">1.2243</span> Acc: <span class="number">0.6951</span> Time elapsed: <span class="number">166</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.9871</span> Acc: <span class="number">0.5196</span> Time elapsed: <span class="number">195</span> sec.</span><br><span class="line">val Loss: <span class="number">0.9578</span> Acc: <span class="number">0.7216</span> Time elapsed: <span class="number">219</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.5865</span> Acc: <span class="number">0.6225</span> Time elapsed: <span class="number">249</span> sec.</span><br><span class="line">val Loss: <span class="number">0.6911</span> Acc: <span class="number">0.8108</span> Time elapsed: <span class="number">273</span> sec.</span><br><span class="line">...</span><br><span class="line">val Loss: <span class="number">0.3919</span> Acc: <span class="number">0.8912</span> Time elapsed: <span class="number">1313</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">21</span>m <span class="number">53</span>s</span><br><span class="line">Best val Acc: <span class="number">0.894118</span></span><br></pre></td></tr></table></figure><h2 id="使用-ResNet18-作為-fixed-feature-extractor">使用 ResNet18 作為 fixed feature extractor</h2><p>因為作業有要求，要使用 ResNet18 作為 fixed feature extractor，所以我們要把所有的參數都設定為不可訓練，只有最後一層的參數是可以訓練的，<strong>簡單來說就是別人訓練好的 model 你就不要改人家的 weight 了拉</strong>。要改的地方就是，把 model 的每個 parameters 的 <code>requires_grad</code> 都設定為 False。這樣，我們就可以把 ResNet18 當作 fixed feature extractor 來使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他都老樣子</span></span><br><span class="line">model_conv = torchvision.models.resnet18(weights=<span class="string">&#x27;IMAGENET1K_V1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># !!! 添加這兩行，把 requires_grad 設定為 False，這樣就不會更新該參數了</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model_conv.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他都老樣子</span></span><br><span class="line">num_ftrs = model_conv.fc.in_features</span><br><span class="line">model_conv.fc = nn.Linear(num_ftrs, <span class="number">102</span>)</span><br><span class="line">model_conv = model_conv.to(device)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer_conv = optim.SGD(model_conv.fc.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_conv, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然後我們開始訓練 </span></span><br><span class="line">model_conv_SGD = train_model(model_conv, criterion, optimizer_conv,</span><br><span class="line">                         exp_lr_scheduler, num_epochs=<span class="number">25</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下：準確率 79.11% 比較差一點，但是這樣的訓練速度會比較快</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.6979</span> Acc: <span class="number">0.0176</span> Time elapsed: <span class="number">24</span> sec.</span><br><span class="line">val Loss: <span class="number">3.9863</span> Acc: <span class="number">0.1235</span> Time elapsed: <span class="number">48</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.0589</span> Acc: <span class="number">0.1137</span> Time elapsed: <span class="number">72</span> sec.</span><br><span class="line">val Loss: <span class="number">3.1125</span> Acc: <span class="number">0.3608</span> Time elapsed: <span class="number">95</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.4935</span> Acc: <span class="number">0.2304</span> Time elapsed: <span class="number">119</span> sec.</span><br><span class="line">val Loss: <span class="number">2.5003</span> Acc: <span class="number">0.4912</span> Time elapsed: <span class="number">142</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.1030</span> Acc: <span class="number">0.3422</span> Time elapsed: <span class="number">165</span> sec.</span><br><span class="line">val Loss: <span class="number">2.1583</span> Acc: <span class="number">0.5510</span> Time elapsed: <span class="number">189</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">2.7367</span> Acc: <span class="number">0.4402</span> Time elapsed: <span class="number">212</span> sec.</span><br><span class="line">val Loss: <span class="number">1.7064</span> Acc: <span class="number">0.6304</span> Time elapsed: <span class="number">236</span> sec.</span><br><span class="line">...</span><br><span class="line">val Loss: <span class="number">1.0910</span> Acc: <span class="number">0.7824</span> Time elapsed: <span class="number">1179</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">19</span>m <span class="number">39</span>s</span><br><span class="line">Best val Acc: <span class="number">0.791176</span></span><br></pre></td></tr></table></figure><h1 id="Task-6-4-Transfer-Learning：EfficientNet-B5">Task 6 &amp; 4 - Transfer Learning：EfficientNet_B5</h1><div class="note info flat"><ol start="4"><li><strong>使用dataset訓練模型並印出Testing的準確率</strong>：Train the model on the dataset and measure the accuracy on hold out test data.</li><li><strong>使用EfficientNet_B5進行Fineturned</strong>：Repeat step 4 but now use EfficientNet_B5 instead of RestNet18.</li></ol></div><p>接下來，我們需要把 RestNet18 根據題目要求換成別的訓練好的模型，你可能會需要先透過 pip 安裝 <code>efficientnet_pytorch</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install efficientnet_pytorch</span><br></pre></td></tr></table></figure><p>然後再執行下面的程式碼：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> efficientnet_pytorch <span class="keyword">import</span> EfficientNet</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the pre-trained EfficientNet-B5 model</span></span><br><span class="line">model_ft = EfficientNet.from_pretrained(<span class="string">&#x27;efficientnet-b5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一樣，我們先取得該 model 最後一層 layer 的輸入數量</span></span><br><span class="line">num_ftrs = model_ft._fc.in_features</span><br><span class="line"><span class="comment"># 建立一個新的 layer，輸入數量是 num_ftrs，輸出數量是 102（因為這個case有102個）</span></span><br><span class="line">model_ft.fc = nn.Linear(num_ftrs, <span class="number">102</span>)</span><br><span class="line"><span class="comment"># 把 model 放到 GPU 中</span></span><br><span class="line">model_ft = model_ft.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loss function</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Observe that all parameters are being optimized</span></span><br><span class="line">optimizer_ft = optim.SGD(model_ft.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decay LR by a factor of 0.1 every 7 epochs</span></span><br><span class="line">exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始訓練</span></span><br><span class="line">model_ft_effb5 = train_model(model_ft, criterion, optimizer_ft, exp_lr_scheduler,</span><br><span class="line">                       num_epochs=<span class="number">25</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下：準確率 73.33% 好像沒有比較好。</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Epoch <span class="number">0</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">6.2860</span> Acc: <span class="number">0.0157</span> Time elapsed: <span class="number">156</span> sec.</span><br><span class="line">val Loss: <span class="number">5.6637</span> Acc: <span class="number">0.0382</span> Time elapsed: <span class="number">200</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">4.8955</span> Acc: <span class="number">0.1039</span> Time elapsed: <span class="number">322</span> sec.</span><br><span class="line">val Loss: <span class="number">4.5101</span> Acc: <span class="number">0.2392</span> Time elapsed: <span class="number">365</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.8566</span> Acc: <span class="number">0.2422</span> Time elapsed: <span class="number">485</span> sec.</span><br><span class="line">val Loss: <span class="number">3.6194</span> Acc: <span class="number">0.4265</span> Time elapsed: <span class="number">529</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">3.0979</span> Acc: <span class="number">0.3637</span> Time elapsed: <span class="number">653</span> sec.</span><br><span class="line">val Loss: <span class="number">2.8613</span> Acc: <span class="number">0.5539</span> Time elapsed: <span class="number">696</span> sec.</span><br><span class="line"></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">2.4323</span> Acc: <span class="number">0.4725</span> Time elapsed: <span class="number">818</span> sec.</span><br><span class="line">val Loss: <span class="number">2.2894</span> Acc: <span class="number">0.6725</span> Time elapsed: <span class="number">863</span> sec.</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Epoch <span class="number">24</span>/<span class="number">24</span></span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">train Loss: <span class="number">1.3168</span> Acc: <span class="number">0.7343</span> Time elapsed: <span class="number">4769</span> sec.</span><br><span class="line">val Loss: <span class="number">1.3167</span> Acc: <span class="number">0.8167</span> Time elapsed: <span class="number">4812</span> sec.</span><br><span class="line"></span><br><span class="line">Training complete <span class="keyword">in</span> <span class="number">80</span>m <span class="number">12</span>s</span><br><span class="line">Best val Acc: <span class="number">0.821569</span></span><br></pre></td></tr></table></figure><h1 id="Task-7-討論">Task 7 - 討論</h1><div class="note info flat"><ol start="7"><li><strong>比較這些不同的方法，並列印出準確度</strong>：Compare the accuracy of the different approaches on the test data and print out the training</li></ol></div><p>從前面開始，我們測試了幾個方法：</p><ul><li><a href="#Task-3-4-CNN-Batch-Normalization">使用自己建立的 CNN</a></li><li><a href="#Task-5-4-Transfer-Learning%EF%BC%9AResnet18">使用Transfer Learning Resnet18</a></li><li><a href="#Task-6-4-Transfer-Learning%EF%BC%9AEfficientNet-B5">使用Transfer Learning EfficientNet-B5</a></li></ul><p>他們的數據大概如下：</p><table><thead><tr><th>Model</th><th>Accuracy</th><th>Training Time</th><th>Result</th></tr></thead><tbody><tr><td>自建 CNN</td><td><code>35%</code></td><td><code>超過1小時</code></td><td>最差</td></tr><tr><td>Resnet18</td><td><strong>89.41%</strong></td><td>21分鐘</td><td>準確率最高</td></tr><tr><td>Resnet18 (fixed feature extractor)</td><td>79.11%</td><td><strong>19分鐘</strong></td><td>時間最短</td></tr><tr><td>EfficientNet-B5</td><td>82.15%</td><td>80分鐘</td><td>普普</td></tr></tbody></table><div class="note warning flat"><p><strong>結論</strong></p><ul><li>如果使用 Transfer Learning 可明顯感受到，準確率明顯提高，並且訓練時間大幅縮短。</li><li>再者，以目前的案例來說，不要fixed model 的參數，準確率比較好，雖然相對的時間也會比較長，因為要做gradient descent。</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CIFAR10 Dataset - 使用 Pytorch 搭建 CNN + 啟用 GPU + 結果展示至 TensorBoard</title>
      <link href="/posts/pytorch-CNN-TensorBoard/"/>
      <url>/posts/pytorch-CNN-TensorBoard/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近選了一堂AI課程，這是第三個作業，主要參考以下網站：</p><ul><li>教授如何使用 Pytorch 搭建 CNN：<a href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html">Pytorch Tutorial</a></li><li>教授如何使用 TensorBoard：<a href="https://pytorch.org/tutorials/intermediate/tensorboard_tutorial.html">Pytorch TensorBoard Tutorial</a></li><li>在 CoLabe 使用 TensorBoard 教學：<a href="https://www.tensorflow.org/tensorboard/tensorboard_in_notebooks">TensorBoard in CoLabe Tutorial</a></li></ul><p>本篇的主要目的是理解 CNN，並試圖搭建更深層的 Network，並使用GPU加快效率，最後將結果 Loss 與 猜錯的結果 顯示在 TensorBoard 上。</p><h1 id="環境設置與作業要求">環境設置與作業要求</h1><blockquote><p>環境設置：</p><ul><li>Python 3.10.9</li><li>Pytorch 2.0.1</li></ul></blockquote><h1 id="作業要求">作業要求</h1><p>Task:</p><ol><li><strong>先建立一個CNN</strong>：Train the same network as in the PyTorch CNN tutorial.</li><li><strong>建立出CNN滿足以下要求</strong>：Change now the network architecture as follows and train the network:<ol><li>Conv layer with 3x3 kernel and depth = 8, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 16, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Conv layer with 3x3 kernel and depth = 32, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 64, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Fully connected with 4096 nodes, ReLu activation</li><li>Fully connected with 1000 nodes, ReLu activation</li><li>Fully connected with 10 nodes, no activation</li></ol></li><li><strong>使用GPU並比較CPU結果</strong>：Run the training on the GPU and compare the training time to CPU.</li><li><strong>把 Trainning Loss 放到 Tensorboard</strong>: Log the training loss in tensorboard.</li><li><strong>修改表示正確的標準為只要答案在前三者output 的prediction中，就視為正確</strong>：Change the test metric as follows: A prediction is considered „correct“ if the true label is within the top three outputs of the network. Print the accuracy on the test data (with respect to this new definition).</li><li><strong>雖機抽取五個例子是猜錯的，並放到tensorboard中</strong>：Randomly take 5 examples on which the network was wrong on the test data (according to the new definition of correct) and plot them to tensorboard together<br>with the true label.</li><li><strong>在 notebook 上顯示 tensorBoard</strong>：Show the tensor board widget at the end of your notebook.</li></ol><ul><li><strong>Bonus</strong>: See if you can get better by using a deeper network (or another architecture).</li></ul><h1 id="前置準備">前置準備</h1><ol><li>先載入必要的套件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把tesorBaord的結果存到 ./board/assignment_3</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;./board/resule&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li>下載訓練和測試用的 Dataset 到當前文件中所在的資料夾中建立<code>/data</code>資料夾。為了做歸一化，把均值設定為 0.5 標準差設定為 0.5，表示圖像的範圍在 [0, 1] 之間，變成 [-1, 1] 之間。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義圖像轉換，將圖像轉換成張量並進行歸一化</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># 將圖像轉換為 PyTorch 张量</span></span><br><span class="line">    <span class="comment"># 因為每個像素有三個通道（紅、綠、藍），且通道值通常在 [0, 1] 範圍內。</span></span><br><span class="line">    <span class="comment"># 所以我們要把這三個通道，進行歸一化，讓它們的範圍變成 [-1, 1]。</span></span><br><span class="line">    <span class="comment"># 因 [0,1] 的均值是 0.5，mean 設定 0.5 表示減去均值 0.5 使得原本的均值由 0.5 變成 0 </span></span><br><span class="line">    <span class="comment"># 因 [0,1] 的標準差是 0.5，std 設定 0.5 表示除以標準差 0.5 使得原本的標準差由 0.5 變成 1</span></span><br><span class="line">    <span class="comment"># 最後因為 mean 變成 0 標準差是 1 所以就獲得 [-1,1]</span></span><br><span class="line">    transforms.Normalize(mean=(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), std=(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))  <span class="comment"># 歸一化圖像數據</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義訓練批次大小</span></span><br><span class="line">batch_size = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載和加載 CIFAR-10 訓練數據集</span></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,  <span class="comment"># 存儲數據的根目錄</span></span><br><span class="line">    train=<span class="literal">True</span>,  <span class="comment"># 載入訓練數據</span></span><br><span class="line">    download=<span class="literal">True</span>,  <span class="comment"># 下載數據（如果還未下載）</span></span><br><span class="line">    transform=transform  <span class="comment"># 應用先前定義的圖像轉換</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 創建一個用於訓練數據的 DataLoader，用於批次處理和數據加載</span></span><br><span class="line">trainloader = torch.utils.data.DataLoader(</span><br><span class="line">    trainset,</span><br><span class="line">    batch_size=batch_size,  <span class="comment"># 設置每個批次的大小</span></span><br><span class="line">    shuffle=<span class="literal">True</span>,  <span class="comment"># 隨機打亂數據，增加訓練的隨機性</span></span><br><span class="line">    num_workers=<span class="number">2</span>  <span class="comment"># 使用多個工作進程來加快數據讀取速度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下載和加載 CIFAR-10 測試數據集，同樣的數據轉換和數據加載設置</span></span><br><span class="line">testset = torchvision.datasets.CIFAR10(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>,</span><br><span class="line">    train=<span class="literal">False</span>,  <span class="comment"># 載入測試數據</span></span><br><span class="line">    download=<span class="literal">True</span>,</span><br><span class="line">    transform=transform</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 創建一個用於測試數據的 DataLoader</span></span><br><span class="line">testloader = torch.utils.data.DataLoader(</span><br><span class="line">    testset,</span><br><span class="line">    batch_size=batch_size,</span><br><span class="line">    shuffle=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有的類別名稱放到一個 tuple 中</span></span><br><span class="line">classes = (<span class="string">&#x27;plane&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;bird&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">           <span class="string">&#x27;deer&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;frog&#x27;</span>, <span class="string">&#x27;horse&#x27;</span>, <span class="string">&#x27;ship&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Task-1-2-建立出-CNN">Task 1+2 建立出 CNN</h1><div class="note info flat"><ol><li><strong>先建立一個CNN</strong>：Train the same network as in the PyTorch CNN tutorial.</li><li><strong>建立出CNN滿足以下要求</strong>：Change now the network architecture as follows and train the network.</li></ol></div><h2 id="建立-CNN">建立 CNN</h2><p><strong>Task 2. 建立出CNN滿足以下要求</strong>：Change now the network architecture as follows and train the network:</p><ol><li>Conv layer with 3x3 kernel and depth = 8, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 16, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Conv layer with 3x3 kernel and depth = 32, ReLu activation</li><li>Conv layer with 3x3 kernel and depth = 64, ReLu activation</li><li>Max pooling with 2x2 kernel</li><li>Fully connected with 4096 nodes, ReLu activation</li><li>Fully connected with 1000 nodes, ReLu activation</li><li>Fully connected with 10 nodes, no activation</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NewNet, self).__init__()</span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 color 3 RGB，32*32 pixel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">8</span>, <span class="number">3</span>)  <span class="comment"># 第1層：3x3 kernel and depth = 8 </span></span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 題目要求的 8，32-3+1=30，因此是 30*30 pixel</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">8</span>, <span class="number">16</span>, <span class="number">3</span>)  <span class="comment"># 第2層：3x3 kernel and depth = 16</span></span><br><span class="line">        <span class="comment"># 30/2=15，因此是 15*15 pixel</span></span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 第3層：Max pooling with 2x2 kernel</span></span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 題目要求的 16，15-3+1=13，因此是 13*13 pixel</span></span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">3</span>)  <span class="comment"># 第4層：3x3 kernel and depth = 32</span></span><br><span class="line">        <span class="comment"># (input是上一個的depth，也就是 題目要求的 32，13-3+1=11，因此是 11*11 pixel</span></span><br><span class="line">        self.conv4 = nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>)  <span class="comment"># 第5層：3x3 kernel and depth = 64 </span></span><br><span class="line">        <span class="comment"># 還要再做一個 Max pooling，11/2=5，因此是 5*5 pixel</span></span><br><span class="line">        <span class="comment"># 因此最終 input 是 64，pixel 是 5*5 因此 64*5*5</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">64</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">4096</span>)  <span class="comment"># 第6層：Fully connected with 4096 nodes</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">4096</span>, <span class="number">1000</span>)  <span class="comment"># 第7層：Fully connected with 1000 nodes</span></span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">1000</span>, <span class="number">10</span>)  <span class="comment"># 第8層：Fully connected with 10 nodes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(self.conv1(x))  <span class="comment"># ReLu activation</span></span><br><span class="line">        x = F.relu(self.conv2(x))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = F.relu(self.conv3(x))</span><br><span class="line">        x = F.relu(self.conv4(x))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">64</span> * <span class="number">5</span> * <span class="number">5</span>)  <span class="comment"># flatten</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="Task-3-4-GPU-and-loss-on-tensorBoard">Task 3 + 4 GPU and loss on tensorBoard</h1><div class="note info flat"><ol start="3"><li><strong>使用GPU並比較CPU結果</strong>：Run the training on the GPU and compare the training time to CPU.</li><li><strong>把 Trainning Loss 放到 Tensorboard</strong>: Log the training loss in tensorboard.</li></ol></div><h2 id="使用-GPU-加速-Network">使用 GPU 加速 Network</h2><p>因為我是使用mac，因此輸入<code>mps</code>，但如果你是 windows 系統，請輸入 <code>cuda</code>。<br>初始化function and optimizer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># device = torch.device(&quot;cuda&quot; if torch.backends.mps.is_available() else &quot;cpu&quot;)</span></span><br><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">net = NewNet()</span><br><span class="line">net.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s use a Classification Cross-Entropy loss and SGD with momentum.</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><h2 id="建立訓練模型">建立訓練模型</h2><p>開始撰寫訓練模型，並且把結果寫到 tensorBoard 上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        <span class="comment"># 把資料放到 gpu 或 cpu 上</span></span><br><span class="line">        inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        outputs.to(device)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.to(device)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">200</span> == <span class="number">199</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, <span class="subst">&#123;i + <span class="number">1</span>:5d&#125;</span>] loss: <span class="subst">&#123;running_loss / <span class="number">200</span>:<span class="number">.3</span>f&#125;</span> time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>)&#125;</span> min&#x27;</span>)</span><br><span class="line">            <span class="comment"># ...log the running loss</span></span><br><span class="line">            <span class="comment"># 把 loss 寫到 tensorBoard，因為每次 200 才寫進去，所以要 / 200 才是真正的 loss</span></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;training loss&#x27;</span>,</span><br><span class="line">                            running_loss / <span class="number">200</span>,</span><br><span class="line">                            epoch * <span class="built_in">len</span>(trainloader) + i)</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算時間用來比較 cpu 跟 gpu 的差異</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Finished Training. Total elapsed time: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>, <span class="number">1</span>)&#125;</span> min&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>結果如下圖</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,  <span class="number">3600</span>] loss: <span class="number">1.977</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">3800</span>] loss: <span class="number">2.021</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4000</span>] loss: <span class="number">1.933</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4200</span>] loss: <span class="number">1.922</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4400</span>] loss: <span class="number">1.902</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4600</span>] loss: <span class="number">1.836</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">4800</span>] loss: <span class="number">1.788</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>,  <span class="number">5000</span>] loss: <span class="number">1.818</span> <span class="built_in">time</span> elapsed: <span class="number">1</span> <span class="built_in">min</span></span><br><span class="line">...</span><br><span class="line">[<span class="number">1</span>, <span class="number">12000</span>] loss: <span class="number">1.479</span> <span class="built_in">time</span> elapsed: <span class="number">2</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12200</span>] loss: <span class="number">1.469</span> <span class="built_in">time</span> elapsed: <span class="number">2</span> <span class="built_in">min</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">12400</span>] loss: <span class="number">1.485</span> <span class="built_in">time</span> elapsed: <span class="number">2</span> <span class="built_in">min</span></span><br><span class="line">Finished Training. Total elapsed <span class="built_in">time</span>: <span class="number">2.2</span> <span class="built_in">min</span></span><br></pre></td></tr></table></figure><p>然後可以再寫一個 cpu 比較一下時間</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use CPU </span></span><br><span class="line">device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">net.to(device)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> <span class="built_in">enumerate</span>(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        <span class="comment"># inputs, labels = data, put the inputs and labels on the device (cpu or gpu)</span></span><br><span class="line">        inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        outputs.to(device)</span><br><span class="line"></span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.to(device) </span><br><span class="line">        loss.backward() <span class="comment"># 計算梯度</span></span><br><span class="line"></span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">200</span> == <span class="number">199</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, <span class="subst">&#123;i + <span class="number">1</span>:5d&#125;</span>] loss: <span class="subst">&#123;running_loss / <span class="number">2000</span>:<span class="number">.3</span>f&#125;</span> time elapsed: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>)&#125;</span> min&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Finished Training. Total elapsed time: <span class="subst">&#123;<span class="built_in">round</span>((time.time() - start_time) / <span class="number">60</span>, <span class="number">1</span>)&#125;</span> min&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/GW04dzw.png" alt=""></p><h2 id="訓練結果儲存">訓練結果儲存</h2><p>我目前是先把模型儲存在 <code>./model/cifar_net.pth</code>，之後再把它讀出來，下次就不用重新訓練了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH = <span class="string">&#x27;./model/cifar_net.pth&#x27;</span></span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br><span class="line">net = NewNet()</span><br><span class="line">net.load_state_dict(torch.load(PATH)) <span class="comment"># load the weights from the saved file</span></span><br></pre></td></tr></table></figure><h2 id="使用-Test-Data-評估模型">使用 Test Data 評估模型</h2><div class="note info flat"><p><strong>Task 5. 修改表示正確的標準為只要答案在前三者output 的prediction中，就視為正確</strong>：Change the test metric as follows: A prediction is considered „correct“ if the true label is within the top three outputs of the network. Print the accuracy on the test data (with respect to this new definition).</p></div><p>根據作業要求，要做以下事情：</p><ul><li>TODO 1 調整對準確率的定義，只要答案在前三者output 的prediction中，就視為正確。</li><li>TODO 2 列印出準確率，這邊我列印出 “每個類別” 的準確率 和 &quot;整個準確率“。</li><li>TODO 3 因為他要把錯誤的圖片、輸出和標籤記錄下來，因此我們要先把它們記錄下來，之後隨機選五個錯誤的會使用到。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">class_correct = [<span class="number">0</span>] * <span class="built_in">len</span>(classes)  <span class="comment"># 用來記錄每個類別的正確預測數</span></span><br><span class="line">class_total = [<span class="number">0</span>] * <span class="built_in">len</span>(classes)    <span class="comment"># 用來記錄每個類別的總樣本數</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來儲存所有錯誤預測的圖片、輸出和標籤</span></span><br><span class="line">all_errors = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因為我們不訓練，所以不需要計算輸出的梯度</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data </span><br><span class="line">        outputs = net(images) </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在這裡我們不需要 values 所以放 _, 但是我們需要 結果的index 所以放 predicted</span></span><br><span class="line">        _, predicted = torch.topk(outputs, <span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 因為 testloader 是 batch，所以我們需要逐個樣本（在這種情況下為 4）進行循環</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(labels)):</span><br><span class="line">            <span class="comment"># Example Print out =&gt; Predicted: tensor([3, 5, 2]) Actual: 3 Correct: True</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;Predicted: <span class="subst">&#123;predicted[i]&#125;</span> Actual: <span class="subst">&#123;labels[i]&#125;</span> \t Correct: <span class="subst">&#123;labels[i] <span class="keyword">in</span> predicted[i]&#125;</span>&#x27;</span>)</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 針對 key 是 labels[i] 的 class_total 加 1</span></span><br><span class="line">            class_total[labels[i]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 檢查 labels[i] 是否在 predicted[i] 中，因為labels有四個值，所以用 i 來取出</span></span><br><span class="line">            <span class="keyword">if</span> labels[i] <span class="keyword">in</span> predicted[i]:</span><br><span class="line">                correct += <span class="number">1</span></span><br><span class="line">                class_correct[labels[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 將錯誤的圖片、輸出和標籤記錄下來</span></span><br><span class="line">                all_errors.append((images[i], outputs[i], labels[i]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算每個類別的準確率</span></span><br><span class="line">class_accuracies = [class_correct[i] / class_total[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 計算並列印新的準確度</span></span><br><span class="line">accuracy = correct / total</span><br></pre></td></tr></table></figure><p>結果長這樣</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Predicted: tensor([3, 5, 2]) Actual: 3  Correct: True</span><br><span class="line">Predicted: tensor([8, 0, 1]) Actual: 8  Correct: True</span><br><span class="line">Predicted: tensor([8, 1, 9]) Actual: 8  Correct: True</span><br><span class="line">Predicted: tensor([8, 0, 1]) Actual: 0  Correct: True</span><br><span class="line">Predicted: tensor([4, 2, 6]) Actual: 6  Correct: True</span><br><span class="line">Predicted: tensor([6, 3, 5]) Actual: 6  Correct: True</span><br><span class="line">Predicted: tensor([1, 9, 5]) Actual: 1  Correct: True</span><br><span class="line">Predicted: tensor([2, 6, 4]) Actual: 6  Correct: True</span><br><span class="line">Predicted: tensor([3, 5, 2]) Actual: 3  Correct: True</span><br><span class="line">Predicted: tensor([1, 8, 9]) Actual: 1  Correct: True</span><br><span class="line">...</span><br><span class="line">Predicted: tensor([5, 7, 2]) Actual: 5  Correct: True</span><br><span class="line">Predicted: tensor([4, 2, 3]) Actual: 1  Correct: False</span><br><span class="line">Predicted: tensor([7, 4, 2]) Actual: 7  Correct: True</span><br></pre></td></tr></table></figure><h2 id="列印出準確率">列印出準確率</h2><p>現在就可以列印出準確率了，我們可以看到準確率是 0.1，因為我們只有 10 個類別，所以隨機猜的準確率就是 0.1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy on test data (top-3): <span class="subst">&#123;<span class="number">100</span> * accuracy:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print each class accuracy</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(classes)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Accuracy for class <span class="subst">&#123;classes[i]&#125;</span>: <span class="subst">&#123;<span class="number">100</span> * class_accuracies[i]:<span class="number">.2</span>f&#125;</span>%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print the number of misclassified images</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Total misclassified images: <span class="subst">&#123;<span class="built_in">len</span>(all_errors)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>結果會如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Accuracy on test data (top-3): 91.60%</span><br><span class="line">Accuracy for class plane: 89.50%</span><br><span class="line">Accuracy for class car: 96.30%</span><br><span class="line">Accuracy for class bird: 85.20%</span><br><span class="line">Accuracy for class cat: 91.80%</span><br><span class="line">Accuracy for class deer: 92.40%</span><br><span class="line">Accuracy for class dog: 91.40%</span><br><span class="line">Accuracy for class frog: 88.30%</span><br><span class="line">Accuracy for class horse: 91.50%</span><br><span class="line">Accuracy for class ship: 96.20%</span><br><span class="line">Accuracy for class truck: 93.40%</span><br><span class="line"></span><br><span class="line">Total misclassified images: 840</span><br></pre></td></tr></table></figure><h1 id="Task-6-Random-5-errors-img">Task 6 Random 5 errors img</h1><div class="note info flat"><p><strong>Task 6. 雖機抽取五個例子是猜錯的，並放到tensorboard中</strong>：Randomly take 5 examples on which the network was wrong on the test data (according to the new definition of correct) and plot them to tensorboard together<br>with the true label.</p></div><h2 id="設定圖片轉換函式">設定圖片轉換函式</h2><p>為了後續可以把圖片印出來，我們需要製作一個顯示圖片用的function，而因為 torchvision 資料集的輸出是範圍 [0, 1] 的 PILImage 影像。我們將它們轉換為歸一化範圍 [-1, 1] 的張量。如果我們要把圖片轉換顯示出來，我們必須進行反歸一化，也就是把歸一化後的 [-1, 1] 變回去 [0, 1]，所以我們可以透過 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>x</mi><mn>2</mn></mfrac><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\frac{x}{2} + 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0404em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span> 達成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># functions to show an image</span></span><br><span class="line"><span class="comment"># 如果 one_channel 為 True，則函數假定輸入的影像是單通道的（通常是灰階影像），並使用灰階色圖來顯示影像。</span></span><br><span class="line"><span class="comment"># 如果 one_channel 為 False，則函數假定輸入的影像是三通道的（通常是彩色影像），並使用彩色色圖來顯示影像。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matplotlib_imshow</span>(<span class="params">img, one_channel=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> one_channel:</span><br><span class="line">        img = img.mean(dim=<span class="number">0</span>)</span><br><span class="line">    img = img / <span class="number">2</span> + <span class="number">0.5</span>     <span class="comment"># unnormalize</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    <span class="keyword">if</span> one_channel: </span><br><span class="line">        plt.imshow(npimg, cmap=<span class="string">&quot;Greys&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 因為 matplotlib 所使用的函式輸入是 (高_1, 深度_2, 寬_0) </span></span><br><span class="line">        <span class="comment"># 但是 npimg 預設是 (寬_0, 高_1, 深度=顏色RGB_2) </span></span><br><span class="line">        <span class="comment"># 因此我們需要透過 np.transpose 操作來將通道的順序從(寬_0, 高_1, 深度=顏色RGB_2) 轉換為(高_1, 深度_2, 寬_0)，</span></span><br><span class="line">        plt.imshow(np.transpose(npimg, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br></pre></td></tr></table></figure><h2 id="隨機選擇-5-個錯誤">隨機選擇 5 個錯誤</h2><p>我們剛剛有收集好所有錯誤的 images 還有 predicts 跟 labels，依據題目要求我們需要從中選出 5 個錯誤的 images，並且把它們印出來。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_classes_preds</span>(<span class="params">all_errors</span>):</span><br><span class="line">    <span class="comment"># 隨機選五個猜錯的圖片</span></span><br><span class="line">    random_errors = random.sample(all_errors, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 創建一個大的 matplotlib 圖表，figsize 參數用於指定圖形物件（Figure）的寬度和高度，通常以英吋為單位</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, (image, output, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(random_errors):</span><br><span class="line">        <span class="comment"># 參數表示：行數，列數，子圖索引（從 1 開始，放五個圖片在 長度12英吋*18英吋的圖表）</span></span><br><span class="line">        <span class="comment"># xticks, yticks 用來設定座標的參數，如果不想顯示座標，可以設定為空串列</span></span><br><span class="line">        ax = fig.add_subplot(<span class="number">1</span>, <span class="number">5</span>, idx+<span class="number">1</span>, xticks=[], yticks=[])</span><br><span class="line">        <span class="comment"># 列印出彩色的圖片</span></span><br><span class="line">        matplotlib_imshow(image, one_channel=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 因為 output 是一個 寬1長10 的張量，因此我們要用 dim=0 取出 column 的 top 3 </span></span><br><span class="line">        preds = torch.topk(output, <span class="number">3</span>, dim=<span class="number">0</span>).indices  <span class="comment"># 關於 dim 請看補充</span></span><br><span class="line">        pred_classes = [classes[p] <span class="keyword">for</span> p <span class="keyword">in</span> preds] <span class="comment"># 把 index 轉成 class name，並放入 list 中會有三個 string </span></span><br><span class="line">        <span class="comment"># 給當前這個圖片設定標題，顯示出預測的類別和實際的類別</span></span><br><span class="line">        ax.set_title(<span class="string">&quot;\n(label: &#123;0&#125;)\n(&#123;1&#125;)&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            classes[label],</span><br><span class="line">            <span class="string">&quot;, &quot;</span>.join(pred_classes)),</span><br><span class="line">            color=<span class="string">&quot;red&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最後回傳全部畫好的圖表（總共會有5個圖片）</span></span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫函示</span></span><br><span class="line">plot_classes_preds(all_errors)</span><br></pre></td></tr></table></figure><blockquote><p>會如下圖<br><img src="https://i.imgur.com/OY6EvGW.png" alt=""></p></blockquote><h2 id="把圖片放到-tensorBoard">把圖片放到 tensorBoard</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 放到 tensorBoard</span></span><br><span class="line">fig = plot_classes_preds(all_errors)</span><br><span class="line">writer.add_figure(<span class="string">&quot;predictions vs. actuals&quot;</span>, fig)</span><br></pre></td></tr></table></figure><h1 id="Task-7-在-notebook-上顯示-tensorBoard">Task 7 在 notebook 上顯示 tensorBoard</h1><div class="note info flat"><p><strong>Task 7. 在 notebook 上顯示 tensorBoard</strong>：Show the tensor board widget at the end of your notebook.</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 notebook 上顯示 tensorBoard</span></span><br><span class="line">%load_ext tensorboard <span class="comment"># 這行程式碼會載入TensorBoard的擴展，以便你可以在Notebook中執行TensorBoard。</span></span><br><span class="line">%tensorboard --logdir board <span class="comment"># 這行程式碼會啟動TensorBoard，並將其指向你的日誌文件夾。</span></span><br></pre></td></tr></table></figure><h1 id="補充">補充</h1><h2 id="歸一化-vs-標準化">歸一化 vs 標準化</h2><ul><li>Ref: <a href="https://medium.com/ai%E5%8F%8D%E6%96%97%E5%9F%8E/preprocessing-data-%E6%95%B8%E6%93%9A%E7%89%B9%E5%BE%B5%E6%A8%99%E6%BA%96%E5%8C%96%E5%92%8C%E6%AD%B8%E4%B8%80%E5%8C%96-9bd3e5a8f2fc">Preprocessing Data : 數據特徵標準化和歸一化</a></li></ul><blockquote><p><strong>歸一化 vs 標準化 差異？</strong></p></blockquote><ul><li><code>歸一化 (Normalization)</code>：將數據按比例縮放，使之落入一個小的特定區間，例如 [0, 1] 或 [-1, 1]。<ul><li>公式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x_i - min(x_i)}{max(x_i) - min(x_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">min</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">min</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li><code>標準化 (Standardization)</code>：將數據按比例縮放，使之落入平均值為 0，方差為 1 的分佈中，因此極端值是可以不在[0, 1]的區間。<ul><li>公式： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>μ</mi></mrow><mrow><mi>s</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x_i - \mu}{sd(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3744em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8544em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">d</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">μ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li></ul><blockquote><p><strong>這兩者的共同標準？</strong></p></blockquote><ul><li>都是對某個特徵（column）進行縮放（scaling）而不是對某個樣本的特徵向量（row）進行縮放。</li></ul><blockquote><p><strong>為什麼要做歸一化？</strong></p></blockquote><ol><li><strong>提高精準度</strong>：在機器學習算法的目標函數，許多學習算法中目標函數的基礎都是假設所有的特徵都是零均值並且具有同一階數上的平方差。如果某個特徵的平方差比其他特徵大幾個數量級，那麼它就會在學習算法中佔據主導位置，導致學習器並不能像我們說期望的那樣，從其他特徵中學習。因此，歸一化是<strong>讓不同維度之間的特徵在數值上有一定比較性</strong>，可以大大提高分類器的準確性。</li><li><strong>提升收斂速度</strong>：經過歸一化後，<strong>最優解的尋優過程明顯會變得平緩</strong>，更容易正確的收斂到最優解。</li></ol><h2 id="dim">dim ?</h2><p>dim 參數的不同設置，它決定了在哪個維度上進行排名和獲取最大值。<br>讓我們透過一個範例來說明它們之間的差異：</p><ul><li>如果設定 dim=0 就會是看整個 column 的最大值</li><li>如果設定 dim=1 就會是看整個 row 的最大值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个示例张量</span></span><br><span class="line">output = torch.tensor([[<span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">0.9</span>, <span class="number">0.5</span>, <span class="number">0.3</span>],</span><br><span class="line">                       [<span class="number">0.4</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.7</span>, <span class="number">0.2</span>],</span><br><span class="line">                       [<span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">0.1</span>, <span class="number">0.2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每列中的前 3 个最大值及其索引</span></span><br><span class="line">top_values_col, top_indices_col = torch.topk(output, <span class="number">3</span>, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每行中的前 3 个最大值及其索引</span></span><br><span class="line">top_values_row, top_indices_row = torch.topk(output, <span class="number">3</span>, dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Output tensor:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top 3 values and indices per column:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(top_values_col)</span><br><span class="line"><span class="built_in">print</span>(top_indices_col)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Top 3 values and indices per row:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(top_values_row)</span><br><span class="line"><span class="built_in">print</span>(top_indices_row)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Output tensor:</span><br><span class="line">tensor([[<span class="number">0.2000</span>, <span class="number">0.6000</span>, <span class="number">0.9000</span>, <span class="number">0.5000</span>, <span class="number">0.3000</span>],</span><br><span class="line">        [<span class="number">0.4000</span>, <span class="number">0.1000</span>, <span class="number">0.8000</span>, <span class="number">0.7000</span>, <span class="number">0.2000</span>],</span><br><span class="line">        [<span class="number">0.5000</span>, <span class="number">0.8000</span>, <span class="number">0.9000</span>, <span class="number">0.1000</span>, <span class="number">0.2000</span>]])</span><br><span class="line">Top <span class="number">3</span> values <span class="keyword">and</span> indices per column:</span><br><span class="line"><span class="comment"># 已經從大到小排好了</span></span><br><span class="line">tensor([[<span class="number">0.5000</span>, <span class="number">0.8000</span>, <span class="number">0.9000</span>, <span class="number">0.7000</span>, <span class="number">0.3000</span>],</span><br><span class="line">        [<span class="number">0.4000</span>, <span class="number">0.6000</span>, <span class="number">0.9000</span>, <span class="number">0.5000</span>, <span class="number">0.2000</span>],</span><br><span class="line">        [<span class="number">0.2000</span>, <span class="number">0.1000</span>, <span class="number">0.8000</span>, <span class="number">0.1000</span>, <span class="number">0.2000</span>]])</span><br><span class="line"><span class="comment"># 印出 column 中依序最大到最小的 index 舉例來說 第一列（0.2,0.4,0.5）的 0.5最大 因此 第一個 index 依序是 2, 1, 0 </span></span><br><span class="line"><span class="comment"># 這就是為什麼你看到第一列出現 [[2...], [1...], [0...]]</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], </span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">Top <span class="number">3</span> values <span class="keyword">and</span> indices per row:</span><br><span class="line"><span class="comment"># 已經從大到小排好了</span></span><br><span class="line">tensor([[<span class="number">0.9000</span>, <span class="number">0.6000</span>, <span class="number">0.5000</span>],</span><br><span class="line">        [<span class="number">0.8000</span>, <span class="number">0.7000</span>, <span class="number">0.4000</span>],</span><br><span class="line">        [<span class="number">0.9000</span>, <span class="number">0.8000</span>, <span class="number">0.5000</span>]])</span><br><span class="line"><span class="comment"># 印出 row 中一句最大到最小的 index 舉例來說 第一行 （0.2, 0.6, 0.9, 0.5, 0.3）的 0.9最大 因此 第一個 index 依序是 2, 1, 3</span></span><br><span class="line"><span class="comment"># 這就是為什麼妳看到第一行出現 [[2, 1, 3]</span></span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLP - Data Leakage Protection 的論文 Survey</title>
      <link href="/posts/DLP-Survay-Paper/"/>
      <url>/posts/DLP-Survay-Paper/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因為在做資料庫的零信任相關研究，在這篇<a href="/posts/ZTA-survey-AP-DB-summary">適用於應用程式AP與資料庫DB之間的零信任架構(ZTA)原則 - 總整理篇</a>有提到幾點跟資料保護重要的技術，也就是DLP跟DRM。為此，本篇主要就是總結目前Survey與DLP相關的文獻。</p><p>主要目的是可以找出以下議題的相關論文，並擁有一定的了解：</p><ul><li>DLP 在做什麼？</li><li>DLP 的相關技術？</li><li>DLP 跟 Data Risk Labeling 的結合？</li><li>DLP 跟 Access Control 的結合？</li><li>DLP 關於 Machine Learning 的應用？</li></ul><h1 id="DLP-在做什麼？">DLP 在做什麼？</h1>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> DLP </category>
          
          <category> 畢業論文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碩士論文 </tag>
            
            <tag> DLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Titanic Dataset - 使用 Pytorch 搭建神經網路 + 測試 overfitting</title>
      <link href="/posts/pytorch-titanic-nn/"/>
      <url>/posts/pytorch-titanic-nn/</url>
      
        <content type="html"><![CDATA[<h1 id="Reference">Reference</h1><ul><li>Ref:<a href="https://towardsdatascience.com/predicting-the-survival-of-titanic-passengers-30870ccc7e8">很詳細說明Titanic資料裡面的結構狀態</a></li></ul><h1 id="前言">前言</h1><p>最近選了一堂AI課程，有一個作業是我們寫出一個Nerual Network，並且使用Titanic Dataset來訓練，並且透過增加 hidden layer 跟 neurons 的方式實現overfitting，並透過 dropout 或其他方法來消除 overfitting 的影響。</p><p>在此紀錄ㄧ下作業撰寫的過程。</p><h1 id="環境設置與作業要求">環境設置與作業要求</h1><blockquote><p>環境設置：</p><ul><li>Python 3.10.9</li><li>Pytorch 2.0.1</li></ul></blockquote><h2 id="作業要求">作業要求</h2><ol><li>Write a custom <strong>dataset class for the titanic data</strong> (see the data folder on <a href="https://github.com/pabair/ki-lab-ss23">GitHub</a>). Use only the features: “Pclass”, “Age”, “SibSp”, “Parch”, „Fare“, „Sex“, „Embarked“. <strong>Preprocess the features</strong> accordingly in that class (scaling, one-hot-encoding, etc) and split the data into train and validation data (80% and 20%). The constructor of that class should look like this: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic_train = TitanicDataSet(<span class="string">&#x27;titanic.csv&#x27;</span>, train=<span class="literal">True</span>)</span><br><span class="line">titanic_val = TitanicDataSet(<span class="string">&#x27;titanic.csv&#x27;</span>, train=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li>Build a neural network with <strong>one hidden layer of size 3</strong> that predicts the survival of the passengers. Use a <strong>BCE loss</strong> (Hint: you need a <strong>sigmoid activation</strong> in the output layer). Use a data loader to train in batches of <strong>size 16</strong> and shuffle the data.</li><li><strong>Evaluate the performance</strong> of the model on the validation data using accuracy as metric.</li><li><strong>Create the following plot</strong> that was introduced in the lecture.<ul><li><img src="https://i.imgur.com/yPNS7vc.png?x300" alt=""></li></ul></li><li>Increase the complexity of the network by <strong>adding more layers and neurons</strong> and see if you can overfit on the training data.</li><li>Try to remove overfitting by introducing a <strong><a href="https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html">dropout</a> layer</strong>.</li></ol><h2 id="簡單來說">簡單來說</h2><p>簡單來說，我們會從以下四個步驟中滿足上述要求：</p><ol><li><p><strong>資料前處理</strong></p><ul><li><code>Task 1</code>: 建制 class 並且把 Titanic 的資料導入</li><li><code>Task 1</code>: 只選取特定欄位作為訓練特徵</li><li><code>Task 1</code>: 資料前處理 (scaling, one-hot-encoding, etc)，把性別或是Embaded的這種object型態，非數字的欄位轉換成數字</li><li><code>Task 1</code>: 資料切分成 train data 跟 validation data (80% and 20%)</li><li><code>Task 1</code>: 建立一個 class 並且把資料導入</li></ul></li><li><p><strong>建置 Neural Network</strong></p><ul><li><code>Task 2</code>: 建立一個 three layer 的 network (1 input layer + 1 hidden layer + 1 output layer)。</li><li><code>Task 2</code>: 第一層 hidden layer 的 neurons size 為 3</li><li><code>Task 2</code>: 使用 BCE loss 作為 loss Function</li><li><code>Task 2</code>: 使用 sigmoid activation 作為 output layer 的 activation function</li></ul></li><li><p><strong>模型訓練</strong></p><ul><li><code>Task 3</code>: 開始訓練模型，並且記錄每次的 accuracy</li></ul></li><li><p><strong>產出結果</strong></p><ul><li><code>Task 4</code>: 產出結果，並且畫出圖表</li></ul></li><li><p><strong>製造 Overfitting</strong></p><ul><li><code>Task 5</code>: 增加 hidden layer 跟 neurons 的方式實現overfitting</li></ul></li><li><p><strong>使用 Dropout</strong></p><ul><li><code>Task 6</code>: 透過 dropout 或其他方法來消除 overfitting 的影響</li></ul></li></ol><h1 id="Step1-資料前處理">Step1. 資料前處理</h1><div class="note info flat"><p>那我們就先來開始做<strong>資料前處理</strong>：</p><ul><li><code>Task 1</code>: 建制 class 並且把 Titanic 的資料導入</li><li><code>Task 1</code>: 只選取特定欄位作為訓練特徵</li><li><code>Task 1</code>: 資料前處理 (scaling, one-hot-encoding, etc)，把性別或是Embaded的這種object型態，非數字的欄位轉換成數字</li><li><code>Task 1</code>: 資料切分成 train data 跟 validation data (80% and 20%)</li><li><code>Task 1</code>: 建立一個 class 並且把資料導入</li></ul></div><h2 id="1-1-資料前處理">1.1 資料前處理</h2><ol><li><p>我們先匯入目前所需要的所有套件</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># data process </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, transform</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot </span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># neural network </span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocessing</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler,OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.ion()   <span class="comment"># interactive mode</span></span><br></pre></td></tr></table></figure></li><li><p>在開始之前，我想要先把所有需要會使用的參數都放在最上面比較好更改：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># share variables</span></span><br><span class="line">D_in, D_out = <span class="number">10</span>, <span class="number">1</span> </span><br><span class="line">num_epochs = <span class="number">250</span> </span><br><span class="line">log_interval = <span class="number">100</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># batch_size：每次訓練的資料量</span></span><br><span class="line">batch_size = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># learning rate：因為我會建立兩種不同的 network，因此我們分別設定兩種不同的 learning rate</span></span><br><span class="line">learning_rate = <span class="number">0.001</span></span><br><span class="line">multi_learning_rate = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hidden layers </span></span><br><span class="line">multi_num_layers = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hidden neurons：因為我會建立兩種不同的 network，因此我們分別設定兩種不同的 hidden neurons</span></span><br><span class="line">neurons = <span class="number">3</span> </span><br><span class="line">multi_neurons = <span class="number">1024</span> </span><br></pre></td></tr></table></figure></li><li><p>接著，我們根據要求建制 class 並且把 Titanic 的資料導入，並回傳features</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TitanicDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化函數，用於載入和預處理數據</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, train=<span class="literal">True</span>, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># train 參數用於指示是訓練數據還是測試數據</span></span><br><span class="line">        self.train = train</span><br><span class="line">        <span class="comment"># transform 參數用於定義一個轉換函數，如果需要對數據進行轉換的話</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 創建 MinMaxScaler 和 OneHotEncoder 來進行數據預處理</span></span><br><span class="line">        minmax_scaler = MinMaxScaler()</span><br><span class="line">        onehot_enc = OneHotEncoder()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 讀取 CSV 文件中的鐵達尼號數據</span></span><br><span class="line">        titanic = pd.read_csv(root_dir)</span><br><span class="line">        <span class="comment"># 從數據中選取特定的列</span></span><br><span class="line">        titanic = titanic[[<span class="string">&quot;Pclass&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;SibSp&quot;</span>, <span class="string">&quot;Parch&quot;</span>, <span class="string">&quot;Fare&quot;</span>, <span class="string">&quot;Sex&quot;</span>, <span class="string">&quot;Embarked&quot;</span>, <span class="string">&quot;Survived&quot;</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將 &quot;Age&quot; 列中的缺失值用平均值填充，並刪除包含缺失值的行</span></span><br><span class="line">        titanic[<span class="string">&quot;Age&quot;</span>] = titanic[<span class="string">&quot;Age&quot;</span>].fillna(titanic[<span class="string">&quot;Age&quot;</span>].mean())</span><br><span class="line">        titanic = titanic.dropna()</span><br><span class="line">        titanic = titanic.reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將數據分為類別特徵、數值特徵和標籤</span></span><br><span class="line">        categorical_features = titanic[titanic.select_dtypes(include=[<span class="string">&#x27;object&#x27;</span>]).columns.tolist()]</span><br><span class="line">        numerical_features = titanic[titanic.select_dtypes(exclude=[<span class="string">&#x27;object&#x27;</span>]).columns].drop(<span class="string">&#x27;Survived&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">        label_features = titanic[<span class="string">&#x27;Survived&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 對數值特徵進行歸一化（MinMax 歸一化）</span></span><br><span class="line">        numerical_features_arr = minmax_scaler.fit_transform(numerical_features)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 對類別特徵進行獨熱編碼</span></span><br><span class="line">        categorical_features_arr = onehot_enc.fit_transform(categorical_features).toarray()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將歸一化的數值特徵和獨熱編碼後的類別特徵合併成一個數據集</span></span><br><span class="line">        combined_features = pd.DataFrame(data=numerical_features_arr, columns=numerical_features.columns)</span><br><span class="line">        combined_features = pd.concat([combined_features, pd.DataFrame(data=categorical_features_arr)], axis=<span class="number">1</span>)</span><br><span class="line">        combined_features = pd.concat([combined_features, label_features], axis=<span class="number">1</span>).reset_index(drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 將數據集分為訓練集和測試集</span></span><br><span class="line">        train_data, test_data = train_test_split(combined_features, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根據訓練或測試模式選擇要使用的數據</span></span><br><span class="line">        <span class="keyword">if</span> train:</span><br><span class="line">            self.data = train_data</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data = test_data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回數據集的長度</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用於訓練神經網絡的函數，返回特徵和標籤</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="comment"># 獲取在 self.data DataFrame 中的第 idx 行的數據</span></span><br><span class="line">        sample = self.data.iloc[idx] </span><br><span class="line">        <span class="comment"># 將一個數據結構轉換為 PyTorch 張量 並指定這個张量的數據類型為浮點數（float）</span></span><br><span class="line">        features = torch.FloatTensor(sample[:-<span class="number">1</span>])</span><br><span class="line">        label = torch.FloatTensor([sample[<span class="string">&#x27;Survived&#x27;</span>]])</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            features = self.transform(features)</span><br><span class="line">        <span class="keyword">return</span> features, label</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回整個數據集的 DataFrame</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>寫好 function 後，就可以開始使用了，我們可以使用以下指令來測試一下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">titanic_train = TitanicDataset(<span class="string">&#x27;./data/titanic.csv&#x27;</span>, train=<span class="literal">True</span>)</span><br><span class="line">titanic_val = TitanicDataset(<span class="string">&#x27;./data/titanic.csv&#x27;</span>, train=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_dataset len:&#x27;</span>, <span class="built_in">len</span>(titanic_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;val_dataset len:&#x27;</span>, <span class="built_in">len</span>(titanic_val))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;total_dataset len:&#x27;</span>, <span class="built_in">len</span>(titanic_train) + <span class="built_in">len</span>(titanic_val))</span><br><span class="line"><span class="comment"># 最後會印出如下：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">train_dataset len: 711</span></span><br><span class="line"><span class="string">val_dataset len: 178</span></span><br><span class="line"><span class="string">total_dataset len: 889</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>可以透過以下程式，列印出以下結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic_val.getData()</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/d2C0wTF.png" alt=""></p><h1 id="Step2-建制-Neural-Network">Step2. 建制 Neural Network</h1><ol><li>接下來我們建制以下 Neural Network，主要做以下事情：<ul><li><code>__init__</code>: 建立一個 three layer 的 network (1 input layer + 1 hidden layer + 1 output layer)。<ul><li><code>D_in</code>: input layer 的 neurons size</li><li><code>H</code>: hidden layer 的 neurons size</li><li><code>D_out</code>: output layer 的 neurons size</li></ul></li><li><code>forward</code>: 進行 forward pass 的地方，主要做第一層的 linear transformation，並且使用 <code>relu</code> 作為 activation function，第二層的 linear transformation，並且使用 <code>sigmoid</code> 作為 activation function，最後回傳預測的結果。</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, H, D_out</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        In the constructor we instantiate two nn.Linear modules and assign them as member variables.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(TwoLayerNet, self).__init__()</span><br><span class="line">        <span class="comment"># the weight and bias of linear1 will be initialized </span></span><br><span class="line">        <span class="comment"># you can access them by self.linear1.weight and self.linear1.bias</span></span><br><span class="line">        self.linear1 = nn.Linear(D_in, H) <span class="comment"># this will create weight, bias for linear1</span></span><br><span class="line">        self.linear2 = nn.Linear(H, D_out) <span class="comment"># this will create weight, bias for linear2</span></span><br><span class="line">        self.sigmoid = nn.Sigmoid() <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        In the forward function we accept a Tensor of input data and we must return a Tensor of output data.</span></span><br><span class="line"><span class="string">        We can use Modules defined in the constructor as well as arbitrary operators on Tensors.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        h_relu = F.relu(self.linear1(x))</span><br><span class="line">        y_pred = self.sigmoid(self.linear2(h_relu))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure></li><li>在訓練模型之前，我們要先把模型建立起來。下面程式碼的意思就是，我們設定 batch_size = 16，每次以 16 個單位進行一次訓練，然後把所有 889 筆資料以 16單位全部訓練完作為一次epoch，input layer 的 neurons size = 10，hidden layer 的 neurons size = 3，output layer 的 neurons size = 1，learning rate = 0.001，總共訓練 500 次。<ul><li>我們建立了 network 把網路神經建立起來</li><li>使用 Adam 作為 optimizer，進行 Gradient Descent 的更新</li><li>使用 Binary Cross-Entropy Loss 作為 loss function</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">N, D_in, H, D_out = <span class="number">16</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">lr = <span class="number">0.001</span></span><br><span class="line">n_epochs = <span class="number">50</span></span><br><span class="line">log_interval = <span class="number">100</span> <span class="comment"># Print the training status every log_interval epoch</span></span><br><span class="line"></span><br><span class="line">network = TwoLayerNet(D_in, H, D_out)  <span class="comment"># H=3 for one hidden layer with 3 neurons</span></span><br><span class="line">optimizer = optim.Adam(network.parameters(), lr)</span><br><span class="line">criterion = nn.BCELoss() <span class="comment"># Define the loss function as Binary Cross-Entropy Loss</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Step3-模型訓練">Step3. 模型訓練</h1><ol><li>可以先建立好所需的 list 清單來記住每次的 loss 跟 accuracy <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_losses = [] <span class="comment"># Save the loss value of each training loop (epoch) of the neural network model during the training process</span></span><br><span class="line">train_counter = [] <span class="comment"># Save the number of images for training so far</span></span><br><span class="line">test_losses = [] <span class="comment"># Save the loss value of each test loop (epoch) of the neural network model during the training process</span></span><br><span class="line">test_counter = [i*<span class="built_in">len</span>(titanic_train) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs+<span class="number">1</span>)] <span class="comment"># how many data for training so far</span></span><br></pre></td></tr></table></figure></li><li>建制 train function，主要目的是把 model train 好，使用 train dataset 來進行模型訓練。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>): <span class="comment"># 目前跑了第幾個 epoch</span></span><br><span class="line">    network.train() <span class="comment"># 把上一步驟建立好的 network 拿進來使用</span></span><br><span class="line">    correct = <span class="number">0</span> <span class="comment"># 紀錄目前正確的次數</span></span><br><span class="line">    cur_count = <span class="number">0</span>  <span class="comment"># 紀錄目前已經訓練了多少筆資料</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 先把目前的 gradient 清空，因為每次訓練完一個 batch 就會更新一次 gradient</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># forward propagation</span></span><br><span class="line">        output = network(data) <span class="comment"># 把資料餵入 network 進行 forward propagation</span></span><br><span class="line">        loss = criterion(output, target) <span class="comment"># 計算 loss</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># Accuracy</span></span><br><span class="line">        pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># 因為答案不是0就是1，因此我們需要設定 threshold，大於等於 0.5 就是 1，小於 0.5 就是 0</span></span><br><span class="line">        correct += (pred == target).<span class="built_in">sum</span>().item() <span class="comment"># 紀錄目前正確的次數，如果與 target 一樣就 +1 </span></span><br><span class="line">        cur_count += <span class="built_in">len</span>(data) <span class="comment"># 紀錄目前已經訓練了多少筆資料   </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># backword propagation</span></span><br><span class="line">        loss.backward() <span class="comment"># 計算 loss 的 gradient</span></span><br><span class="line">        optimizer.step() <span class="comment"># 更新 gradient</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % log_interval == <span class="number">0</span>: <span class="comment"># 每 log_interval 印出一次訓練狀態</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;\t Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, </span><br><span class="line">                cur_count, </span><br><span class="line">                <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * cur_count / <span class="built_in">len</span>(train_dataloader.dataset), </span><br><span class="line">                loss.item(), </span><br><span class="line">                correct, <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * correct / <span class="built_in">len</span>(train_dataloader.dataset))</span><br><span class="line">            )</span><br><span class="line">            train_losses.append(loss.item())</span><br><span class="line">            train_counter.append((batch_idx*<span class="number">16</span>) + ((epoch-<span class="number">1</span>)*<span class="built_in">len</span>(train_dataloader.dataset)))</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 回傳目前的 accuracy</span></span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(train_dataloader.dataset)</span><br></pre></td></tr></table></figure></li><li>建制 test function，主要目的是把 train 好的 model 透過 validation dataset 進行測試，看這個模型訓練在檢測未知資料時，準確率如何。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    network.<span class="built_in">eval</span>() <span class="comment"># 把上一步驟建立好的 network 拿進來使用，告知目前要進行 evaluation 的狀態</span></span><br><span class="line">    test_loss = <span class="number">0</span> <span class="comment"># 紀錄目前的 loss</span></span><br><span class="line">    correct = <span class="number">0</span> <span class="comment"># 紀錄目前正確的次數</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment"># 因為不需要計算 gradient，因此可以使用 torch.no_grad() 來加速</span></span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_dataloader: <span class="comment"># 透過 test_dataloader 來取得資料</span></span><br><span class="line">            <span class="comment"># forward propagation </span></span><br><span class="line">            output = network(data) <span class="comment"># 把資料餵入 train 好的 network 進行 forward propagation</span></span><br><span class="line">            test_loss += criterion(output, target).item() <span class="comment"># 計算 loss </span></span><br><span class="line">            <span class="comment"># Accuracy</span></span><br><span class="line">            pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># 0.5 is the threshold </span></span><br><span class="line">            correct += (pred == target).<span class="built_in">sum</span>().item() <span class="comment"># 紀錄目前正確的次數，如果與 target 一樣就 +1</span></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_dataloader.dataset) <span class="comment"># 計算平均的 loss</span></span><br><span class="line">    test_losses.append(test_loss) <span class="comment"># 把目前的 loss 加入 list 中 </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, </span><br><span class="line">        correct, </span><br><span class="line">        <span class="built_in">len</span>(test_dataloader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_dataloader.dataset))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(test_dataloader.dataset) <span class="comment"># 回傳目前的 accuracy </span></span><br></pre></td></tr></table></figure></li><li>最後我們就可以根據 epoch 數量來進行模型的訓練，並做完每次 epoch 時，就透過 <code>test()</code> 來檢驗一下訓練狀況。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test()</span><br><span class="line">train_accuracy_list = []</span><br><span class="line">test_accuracy_list = []</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_epochs + <span class="number">1</span>): <span class="comment"># 進行 n_epochs 次的訓練</span></span><br><span class="line">    train_accuracy_list.append(train(epoch)) <span class="comment"># 訓練完後，把目前的 accuracy 加入 list 中</span></span><br><span class="line">    test_accuracy_list.append(test()) <span class="comment"># 訓練完後，把目前的 accuracy 加入 list 中</span></span><br></pre></td></tr></table></figure></li><li>出來應該會長這樣：</li></ol><h1 id="Step4-產出結果">Step4. 產出結果</h1><p>最後可以透過以下指令來產出結果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(train_accuracy_list, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.plot(test_accuracy_list, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># plt.ylim(0.5, 1)</span></span><br><span class="line">plt.legend([<span class="string">&#x27;Train Accuracy&#x27;</span>, <span class="string">&#x27;Test Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Train Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Test Accuracy&#x27;</span>], loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/8yHAk60.png" alt=""></p><h1 id="Step5-製造-Overfitting">Step5. 製造 Overfitting</h1><div class="note info flat"><p>製造 Overfitting 主要可以有幾種方式：</p><ol><li><strong>epoch 調大</strong>，就會有一點 overfitting 的現象</li><li>或是把 <strong>hidden layer 數量提高</strong>或是把 <strong>neurons size 調大</strong>，也會有一點 overfitting 的現象</li></ol></div><p>因為題目要求把 hidden layer 數量提高獲釋把 neurons size 調大，因此我們就來試試看吧！<br>最簡單的方式就是把，hidden layer調高一點，neurons size 調大一點，並且 epoch 調大一點，就可以看到 overfitting 的現象了。</p><ol><li>建立一個 MultiLayerNet，並且把 hidden layer 跟 neurons size 調高一點 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, H, D_out, num_layers</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        neurons = <span class="number">128</span></span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, H)</span><br><span class="line">        self.linear1 = nn.Linear(H, <span class="number">128</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line">        self.linear4 = nn.Linear(<span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line">        self.output = nn.Linear(<span class="number">16</span>, D_out)</span><br><span class="line">        self.sigmoid = nn.Sigmoid() <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y_relu = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        y_relu = F.relu(self.linear1(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear2(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear3(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear4(y_relu))</span><br><span class="line">        y_pred = self.sigmoid(self.output(y_relu))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure></li></ol><div class="note danger flat"><p>踩雷筆記：如果你純粹增加 layer 並不會有太多學習的效果，你會總是看到一水平的條線…，然後準確率就沒再上升了！後來同學發現，neurons要從多慢慢遞減，才會有學習的效果，因此我們可以把 neurons 設定成 128, 64, 32, 16！<br>「 同學說：這就像沙漏一樣」，這樣會慢慢一步步的過濾掉不重要的資訊，最後留下重要的資訊！」</p></div><ol><li><p>針對 multi network 建立新的 multi_train() 跟 test_multi() function</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_multi</span>(<span class="params">epoch</span>):</span><br><span class="line">    multi_network.train() <span class="comment"># 把上一步驟建立好的 network 拿進來使用</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    cur_count = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        multi_optimizer.zero_grad()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># forward propagation</span></span><br><span class="line">        output = multi_network(data) <span class="comment"># 你會發現這裡使用 multi_network 來進行 forward propagation</span></span><br><span class="line">        loss = multi_criterion(output, target) <span class="comment"># 你會發現這裡使用 multi_criterion 來計算 loss</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># Accuracy</span></span><br><span class="line">        pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># survival_rate is the threshold</span></span><br><span class="line">        correct += (pred == target).<span class="built_in">sum</span>().item()</span><br><span class="line">        cur_count += <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># backword propagation</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        multi_optimizer.step()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_idx % log_interval == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Muti Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;\t Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, </span><br><span class="line">                cur_count, </span><br><span class="line">                <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * cur_count / <span class="built_in">len</span>(train_dataloader.dataset), </span><br><span class="line">                loss.item(), </span><br><span class="line">                correct, <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                <span class="number">100.</span> * correct / <span class="built_in">len</span>(train_dataloader.dataset))</span><br><span class="line">            )</span><br><span class="line">            train_losses.append(loss.item())</span><br><span class="line">            train_counter.append((batch_idx*<span class="number">16</span>) + ((epoch-<span class="number">1</span>)*<span class="built_in">len</span>(train_dataloader.dataset)))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(train_dataloader.dataset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_multi</span>():</span><br><span class="line">    multi_network.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            <span class="comment"># forward propagation</span></span><br><span class="line">            output = multi_network(data)</span><br><span class="line">            test_loss += multi_criterion(output, target).item()</span><br><span class="line">            <span class="comment"># Accuracy</span></span><br><span class="line">            pred = (output &gt;= <span class="number">0.5</span>).<span class="built_in">float</span>()  <span class="comment"># 0.5 is the threshold</span></span><br><span class="line">            correct += (pred == target).<span class="built_in">sum</span>().item()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_dataloader.dataset)</span><br><span class="line">    test_losses.append(test_loss)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nMulti Test set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, </span><br><span class="line">        correct, </span><br><span class="line">        <span class="built_in">len</span>(test_dataloader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_dataloader.dataset))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(test_dataloader.dataset)</span><br></pre></td></tr></table></figure></li><li><p>重新 train model</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_multi()</span><br><span class="line"></span><br><span class="line">multi_train_accuracy_list = []</span><br><span class="line">multi_test_accuracy_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n_epochs + <span class="number">1</span>):</span><br><span class="line">    multi_train_accuracy_list.append(train_multi(epoch))</span><br><span class="line">    multi_test_accuracy_list.append(test_multi())</span><br></pre></td></tr></table></figure></li><li><p>重新畫圖: 你可以嘗試把 epoch 條到 500 次，就會看到 overfitting 的現象了！</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(multi_train_accuracy_list, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.plot(multi_test_accuracy_list, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.ylim(<span class="number">0.5</span>, <span class="number">0.9</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Train Accuracy&#x27;</span>, <span class="string">&#x27;Test Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Train Accuracy&#x27;</span>, <span class="string">&#x27;Mutli Test Accuracy&#x27;</span>], loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Epoch&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.imgur.com/eVxVkM6.png" alt=""></p><h2 id="進階版">進階版</h2><p>如果希望可以更加動態的調整neurons跟hidden layer的數量，可以使用以下方式：</p><ul><li><code>neurons</code>: 一開始設定的 neurons 數量，如果設定 1024，就會從 1024 開始遞減至 16，每次遞減就除以 2，直到 neurons 數量小於 16 為止</li><li><code>num_layers</code>: hidden layer 數量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">neurons = <span class="number">1024</span> </span><br><span class="line">num_layers = <span class="number">5</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, D_out, neurons, num_layers</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        neurons = neurons</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, neurons)</span><br><span class="line">        self.linears = nn.ModuleList()  <span class="comment"># 需要注意的是，如果要用 for 回圈建立多個 layer，就必須使用 nn.ModuleList() 來建立</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.linears.append(nn.Linear(neurons, <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>)))</span><br><span class="line">            neurons = <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>) </span><br><span class="line">        self.output = nn.Linear(neurons, D_out)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()  <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.linears:</span><br><span class="line">            y = F.relu(layer(y))</span><br><span class="line">        y_pred = self.sigmoid(self.output(y))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure><h1 id="Step6-使用-Dropout">Step6. 使用 Dropout</h1><p>這邊我們可以使用 Dropout 來避免 overfitting 的現象，主要是在 forward propagation 的時候，隨機把一些 neurons 給關掉，這樣就可以避免 overfitting 的現象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, H, D_out, num_layers, dropout_prob</span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, H)</span><br><span class="line">        self.linear1 = nn.Linear(H, <span class="number">128</span>)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">64</span>, <span class="number">32</span>)</span><br><span class="line">        self.linear4 = nn.Linear(<span class="number">32</span>, <span class="number">16</span>)</span><br><span class="line">        self.output = nn.Linear(<span class="number">16</span>, D_out)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line">        self.dropout = nn.Dropout(p=dropout_prob)  <span class="comment"># 添加 Dropout 層</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y_relu = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        y_relu = F.relu(self.linear1(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear2(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear3(y_relu))</span><br><span class="line">        y_relu = F.relu(self.linear4(y_relu))</span><br><span class="line">        y_relu = self.dropout(y_relu)  <span class="comment"># 在需要的位置應用 Dropout</span></span><br><span class="line">        y_pred = self.sigmoid(self.output(y_relu))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這時候你會發現，overfitting 的現象就沒那麼嚴重了！以下是 epoch 數量設定為 200 時的結果。</p><blockquote><p>Without Dropout<br><img src="https://i.imgur.com/BxmZNLL.png" alt=""></p></blockquote><blockquote><p>With Dropout<br><img src="https://i.imgur.com/wj5vFvt.png" alt=""></p></blockquote><h2 id="進階版-2">進階版</h2><p>進階版的差異就是，dropout layer 的數量跟 hidden layer 的數量是一樣的，並且 dropout layer 的數量是隨著 hidden layer 的數量遞減的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLayerNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, D_in, D_out, neurons, num_layers, dropout_prob=<span class="number">0.8</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MultiLayerNet, self).__init__()</span><br><span class="line">        neurons = neurons</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(D_in, neurons)</span><br><span class="line">        self.linears = nn.ModuleList()  </span><br><span class="line">        self.dropouts = nn.ModuleList() <span class="comment">#  ======&gt; dropout layer</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.linears.append(nn.Linear(neurons, <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>)))</span><br><span class="line">            self.dropouts.append(nn.Dropout(p=dropout_prob)) <span class="comment"># ======&gt; dropout layer</span></span><br><span class="line">            neurons = <span class="built_in">max</span>(neurons // <span class="number">2</span>, <span class="number">16</span>) </span><br><span class="line">        self.output = nn.Linear(neurons, D_out) <span class="comment"># output layer</span></span><br><span class="line">        self.sigmoid = nn.Sigmoid()  <span class="comment"># Sigmoid activation for binary classification</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = F.relu(self.<span class="built_in">input</span>(x))</span><br><span class="line">        <span class="keyword">for</span> layer, dropout <span class="keyword">in</span> <span class="built_in">zip</span>(self.linears, self.dropouts):</span><br><span class="line">            y = F.relu(layer(y))</span><br><span class="line">            y = dropout(y) <span class="comment"># ======&gt; dropout layer</span></span><br><span class="line">        y_pred = self.sigmoid(self.output(y))</span><br><span class="line">        <span class="keyword">return</span> y_pred</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAC OS - PyTorch 上如何啟用 GPU</title>
      <link href="/posts/PyTorch-Mac-GPU/"/>
      <url>/posts/PyTorch-Mac-GPU/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://blog.csdn.net/DaydreamHippo/article/details/128094886">mac m1,m2 安装 提供GPU支持的pytorch和tensorflow</a></li><li><a href="https://developer.apple.com/metal/pytorch/">Accelerated PyTorch training on Mac</a></li></ul><h1 id="Mac-OS-在-PyTorch-啟用-GPU">Mac OS 在 PyTorch 啟用 GPU</h1><ol><li>因為我本身使用我重新基于Anaconda安装了一下GPU支持的Pytorch，你不確定是否有安裝Conda可以使用指令<code>conda --version</code>查看是否有安裝。如果成供輸出帶有本身有安裝，如果沒有請至<a href="https://www.anaconda.com/products/distribution">Anaconda官網</a>下載。</li><li>（可選）如果想要分開環境，特別建立一個支援GPU的python env，可以使用以下指令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一個 torch-gpu 的環境 使用 python 3.10.9</span></span><br><span class="line">conda create -n torch-gpu python=3.10.9</span><br><span class="line"><span class="comment"># 啟用該環境</span></span><br><span class="line">conda activate torch-gpu</span><br><span class="line"><span class="comment"># 查看 所有環境 </span></span><br><span class="line">conda <span class="built_in">env</span> list </span><br><span class="line"><span class="comment"># 查看目前的 python 版本與啟用的 env python 版本是否相同</span></span><br><span class="line">python --version</span><br></pre></td></tr></table></figure><ol start="3"><li><p>根據 <a href="https://pytorch.org/">Pytorch 官網</a>選擇對應的版本，複製安裝指令<br><img src="https://i.imgur.com/i89otBb.png" alt=""></p></li><li><p>您可以使用簡單的 Python 腳本驗證 mps 支援：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">if</span> torch.backends.mps.is_available():</span><br><span class="line">    mps_device = torch.device(<span class="string">&quot;mps&quot;</span>)</span><br><span class="line">    x = torch.ones(<span class="number">1</span>, device=mps_device)</span><br><span class="line">    <span class="built_in">print</span> (x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;MPS device not found.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或是</span></span><br><span class="line"><span class="built_in">print</span>(torch.backends.mps.is_available()) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(torch.backends.mps.is_built()) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><div class="note warning flat"><p>需要注意的是，如果在 mac os 上，要使用 mps 而非一般 coda:0，要這樣寫：<code>device = torch.device(&quot;mps)</code></p></div>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All basic concept of Mechine Learning - ML 的重點知識整理</title>
      <link href="/posts/ML/"/>
      <url>/posts/ML/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://medium.com/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7-%E5%80%92%E5%BA%95%E6%9C%89%E5%A4%9A%E6%99%BA%E6%85%A7/epoch-batch-size-iteration-learning-rate-b62bf6334c49">Epoch, Batch size, Iteration, Learning Rate</a></li><li><a href="https://youtu.be/Dr-WRlEFefw?si=YUsDXnWbTRSBiR26">ML Lecture 6: Brief Introduction of Deep Learning</a></li><li><a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backporpagation</a></li><li><a href="https://zhuanlan.zhihu.com/p/25110450">聊一聊深度学习的activation function</a></li><li><a href="https://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">台大李鴻毅老師的所有影片</a></li><li><a href="https://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">超詳細的activation function推導公式</a></li><li><a href="https://chih-sheng-huang821.medium.com/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-convolutional-neural-network-cnn-%E5%8D%B7%E7%A9%8D%E8%A8%88%E7%AE%97%E4%B8%AD%E7%9A%84%E6%AD%A5%E4%BC%90-stride-%E5%92%8C%E5%A1%AB%E5%85%85-padding-94449e638e82">卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)</a></li><li><a href="https://cs231n.github.io/neural-networks-3/#hyper">史丹佛nerual-networks-3</a></li></ul><h1 id="Nerual-Network">Nerual Network</h1><p>主要參考：- <a href="https://youtu.be/Dr-WRlEFefw?si=YUsDXnWbTRSBiR26">ML Lecture 6: Brief Introduction of Deep Learning</a></p><p><img src="https://i.imgur.com/QiJ6SSW.png" alt=""></p><ul><li>就是把 <code>input * weight + bias</code> 進行 <code>activation function</code> (ex. sigmoid )，得到 output，然後再進行下一層的運算。</li><li>如果你知道當下 nerual network 當下計算出結果的所有 weight 和 bias ，稱之為一個 function，而梯度下降就是在多組 function set中找到最佳的那組 function。</li></ul><h2 id="Goal">Goal</h2><p><img src="https://i.imgur.com/M7cW1Jv.png" alt=""></p><ul><li>透過 Cross Entropy 來看預測的結果跟實際的結果有多接近，越大表示差越多，越小表示差越少。</li><li>而 <strong>Loss function 就是把所有的 Cross Entropy 加起來</strong>，就是我們要<strong>最小化的目標</strong>。</li></ul><p><img src="https://i.imgur.com/MuUNBwO.png" alt=""></p><ul><li>找到一個 function in function set，讓 Loss function 最小化，就是我們要找的 function。</li><li>找到的過程就是透過 梯度下降法 (Gradient Descent) 來找到 network parameters θ (weight, bias) 的最佳解。</li></ul><h2 id="hidden-layer">hidden layer</h2><p><img src="https://i.imgur.com/HHjICpr.png" alt=""></p><ul><li>一個 layer 就是把 <strong>input * metrix + bias 通過 activation function</strong> （ex. sigmoid funciton）得到最後的結果</li></ul><h2 id="output-layer">output layer</h2><p><img src="https://i.imgur.com/xl7SWAK.png" alt=""></p><ul><li>又稱 Multi-class Classifier ，因為output layer是把前一個layer ouput當作feature，他不是直接使用原始的input(x)，而是經過很多hidden layer很多複雜轉換後抽出一組最好的feature。</li><li>Multi-Class Classifier 要通過一個 Softmax function，把每個類別的機率加起來等於1，然後取最大的機率當作預測的類別。</li></ul><h2 id="決定的參數">決定的參數</h2><ul><li>要決定整個network的structure，決定你的function set長什麼樣子<ul><li>幾個 layer ?</li><li>每個 layer 有幾個 node (neuron) ?</li><li>可不可以自己決定 nerual 要使用的 input 自己串？=&gt; 可以，使用CNN</li></ul></li></ul><h1 id="Epoch-Batch-size-Iteration">Epoch, Batch size, Iteration</h1><p>主要參考：- <a href="https://medium.com/%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7-%E5%80%92%E5%BA%95%E6%9C%89%E5%A4%9A%E6%99%BA%E6%85%A7/epoch-batch-size-iteration-learning-rate-b62bf6334c49">Epoch, Batch size, Iteration, Learning Rate</a></p><ul><li><p><strong>Epoch</strong></p><ul><li>字面：直接翻譯又稱「時代」或「時期」的意思，但是在神經網路上類似「期」。</li><li>意思：表示在訓練過程中，所有的<code>訓練資丟入神經網路進行一次訓練，稱為一個 Epoch</code>。</li><li>例子：如果有一個資料集10筆資料，這時筆資料丟入神經網路後進行一次訓練表示完成 1 個 Epoch 的訓練。</li></ul></li><li><p><strong>Batch size</strong></p><ul><li>字面：批次大小</li><li>意思：如果資料量太大，例如有100萬筆，但是因為 memory 無法一次放入這麼多資料，就可以透過調整batch size分批把資料放入。</li><li>例子：假設有100萬筆資料，batch size設定為1000，那麼一個 epoch 就要訓練 1000 次 才能完成。</li><li>補充：<ul><li>batch size 越大，因為考慮較多參數，進行梯度下降時修正的方向較為準確，雖然每次iteration計算較久，但是調整方向的次數較少，Epoch可以不用很大。</li><li>相反的batch size 越小，Batch size = 1 又稱 Incremental mode，因為一次 iteration 只需算一筆資料，所以權重會配頻繁更新導致方向不太準確，因此 Epoch 要設定大一點，才能讓權重更新的次數多一點，以找到最佳解。</li></ul></li><li>總結：<ul><li>我可以用較大的 Batch size 搭配較大的 η，那結果可能是不用那麼多的 Epoch 就能達到我的期望。</li></ul></li></ul></li><li><p><strong>Iteration</strong></p><ul><li>字面：迭代</li><li>意思：因為資料量太大，我們需要透過 batch 的方式將資料送進神經網路，在程式語言上會需要透過迴圈進行迭代才能將所有資料批次送入訓練，已完成一次Epoch。</li><li>例子：假設有100萬筆資料，batch size設定為1000，那麼一個 epoch 就要金行 1000 次 的迭代才能完成。</li></ul></li></ul><div class="note warning flat"><p><strong>Data set size = Iteration * Batch size * (1 Epoch)</strong><br>100 萬 = 1000 次 * 1000 批次 = 1 Epoch</p></div><div class="note warning flat"><p><strong>Iteration = (Data set size / Batch size) * (n Epoch)</strong><br>如果決定使用Batch size = 1000，訓練5個Epoch總共要迭代幾次？<br>Ans: 100萬/1000 * 5 = 5000次</p></div><h1 id="Learning-Rate">Learning Rate</h1><p>在進行「梯度下降」（Gradient Descent）時，每次計算誤差後會做偏微分來更新權重，更新的程度會由 ∇E（Gradient）乘上一個「 η（Learning rate）」來決定，目的就是為了讓更新的幅度不要太大或太小，讓每次更新 weight, bias 尋找最小的 Loss 時，移動至下一組(weight, bias)的幅度。</p><p><img src="https://i.imgur.com/CEW4U3F.png" alt=""><br>(左圖)learning rate的變化：</p><ul><li>如果<strong>learning rate很低</strong>，那<strong>Loss value會呈現 linear</strong></li><li>如果<strong>learning rate高</strong>，則是<strong>會呈現 exponential</strong>。</li><li><strong>learning rate 過高</strong> 可能會卡在<strong>比較糟的 loss value</strong> (green line)因為優化過程中「能量」過多，參數亂跳，導致無法在優化領域(optimization landscape)找到一個好的位置。</li></ul><p>(右圖)the amount of wiggle (擺動) 與 batch size 有關：</p><ul><li>如果<strong>batch size很大</strong>，那<strong>wiggle就會很小</strong>，因為<strong>每次更新的方向都會比較準確</strong>，除非learning rate設定太高。</li><li>相反的，如果<strong>batch size很小</strong>，那<strong>wiggle就會很大</strong>。</li></ul><div class="note warning flat"><p>我可以用<strong>較大的 Batch size</strong> 搭配<strong>較大的 η</strong>，那結果可能是不用那麼多的 Epoch 就能達到我的期望。<br>相對的，如果我想用<strong>Batch size = 1</strong>的條件下去訓練，那可能就<strong>要配置較小的 η ，才不會在接近 Minima 的時候來回走動</strong>，也就不用走太多冤枉路。但也因為 η 較小，我可能就需要比較多的 Epoch 才會走到 Minima。</p></div><h2 id="Adagrad">Adagrad</h2><p><img src="https://i.imgur.com/kHY3mYz.png" alt=""></p><ul><li>現在每個 parameters 都有自己的 learning rate，把 learning rate 除以過去所有 gradient 的平方和，得到新的parameters。</li><li>如果平時 Gradient 比較陡峭，那給予小的 Learning Rate。相反的，如果平時 Gradient 比較平緩，那給予大的 Learning Rate。</li></ul><h2 id="RMSProp">RMSProp</h2><div class="note warning flat"><p>但是如果今天平時處理的問題可能比較複雜，怎麼辦？如下圖<br>你可以方向在水平直線的地方，一下 gradient 大，一下 gradient 小，所以我們<strong>要能夠更 dynamic 的調整 learning rate</strong>。因此有了 RMSProp。</p></div><p><img src="https://i.imgur.com/Nr1cIpI.png" alt=""></p><ul><li>第一個時間點：把 learning rate 除以一個值 sigma，這個 sigma 就是第一次算出來的 gradient。</li><li>第二個時間點：新的sigma就是&quot;原本sigma值平方&quot;乘上&quot;a&quot;，再加上&quot;新的gradient值平方&quot;乘上&quot;1-a&quot;，這個&quot;a&quot;可以自由去調整。這樣就可以讓 sigma 有一個平滑的效果。</li></ul><div class="note info flat"><p>與原本的 Adagrad 相比，<strong>RMSProp 因為都會把每次的 gradient 參考進去導致有一個平滑的效果</strong>，也可以隨著gradient改變的大小，動態調整 learning rate 的大小，讓 learning rate 更加的動態。</p></div><h1 id="Gradient-Descent">Gradient Descent</h1><p><img src="https://i.imgur.com/jYAlRkm.png" alt=""><br>我們先很快地複習一下一般的 Gradient Descent 是怎麼做的：</p><ul><li>選一個初始的值並計算一下它的 gradient，假設它的 gradient 是左上角紅色箭頭的方向，那我們就走 gradient 的反方向乘上一個 learning rate，再算 gradient 之後再走一個新的方向，以此類推。</li><li>直到 gradient = 0 的時候，或 gradient 趨近 0 的時候就停止。</li></ul><h2 id="momentum">momentum</h2><ul><li><a href="https://ai.ntu.edu.tw/resource/handouts/ML9-1.html">ML9-1 有提到momentum說明</a></li><li><a href="https://youtu.be/xki61j7z-30?si=8eLJMCTDEklR1PU_">影片ML9-1</a></li></ul><div class="note info flat"><p>他是一個可以幫助我們跳出local minimum的方法。參考慣性的概念，讓每次更新時多跑一點。</p></div><p><img src="https://i.imgur.com/e8GMTen.png" alt=""></p><ul><li>在進行Gradient Descent的時候，可能會<code>碰到 local minimum 的問題</code>。</li><li>但是有一個方法可以幫助我們跳出 local minimum，就是使用 momentum。<ul><li>這個概念有點像是在真實世界裡面，把一個球從上圖的左上角讓它滾下來，在球滾到 plateau 的地方時，因為有慣性，所以它不會停下來，而是會繼續往前。</li><li>就算是走到上坡的地方，假設這個坡沒有很陡，因為慣性的關係，可能還是可以翻過這個山坡，結果它就走到了比這個 local minimum 還要好的地方。</li></ul></li></ul><div class="note info flat"><p><strong>所以我們就把這個慣性的特性加到 Gradient Descent 裡面去，這就叫做 momentum，他就是上一個時間點的 movement。</strong></p></div><p><img src="https://i.imgur.com/GUNg87f.png" alt=""><br><img src="https://i.imgur.com/QqVVOQm.png" alt=""></p><ul><li>綠色線條是慣性，紅色是 gradient 的方向，把這兩個方向加起來，就是我們要走的方向。</li><li>再看Momentum in graph，你可以發現在最後一個地方（最右邊處），如果今天球的gradient &lt; momentum 時，可能可以讓球跳出 local minimum。</li></ul><p><img src="https://i.imgur.com/q0rdRfM.png" alt=""></p><ul><li>v 是之前所有 gradient 的總和，而 v 會乘上一個 momentum 的值，然後再加上現在的 gradient，這樣就可以讓我們的 gradient 有一個慣性的效果，讓它可以跳出 local minimum。</li><li>你會發現，v1 是由 v0 * lemda 所組成，如果lemda &lt; 0，則越早之前的移動影響越小。</li><li><code>每一次的移動都會參考之前的移動，但是之前的移動會越來越小</code>，這樣就可以讓我們的移動不會太大，也不會太小，而是一個適中的值。</li></ul><h2 id="Adam">Adam</h2><div class="note info flat"><p><strong>就是 RMSProp + Momentum = 動態調整 Learning Rate + 添加一點「慣性」</strong></p></div><p><img src="https://i.imgur.com/Ir1J6fR.png" alt=""></p><ul><li>m0 是前一個時間點的movement</li><li>v0 之前算出來gradient的平方和</li><li>gt 是現在的gradient</li><li>mt 根據 gt 計算出來現在要走的方向，這其中考慮了「現在要走的方向」+ 「之前的方向」</li><li>vt 準備放在分母的地方，他是過去前一個時間點的vt，加上 gradient 的平方開根號。</li><li>bias correction: 他把 mt 跟 vt 個除上一個值，1減這個值，而這個值到最後會越接近1。</li><li>最後 update 時把 momentum 「建議的方向 mt hat」 乘上 「learning rate: a」除以「RMSProp Normalze 的Learning Rate」</li></ul><h1 id="Batch-Gradient-Descent-Batch-GD">Batch Gradient Descent (Batch GD)</h1><ul><li>Ref: AI老師的投影片 2023-WS_AI_VL-01b-Recap-Neural-Networks.pdf</li></ul><p>批次梯度下降的主要特點是它將<strong>訓練數據拆分成批次，這降低了內存需求</strong>，並使算法更適合大型數據集。但它可能會導致較多的迭代次數，因為每次迭代僅考慮一個小批次的數據。</p><p>和一般的GD差異在於，<strong>梯度下降在每次迭代中使用整個訓練數據集，而批次梯度下降僅使用一個小批次的數據</strong>。</p><h2 id="Stochastic-Gradient-Descent-SGD">Stochastic Gradient Descent (SGD)</h2><p><img src="https://i.imgur.com/3eLwMwv.png" alt=""></p><ul><li>作法：每次迭代中<strong>僅使用單個訓練樣本</strong>來計算梯度，然後更新模型參數。這導致每次迭代的梯度估計都是隨機的。</li><li>優點：SGD的主要優點是對記憶體要求較低，對大型數據集適用，並且可能幫助模型逃離局部極小值。</li><li>缺點：但它可能需要更多的迭代才能收斂，且更新不太穩定。</li></ul><h2 id="Mini-batch-Gradient-Descent-Mini-batch-GD">Mini-batch Gradient Descent (Mini-batch GD)</h2><p><img src="https://i.imgur.com/0jARl1y.png" alt=""></p><ul><li>作法：小批次梯度下降通常是最常用的優化算法。它在每次迭代中<strong>使用一個小批次（batch）的訓練數據</strong>來計算梯度，然後更新模型參數。這樣既降低了內存需求，又提供了相對<strong>穩定</strong>的梯度估計。</li><li>優點：因為它兼具SGD和標準梯度下降的優勢。它可以在大型數據集上工作，提供相對穩定的梯度估計，並在收斂速度和計算效率之間取得良好的平衡</li></ul><h1 id="Back-Propagation">Back Propagation</h1><ul><li>Ref:<ul><li><a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backporpagation</a></li><li><a href="https://zhuanlan.zhihu.com/p/25110450">聊一聊深度学习的activation function</a></li><li><a href="https://youtu.be/Ilg3gGewQ5U?si=tpVt1tpMpa0mlgpk">我看過最讚的解說</a></li></ul></li></ul><p>他是一種優化神經網路的方法，名稱為Back Propagation，可以想像就是能更快的執行梯度下降 Gradient Descent，透過 forward pooling 導數的後向傳遞：先計算輸出層對應的loss，然後將<strong>loss以導數的形式不斷向上一層網路傳遞，修正對應的參數</strong>，達到降低loss的目的。</p><p>詳細可以參考 <a href="https://www.youtube.com/watch?v=ibJpTrp5mcE">ML Lecture 7: Backporpagation</a>。</p><div class="note warning flat"><p>但是，<code>Sigmoid函數在深度網路中常常會導致導數逐漸變成0，使得參數無法被更新</code>，神經網路無法被最佳化。因此，現在常用的激活函數是ReLU，它的導數在正數部分恆為1，因此不會有上述問題。</p></div><h1 id="Loss-of-classification">Loss of classification</h1><p><img src="https://i.imgur.com/ti55P7J.png" alt=""></p><ul><li>pytourch 中的 Cross Entropy 已經包含 softmax 的功能，所以不需要自己寫 softmax function。</li></ul><p><img src="https://i.imgur.com/YNVjMiA.png" alt=""></p><ul><li>Cross Entropy 比較容易透過梯度下降找到最小 loss 但是如果使用 MSE （Mean Square Error）會比較難找到最小 loss，可能會卡住。</li></ul><h1 id="Activation-Function">Activation Function</h1><ul><li>Ref:<ul><li><a href="https://youtu.be/s-V7gKrsels?si=K2y00JURot0GKOlb">Activation Functions - EXPLAINED!</a></li><li><a href="https://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">超詳細的activation function推導公式</a></li></ul></li></ul><div class="note info flat"><p>其實Activation Function就是在經歷每一層 hidden layer <strong>經過非線性的activation function，傳入到下一層神經元繼續往下傳遞</strong>，如此循環往復，直到輸出層。，讓神經網路可以抓取複雜的pattern。</p></div><h2 id="Sigmoid">Sigmoid</h2><p><img src="https://i.imgur.com/nAcok6B.png" alt=""></p><ul><li>左邊是微分前，右邊是微分後。</li><li>值域在1和0之間，最終預測時可加上閾值令大於閾值的輸出為1反之為0，因此通常使用的時機為二元分類問題的輸出層。</li><li>問題：<ul><li><code>Vanishing Gradient Problem</code>: 執行 back Propagation的時候，因為 sigmoid 微分的值都是 &lt; 1，最大值頂多 0.25，會導致<strong>在 train network 從後面的 layer 往 input 靠近的 layer，靠近 input 的 weight update 的量比較小</strong>，使得參數無法被更新，神經網路無法被最佳化，相對地靠近 output 的 weight 每次 update 比較大，學得比較快。</li><li>因此<strong>接近 input 的 weight 還是跟 random 差不多</strong>，但是後面的 weight 會差異很多。這樣會導致整個 network 的 <strong>weight update 很不平均，很難找到最佳解</strong>。</li><li>因此使用sigmoid function時反而不能有太多layer，這會導致靠近input的layer對loss的影響很小。</li></ul></li></ul><p><img src="https://i.imgur.com/P0WuoPn.png" alt=""></p><h2 id="ReLU">ReLU</h2><p><img src="https://i.imgur.com/Z5iB9iE.png" alt=""></p><ul><li>input &lt; 0 就是 0 ，input &gt; 0 就是 input</li><li>這個東西可以微分，但是 input = 0 時是不可微分的，所以在 input = 0 時，我們就隨便給一個數字，例如 0.5 。</li></ul><h3 id="Why-need-ReLU">Why need ReLU?</h3><ul><li><code>Fast to compute</code> : 計算比較快，只要check input 大於小於 0 會比 sigmoid 快很多。</li><li><code>Biological reason</code> : 人腦神經只能傳遞正值，負值會被忽略，所以 ReLU 比較符合人腦神經的運作方式。sigmoid input = 0 的地方，output = 0.5 很奇怪</li><li><code>no vanishing gradient problem</code>:<ul><li>ReLU 微分不是 0 就是 1，output 是 0 的可以想像他是不存在，當我們把output是0的neuron，剩下的又是input=ouput都是linear時，這整個就像a thinner linear network）。</li><li>這導致不會有activation function 遞減的問題。</li><li>input 就直接是 output ，因此如果調整底層 input 的變化就是 output 的變化<strong>每通過一個 layer 每個 layer 的變化量不會有縮減，每層 layer 的影響力都是一樣的，這樣就不會有 vanishing gradient problem。這樣就可以把network重疊的更深。</strong></li></ul></li></ul><h3 id="Problem-of-ReLU">Problem of ReLU?</h3><ul><li>問題：<ul><li>Q1: 變成linear，這個 network 會很弱嗎，因為不是 non-linear function？<ul><li>Ans: 如果對 input 做比較大的改變時，導致改變operational region時，他就變成non-learn。</li></ul></li><li>Q2: 可以微分嗎，因為input &lt; 0的時候，output是0導致無法updata參數？<ul><li>Ans: 可以使用 leaky ReLU。或是透過使用 softplus 解決、或使用 initialize with large bias 解決。但是基本上是 0 的機率比較小，所以問題不會太大。</li></ul></li></ul></li></ul><h2 id="Leaky-Parametric-ReLU">Leaky / Parametric ReLU</h2><p><img src="https://i.imgur.com/9QyRAZ6.png" alt=""><br><img src="https://i.imgur.com/gjxg1M2.png" alt=""></p><div class="note info flat"><p>Leaky ReLU就是在input &lt; 0的時候，output不是0，而是乘上一個很小的數字，例如0.01。</p></div><div class="note info flat"><p>為什麼input不能&lt;0呢？<br>Ans: 因為這會導致output是0，這樣就無法進行back propagation，因為這樣就無法更新gradient。</p></div><p>Leaky ReLU 跟 Parameteric ReLU 的差別在於 <strong>Parameteric ReLU 的 alpha 是可以被訓練的</strong>，而 Leaky ReLU 的 alpha 是固定的(0.01)。</p><div class="note warning flat"><p>但是你可能會想…為什麼input&lt;0時，一定要長成這樣的公式呢？<br>當然還有其他的樣子，因此有了Maxout的概念。</p></div><h2 id="Maxout">Maxout</h2><div class="note info flat"><p>讓<strong>training data決定你的network自動學習activation function</strong>，而不是人為的決定。</p></div><p><img src="https://i.imgur.com/ALMazw3.png" alt=""></p><ul><li>Step1: 他把 value group 起來，將個elements放在一個group裡面是你可以自己決定的</li><li>Step2: 在同一個group裡面，取最大的那個值當作 output。類似max pooling，在layer上做max pooling。</li><li>Step3: 再乘上一個 weight，回去做Step1。</li></ul><h3 id="Maxout-implement-ReLU">Maxout implement ReLU</h3><p><img src="https://i.imgur.com/ZQgNYlD.png" alt=""><br>Maxout 可以模仿 ReLU:</p><ul><li>ReLU<ul><li>在ReLU你可以透過乘上weight＋bias得到z通過ReLU得到a。</li><li>a 與 z 的關係是，如果 z &gt; 0，a = z，如果 z &lt; 0，a = 0。</li></ul></li><li>Maxout<ul><li>input 做兩組計算，第一組將input乘上 w 與 b 得到 z1，第二組是乘上0與0得到 z2。</li><li>然後做 maxpooling，可以從上圖看到 z1 和 z2 中選大的，就是 ReLU 。</li></ul></li></ul><h3 id="multi-activation-function">multi activation function</h3><p><img src="https://i.imgur.com/TwMbHI8.png" alt=""></p><ul><li>可以透過將 0,0 <strong>weight 調整成其他參數</strong>，產生不同的 activation function。<br><img src="https://i.imgur.com/60PVR91.png" alt=""></li><li>也可以透過將<strong>多個 elements groups 再一起</strong>產生不同的 activation function。</li></ul><h3 id="How-to-Train">How to Train</h3><p><img src="https://i.imgur.com/Txu18Kp.png" alt=""><br><img src="https://i.imgur.com/icMx1qg.png" alt=""></p><ul><li>當我們在做 maxout 也是得到一個細長的 linear network，會捨棄掉比較小的output</li></ul><div class="note warning flat"><p>但是這導致某些 neuron 沒 train 到，但是這不是一個問題…為什麼？<br>Ans: 因為當給不同 input 時會導致選擇 max 值的 neuron 不一樣。而 training 的過程中，<strong>有很多不同的 input 重複跑這些 neural network，因此每次training時input值也會不同</strong>，這將會導致每次training時選擇的 max neuron 也會不同，因此每個 neuron 都有機會被 train 到。</p></div><h1 id="Softmax">Softmax</h1><p><img src="https://i.imgur.com/sO085f5.png" alt=""><br><img src="https://i.imgur.com/Ozq0g5F.png" alt=""></p><ul><li>Softmax 是一種激活函數，通常使用在最後的output layer 主要用於多分類（classification）問題，將神經網路的輸出轉換成每一類的機率，並且機率總和為1。</li><li>類似 normalization。</li></ul><h1 id="CNN">CNN</h1><ul><li><p><a href="https://chih-sheng-huang821.medium.com/%E5%8D%B7%E7%A9%8D%E7%A5%9E%E7%B6%93%E7%B6%B2%E8%B7%AF-convolutional-neural-network-cnn-%E5%8D%B7%E7%A9%8D%E8%A8%88%E7%AE%97%E4%B8%AD%E7%9A%84%E6%AD%A5%E4%BC%90-stride-%E5%92%8C%E5%A1%AB%E5%85%85-padding-94449e638e82">卷積神經網路(Convolutional neural network, CNN):卷積計算中的步伐(stride)和填充(padding)</a></p></li><li><p>在CNN的過程中，圖會因為你的<strong>kernel map大小做完卷積後變的更小</strong>。</p></li><li><p>一般卷積網路過程中，除了Input image不稱為Feature map外，中間產生的圖我們都稱之為Feature map，，深度學習過程就是在學資料的特性，所以中間出來的結果都是特徵資料，在影像因為是2D，所以用Feature map來稱呼。</p></li><li><p>原因很簡單就是這些中間產生的圖都是為了「描繪出該任務所應該產生對應的特徵資料」，這也呼應Yann LeCun, Yoshua Bengio &amp; Geoffrey Hinton寫的Deep Learning第一句話寫的「Deep learning allows computational models that are composed of multiple processing layers to learn representations of data with multiple levels of abstraction」</p></li></ul><p>卷積計算基本上有幾個部分：</p><ol><li>輸入的圖：假設 W * W</li><li>Filter (Kernal map): ks * ks</li><li>Stride: 通常是1，表示kernal map在移動時的步伐長度。</li><li>輸出的圖片大小：new_hight * new_width</li></ol><p><img src="https://i.imgur.com/Hhn9ecA.png" alt=""><br>以上圖為例：</p><ol><li>輸入的圖: W × W =10 × 10。</li><li>Filter (kernel map): ks × ks = 3 × 3</li><li>Stride: S=1</li><li>輸出的圖大小為 new_height × new_width = 8 × 8</li></ol><h2 id="padding">padding</h2><p>是不是卷積計算後，卷積後的圖是不是就一定只能變小?<br>ANS: 用zero padding</p><p>這個手法就是看你會消失多少的大小，在輸入的圖部份就給你加上0元素進去，這個手法稱為zero padding，實際作法如下圖。<br><img src="https://i.imgur.com/sXW7Yt2.png" alt=""></p><h2 id="Feature-Normalization">Feature Normalization</h2><ul><li>Ref: <a href="https://youtu.be/BABPWOkSbLE?si=V8dv0zVW95fY56GR">【機器學習2021】類神經網路訓練不起來怎麼辦 (五)： 批次標準化 (Batch Normalization) 簡介</a></li></ul><div class="note info flat"><p>原因：兩個參數W1,W2對斜率的變化很大，固定的Learning Rate可能不會得到好的結果。<br><strong>讓不同的feature有類似接近的數值範圍有很多方法，這些方法統稱為Feature Normalization</strong>。</p></div><blockquote><p>兩個參數W1,W2對斜率的變化很大，固定的Learning Rate可能不會得到好的結果。</p></blockquote><p><img src="https://i.imgur.com/RB51XXy.png" alt=""></p><ul><li>什麼時候w1的改變會對L很小?<ul><li>有可能w1接的input很小的時候，才會有這樣的狀況產生。x2很大，導致乘上w2的時候，會變得很大。</li><li>結論：input的大小，會想想到參數進行optimization的斜率大小。因此問題是，我們如何讓不同feature的dimension都有相同的scale呢?</li></ul></li></ul><p><img src="https://i.imgur.com/8slnaKM.png" alt=""></p><blockquote><p><strong>公式</strong></p></blockquote><ol><li>把同個dimenstion的feature都拿出來，算出他們的平均值和標準差。</li><li>做 normalization，把 (x - dimenstion 平均值) / dimenstion 標準差。</li><li>之後該dimenstaion的feature平均值是0，標準差是1，所有不同的數值都是在0上下。</li><li>他可以讓你在做Gradient Descent訓練更順利，Loss收斂更快。</li></ol><div class="note info flat"><p>問題：如果經過 某一層hidden layer 的計算後 (乘上 w 之後)，會變成很大或很小的數字，這樣就會導致後面的 layer 在接收 input 的時候這些 input 已經變成不同的範圍。因此我們對於 a (經過activation function後) 跟 z (經過activation function之前)都要執行Feature Normalization。</p><p><code>但是對 a 或 z 做 normalization 不會有太大的差別。</code></p></div><p><img src="https://i.imgur.com/eqMZs7Q.png" alt=""></p><ul><li><strong>說明</strong>：<ul><li>我們如果做了feature normalization，會造成<strong>讓所有input都有關連</strong>，因為z1改變會導致平均值跟標準差都改變，使得後面的z跟a都會改變。</li><li>所以我們要<strong>把算出平均值跟標準差的過程，都當作是network的一部分</strong>，因為概念雷同，有一堆input然後計算平均值跟標準差，然後得到一堆output。</li></ul></li></ul><h3 id="Batch-Normalization">Batch Normalization</h3><div class="note info flat"><p>問題：我剛說進行feature normalization的過程就有如network一班，但是他的input很大時，我們沒辦法放這麼多計算進GPU那該怎麼辦？</p></div><p><img src="https://i.imgur.com/jtDm2sm.png" alt=""></p><ul><li><strong>作法</strong>：上述講的把feature normalization 的過程當作 network，然而<strong>一次把上百萬筆資料丟到network就太多了</strong>，才有了batch normalization的概念。</li><li><strong>舉例</strong>：假設batch設定64，所以我們可以一次使用64筆資料，計算這64筆資料的平均值跟標準差，對這64筆data做batch normalization。</li></ul><div class="note warning flat"><p>注意：但是你必須要有夠大的batch size才會有效果，如果設定1那計算出來的平均值跟標準差就是原本的值，沒有任何改變。</p></div><div class="note info flat"><p>問題：如果我不希望mean是0該怎麼做？</p></div><p><img src="https://i.imgur.com/LkDaDvI.png" alt=""><br>還會有其他的設定，乘上另一個向量gama是一個向量，加上另一個向量beta，<strong>有些時候不希望平均是0，這樣可以讓hidden layer的output平均不是0</strong>。gama是全部都是1的向量，beta是全部都是0的向量，這樣一開始訓練的時候每個dimention的分布比較平均。</p><div class="note info flat"><p>問題：Batch normalization 怎麼在 testing 的時候運作？因為testing的時候沒有batch，就沒辦法計算平均值跟標準差。</p></div><p><img src="https://i.imgur.com/iziqNgH.png" alt=""><br>因此這時候會會談到 Moving Average (移動平均)，在Trainning的時候，每次計算完一次batch的平均值跟標準差，就會更新一次 Moving Average，把現在算出來的平均值*p，加上1-p公式如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover><mo>←</mo><mi>p</mi><mover accent="true"><mi>u</mi><mo>ˉ</mo></mover><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><msup><mi>y</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">\bar{u} \gets p\bar{u}+(1-p)y^{t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5678em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5678em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0436em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></p><p>那在<strong>訓練的時候，直接拿Moving Average的平均值跟標準差來做batch normalization即可</strong>。</p><blockquote><p>結果<br><img src="https://i.imgur.com/9y9uccI.png" alt=""></p></blockquote><h1 id="Overfitting">Overfitting</h1><p><img src="https://i.imgur.com/Ck5jTMb.png" alt=""></p><ul><li>Overfitting 就是你的 model 在 training data 上表現得很好，但是在 testing data 上表現得很差。</li><li>你可以從上圖看到，vlidation accuracy在某個epoch開始下降。</li></ul><p><img src="https://i.imgur.com/0NZ1OxN.png" alt=""></p><ul><li>Validation Data Set 驗證數據：集用於內部調整和評估模型的訓練過程。驗證數據集在訓練過程中使用，通常是在每個訓練週期（epoch）結束後，用來評估模型的性能。</li><li>Test Data Set 測試數據集：用於最終評估模型的性能，以確保它對新數據的泛化能力。</li></ul><p>training 結果好但training 結果不好時該怎麼辦呢？有三個作法如下：</p><ol><li>Early Stopping</li><li>Dropout</li><li>Regularization</li></ol><h2 id="Early-Stopping">Early Stopping</h2><p><img src="https://i.imgur.com/q3PniQa.png" alt=""></p><ul><li>如果 learning rate 調整得好，Loss會變小，但是有可能導致Testing data的Loss變大，這時候就需要Early Stopping。</li><li>理想上，如果我們知道 Testing Data Loss 的變化，我們應該要想辦法<strong>找到 Testing Loss最小的時候停下來</strong>。</li><li>但是<code>實際上我們無法知道 Testing Set(有label的data set)</code><ul><li>所以我們會使用 Validation Set來進行驗證。</li><li>也就是說，我們會<strong>把 Training Set 分成 Training Set 和 Validation Set</strong>，然後在 Training Set 上訓練，並在 Validation Set 上驗證，找到 Validation Loss 最小的時候停下來。</li></ul></li></ul><h2 id="Regularization">Regularization</h2><div class="note info flat"><p>重新定義了原本的Minimized的Loss function，透過在原本的 Loss Function (e.g. Minimize square error, cross entropy)添加上「Regularization term」，來達到防止 overfitting 的效果。</p></div><p><img src="https://i.imgur.com/Bdiqb9p.png" alt=""></p><ul><li>Regularization Term<ul><li>他就是添加了 <code>||theta||</code>，這是每一個參數的平方相加(稱為L2 Regularization)，如果不平方就是L1 Regularization。</li><li>一般來說不會考慮 bias，因為加入 Regularization 的目的是為了讓function平滑，bias跟function的平滑程度沒有關係，所以不會考慮進去。</li></ul></li></ul><h3 id="How-to-do-Regularization">How to do Regularization?</h3><p><img src="https://i.imgur.com/iCrRsDt.png" alt=""></p><ul><li>新的 Loss function進行偏微分：<ul><li>update 是原本參數 - learning rate * 偏微分後的結果。</li><li>你會發現每次 update 參數的時候，會把weight減少一點，也就是 learning rate 乘上 lemda，這兩個數都 &lt; 1，因此你會發現每次 update 的時候，w 都是乘上一個小於 1 的值，使得整個 <code>(1- learning rate * lemda)*wt</code>會隨著更新的次數增加而遞減至0。這叫做 <code>weight decay</code>。</li><li>但是越靠近0會使整個w變成0？不會，因為還有後面微分的部分。</li></ul></li></ul><p><img src="https://i.imgur.com/WTd6044.png" alt=""></p><ul><li>絕對值怎麼微分？<ul><li>他是一個V型的圖像，所以微分後會有兩個值，一個是1，一個是-1，而0無法微分就無視或隨便找個數字替代即可，所以就是sgn。</li></ul></li><li>sgn 就是 w &gt; 0 就是 1，w &lt; 0 就是 -1，= 0 就是 0。</li><li>compare with L2 vs L1 ?<ul><li>L1: always delete something，減掉的值都是固定的，所以當w很大的時候，其實檢調固定的值影響不大，因此train出來的結果很多接近0的值，也有很大的值。</li><li>L2: always multiple something smaller than 1，減掉的值會隨著w大小改變（乘上&lt;1的值），train出來的結果會平均的比較小。</li></ul></li></ul><h2 id="Dropout">Dropout</h2><p><img src="https://i.imgur.com/gqNoDQW.png" alt=""></p><div class="note info flat"><p>在training更新參數之前，每個neuron有p％的幾率被丟掉。他就像是每次 train 都是新的 network，所以總共做了 2^N 種不同的 network。</p></div><p><img src="https://i.imgur.com/ArlhR3J.png" alt=""></p><ul><li>可能導致performance變差，但他的目地是為了讓testing結果變好。</li><li>training用dropout，testing 不用 dropout</li></ul><h3 id="How-to-do-dropout">How to do dropout?</h3><p><img src="https://i.imgur.com/3rOdy4W.png" alt=""><br><img src="https://i.imgur.com/2eSN0c3.png" alt=""></p><ul><li>為什麼會需要在 training 的時候反而要將所有 weight 乘上 1-p 是為了讓 testing 時所使用的 weight 接近沒有 dropout 的 training。</li><li>如果不乘上 1-p 會導致 testing 時的 weight 會比 training 時的 weight 大（如果p=0.5，就會大兩倍1/0.5），這樣會導致 testing 時的結果變差。</li></ul><h3 id="Why-dropout-solve-overfitting">Why dropout solve overfitting?</h3><p><img src="https://i.imgur.com/L0ydgyD.png" alt=""></p><ul><li>Training<ul><li>他類似一個終極 Ensemble 方法。</li><li>Ensemble 就是 <code>train 很多個 model，每個 model 平均起來當做最後的結果</code>，類似 Random forest</li><li>每一次更新參數時都會產生新的 network，就有點像是使用了各種不同的 2^n 種network，然後把他們平均起來，這樣就可以避免 overfitting。</li></ul></li></ul><h3 id="Why-not-use-dropout-in-testing">Why not use dropout in testing?</h3><p><img src="https://i.imgur.com/jf67zvl.png" alt=""></p><ul><li>Testing 為什麼不跟 training 一樣做 dropout 呢？<ul><li>因為這一把 network 太多了，沒辦法每次都 input進去再看 output 然後再平均起來，這樣會太花時間。</li><li>但是<strong>如果完整的 network 不做 dropout，但是把 weight 乘上 1-p% 的結果是相近的</strong>。（但是這僅限於Linear Network 才適用）</li><li>因此如果使用接近 Linear 的 Network 時，像是 ReLU，Performance 會比較好。</li></ul></li></ul><h1 id="Transfer-Learning">Transfer Learning</h1><ul><li>Ref: <a href="https://youtu.be/qD6iD4TFsdQ?si=F_Q8-xvBCUaFccMX">Transfer Learning in PyTorch</a></li></ul><div class="note info flat"><p>因為我們沒有大量的資料，因此我們可以透過 Transfer Learning 就是使用別人訓練好的 model，然後再依據此使用自己的 data set 近一步訓練。</p></div><p>Transfer Learning 主要可以分成四個不同的象限來討論：</p><ul><li>Target Data: 與我們的Task有直接相關（訓練目標），有可能是有Label或是沒有的。</li><li>Source Data: 與我們的Task沒有直接相關（無關的資料），有可能是有Label或是沒有的。</li></ul><h2 id="TargetData-Label-SourceData-Label">TargetData Label &amp; SourceData Label</h2><h3 id="Fine-Tuning">Fine-Tuning</h3><div class="note info flat"><p>如果你的target data很少，source data 很多，這可以說是 one-shot learning。</p></div><p><img src="https://i.imgur.com/9p8Of7L.png" alt=""></p><ul><li>Source Data: 很多，先利用source data當作初始的值。</li><li>Target Data: 很少，再利用target data來微調。</li><li>注意：但是要很小心，可能會發生overfitting。</li></ul><h4 id="Conservative-Training">Conservative Training</h4><p><img src="https://i.imgur.com/8eTjv2p.png" alt=""></p><ul><li>Source Data: 很多 speaker 的聲音。</li><li>Target Data: 特定 speaker 的聲音。</li><li>training 的時候下一些限制（Regulization） 透過 Regulization L1 或是 L2 的方式，讓新的 model 和 舊的 model 其 output 不要差異太大，防止 overfitting。</li></ul><h4 id="Layer-Transfer">Layer Transfer</h4><div class="note info flat"><p>用 source data train 好一個 model，把某幾個layer copy 到新 model 裡面，然後 source data 只去 train 沒有 copy 的 layer。</p></div><p><img src="https://i.imgur.com/cL6pvre.png" alt=""></p><ul><li>model 某幾個 layer 直接複製到新的model</li><li>接下來用 source data 只去 train 沒有 copy 的 layer。？？</li><li>如果你覺得data夠通，最後也可以fine-tune整個model</li></ul><p><strong>Ｑ：哪些Layer應該被Trasnfer？</strong></p><ul><li>影像辨識通常是 copy 前面幾層，在 Nerual Network 前面幾層用是學習到一些基本的特徵，後面幾層是學習到一些複雜的特徵。</li><li>聲音辨識通常是 copy 後面幾層，後面幾層是根聲音沒有關係，所以可以copy; 但是前面聲音訊號到發音方式每個人不一樣。</li></ul><h1 id="Object-Detection">Object Detection</h1><ul><li>ref: <a href="https://youtu.be/c1l0mHO5CBA?si=a1mzYmn-Wwbopor7">1.1基於tensorflow的faster rcnn物體鑑測概述</a></li><li>ref: <a href="https://youtu.be/4aAkJCxjzRU?si=waJ0FwOEZ-elzSsA">1.2基于faster rcnn的 深度学习经典检测方法</a></li><li>ref: <a href="https://youtu.be/YKaa1RHmff8?si=9d-tlD8O_5Oi8qIP">1.3faster rcnn概述</a></li></ul><div class="note info flat"><p>Object Detection 就是要找出圖片中的物件，並且要知道物件的位置。</p></div><p><strong>What is Sliding Window?</strong></p><ul><li>他是一個 window，這個 window 會在圖片上移動，然後在每個位置都會做一次辨識，檢查裡面有沒有物件。</li><li>但是這樣會有很多問題，因為你不知道物件的大小，也不知道物件在圖片的哪個位置，因此你會需要很多不同大小的 window，然後在圖片上移動。</li></ul><p><strong>Selective Search?</strong></p><ul><li>如果一個個Sliding Window做辨識，會花很多時間，因此有人提出了Selective Search的概念。</li><li>他會先找出圖片中的一些區域，潛在可能是物體的候選框，大概可能會產生約2k左右。</li></ul><h2 id="R-CNN">R-CNN</h2><div class="note info flat"><p>就是做 Bbox Reg 線性回歸，然後做 SVMs 分類。</p></div><p><strong>步驟</strong></p><ul><li>把候選框拿出來</li><li>作捲積</li><li>再把卷積做好的特徵放到SVMs跟Bbox reg的分類器當中</li></ul><p><strong>問題：速度太慢了</strong></p><ul><li>Q1: 每個框，都要自己構造一個網路，無法共享一個捲積，因為fully connection layer 要保持 input 大小的一致，但是候選框大小不一樣。</li><li>Q2: 使用SVMs太慢了，花了84小時</li></ul><h2 id="使用SPP-net">使用SPP-net</h2><div class="note info flat"><p>為了解決都要自己構造一個網路，<code>無法共享一個捲積的問題</code>，Spatial Pyramid Pooling Layer透過通過一個pooling layer，把<code>不同大小的特徵圖拼接再一起形成一個新的特徵</code>，這樣就可以執行fully connection layer。</p></div><p><img src="https://i.imgur.com/unumRh1.png" alt=""></p><ul><li>feature maps of conv: arbitrary size 任意大小</li><li>把任意大小的size做 SPP (pooling layer)</li><li>pooling 後的不同大小拼接再一起，形成一個新的特徵，但是大小是固定的。</li></ul><h2 id="Fast-R-CNN">Fast R-CNN</h2><div class="note info flat"><p>跟第一代算法的區別：跟R-CNN不同，R-CNN是透過候選框，一個個判斷。但是Faster R-CNN是先把整個圖片放入CNN，然後再去透過特徵找候選框。</p></div><p><img src="https://i.imgur.com/1JxmWGM.png" alt=""></p><p><strong>步驟</strong></p><ol><li>Regions of Interest (RoIs)：但是Faster R-CNN 先對整個圖片執行捲積層操作，在特徵圖上找對有興趣的對應框，以此回去看整個圖片對應到的位置。</li><li>RoI Pooling Layer: 有點像是SPP-net得到一個固定的特徵大小，以連接fully-connected layer</li><li>Linear Classifier &amp; Bounding Box Regressors: 最後辨識物體，跟框出物體的位置。</li></ol><div class="note warning flat"><p>問題：RoIs 產生一個個潛在區域還是很慢</p></div><p><strong>R-CNN vs SPP vs Fast R-CNN</strong><br><img src="https://i.imgur.com/v7drAIO.png" alt=""></p><ul><li>Including Region Proposals: 產生一個候選框所需的時間</li><li>Excluding Region Proposals: 選擇不處理候選框所需的時間</li><li><code>結果 Fast R-CNN的時間還是取決於Region Proposal的方法</code></li></ul><h2 id="Faster-R-CNN">Faster R-CNN</h2><div class="note info flat"><p>Faster R-CNN 就是把 Region Proposal Network (RPN:找出圖像中可能的邊界框) 加入 Fast R-CNN，讓他可以一起訓練。<strong>他先做二元分類、再做多元分類</strong>。</p></div><p><img src="https://i.imgur.com/2aPdqho.png" alt=""></p><ul><li>多了 Region Proposal Network (RPN) 邊迭代邊自動產生候選框，當地一個候選框產生的時候…<ul><li>先做二分類<ul><li>Classification Loss: 先做二元分類，看這個候選框是不是物體，是前景還是背景</li><li>Bounding-Box Regression Loss: 再做Bbox Reg，找出物體的位置</li></ul></li><li>再做多分類<ul><li>Classification Loss: 再來辨識該物體是什麼</li><li>Bounding-Box Regression Loss: 再來找出物體的位置</li></ul></li></ul></li></ul><p><img src="https://i.imgur.com/LsywKgU.png" alt=""></p><ul><li>這樣的結果是可以1s執行五個圖像</li></ul><h2 id="Yolo">Yolo</h2><ul><li>ref:<a href="https://youtu.be/OuutT-XrvP0?si=UhRBv9-GuXqQXBz_">Deep Learning - Yolov5 (1) 簡介及架構說明</a></li><li>ref: <a href="https://hackmd.io/@allen108108/r1-wSTAjS?utm_source=preview-mode&amp;utm_medium=rec">[論文] You Only Look Once : Unified, Real-Time Object Detection</a></li><li>ref: <a href="https://medium.com/ching-i/yolo-c49f70241aa7">YOLOv4 訓練教學 - 李謦伊 Medium</a></li></ul><div class="note info flat"><p>YOLO (You only look once) 是一個 one-stage 的 object detection 演算法，透過將整個影像輸入只需要一個 CNN 就可以一次性的預測多個目標物位置及類別。將物件偵測視為一個回歸任務，來從空間中分割出邊界框 ( Bounding Box )並且計算出類別機率。僅利用一個神經網路CNN 進行一次計算來直接「預測邊界框」及「類別機率」，也因為整個偵測過程只有使用單一個神經網路，因此可以視為是一個 End-to-End 的優化過程。</p></div><p><strong>Yolo 的版本介紹</strong></p><ul><li><code>The original Yolo</code>: 把畫bbox跟辨識物體的工作放在一起做。</li><li><code>Yolo v2</code>：基於original添加<code>BatchNorm</code>, <code>higher resoultion</code>, <code>anchor boxes</code>.</li><li><code>Yolo v3</code>：添加objectness score來評估bbox的好壞，objectness score是一個0~1的數值，越接近1表示越像物體，越接近0表示越不像物體。小的物件檢測的準確度提升。</li><li><code>Yolo v4 &amp; v5</code>（最近的版本，2020相差兩個月，v5網路比較小）<ul><li>v4 使用 Cross Stage Partial Network (CSP)來防止gradient vanishing。</li></ul></li></ul><p><img src="https://i.imgur.com/aQSMFA0.png" alt=""></p><p><strong>作法</strong><br><img src="https://i.imgur.com/5W5eWFj.png" alt=""></p><ol><li>將輸入的影像切割成 SxS 的網格 (grid)</li><li>若被偵測物體的中心落入某個網格內，這個網格就要負責去偵測該物體。</li><li>而每個網格要負責預測B個 bounding boxes (在 YOLO 的設計中，YOLOv1: B=2, YOLOv2: B=5, YOLOv3: B=3) 和屬於各別類別的機率 (假設有C個類別)，其中對每個 bbox 的預測會輸出5個預測值: x, y, w, h 以及 confidence。</li></ol><ul><li>x, y 代表該bndBox的中心座標與圖片寬高的比值，是bndBox歸一化後的中心座標</li><li>w, h代表該bndBox的寬高與輸入圖像寬高的比值，是bndBox歸一化後的寬高座標</li><li>confidence代表bndBox與Ground Truth的IOU值</li></ul><p><strong>主要架構</strong>：</p><ol><li>Backbone：不段做convolution，形成 feature map。<ul><li>通常會使用 pre-trained model，例如 CSPResNet50、CSPDarknet53、EfficientNet-B3。再由新的訓練樣本慢慢調整。</li></ul></li><li>Neck：放在backone和head之間，由一系列layer組成，將 backbone 所取得的 feature 執行 mix and combine 的動作，然後送到 prediction。</li><li>Head：獲取網路輸出內容的網路，利用之前提與的特徵，繪製 bbox 跟 class 的預測。</li></ol><p><strong>關於CSP (Cross Stage Partial Network)</strong>：</p><ul><li>目的：在Yolo v4中使用了Cross Stage Partial Network (CSP)，一個基於DenseNet的模型，可以有效的防止gradient vanishing。</li></ul><p><strong>關於FPN (Feature Pyramid Network)</strong>：</p><ul><li>目的：他是一個feature extractor，利用feature maps的概念，辨識出比較小的物件。</li><li>缺點：很耗時，對記憶體要求高。</li></ul><h1 id="Image-Segmentation">Image Segmentation</h1><ul><li>Ref: <a href="https://medium.com/ching-i/%E5%BD%B1%E5%83%8F%E5%88%86%E5%89%B2-image-segmentation-%E8%AA%9E%E7%BE%A9%E5%88%86%E5%89%B2-semantic-segmentation-1-53a1dde9ed92">影像分割 Image Segmentation — 語義分割 Semantic Segmentation(1)</a></li><li>Ref: <a href="https://kknews.cc/code/95q8rzl.html">一文看懂反卷積層</a></li></ul><p><img src="https://i.imgur.com/cVkfrIn.png" alt=""></p><ul><li><strong>Image classification</strong>: <code>判別一個圖片有哪些物體</code>，但是不知道物體的位置。</li><li><strong>Object detection</strong>: 判別一個圖片有哪些物體，並且知道物體的<code>位置會匡列</code>出來。</li><li><strong>Instance Segmentation 實例分割</strong>: 可以清楚<code>描繪出物體的輪廓</code>，並且知道物體的位置。</li><li><strong>Semantic Segmentation 語意分割</strong>: 可以清楚描繪出物體的論闊，針對圖像中所有像素點進行分類，但是<code>無法辨別同一類別不同物體</code>。</li></ul><h2 id="Semantic-Segmentation-U-Net">Semantic Segmentation: U-Net</h2><ul><li><a href="https://arxiv.org/abs/1505.04366">https://arxiv.org/abs/1505.04366</a></li></ul><p><img src="https://i.imgur.com/8laTgKf.png" alt=""><br>U-Net 基於 Encoder-Decoder 結構，主要應用於醫學影像分割。Encoder (U-Net 稱為 contracting path) 負責提取特徵、Decoder (U-Net 稱為 expansive path) 則是用於 upsampling，網路架構形似 U。此外，經過上採樣後會與 contracting path 進行 concat，不過 contracting path 特徵圖的尺寸較大需要經過 crop 裁剪。</p><h2 id="Instance-Segmentation-SegNet">Instance Segmentation: SegNet</h2><p><img src="https://i.imgur.com/s2dwXTH.png" alt=""><br>SegNet 結構與 DeconvNet 類似，不同的是去除了中間的 1x1 卷積層，為了降低記憶體使用及提升推理速度，主要應用於場景理解。由上圖可以看到 SegNet 的網路架構：</p><ul><li>Encoder 用於提取特徵</li><li>Decoder 則是將特徵圖做 upsampling</li></ul><h2 id="Evaluation-Metrics">Evaluation Metrics</h2><ul><li>以下圖片取自：<a href="https://medium.com/ching-i/fully-convolutional-networks-%E8%AB%96%E6%96%87%E9%96%B1%E8%AE%80-246aa68ce4ad">https://medium.com/ching-i/fully-convolutional-networks-論文閱讀-246aa68ce4ad</a><br>介紹 Semantic Segmentation 的評估指標，主要建立於 Confusion Matrix的基礎之上(TP, FP, FN)：<br><img src="https://i.imgur.com/tiRNvkq.png" alt=""><br><img src="https://i.imgur.com/qaIn1qP.png" alt=""><br><img src="https://i.imgur.com/VNtD1yj.png" alt=""></li></ul><h1 id="NLP">NLP</h1><ul><li><a href="https://leemeng.tw/shortest-path-to-the-nlp-world-a-gentle-guide-of-natural-language-processing-and-deep-learning-for-everyone.html">https://leemeng.tw/shortest-path-to-the-nlp-world-a-gentle-guide-of-natural-language-processing-and-deep-learning-for-everyone.html</a></li><li>實作nlp-lstm: <a href="https://peaceful0907.medium.com/%E4%BE%86%E7%8E%A9%E9%BB%9Enlp-lstm-vs-bert-on-imdb-dataset-4aa18ecd65e2">https://peaceful0907.medium.com/來玩點nlp-lstm-vs-bert-on-imdb-dataset-4aa18ecd65e2</a></li><li></li></ul><h1 id="RNN">RNN</h1><ul><li>ML Lecture 21-1: Recurrent Neural Network (Part I):<a href="https://www.youtube.com/watch?v=xCGidAeyS4M">https://www.youtube.com/watch?v=xCGidAeyS4M</a></li></ul><p><strong>為什麼會需要RNN?</strong><br>我們先來看一個例子，如果要把一個句子，放入 Neural Network 來辨識其意義：</p><ul><li>Input: “Arrive Taipei on November 2nd”</li></ul><p>我們希望他辨識出 Taipei 是一個 destination</p><ul><li>Output: <code>&#123;Taipei: destination&#125;</code></li></ul><p>那這必須解決以下問題：</p><ol><li>我們需要把 Taipei 轉換成一個 向量<ul><li>可以使用 one-hot-encoding</li><li>或是 1-of-n-encoding，n 表示為字典的大小，e.g. n=3切割 Taipei，就會看aaa, aab, tai, aip, ipe, … 轉換成 0,0,1,1,1…來構成Taipei這個單字。</li></ul></li><li>但是這出現第二個問題，<ul><li>如果改成句子例&quot;Leave Taipei on November 2nd&quot; 這時候的 Taipei 不是 destination，而是 place of departure。</li><li>我們希望模型可以學習出現過的字&quot;arrive&quot;參考上下文，來判斷出這時候的taipei已經不是destination。</li></ul></li></ol><div class="note info flat"><p>RNN 是一種有記憶的Neural Network，稱做 Recurrent Neural Network，每一層產生的output都會存到 memory，下一層的input會加上上一層的output，這樣就可以記住之前的資訊。</p></div><p><strong>RNN的運作原理</strong><br><img src="https://i.imgur.com/Wgj0fGt.png" alt=""></p><ul><li>因為是第一筆input，沒有前一筆資料，因此我們可以給初始值0</li><li>然後開始計算，得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">2=1+1+0+0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>(黃色跟藍色相加)，最後得到output <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>=</mo><mn>2</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">4=2+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>(綠色)</li><li>並且於下一步把 hidden layer 的 neuron output 值儲存，也就是將綠色的 neuron 值 2 儲存</li></ul><p><img src="https://i.imgur.com/Vv2Utec.png" alt=""></p><ul><li>然後開始計算這時考慮到之前的值2（綠色，hidden layer output），得到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>=</mo><mn>2</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">6=2+2+1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，最後得到output <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn><mo>=</mo><mn>6</mn><mo>+</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">12=6+6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">6</span></span></span></span></li><li>並且於下一步把 hidden layer 的 neuron 值儲存，也就是將綠色的 neuron 儲存</li></ul><div class="note info flat"><p>總結，你會發現 <strong>RNN 會考慮 input 的 order</strong>，如果把<code>[2,2]</code>移動到前面，很顯然的綠色的內容一定會改變(hidden layer output改變)，導致後面的output也會改變。</p></div><p><img src="https://i.imgur.com/HrZrlTT.png" alt=""><br>也因此，當我們放進去 <code>Arrive Taipei on November 2nd</code> 時，Arrive 的output會影響到 Taipei 的output，<strong>這讓 Arrive 跟 Taipei 產生關聯</strong>，因此可以判斷出 Taipei 是 destination。</p><h2 id="Elman-v-s-Jordan-Network">Elman v.s Jordan Network</h2><p><img src="https://i.imgur.com/KUQrBbv.png" alt=""></p><ul><li>Elman Network: 他的 hidden layer 的 input 是來自於<strong>上一層的 hidden layer 的 output</strong>。</li><li>Jordan Network: 他的 hidden layer 的 input 是來自於<strong>上一層的 output</strong>。（有人說此效果比較好）</li></ul><h2 id="Bidirectional-RNN">Bidirectional RNN</h2><p><img src="https://i.imgur.com/3Em8uRq.png" alt=""></p><ul><li>可以同時train正向跟逆向的RNN，把這兩個RNN的hidden layer output相加，就可以得到最後的output。</li><li>好處是，<strong>他看的範圍比較廣，他是看了整個句子，而不是只看前面的字</strong>。</li></ul><h2 id="LSTM">LSTM</h2><div class="note info flat"><p>RNN 是一個簡單版，只要有新的input進來memory的內容就會被洗掉，而LSTM則是可以記得比較長，<strong>關鍵在於gate</strong>：</p><ul><li>先通過input gate，才可以寫道memory裡面，所以有可能存在memory裡面的是很前面的字。</li><li>output 則是要通過 gate 讀控制才能取得。</li><li>forget gate 何時要把過去記得的東西忘記</li></ul><p>這個gate何時打開關閉是Neural Network自己學到決定的。</p></div><p><img src="https://i.imgur.com/CA4mkvG.png" alt=""><br>LSTM 有四個 input 和 一個 output，四個inputs分別為：</p><ol><li>input</li><li>操作input gate 的訊號</li><li>操作output gate 的訊號</li><li>操作forget gate 的訊號</li></ol><p><strong>LSTM的簡單範例</strong><br><img src="https://i.imgur.com/0YPS7Ka.png" alt=""><br><img src="https://i.imgur.com/CJOUTOP.png" alt=""></p><p><strong>運作原理Simplfy</strong><br><img src="https://i.imgur.com/fk3KLR0.png" alt=""><br><img src="https://i.imgur.com/1iVgXng.png" alt=""><br><img src="https://i.imgur.com/JVKRvR6.png" alt=""></p><ul><li>z 是的input經過transform的值，其dimension是LSTM中cell（存memory）的數目</li><li>z_i 是x乘上另一個transform，每個dimension分別操控不同的input gate。</li><li>z_f 是x乘上另一個transform，每個dimension分別操控不同的forget gate。</li><li>z_o 是x乘上另一個transform，每個dimension分別操控不同的output gate。</li><li>上述的 z 都是 vector 的形式。</li><li>執行以下步驟<ol><li>z_i 通過 activation function 與 z 相乘。</li><li>通過 activation function 的 z_f 與 memory 相乘。</li><li>step 1 + step 2 的結果。</li><li>z_o 聽過 activation function 與 step 3 的結果相乘，最後得到output y。</li></ol></li></ul><p><strong>真正的LSTM</strong><br><img src="https://i.imgur.com/nOjfdSC.png" alt=""></p><p><strong>一般NN跟LSTM的差異</strong></p><ul><li>LSTM 需要 4 個 input 才能產生 1 個 output ，參數量是一般 NN 的 4 倍。</li><li>現在基本上RNN就是LSTM。</li></ul><h1 id="Todo-Word-Embedding">Todo: Word Embedding</h1><ul><li>ML Lecture 14: Unsupervised Learning - Word Embedding: <a href="https://youtu.be/X7PH3NuYW0Q?si=VpsrrK1fMJd7PXOy">https://youtu.be/X7PH3NuYW0Q?si=VpsrrK1fMJd7PXOy</a></li><li>ELMO, BERT, GPT 前段部分有講到：<a href="https://www.youtube.com/watch?v=ugWDIIOHtPA">https://www.youtube.com/watch?v=ugWDIIOHtPA</a></li></ul><h2 id="ELMO">ELMO</h2><p>是一個RNN的Language Model，不需要標籤，只需要大量的文本資料，就可以訓練出一個模型，然後這個模型可以把每個字轉換成一個向量，這個向量可以代表這個字的意思，這個向量就是 word embedding。</p><p><img src="https://i.imgur.com/0wSfBf5.png" alt=""></p><p>每一層都會給 contextualize embedding，把這些embedding全部加起來，把第一層<em>a1，第二層</em>a2，第三層<em>a3</em>加起來，就可以得到最後的embedding。a1, a2 會根據不同的任務學出不同的weight。</p><h2 id="BERT">BERT</h2><p>他是 Transformer 的 Embedding，做的事情給他一個句子，每個句子中的詞彙，都會吐出一個embedding。這個embedding可以代表這個詞彙的意思。</p><h3 id="Masked-LM">Masked LM</h3><p>訓練Bert的方法：Masked LM 交給 Bert 的句子中，隨機有 15% 的詞彙會替換成 <code>[Mask]</code>的Token，你會蓋掉一個句子15%的詞彙。然後讓 Bert 去預測這個詞彙是什麼。</p><p>Bert 怎麼填回來的？<br><img src="https://i.imgur.com/bzB5CRW.png" alt=""></p><h1 id="Todo-Transformer">Todo: Transformer</h1><ul><li><a href="https://www.youtube.com/watch?v=ugWDIIOHtPA">https://www.youtube.com/watch?v=ugWDIIOHtPA</a></li></ul><div class="note info flat"><p>他是一個</p></div><h1 id="Todo-BERT">Todo: BERT</h1><ul><li>進擊的 BERT：NLP 界的巨人之力與遷移學習: <a href="https://leemeng.tw/attack_on_bert_transfer_learning_in_nlp.html">https://leemeng.tw/attack_on_bert_transfer_learning_in_nlp.html</a></li><li>Hung-yi-lee ELMO, BERT, GPT: <a href="https://www.youtube.com/watch?v=UYPa347-DdE">https://www.youtube.com/watch?v=UYPa347-DdE</a></li><li>Hung yi lee - Transformer: <a href="https://www.youtube.com/watch?v=ugWDIIOHtPA">https://www.youtube.com/watch?v=ugWDIIOHtPA</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Mechine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mechine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Pattern - Day1: Introd to Design Pattern</title>
      <link href="/posts/Design-Pattern-Hands-on/"/>
      <url>/posts/Design-Pattern-Hands-on/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction">Introduction</h1><p>I am going to complete something I have always want to do, which is finishing the Design Patterns book written by Eric Freeman. I have read this book for several times, but I never managed to finish it. I believe it’s time to finaly complete it. And for not forgeting the knowledge I have learned, I will write down the notes here.</p><h1 id="Agenda">Agenda</h1><p>The following are the agenda of this hands-on. I will try to base on my understanding to explain the design pattern.</p><ul><li>[ ] Day1: Introd to Design Pattern</li><li>[ ] Day2: Observer Pattern</li><li>[ ] Day3: Decorator Pattern</li><li>[ ] Day4: Factory Pattern</li><li>[ ] Day5: Singleton Patterns</li><li>[ ] Day6: Command Pattern</li><li>[ ] Day7: Adapter and Facade Pattern</li><li>[ ] Day8: Template Method Pattern</li><li>[ ] Day9: Iterator and Composite Pattern</li><li>[ ] Day10: State Pattern</li><li>[ ] Day11: Proxy Pattern</li><li>[ ] Day12: Compound Pattern</li></ul><h1 id="How-to-bend-your-brain-into-submission">How to bend your brain into submission?</h1><p>These tips are a starting point; <strong>listen to your brain and figure out what works for you and what doesn’t</strong>. Try new things.</p><ul><li>Slow down. The more you understand, the less you have to memorize.</li><li>Do the exercises. Write your own notes.</li><li>Read the “There Are No Dumb Questions”</li><li>Make this the last thing you read before bed. Or at least the last challenging thing.</li><li>Drink water. Lots of it.</li><li>Talk about it. Out loud.</li><li>Listen to your brain.</li><li>Feel something! Get involved with the stories.</li><li>Design something!</li></ul><h1 id="When-to-use-superclass-and-interface">When to use superclass and interface?</h1><p>Let’s tell a story, we are an game factory and making different species of ducks. Every duck have their own quack and fly behavior. So we can <strong>create a superclass called Duck and put the common behavior in it</strong>. However, when the boss wants to add new behavior, such as fly, if we put the fly behavior in the superclass, then all the ducks will have the fly behavior. But not all the ducks can fly, so we need to <strong>create an interface called Flyable and put the fly behavior in it</strong>. Then we can implement the interface in the duck that can fly.</p><p><img src="https://i.imgur.com/nQXkpmN.png" alt=""></p><ul><li>reduce code <code>duplication in subclasses</code>, we need to implement the fly behavior in every duck that can fly or even can’t fly.</li></ul><p><img src="https://i.imgur.com/Vs9rzAq.png" alt=""></p><ul><li>Now we take out the fly behavior from the superclass and <code>put it in the interface</code>. So we can <code>implement the interface in the subclass duck that can fly</code>. And the duck that can’t fly doesn’t need to implement the interface.</li></ul><div class="note danger flat"><p>But there is a problem. <code>If you want to override a few methods, these implemented subclass are all needed to be changed</code>, which is a lot of work.</p><blockquote><blockquote><p>Therefore, we need to use the <code>Design Pattern</code> to solve this problem.</p></blockquote></blockquote></div><h1 id="The-core-of-Design-Pattern">The core of Design Pattern</h1><div class="note warning flat"><p><strong>Take what varies and “encapsulate” it so it won’t affect the rest of your code.</strong></p><p>Design Pattern provide a way to <strong>let some part of a system vary independetly of all other parts.</strong></p></div>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code Style </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德國鐵路交通大全</title>
      <link href="/posts/transportation-germany/"/>
      <url>/posts/transportation-germany/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><div class="note warning flat"><p>主要是為了自己觀看方便，想把所有跟德國鐵路的相關資訊一併整理在這。</p></div><h1 id="德鐵種類">德鐵種類</h1><p>國鐵分為以下三種，A最快C最慢，要注意早鳥票只有A、B類火車有販售，最早可以提前半年在官網上訂購。</p><ul><li>A 長途高速列車ICE (從法蘭克福搭往Karlsruhe就是這個)</li><li>Ｂ快速城際火車IC、EC、CNL</li><li>Ｃ 區間火車IRE、RE、RB、S-Bahn、U-Bahn</li></ul><h2 id="近郊列車-區間車-S-Bahn-、地鐵-捷運-U-bahn">近郊列車/區間車(S-Bahn)、地鐵/捷運(U-bahn)</h2><p><img src="https://i.imgur.com/NYUP2vB.png" alt=""></p><ul><li>在德國市區，S-Bahn跟U-Bahn常常都是會一起出現的，會有<code>綠色S</code>跟<code>藍色U</code>作為標示（如上圖）：<ul><li>S-Bahn就像我們台鐵的區間車，S代表的是Suburban也就是郊區；</li><li>U-Bahn像我們的捷運，U代表地下Underground。</li></ul></li></ul><p><strong>#購票方式</strong>：地鐵站內的自動售票機<br><strong>#注意事項</strong>：</p><ul><li><code>搭車的時候，上下車要自己按鈕開門</code>(超重要！！很多人忘記！！)</li><li>一天去<code>超過3個景點</code>就建議<code>購買一日卷</code></li><li>記得準備<code>小鈔</code>或<code>Visa信用卡</code>，<strong>機器只接受5歐以下的現金</strong></li><li>記得檢查<code>票卷上是否有日期</code>，沒有日期被查票也視同逃票！</li><li>月台沒有閘門及驗票口，可自由通行</li></ul><h2 id="電車-Tram">電車(Tram)</h2><p><img src="https://i.imgur.com/TuWbg5F.png" alt=""></p><p>相對於地鐵，較少使用到，在<code>慕尼黑跟紐倫堡才比較有機會</code>搭乘～。慕尼黑是德國很有歷史的一座城市，電車也早在1876年就開始發展了，如果是電車迷的話，來慕尼黑一定要來搭搭看，目前1960年產的電車也還在服役中哦！坐在有點年代感的電車配上慕尼黑古色古香的風景，讓人彷彿瞬間回到20世紀。</p><p><strong>#購票方式</strong>：可以上車購買，但較複雜，建議可以在地鐵站內購買。</p><h2 id="巴士（公車）Bus">巴士（公車）Bus</h2><p>其實在德國的大城市中，地鐵就相當方便，搭乘的機會比較不多，不過到一些大城市，像是慕尼黑跟柏林，就可以搭觀光路線的巴士，讓你一覽德國市內風光～<br><strong>＃觀光巴士路線推薦</strong><br>・慕尼黑：100號<br>・柏林：100號、200號</p><p><strong>＃購票方式</strong>：可以上車向司機購買車票，或使用車上的機器。</p><p><strong>＃注意事項</strong>：<br>・要按Stop才會停車<br>・在公車站牌前等候就可，不必揮手示意</p><h1 id="德鐵搭乘須知：誤點-換月台-搭錯終點">德鐵搭乘須知：誤點 換月台 搭錯終點</h1><p>德鐵最有名的就是無限誤點、改站台等等，建議看這個<a href="https://youtu.be/SkaQqGffgxM?si=j2SFaz3qSkqyMrhm%25">影片</a>！<br>總結：</p><ul><li>下載DB Navigator App</li><li>選單裡面有 Trip Planner，進行搜尋會出現幾個不同的交通選擇<ul><li><img src="https://i.imgur.com/JbuMlFc.png" alt=""></li></ul></li><li>找到想要搭乘的車次後，可以添加到Favorite<ul><li><img src="https://i.imgur.com/IdK6yNJ.png" alt=""></li></ul></li><li>之後搭乘前，就可以在Favorite的頁面看到最新資訊<ul><li><img src="https://i.imgur.com/BidGI49.png" alt=""></li></ul></li></ul><p>可能出現的列車變更：<br><img src="https://i.imgur.com/JPwNg8u.png" alt=""></p><h2 id="月台更換">月台更換</h2><p>換月台的前兆：</p><ul><li>誤點超過30分鐘以上</li><li>車班資訊突然消失（大概會需要等3-4分鐘更新資訊）</li><li>站牌顯示 Gleis (站台)，表示新站台要更換</li><li>隨時觀察周遭的人動作</li></ul><h2 id="車廂等級與終點">車廂等級與終點</h2><p>要注意，德國的車廂外面會寫「車廂等級」（主要分）class 1, class 2），還有「終點」。<br>更奇特的是，你要注意的是「終點」，因為<strong>德國的火車會有分段</strong>，例如從法蘭克福到Karlsruhe，會有一段是法蘭克福到Mannheim，然後Mannheim到Karlsruhe，所以你要注意的是「終點」，如果寫Mnniheim，是否跟你的車票一樣，如果寫Karlsruhe，那就是你要搭的車廂對不對。因為<strong>他們有可能中途分裂開來…就開到別的國家或市區去了</strong>。</p><h2 id="上車查票">上車查票</h2><p>德國都不需要再上車前先過票閘或檢票，大多是在車上進行查票。車長會不定IC EC IC基本上一定會查票，甚至會要求身份檢查（passport）。</p><h2 id="可以坐的位置">可以坐的位置</h2><ul><li>一般來說<strong>德國「座位」跟「票」是分開買的</strong>，座位大概4.5歐元。如果是長途的話還是建議買票比較保險。</li><li>要特別注意座位上面的資訊燈會顯示有被劃位的區段。<ul><li>如果沒有被劃位，就不會顯示任何東西。</li><li>劃位會顯示區段</li><li><code>GGF. RESERVIERT</code> 表示可能被劃位了，系統更新不全問題所導致。</li></ul></li></ul><p><img src="https://i.imgur.com/MnVYLqU.png" alt=""><br><img src="https://i.imgur.com/dIOBe0Q.png" alt=""><br><img src="https://i.imgur.com/0GFul53.png" alt=""></p><h2 id="車班大亂">車班大亂</h2><ul><li>app 會顯示綠色字<code>Current alternative</code>系統幫你計算可以接上去的時間，不用退票或重新買票。</li><li>如果車長問題，就截圖說明即可。<br><img src="https://i.imgur.com/HaVPoJL.png" alt=""></li></ul><h1 id="德鐵劃位規則">德鐵劃位規則</h1><ul><li>參考這個寫得很詳細：<a href="https://www.euphotravel.com/2021/07/DB-Seat-reservation.html">https://www.euphotravel.com/2021/07/DB-Seat-reservation.html</a></li></ul><p><strong>德鐵車票有包括座位嗎?</strong><br>除了一等艙有整合劃位，票價包含座位。德鐵快車(ICE,IC,EC)的二等艙不論是超級特價票、特價票跟原價票<code>都要另外劃位</code>。如果你在查詢的時候覺得人沒很多，那可以不用。。請特別注意劃位要綁定德鐵快車的搭乘日期跟車次，劃位錯誤是無法更換到車班(2021年已取消)甚至退款。</p><h2 id="劃位費">劃位費</h2><ul><li>Einzelreservierung (Single Reservation 單字劃位)<ul><li><ol start="2"><li>Klasse (二等艙)</li></ol><ul><li>購票時訂位: 4 €/整段單程路線的快車座位</li><li>單獨訂位: 4 €/整段單程路線的快車座位</li></ul></li><li><ol><li>Flasses (一等艙)</li></ol><ul><li>購票時已整合訂位</li><li>單獨訂位: 5.3 €/整段單程路線的快車座位</li></ul></li></ul></li><li>Familienreservierung (Family reservation，家庭訂位)<ul><li><ol start="2"><li>Klasse (二等艙):</li></ol><ul><li>購票時訂位: 8 €/整段單程路線</li><li>單獨訂位: 8 €/整段單程路線</li></ul></li><li><ol><li>Klasse (一等艙)</li></ol><ul><li>購票時已整合訂位</li><li>單獨訂位: 10.6 €/整段單程路線</li></ul></li></ul></li><li>Gruppenreservierung(Group reservation，團體票訂位)<ul><li><ol start="2"><li>Klasse (二等艙)</li></ol><ul><li>購票時已包含座位</li></ul></li><li><ol><li>Klasse (一等艙)</li></ol><ul><li>購票時已包含座位</li></ul></li></ul></li><li>Dauerreservierung (Duration reservation，定期票訂位)<ul><li><ol start="2"><li>Klasse (二等艙):41.4 €/月</li></ol></li><li><ol><li>Klasse (一等艙):41.4 €/月</li></ol></li></ul></li></ul><h2 id="車廂類型">車廂類型</h2><p><img src="https://i.imgur.com/hriYFHv.png" alt=""></p><ul><li>選項一 any (德文:beliebig,中文:任意) :  交由德鐵系統安排</li><li>選項二 Open saloon (德文: Großraum, 中文: 開放車廂): 二等艙是中央走道兩邊各兩排相鄰座位，一等艙是中央走道兩邊，一邊是一排座位，另一邊兩排相鄰座位。</li><li>選項三 Open saloon with table (德文: Großraum mit Tisch, 中文: 開放車廂座位附桌子)  通常兩人一桌或四人一桌，兩兩面對面。家庭出遊可以考慮訂這個座位，讓好動的小朋友有桌子可以玩玩具、吃東西跟看書。</li><li>選項四 Compartment (德文: Abteil, 中文: 包廂):  大多是6張座位一間，一邊各三張座位面對面坐。部分ICE一等艙也有4張座位一間，一邊各兩張座位面對面坐。有冷暖空調跟玻璃門，可用拉簾遮住整面玻璃門，保持隱私。</li></ul><h2 id="座位位置">座位位置</h2><p><img src="https://i.imgur.com/HcfYLpU.png" alt=""></p><p>單人訂位時<br>選項一: any (德文:beliebig, 中文:任意): 由德鐵系統安排<br>選項二:Window (德文:Fenster , 中文:窗戶): 靠窗邊<br>選項三:Aisle ( 德文:Gang, 中文:走道) : 靠走道</p><p>兩人訂位時: <code>很多時候，因為車廂內的配置，德鐵系統只能盡力配合，但不能盡如人意!!</code><br>選項一: any (德文:beliebig, 中文: 任意): 由德鐵系統安排。<br>選項二: Window across from each other (德文: Fenster gegenüber , 中文: 彼此相對靠窗坐著)。<br>選項三:across from each other (德文:Gang gegenüber, 中文:彼此相對靠走道坐著)</p><h2 id="車廂區域">車廂區域</h2><p><img src="https://i.imgur.com/FHFk98B.png" alt=""><br>選項一 any (德文:beliebig, 中文:任意): 由德鐵系統安排<br>選項二 Phone zone (德文:Handybereich,中文:手機區): 車上有手機訊號放大設備，在高速行進時還可以接聽手機。<br>選項三 Quiet zone (德文:Ruhebereich, 中文:靜音區): 禁止講手機跟大聲喧嘩。只有 ICE Sprinter 及 ICE 車班能選擇靜音區。</p><p>如果如願選到你想要的位置，都會是<code>綠色勾勾</code>，否則會出現<code>紅色驚嘆號</code>表示系統幫你修改某個選項來安排座位。</p><h2 id="圖示說明">圖示說明</h2><p><img src="https://i.imgur.com/9NyNd3s.png" alt=""></p><p><img src="https://i.imgur.com/v5pkm5H.png" alt=""><br><img src="http://i.imgur.com/uploading.png" alt=""></p><h1 id="德鐵搭乘方向">德鐵搭乘方向</h1><p>我蠻多朋友不太擅長搭在對的方向德鐵，所以我整理一下我自己搭乘的注意要點：</p><ul><li>有些鐵路在路面上，有些在地下，所以要注意看一下站牌上有沒有你要搭的號碼，如果沒有可能就在地下（S1跟1是完全不一樣的！）</li><li>德國是靠右走，所以你要搭車的方向應該是在你要前往方向的右手邊</li><li>HBF是中央火車站的意思，火車、地鐵、區間車，三者皆有</li></ul><h1 id="專有名詞">專有名詞</h1><ul><li>大城市火車站大多會有地名+「<strong>HBF</strong>」的字樣 (ex. <code>Karlsruhe HBF</code>)，這個是<strong>中央火車站的意思，火車、地鐵、區間車，三者皆有</strong>！</li></ul><h1 id="參考連結">參考連結</h1><ul><li><a href="https://www.tripresso.com/blog/2019/02/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E9%80%9A-%E6%94%BB%E7%95%A5/">【德國交通】第一次德國自由行就上手！ 德國交通工具、APP攻略總整理</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 交通旅遊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 德國 </tag>
            
            <tag> 交通鐵路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德國交換留學準備攻略（入籍|第三方責任險|延簽+居留證|sim|提領帳戶|Revolut）</title>
      <link href="/posts/prepare-germnay/"/>
      <url>/posts/prepare-germnay/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>準備9/3飛往德國，在抵達德國前總要知道抵達後應該做的事情，因此整理出這篇文章條列說明，需要做的事情，包含入籍、延簽、居留證、開戶、申請電話卡等。全部一併在這裡準備，我不喜歡分太多文章，如果你想<strong>快速知道去德國到底具體要做哪些事情，可以直接參考我這篇～</strong>。畢竟網戶很多文章都是單獨分開的，有的入籍，但你不會知道要辦理延簽，有的想要提領帳戶但是不知道要怎麼開戶，還有一堆小事情要處理分散在網路各個不同的地方。</p><p>所以我這篇主要目的就是<strong>希望提供大家一個快速可以知道自己到底去德國要做什麼事情的整理，和我的心得</strong>。但是如果想要知道更詳細的操作畫面，建議還是參考別的網站，但是我主要是希望你可以知道自己具體要準備什麼。</p><h1 id="保險-提領帳戶：Expatrio">保險+提領帳戶：Expatrio</h1><p>保險和提領帳戶我是透過 <a href="https://www.expatrio.com/">Expatrio</a> 申請，因為他們有提供一個套餐，包含了保險和提領帳戶，而且申請起來也很方便，只需要填寫一些基本資料，就可以申請成功，而且他們的保險也是德國政府認可公保 TK 的，所以我就直接申請了。</p><p>選擇Expatrio好處：</p><ul><li>速度快（提領帳戶匯錢後當天就更新通知了）</li><li>繳交文件方便</li><li>公保是TK，如果想打子宮頸疫苗可以免費打</li></ul><p>幸好當時的匯率不貴，大概是33塊台幣換算一歐元，而德國政府規定每個月應該要有935歐元的生活費，而我是去一年，因此大概換算台幣約39萬左右。<br>至於怎麼填寫裡面的內容，我建議上網找有很多教學。至於<strong>匯款至提領帳戶的部分，絕對不要使用郵局喔，因為郵局不保證全額到帳</strong>！除非你自己先算把中間可能會付的手續費都算好，一次轉你要匯入的金額＋你算的手續費，不然還是建議使用銀行匯款，銀行才能確保全額到帳。</p><h2 id="Q1-公保-vs-私保？">Q1: 公保 vs 私保？</h2><ul><li>詳細可參考：<a href="https://www.german-preture.com/%E5%BE%B7%E4%BA%A4%E6%8F%9B%E7%95%99%E5%AD%B8%E5%BF%85%E7%9C%8B%E4%BF%9D%E9%9A%AA%E6%94%BB%E7%95%A5%EF%BD%9C%E5%85%AC%E4%BF%9D%E7%A7%81%E4%BF%9D%E5%93%AA%E4%B8%80%E5%80%8B%E5%A5%BD%EF%BC%9F/">德交換留學必看保險攻略｜公保私保哪一個好？</a></li></ul><p><img src="https://i.imgur.com/8TCaDx1.png" alt=""></p><h2 id="Q2-簽證需要保險的什麼文件？">Q2: 簽證需要保險的什麼文件？</h2><ul><li>如果你是 Expatrio 去下載 Incoming Insurance Certificate incl. dates.pdf<br><img src="https://i.imgur.com/N6J6lFa.png" alt=""></li></ul><h1 id="第三方責任險：AXA">第三方責任險：AXA</h1><ul><li>參考來源：<a href="https://www.german-preture.com/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E6%8F%9B%E3%80%81%E7%95%99%E5%AD%B8%E5%BF%85%E5%82%99%E4%BF%9D%E9%9A%AA%EF%BD%9C%E7%AC%AC%E4%B8%89%E8%B2%AC%E4%BB%BB%E9%9A%AA-haftpflichtversicherung/">德國交換、留學必備保險｜第三責任險-haftpflichtversicherung</a></li></ul><p>如果<strong>在德國弄壞別人的東西，或是遺失鑰匙，可能會付出慘痛的代價</strong>。&quot;Haftpflichtversicherung&quot;第三方責任險又名責任保險 (英文是：Liability Insurance），這是一種在德國普及率很高的保險，根據德國法律，每個人對別人造成的傷害都必須負責，因此85%-90%德國人都有基本上人人都有。第三方責任險價錢大慨每月€5－10（我自己使用AXA年費是33.99歐元，這樣算換下來更加划算），第三方責任險並不像醫療保險是強制的，但是我覺得第三方責任險是非常有用。</p><h2 id="包含哪些範圍？">包含哪些範圍？</h2><p>受保人的行為對第三方造成了損害時要賠償給對方，大致上分為3類：</p><ol><li>他人物品損壞</li><li>人身傷害</li><li>金錢損失</li></ol><p>第三方責任險特別適合租房的人，有些<strong>屋主會要求租客有第三方責任險</strong>，以免發生需要賠償時無法負擔令雙方更有保障。有第三方責任險找房時也會加大自己租到房子的籌碼呢！我們的房東雖然沒有要求第三方責任險也告訴我們非常建議要有。租房較常見的意外例如：</p><ul><li>租屋裡的水龍頭因忘記關掉而水浸導致地板受損波及下層鄰居的天花板滲水</li><li>屋主的傢具受損/出租屋遺失鑰匙等等</li></ul><p>遺失鑰匙是最常發生需要索償理賠的，只是不見自己家的鑰匙費用還不很糟（找維修工換鎖100歐起跳啊！），<strong>遺失了宿舍大門的鑰匙而且房間門鑰匙都一樣的話，所有人的鑰匙就得換新的，這種情況費用就付出非常昂貴的代價</strong>。</p><p>日常生活中不小心損壞他人的物品這些事常常發生，誰也不知道哪一天因不小心的錯失而需要賠償小則幾百歐大則幾萬歐金額給對方。一般都會在保障範圍內可以申請理賠，保障我們不用高額賠償給對方，有第三方責任險給自己增添保障。</p><h2 id="申辦方法？">申辦方法？</h2><p>我問德國的同學是參考間保險公司，大多聽到是購買AXA的家庭方案，他們說家人從小就會幫他們保（不能小看小孩破壞力呀！）。本來有在網路上看到有<a href="https://www.german-preture.com/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E6%8F%9B%E3%80%81%E7%95%99%E5%AD%B8%E5%BF%85%E5%82%99%E4%BF%9D%E9%9A%AA%EF%BD%9C%E7%AC%AC%E4%B8%89%E8%B2%AC%E4%BB%BB%E9%9A%AA-haftpflichtversicherung/">台灣人買COYA</a>，後來改名叫Luko，使用他們網站後頻繁出現錯誤，就放棄了。改用AXA，我大概做了以下事情：</p><ol><li>前往官網的<a href="https://www.axa.de/pk/haftpflicht/p/private-haftpflichtversicherung">Private Liability Insurance</a>，大概看了一下他們的合約。</li><li>因為我希望鑰匙不見得部分都包含在內，因此選擇了 “M” 方案。<ul><li><img src="https://i.imgur.com/NzwFWJ4.png" alt=""></li></ul></li><li>填寫完資訊後，他會跳出以下畫面，要你聯絡他們。(好麻煩呀！還是要聯絡真人幹嘛填表單)<ul><li><img src="https://i.imgur.com/xE66Wj4.png" alt=""></li></ul></li><li>我是想採用email，點擊進去<a href="https://www.axa-betreuer.de/">Start your consultant search</a> 然後我輸入Karlsruhe 他會show給你該地區的保險業務人。<ul><li><img src="https://i.imgur.com/P3JQoLa.png" alt=""></li></ul></li><li>點擊進去保險人的資訊（ex. 例如我選<a href="https://www.axa-betreuer.de/eric_lagasse">Eric Lagasse</a>可以點擊進去，Make an appointment<ul><li><img src="https://i.imgur.com/omsl4Bk.png" alt=""></li></ul></li><li>大概是跟他說你的需求（身份,要購買的產品)，就差不多惹@…@，寫完內容他會問你要phone call還是email選email即可。</li></ol><h1 id="台灣信用卡-雙幣帳戶">台灣信用卡+雙幣帳戶</h1><p>如果要去德國留學一年，包含提領帳戶至少要準備40萬比較好，因為到德國後還無法立刻取得提領帳戶的錢。<br>最好<strong>帶一個月的生活費</strong>，並且在<strong>台灣先開好雙幣帳戶</strong>（比較多人推薦：大戶卡雙幣卡）。我是使用媽媽的副卡辦理玉山銀行的雙幣信用卡，當時一年內刷卡免手續費，一年到期後就要繳會費了（反正只留學一年 XD），這樣刷卡額度高，也不是直接從帳戶扣款。玉山銀行的雙幣信用卡好處是：</p><ol><li>你可以直接把台幣轉換成歐元存在另一個帳戶。</li><li>如果每個月結帳的時候，他會直接從歐元帳戶扣款。</li><li>手續費免。</li></ol><p>我也有辦理大戶卡，只是那就是Debit Card，不是信用卡。到時候要辦理刷退會比較沒效率…（畢竟是扣自己的錢，如果使用信用卡就是扣銀行的）。</p><h1 id="入籍：karlsruhe">入籍：karlsruhe</h1><p>我是在Karlsruhe留學，所以跟一般大都市流程可能會有所差異，但是都不會差太遠。基本上要準備以下事情，和相關文件：</p><ul><li>預約登記網址進行預約，並把預約資訊列印出來：<a href="https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe/extern/calendar/?uid=f91279e2-e275-4165-a3af-515a7d4e0990">https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe/extern/calendar/?uid=f91279e2-e275-4165-a3af-515a7d4e0990</a> (refresh th epage; choose “Zuzug nach Karlsruhe” (Residence - Moving to Karlsruhe (students)).</li><li>準備的相關文件：<ul><li>要給房東填寫的表單: <a href="https://web1.karlsruhe.de/service/Formulare/ordnungsamt/OA2_Wohnungsgeberbescheinigung.pdf">Wohnungsgeberbescheinigung (Papierformular) / Landlord certificate</a></li><li>列印好你跟房東簽約的合約紙本（對方會需要看）。</li><li>攜帶好你的VISA跟護照。</li></ul></li></ul><p>基本上當天準備好的時候，就是希望上述這些東西過去。辦入籍大概等約一兩週，他們就會寄入籍資料（包含稅號）給你，有了稅號到時候如果要實習，或是工作都比較方便。</p><h1 id="德國開戶：N26-vs-Revolut">德國開戶：N26 vs Revolut</h1><p>本來是想使用 N26，但是近期好像因為疫情關係，他們不再接受台灣的Passport跟德國簽證，<strong>N26視訊時要看的是居留證，不接受護照或簽證</strong>！！！你想想我們這種菜雞還沒過去德國，哪來的居留證…。所以如果你想在台灣就先開好，建議Revolut，基本上只要上傳Passport，並且有德國的地址就可以開戶了。方便多了。</p><p>我所申辦的方案是 Standard (不用錢的那個)，然後有辦理實體卡用來提款用。到時候提領帳戶就可以直接綁在Revolut。</p><h1 id="SIM-卡：Fraenk">SIM 卡：Fraenk</h1><p>這邊SIM最常聽到的就是 Telekon, O2, Vodafone，但是我問一些過來台灣留學的德國人他們反而推薦 Fraenk。後來去看看真的不錯，畢竟歐洲不像台灣是網路吃到飽，（難怪他們在通勤的時候會看書XD），<strong>O2先不考慮災情太多，Telekon則是費用很貴</strong>。我反而是Vodafone跟Fraenk在選。<strong>最後打算選擇Fraenk</strong>，是因為他邀請朋友可以再+1G，直到上限滿了(15個朋友)。<strong>他一個月費用10歐元7Ｇ（+ xG 朋友邀請加量），相比Vodafone是9.99歐元4Ｇ而已</strong>，不僅如此，Fraenk除了跟Vodafone一樣可以在歐盟區使用免費漫遊，他還包含了被排除在外的瑞士！！</p><ul><li>Fraenk 預付卡官網：<a href="https://fraenk.de/prepaid-alternative/">https://fraenk.de/prepaid-alternative/</a></li><li>Vodafone 預付卡種類：<a href="https://www.vodafone.de/prepaid/">https://www.vodafone.de/prepaid/</a></li></ul><div class="note warning flat"><p>其實預付卡可以上網買，只是<strong>德國政府規定現在買預付卡也要身分證明</strong>，所以記得帶護照，驗證後他可以線上認證後送你家。但應該還是去實體比較快，只是擔心實體沒有預付卡的庫存（我爬文看到德國有些時候門市都買不到，因為他們希望你簽合約…）</p></div><h2 id="辦理過程？">辦理過程？</h2><p>可能因為我是外國人，所以透過app申請的時候，被通知申請失敗，需要在他們官網透過 <a href="https://www.fraenk.de/chat">service chat</a>的方式近一步確認身份！</p><ol><li>下載app</li><li>透過邀請碼進行註冊（到時候合約成功雙方可獲得1G)<ul><li>可以使用邀請碼：<a href="https://fraenk.page.link/?link=https%3A%2F%2Ffraenk.de%2Fdeeplink%2Fmgm%3FfriendCode%3DYIHH1&amp;apn=de.congstar.fraenk&amp;amv=1040000&amp;imv=1.4&amp;isi=1493980266&amp;ibi=de.congstar.fraenk&amp;ius=fraenk&amp;ofl=https%3A%2F%2Ffraenk.de">YIHH1</a></li></ul></li><li>註冊完後，他會發信給你說資料不夠請在7天內聯絡Service Chat</li><li>你就根據app提供的訂單number給service chat</li><li>對方會要求你傳&quot;visa+passport&quot;, &quot;入籍&quot;的紙上傳即可。</li><li>通過後等待你的SIM卡(我大概等了3-4天)</li></ol><h1 id="居留證和延簽：Karlsruhe">居留證和延簽：Karlsruhe</h1><p>所有非歐盟交換生都需要持有涵蓋整個交換期的簽證或有效的學習居留許可。為什麼需要延簽？如果您的簽證在交換停留結束之前到期，您將需要在簽證到期之前申請學習居留許可。所以我們會需要在簽證過期前趕緊拿到居留證！但是他可不像入籍一樣好處理，通常要等2-3個月！所以最好到德國的時候就開始準備申請居留證拉！這邊提供的是Karlsruhe的延簽申請準備流程。</p><p>如需向外國人部門 (Ausländerbehörde) 登記，請準備以下文件（副本）：</p><ol><li>填寫居留許可申請表（點擊<a href="https://web1.karlsruhe.de/service/Buergerdienste/organisation.php?id=6028411">此處</a>並選擇“Formulare”下的“Antrag auf Erteilung einer Aufenthaltserlaubnis”），基本上就是填寫<img src="https://i.imgur.com/6mVctAi.png" alt=""></li><li>biometric picture （大頭照）</li><li>護照+Visa影本</li><li>入籍後的相關文件 confirmation of your registration as a resident of the city of Karlsruhe</li><li>租賃合同副本</li><li>提領帳戶證明：足夠的資金證明足以支付您在德國逗留期間的所有費用（每月至少 934 歐元，例如凍結的銀行賬戶或獎學金的官方聲明）</li><li>《錄取通知書》和《在學證明》</li><li>健康保險證明</li></ol><p>準備好上述文件之後，執行以下步驟：</p><ol><li>您需要在簽證到期之前<strong>及時將填妥並簽名的申請表</strong>和<strong>所需文件</strong>以 <strong>PDF 文件形式通過電子郵件發送至 <code>abh@oa.karlsruhe.de</code></strong></li><li>確保您的申請完整併保存自動發送的收據確認信息。(目前，<code>申請的處理時間約為 10 週，因此儘早提交申請非常重要</code>。)</li><li>您將通過電子郵件或郵寄收到他們的決定結果。</li><li>他們會回應你通不通過，收到結果後您可以在<a href="https://stadt-karlsruhe.saas.smartcjm.com/m/stadt-karlsruhe-abh/extern/calendar/?uid=8311b67c-7f17-41d3-801d-ae23fb82fd51&amp;wsid=45b88bcd-75e1-44cd-8605-2a741189bbc6&amp;lang=de">這裡預約</a>提交生物識別數據（指紋和照片 - 選擇“Abgabe biometrischer Daten”）。在這次預約的同時時，他們將為您訂購新的電子居留許可證。</li></ol><blockquote><p>寄信的範本：</p></blockquote><p><img src="https://i.imgur.com/1x2CJrw.png" alt=""></p><div class="note danger flat"><p><strong>目前收取的費用是: EUR 100,00 （只能付現）</strong></p><p>根據官方說明 <a href="https://web1.karlsruhe.de/service/Buergerdienste/leistung.php?id=6004449">Kosten</a><br>居留許可或ICT卡的發放：EUR 100,00<br>居留許可或ICT卡的延期長度最多三個月：EUR 96,00<br>居留許可或ICT卡的延期超過三個月：EUR 93,00<br>永久居留許可：EUR 113,00<br>歐盟長期居留許可：EUR 109,00<br>高技能移民的永久居留許可：EUR 147,00<br>自主工作居留許可：EUR 124,00<br>移動ICT卡的發放：EUR 80,00<br>移動ICT卡的延期：EUR 70,00</p></div><h2 id="時程">時程</h2><ul><li>2023/09/06 寄信給 <code>abh@oa.karlsruhe.de</code></li><li>2023/11/01 收到實體信件說明要預約提供生物識別數據（指紋和照片）</li><li>2023/11/16 到場提供指紋和照片</li><li>to be continued…（大約四週後可領）</li></ul><h2 id="流程">流程</h2><div class="note info flat"><p>前提：如果是要提供生物識別資料，攜帶以下即可：</p><ul><li>[x] 有效護照</li><li>[x] 目前的生物辨識護照照片（照片不得超過 6 個月；每個新申請都需要一張新的生物辨識照片！）</li><li>[x] 現金/EC卡支付費用</li><li>[ ] 居留許可申請表 （可帶可不帶，可以加快處理速度）</li></ul></div><ol><li>收到信請你預約繳交指紋跟照片的時段後，當天就前往事務處 <a href="https://maps.app.goo.gl/k2BBHuNLWADuhuxZA">Ausländerbehörde Kaiserallee 8, 76133 Karlsruhe</a>。</li><li>進去後，<strong>一樓左轉，前往 Zimmer 16</strong>。</li><li>裡面有一台機器，<strong>輸入你 Email 收到的預約號碼</strong>：e.g. 8046</li><li>然後房間會有一台電視，當你的<strong>號碼出現在電視上</strong>的時候，前往該房間，以圖中為例就是 Zimmer 02。<br><img src="https://i.imgur.com/x8cwcKA.png" alt=""></li><li>前往 Zimmer 02，是一個小房間，裡面有兩個人而已，你就<strong>直接把照片跟護照給他即可</strong>。<br><img src="https://i.imgur.com/xOjUGRW.png" alt=""></li><li>過程中他會請你<strong>簽名,提交左右手食指的指紋</strong>。</li><li>他還會問你身高、髮色（這當初表單都有填寫，你也<strong>可以攜帶表單給他看</strong>）。</li><li>完成後他會給你一張紙（說明書）處理卡片大概會<strong>需要4個週期的工作天</strong>，到時候會寄信給你，內含有PIN碼。屆時根據紙上的預約網址<strong>輸入PIN碼預約領取時間即可</strong>。</li><li>最後，你會到付款環節，他會給你一個<strong>繳款卡片</strong>。<br><img src="https://i.imgur.com/FxPwqHQ.png" alt=""></li><li>卡片要去一樓，進門後的<strong>正門口左邊有一台機器</strong>。繳費後，他就會給你收據（注意不支援信用卡付款，建議攜帶足夠的現金，不收200或500）<br><img src="https://i.imgur.com/8wVDOL4.png" alt=""><br><img src="https://i.imgur.com/gb0AXt6.png" alt=""></li></ol><h1 id="參考資料">參考資料</h1><ul><li><a href="https://annie89339.pixnet.net/blog/post/403314302-%E5%88%B0%E9%81%94%E5%BE%B7%E5%9C%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%B6%E4%BA%8B%EF%BC%9A%E5%9F%8E%E5%B8%82%E5%85%A5%E7%B1%8D-%28anmelden%29---%E4%B8%80">到達德國的第一件事：城市入籍 (Anmelden) 一點也不難！---- @ 享受孤獨走出舒適圈 :: 痞客邦 :: (pixnet.net)</a> ：有蠻詳細要做的事情，包含入籍申請、開戶、申請電話卡。</li><li><a href="https://tingundting.medium.com/2022-%E5%BE%B7%E5%9C%8B-%E5%85%A5%E7%B1%8D-anmeldung-%E5%B1%85%E7%95%99%E8%AD%89-aufenthaltserlaubnis-%E7%94%B3%E8%AB%8B%E5%88%86%E4%BA%AB-ff6495a75df2">2022 德國 入籍(Anmeldung)、延簽轉居留證(Aufenthaltserlaubnis) 申請分享 - Ting&amp;Ting - Medium</a>：詳細說明入籍跟取得居留證的內容。（要有居留證才可以申請N26喔…）</li><li><a href="https://mwentalk.pixnet.net/blog/post/165268">2019如何啟用Expatrio 領到錢(連結Revolut帳戶) @ 奶玟TALK :: 痞客邦 :: (pixnet.net)</a>: 詳細說明怎麼把提領帳戶與Revolut進行連結。</li><li><a href="https://expateva.com/recommendation/revolut/">2023年最詳細的Revolut使用教學指南與攻略 - Expateva</a>：Revolut超級詳細解說app使用教學</li><li><a href="https://annie89339.pixnet.net/blog/post/405347211-%E4%BB%80%E9%BA%BC%E6%98%AF%E5%BB%B6%E7%B0%BD%EF%BC%9F%E4%BB%80%E9%BA%BC%E6%98%AF%E5%B1%85%E7%95%99%E8%AD%89%EF%BC%9F%E5%88%B0%E9%81%94%E5%BE%B7%E5%9C%8B%E5%BE%8C%E5%BF%85%E9%A0%88">什麼是延簽？什麼是居留證？到達德國後必須做的事情 （慕尼黑經驗分享） @ 享受孤獨走出舒適圈 :: 痞客邦 :: (pixnet.net)</a>：居留證申請教學。</li><li><a href="https://emilydelife.wordpress.com/2019/03/22/%E5%BE%B7%E5%9C%8B%E7%94%B3%E8%BE%A6%E9%A0%90%E4%BB%98%E5%8D%A1/">德國申辦 Vodafone 預付卡 – 德國日常 x 歐洲旅遊 (wordpress.com)</a>：詳細說明Vodafone有哪些卡可以申辦。</li><li><a href="https://www.travelclassroom.net/2017/07/europe-sim.html">歐洲上網卡(SIM卡)：覆蓋、速度與價格比較 + 購買攻略和使用方法分享 - 旅遊教室 (travelclassroom.net)</a>：詳細說明預付卡可以使用的範圍。</li><li><a href="https://www.h-ka.de/en/exchange-students#c61005">Die HKA - Die Hochschule Karlsruhe : Exchange students (h-ka.de)</a> : 學校官網提醒要做的延簽,入籍等事項</li><li><a href="https://www.german-preture.com/%E5%BE%B7%E5%9C%8B%E4%BA%A4%E6%8F%9B%E3%80%81%E7%95%99%E5%AD%B8%E5%BF%85%E5%82%99%E4%BF%9D%E9%9A%AA%EF%BD%9C%E7%AC%AC%E4%B8%89%E8%B2%AC%E4%BB%BB%E9%9A%AA-haftpflichtversicherung/">德國交換、留學必備保險｜第三責任險-haftpflichtversicherung</a>：講到買第三方責任險的必要性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 抵達德國必做 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 德國 </tag>
            
            <tag> 入籍 </tag>
            
            <tag> 延簽 </tag>
            
            <tag> 居留證 </tag>
            
            <tag> sim卡 </tag>
            
            <tag> 提領帳戶 </tag>
            
            <tag> Revolut </tag>
            
            <tag> 保險 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>適用於應用程式AP與資料庫DB之間的零信任架構(ZTA)原則 - 總整理篇</title>
      <link href="/posts/ZTA-survey-AP-DB-summary/"/>
      <url>/posts/ZTA-survey-AP-DB-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>根據<a href="/posts/ZTA-survey-AP-DB-summary">上一篇</a>的內容，我們整理的主流的ZTA相關文件，並針對AP與DB的部分做重點。而本篇的目的就是針對這些文件做一個總整理，並且<strong>針對AP與DB的部分做一個總結</strong>。會想要整理這篇的目的是這樣的：</p><p>目前市面上的<code>零信任架構文件更多探討的是使用者訪問敏感數據或受保護資源之前，與「應用程式或服務」的互動中如何實施持續性的驗證</code>，並且由動態策略來進行決策。但是，這往往讓人<strong>忽略了在使用者完成與應用程式的驗證後，延續到應用程式對資料進行存取時的安全策略</strong>，儘管文件有提及到一些適用於應用程式應滿足的安全要求，例如應該要確保第三方元件的安全等。但並無特別列出應用服務在存取資源時如何持續地進行驗證、授權，或是對事件的監控、資料的收集和分析等，而資料安全方面也僅僅提出基本的要求，包含對重點資料座標記和分類，在應用程式對資源進行存取時，動態存取策略所需考量的要素、架構模型等以滿足零信任要求皆無更多的討論。</p><p>在微服務與雲原生架構的盛行下，<code>多個應用程式可能會有存取相同的資源的需求</code>，而對資源的存取權限往往掌控在應用程式對使用者的驗證與授權，然而基於零信任原則，<strong>我們不應信任並假設每個應用程式的驗證機制都能滿足零信任原則</strong>，在使用者環境或裝置本身遭受惡意人士入侵時，仍存在因為某些的應用程式或其設備的安全性不足而遭受入侵的風險，導致資料洩露或進行未經授權的篡改，而影響其他應用或服務的正常運作。</p><div class="note warning flat"><p>有鑑於此，本研究將會著重在應用程式進行資料存取時，探討該如何滿足<code>AP與DB之間的零信任要求，適用於應用程式與資料存取之間的所應滿足的原則與應該實現的能力</code>。最後，並基於零信任原則<code>設計出適用於應用程式與資料之間的存取控制模型</code>，以針對應用程式進行驗證授權，實現動態決策的存取控制滿足零信任要求。</p></div><h1 id="架構與流程介紹">架構與流程介紹</h1><p>本文的架構主要會依序說明：</p><ul><li>零信任的核心、情境假設、原則</li><li>部署種類與架構：定位論文採取的部署方式</li><li>從零信任的相關文獻中，主要挑選出適用於 AP 與 DB 所應滿足的要求。</li></ul><h1 id="標準之間的比較">標準之間的比較</h1><p><img src="https://i.imgur.com/vFwAl6t.png" alt=""><br>在開始之前，我們先來看一下以下三者的內容中的比較：</p><blockquote><p><strong>NIST SP 800-207</strong></p></blockquote><p>說到零信任架構，最先會被提及的就是NIST SP 800-207了！</p><ul><li>優點：裏面說明的內容比較全面，也潛顯易懂，在ZTA架構的元件其工作職責有定義清楚。</li><li>缺點：只是<strong>針對&quot;資料保護&quot;的存取控制較少</strong>、沒有特別針對AP與DB之間的控制。</li></ul><blockquote><p><strong>DoD Zero Trust Reference Architecture</strong></p></blockquote><p>這裡面中我認為DoD的標準文件更加詳細！</p><ul><li><strong>優點</strong>：<ul><li>他與其他兩者不同之處在於他不僅僅限於User與AP之間的授權驗證，他有<code>特別提及NPE(Non-Person Entity)的授權</code>要求。</li><li>同時也包含提供針對保護資源的架構、提及資料保護元件。</li></ul></li><li><strong>缺點</strong>：只是資料<code>保護元件具體功能不清楚、架構較為複雜，執行流程不清楚</code>，那就是我要負責研究跟實作的議題了。</li></ul><blockquote><p><strong>OMB Federal Zero Trust Strategy</strong></p></blockquote><ul><li><strong>優點</strong>：這份文件&quot;針對User的身份驗證&quot;要求具體。</li><li><strong>缺點</strong>：<ul><li>但是針對Data的要求很基本，沒特別細說存取控制在Data面的要求</li><li>Identity的部分著重在 User，所以如果想要在這裡面找到特別針對AP和DB之間的授權驗證要求，可能會比較困難。</li></ul></li></ul><h1 id="原則-假設">原則 &amp; 假設</h1><p><img src="https://i.imgur.com/nQQDg6t.png" alt=""><br><img src="https://i.imgur.com/VMKkymZ.png" alt=""></p><p>這邊列出每一個文件中所提及ZTA的Tenets，並且做 Mapping，以方便用全局的角度去看具體來說應該滿足的原則。<br>首先主要整理出以下幾個層級，來探討每個層級所應滿足的零信人原則：</p><ul><li>使用者：使用者本人。</li><li>使用者裝置：使用者所存取資料時所使用的裝置。</li><li>工作流程：使用者透過裝置執行特定的工作流程。</li><li>應用/服務/裝置：主要提供服務給使用者的主體，該主體可能是應用程式、服務或是裝置。</li><li>網路：使用者與應用程式、服務或是裝置之間的網路。</li><li>資料：使用者所存取的資料。</li></ul><p>從上圖中，本研究主要探討工作流程到資源層級所應滿足的零信任要求。並以以下假設作為前提：</p><ul><li>工作流程方面：我們應該確保如何保有一致的安全策略。</li><li>應用/服務/裝置方面：在授予資源存取前，應確保這些資產都通過PEP的評估其安全狀態。</li><li>網路：企業內部網路不能被視為隱性信任區。</li><li>資源：不是所有企業資源都位於企業擁有的基礎設施上。</li></ul><h1 id="部署種類">部署種類</h1><ul><li>Ref: <a href="/posts/zta-survey.html#Enclave-Based-Deployement">詳細可以參考這篇</a></li></ul><p><img src="https://i.imgur.com/R85LkBO.png" alt=""><br>部署種類會偏好 Enclave-Based Deployment 的架構:</p><ul><li>應用/服務/裝置：在執行應傭服務的機器上，安裝 agent</li><li>資源：在前面建立Gateway而非建制在資源上。</li><li>適用：適用於具有Legacy的應用程式或on-premises的數據中心</li></ul><h1 id="AP與DB應滿足的要求">AP與DB應滿足的要求</h1><p><img src="https://i.imgur.com/x5B209y.png" alt=""></p><p><img src="https://i.imgur.com/2xZ3xAF.png" alt=""><br>可以從 DoD 文獻的 7 Pillar 來探討，針對AP與DB的部分，應滿足下列：</p><ul><li><p>Users &amp; Device : Continuous Authentication &amp; Authorization</p><ul><li><code>AP</code>：要執行 Application 的 MFA。</li><li><code>AP</code>：基於 ABAC 的存取控制。</li><li><code>AP</code>：Application 的裝置數據收集。</li><li><code>AP</code>：Application 的行為記錄。</li><li><code>AP</code>：即時的存取控制。</li><li><code>PDP</code>：統一的存取政策管理。</li></ul></li><li><p>Network/Environment &amp; Workloads &amp; Data : ZT infra</p><ul><li><code>AP</code>：基於風險考量的應用程式存取。</li><li><code>DB</code>：資料標籤的方法。</li><li><code>PEP</code>：動態的政策執行。</li><li><code>DB</code>：Data Right Management。</li><li><code>DB</code>：Data Loss Prevention。</li></ul></li><li><p>Visibility &amp; Analytics / Orchestration &amp; Automation : Analytics &amp; Orchestration</p><ul><li><code>AP&amp;DB</code>：持續監控</li><li><code>PDP</code>：ZT Policy Engine</li><li><code>PDP</code>：存取控制政策</li></ul></li></ul><h1 id="研究總結">研究總結</h1><blockquote><p>系統架構：條列每個元件應該滿足的要求</p></blockquote><p><img src="https://i.imgur.com/d3hNCsr.png" alt=""></p><h1 id="有哪些研究議題？">有哪些研究議題？</h1><blockquote><p>成熟度模型要求</p></blockquote><p><img src="https://i.imgur.com/sra6GPM.png" alt=""></p><h2 id="實作內容">實作內容</h2><p>上述為成熟度模型，可以依據此參考逐步滿足零信任的要求，而本研究主要著重在“<code>紅色</code>”的部分，如下：</p><ul><li><p><strong>存取控制 AC, Access Control</strong></p><ul><li>AC: 確保存取 DAAS 的時候是經由 Cybersecurity policies 所決定的。</li><li>AC: 實現最小權限存取。</li><li>AC: 基於細顆粒度 (user and device attribute) 進行控制</li><li>AC: 確保存取 DAAS 的時候是經由 Cybersecurity policies 所決定的。</li><li>AC: 完全的實施 Just-in-Time 和 Just-Enough 的存取政策</li></ul></li><li><p><strong>風險標籤 RL, Risk Labeling</strong></p><ul><li>RL: 資料透過 flow analysis 和簡單的自動化進行標籤與分類</li><li>RL: 實施DLP &amp; DRM</li><li>RL: 進階分析技術，使威脅檢測能夠自動化並根據事先設計的策略進行協調（Risk Label實現）</li></ul></li><li><p><strong>身份驗證 IA, Identity Authentication</strong></p><ul><li>IA: 使用MFA進行驗證</li><li>AC:持續性適應驗證與授權</li></ul></li><li><p><strong>網路安全 NS, Network Security</strong></p><ul><li>NS: 滿足加密要求</li></ul></li></ul><h2 id="文獻補充">文獻補充</h2><p>以下是預計要探討的相關文獻，以輔助本研究的存取控制模型架構：</p><ul><li><strong>機器學習 ML</strong><ul><li>DL: 進行 data 辨識，並標示敏感或關鍵資料</li><li>DL: (自動)辨識 DAAS (數據、應用程序、資產和服務)</li><li>DL: Map data flows</li><li>ML: 使用者和 Entity 的行為分析（UEBA, User and Entity Behavior Analytics）建立 baseline policy</li></ul></li></ul><h1 id="缺乏的部分？">缺乏的部分？</h1><p>還缺乏以下部分要進行 survey …</p><ul><li><code>實作</code> Data<ul><li>如何執行DRM、DLP、軟體定義環境和細粒度數據標記等解決方案支持對關鍵數據的保護？</li><li>如何結合上述兩者於Data Labeling?</li></ul></li><li><code>實作</code> AP<ul><li>AP 如何做 MFA？</li><li>思考怎麼把 DLP, DRM 併入存取控制政策中？</li></ul></li><li><code>文獻</code> ML<ul><li>怎麼透過 ML 辨識 DAAS?</li><li>怎麼透過 ML 進行 data 辨識，並標示敏感或關鍵資料，甚至將其自動化？</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> Zero Trust </category>
          
          <category> 畢業論文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碩士論文 </tag>
            
            <tag> Zero Trust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 方便的常用指令（SSH,加密分割壓縮檔）</title>
      <link href="/posts/linux-usual-command/"/>
      <url>/posts/linux-usual-command/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH">SSH</h1><p>參考：<a href="https://askie.today/lets-set-ssh-config/">https://askie.today/lets-set-ssh-config/</a></p><div class="note warning flat"><p>SSH登入主機時，<strong>不用再輸入密碼，然後也不用輸入ip</strong>的方法:</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地產生金鑰</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把金鑰送入想要免輸入密碼的host</span></span><br><span class="line"><span class="comment"># 把公開金鑰送入遠端主機</span></span><br><span class="line">ssh-copy-id 帳號@主機IP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先進入ssh目錄準備設定host別名</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">vi config </span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定如下</span></span><br><span class="line"><span class="comment"># vmware</span></span><br><span class="line">Host <span class="built_in">test</span> <span class="comment"># 以下機器的簡稱</span></span><br><span class="line">  HostName 192.168.4.18 <span class="comment"># ip </span></span><br><span class="line">  User prlab <span class="comment"># 帳號</span></span><br><span class="line">  identityfile ~/.ssh/id_rsa <span class="comment"># 金鑰位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 之後就可以直接輸入</span></span><br><span class="line">ssh <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h1 id="zip">zip</h1><div class="note warning flat"><p>我最常用的就是壓所檔案，並且需要<strong>加密或分割檔案</strong>用。</p></div><ol><li>一般加密檔案用的指令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ”加密“要使用-e，&quot;資料夾“要使用-r，如果只是一般檔案-e即可，不需要r</span></span><br><span class="line"><span class="comment"># 把本地 ./test 資料夾 加密成 ./test.zip，並且輸入密碼</span></span><br><span class="line">zip -er ./test.zip ./test</span><br></pre></td></tr></table></figure><ol start="2"><li>把zip檔案進行分割和合併的做法。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 以下指令 - 表示標準輸入。這個命令的意思是將 zip 命令的輸出作為 split 命令的輸入。</span></span><br><span class="line"><span class="comment"># 如果不添加 -，則 split 命令將不會接收到 zip 命令的輸出，而是會試圖從文件中讀取數據。</span></span><br><span class="line"><span class="comment"># 下面的指令就是透過 zip 把 zip 檔案輸出給 split 這個指令以10MB為單位進行切割</span></span><br><span class="line"><span class="comment"># 以下指令就是回到上一層，找到zip檔案開始分割</span></span><br><span class="line">zip - ../test.zip | <span class="built_in">split</span> -b 10MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># $ &gt; 會產出 xaa, xab, xac, ... # 這樣的檔案，所以我們可以透過 cat 來進行合併</span></span><br><span class="line"><span class="comment"># 把當前目錄底下x開頭的檔案都合併成 test.zip</span></span><br><span class="line"><span class="built_in">cat</span> x* &gt; ../test.zip</span><br></pre></td></tr></table></figure><h1 id="Mac">Mac</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 轉換成中文</span><br><span class="line">option + shift + B : 可以打入顏文字 </span><br><span class="line"># emoji </span><br><span class="line">ctrl + command + space : 可以打入表情符號</span><br><span class="line"></span><br><span class="line"># mac </span><br><span class="line">ctrl + command + F : 全螢幕</span><br><span class="line">ctrl + 左右鍵 : 往右邊的 desktop 切換</span><br><span class="line">command + M : 收起來最小化</span><br><span class="line"></span><br><span class="line"># 瀏覽器</span><br><span class="line">command + T : 新增分頁</span><br><span class="line">command + W : 關閉分頁</span><br><span class="line">command + shift + T : 還原關閉分頁</span><br><span class="line">command + L : 跳到網址列</span><br><span class="line">command + R : 重新整理</span><br><span class="line">command + [ : 上一頁</span><br><span class="line">command + ] : 下一頁</span><br><span class="line"></span><br><span class="line"># Aflred </span><br><span class="line">command + , : 開啟 Preference 設定</span><br></pre></td></tr></table></figure><h1 id="SHELL-配置文件">SHELL 配置文件</h1><ul><li>參考：<a href="https://www.cnblogs.com/MaelDNM/p/16196273.html">https://www.cnblogs.com/MaelDNM/p/16196273.html</a></li></ul><div class="note info flat"><p><code>.bashrc</code> vs <code>.zshrc</code> vs <code>.profile</code> vs <code>.bash_profile</code> 差異在哪裡？</p></div><table><thead><tr><th>比較</th><th>bashrc</th><th>bash_profile</th><th>zshrc</th></tr></thead><tbody><tr><td>啟動時間</td><td><code>系統啟動後</code>自動運行，只在bash shell下執行</td><td><code>用戶登入後</code>才會運行</td><td><code>系統啟動後</code>自動運行，只在 zsh shell下執行</td></tr><tr><td>實行時機</td><td><code>每次打開終端</code>都會運行</td><td><code>每次登入</code>都會運行一次</td><td><code>每次打開終端</code>都會運行</td></tr><tr><td>更新方法</td><td><code>source bashrc</code></td><td><code>source profile</code></td><td><code>source zshrc</code></td></tr><tr><td>局面變量</td><td><code>局部</code>，只能繼承 <code>/etc/profile</code> 中的變量</td><td><code>/etc/profile</code> 中設定的變量是<code>全局</code>。</td><td><code>全局</code>，可以用於任何用戶</td></tr></tbody></table><p>總結：</p><ul><li>如果使用 bash 請更改 <code>~/.bashrc</code> 或是 <code>~/.bash_profile</code><ul><li>bashrc 是每次打開終端都會運行</li><li>bash_profile 是每次登入都會運行一次</li></ul></li><li>如果使用 zsh 請更改<code> ~/.zshrc</code> 或是 <code>~/.zshenv</code></li><li>如果使用 bash 並且想要讓所有用戶都生效，請更改 <code>/etc/profile</code></li></ul><h1 id="關於-usr">關於 /usr/</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local <span class="comment"># 通常是用戶自己手動下載的非系統預設軟體，這個folder由用戶自己管理</span></span><br><span class="line">/usr/bin <span class="comment"># 是用來存放系統預設的可執行檔，這是MacOS預設就幫你裝好的，不要亂動</span></span><br></pre></td></tr></table></figure><h1 id="關於-python-conda">關於 python &amp; conda</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> python <span class="comment"># 查看 python 的路徑</span></span><br><span class="line"><span class="built_in">which</span> -a python <span class="comment"># 查看所有 python 的路徑</span></span><br><span class="line"><span class="built_in">which</span> -a python3 <span class="comment"># 查看所有 python3 的路徑</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conda </span></span><br><span class="line">conda <span class="built_in">env</span> list <span class="comment"># 查看所有環境</span></span><br><span class="line">conda search python <span class="comment"># 查看所有 python 版本 </span></span><br><span class="line">conda list -n your_environment_name python</span><br><span class="line">conda list <span class="comment"># 查看當前環境的所有套件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立環境 </span></span><br><span class="line">conda create -n &lt;env_name&gt; python=3.7 <span class="comment"># 建立環境 python=3.7 的名稱是 &lt;env_name&gt; </span></span><br><span class="line">conda activate &lt;env_name&gt; <span class="comment"># 進入環境 到時候輸入 python --version 就是新的環境版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除環境</span></span><br><span class="line">conda remove -n &lt;env_name&gt; --all <span class="comment"># 刪除環境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 環境改名 需要先 copy 到其他新環境 再刪除舊環境 </span></span><br><span class="line">conda create --name new_name --<span class="built_in">clone</span> old_name</span><br><span class="line">conda remove --name old_name --all</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>適用於AP與DB之間的零信任架構(ZTA)原則</title>
      <link href="/posts/zta-survey/"/>
      <url>/posts/zta-survey/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf">美國 NIST 在 2020 年發佈了 NIST SP 800-207 的文件</a></li><li><a href="https://dodcio.defense.gov/Portals/0/Documents/Library/(U)ZT_RA_v2.0(U)_Sep22.pdf">美國國防資訊系統局就在 2021發布美國國防部的零信任參考架構 Department of Defense - Zero Trust Reference Architecture</a></li><li><a href="https://zerotrust.cyber.gov/federal-zero-trust-strategy/">美國預算與管理辦公室於 2021 年 9 月先發布推動策略徵求意見後，於 2022 年 1 月發佈正式文件</a></li></ul><h1 id="前言">前言</h1><p>身為一個想要做資料庫與AP之間安全論文的研究生，如果想要套用零信任架構上去，首先就必須了解各種文件上面談到零信任<code>應該滿足的要求</code>或是符合零信任的<code>架構</code>。同時因為是要找AP與資料庫之間的安全，而零信任卻是更全面地談及不同層面應該滿足的要求，像是針對使用者的身份驗證等。因此需要認清楚自己的目標對象怎麼著中在AP與資料之間的安全，為此我將整理的要求和架構進行分類，<strong>哪些是針對User與AP，哪些可以用於AP與AP就需要區分出來</strong>。</p><p>因此這篇文章的目的是在整理以下三篇文章：</p><ul><li><a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf">美國 NIST 在 2020 年發佈了 NIST SP 800-207 的文件</a>：此文件作為國家導入零信任架構訂定基礎。</li><li><a href="https://dodcio.defense.gov/Portals/0/Documents/Library/(U)ZT_RA_v2.0(U)_Sep22.pdf">美國國防資訊系統局就在 2021發布美國國防部的零信任參考架構 (Zero Trust Reference Architecture)</a>：列出要導入零信任架構時的參考元件。</li><li><a href="https://zerotrust.cyber.gov/federal-zero-trust-strategy/">美國預算與管理辦公室於 2021 年 9 月先發布推動策略徵求意見後，於 2022 年 1 月發佈正式文件</a>：要求美國聯邦政府的各單位，要在 2024 年的預算年度，達成零信任安全在身分識別、裝置安全、網路安全、應用安全，與資料安全等五大目標上的要求。</li></ul><div class="note danger flat"><p>因為這篇主要是我自己整理的內容，所以可能內容還沒有更加的統整，如果想直接看總結，建議查看<a href="/posts/ZTA-survey-AP-DB-summary">零信任架構的方法</a>。</p></div><h1 id="NIST-零信任假設">NIST 零信任假設</h1><blockquote><p>以下內容主要出自於 NIST SP 800-207 大概看看就好。</p></blockquote><p>以下是零信任架構的假設前提，我們應該要：</p><ol><li><strong>The entire enterprise private network is not considered an implicit trust zone.</strong><ul><li><code>企業內部網路不能被視為隱性信任區</code></li></ul></li><li><strong>Devices on the network may not be owned or configurable by the enterprise.</strong><ul><li><code>裝置可能不是由企業擁有或設置管理的</code>（ex. BYOD）</li></ul></li><li><strong>No resource is inherently trusted.</strong><ul><li><code>沒有資源本身是受信任的，在授予資源存取前，每項資產都必須通過 PEP 評估其安全狀況</code></li></ul></li><li><strong>Not all enterprise resources are on enterprise-owned infrastructure.</strong><ul><li><code>不是所有企業資源都位於企業擁有的基礎設施上</code>。</li><li>資源包括遠程企業主體以及雲服務。</li><li>企業擁有或管理的資產可能需要使用本地（即非企業）網路進行基本連接和網路服務（例如，DNS解析）。</li></ul></li><li><strong>Remote enterprise subjects and assets cannot fully trust their local network connection</strong><ul><li><code>遠端存取者應假設本地網路環境是不安全的</code>。</li><li>資產應該假設所有流量都被監控並有可能被修改。</li><li>所有連線必須是被驗證獲授權的。</li></ul></li><li><strong>Assets and workflows moving between enterprise and non-enterprise infrastructure should have a consistent security policy and posture.</strong><ul><li><code>在企業基礎設施和非企業基礎設施之間移動的資產和工作流程應該具有一致的安全策略和姿態</code>。</li></ul></li></ol><h1 id="NIST-零信任原則-ZTA-Tenets">NIST 零信任原則 ZTA Tenets</h1><blockquote><p>以下內容主要出自於 NIST SP 800-207</p></blockquote><div class="note warning flat"><p>對於NIST SP 800-207中提出的零信任原則所指的對象通常不限定於使用者、應用或服務，主要提出作為存取者發出對於資源的請求時，所應滿足的原則以符合零信任，而對於應用程式或服務在存取資源時的特定情況並沒有具體的說明。</p><p><strong>因此這裡我會多補充一些關於應用程式與資源之間，應如何做到滿足零信任的原則。</strong></p></div><details class="toggle" ><summary class="toggle-button" style="">Tenet 1. All data sources and computing services are consider resources. <br> > 原則1: 企業內部的數據資源或是計算服務都需要被視為受保護的資源</summary><div class="toggle-content"><p>感想：</p><ul><li>已資料庫來說，<strong>資料庫可以視為被保護的資源</strong>之ㄧ。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenet 2. All communication is secured regardless of network location. <br> > 原則2: 不能只是根據網路位置就授予信任，內部的存取請求所經歷的安全要求與外部請求必須相同</summary><div class="toggle-content"><p>感想：</p><ul><li>不會預設有信任應用程式，<code>所有存取資料庫的應用程式</code>應該都要<strong>持續授權與驗證</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenet 3. Access to individual enterprise resources is granted on a per-session basis. <br> > 原則3: 企業內部的資源存取必須是基於每個連線的基礎</summary><div class="toggle-content"><p>內容：</p><ul><li>在請求被授權前應該經過衡量並滿足執行任務的<strong>最小權限原則</strong></li><li>值得注意的是，提到不一定要直接在啟動會話或執行與資源的交易之前才授予權限，相反，企業可以在使用者提出存取請求之前，先評估這個使用者的身份和信任程度，並根據這些評估結果授予相應的權限。這樣做可以在使用者真正需要存取資源時，節省時間並簡化存取流程。</li></ul><p>感想：</p><ul><li>應用程式與資料庫在建立連線時，應該要能夠根據應用程式的身份進行驗證。</li><li>並<strong>確保該應用程式執行工作的權限應屬於該應用程式的資料存取範圍</strong>，這表示對於每個存取資料庫的<code>應用程式都要有清楚的身份區別</code>，以辨別該應用程式可以存取的資源。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenets 4. Access to resources is determined by dynamic policy - including the observable state of client identity、 application/service、 and the requesting asset - and may include other behavior and environmental attributes. <br> > 原則4: 資源請求應該經由動態政策來決定，這包含觀察客戶端應用和服務的身份、請求狀態、環境屬性、存取行為等</summary><div class="toggle-content"><p>內容：</p><ul><li><code>請求資產</code>狀態：可以包含裝置屬性像是<strong>軟體版本, 網路位置, 請求時間日期, 觀察的歷史行為, 安裝的憑證</strong></li><li><code>行為</code>屬性包含但不限於：自動化的<strong>存取者分析, 裝置分析, 使用模式偏差</strong>。</li><li><code>環境屬性</code>可以包含：請求者<strong>網路位置, 時間, 主動攻擊報告</strong>。</li><li><code>Policy</code>：是基於屬性的存取規則集合，屬性由組織assign給subject, data asset或application。</li></ul><p>感想：</p><ul><li>應該要<strong>設計出一存取控制政策</strong>應該要能包含各種不同的屬性，如上述內容所提到的。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenets 5. The enterprise monitors and measures the integrity and security posture of all owned and associated assets. <br> > 原則 5. 不再預設信任任何資產，而是持續監控和評估所有資產的安全狀態</summary><div class="toggle-content"><p>內容：</p><ul><li>企業應該建立一個持續性診斷和強化CDM來監控裝置和應用程式的狀態，並根據需要應用補丁/修補程式。</li><li>建立健全的監控和報告系統，提供有關企業資源當前狀態的可行數據。</li></ul><p>感想：</p><ul><li>對於<code>存取資料庫的應用程式</code>來說，應該也要<strong>持續性的監控該應用程式所使用的第三方套件版本、補丁</strong>等，作為該應用的狀態。</li><li>同時也要<code>監控應用程式執行的裝置環境</code>是否正常。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenet 6. All resource authentication and authorization are dynamic and strictly enforced before access is allowed. <br> > 原則 6. 資源驗證和授權是動態的，必須在允許訪問之前嚴格執行</summary><div class="toggle-content"><p>內容：</p><ul><li>這是一個不斷循環的過程，包括獲取訪問權限、掃描並評估威脅、適應變化，以及持續重新評估通信中的信任。</li><li>這種方法確保在任何時候只有經過授權的用戶才能訪問企業資源。</li><li>實施零信任架構的企業預期會擁有身份identity、憑證credential和訪問管理access management（簡稱ICAM）以及asset management system資產管理系統。</li><li>在<strong>用戶交易過程中，不斷進行監控，可能需要重新驗證和重新授權</strong>。</li><li>這是根據政策（例如基於時間的重新驗證、新資源請求、資源修改、檢測到異常用戶活動等）來定義和強制執行的。</li><li><strong>政策旨在在安全性、可用性、易用性和成本效率之間取得平衡</strong>。</li></ul><p>感想：</p><ul><li>首先<code>任何應用程式在進行資料庫存取</code>時，都必須<strong>經過嚴格的驗證與授權</strong>，只有經過授權的應用程式才能訪問資料庫。</li><li>在<strong>存取資料的過程</strong>中，都應該<code>持續性地進行監控</code>，可能需要根據存取的資源不同，進行重新驗證與授權。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Tenets 7. The enterprise collects as much information as possible about the current state of assets、 network infrastructure and communications and uses it to improve its security posture. <br> > 原則 7. 應收集資產的安全狀況、網絡流量和訪問請求等，收集到的資料將用於改進政策制定和執行，以提升資安策略</summary><div class="toggle-content"><p>感想：</p><ul><li>資料庫、應用程式的安全狀況、網路流量、請求內容、請求結果<code>應該要做紀錄並收集</code>。</li><li>這些<strong>收集的資料可以用於改進政策制定和執行</strong>，以提升資安策略。</li></ul></div></details><h1 id="NIST-零信任架構的方法">NIST 零信任架構的方法</h1><div class="note warning flat"><p>我個人個觀點，若是要實施零信任架構於應用程式和資料庫之間，則應該<strong>採用<code>Using Enhanced Identity Governance</code>的做法作為本研究的架構</strong>。</p></div><p>NIST SP 800-207主要題中三種作為零信任架構的方法：</p><ol><li><strong>Using Enhanced Identity Governance 使用增強的身份管理</strong><ul><li><strong>說明</strong>：一種以<code>身份為核心</code>，<code>基於身份和屬性</code>制定資源訪問政策。</li><li><strong>感想</strong>：在放行應用程式的請求至資料庫前，應該要<code>先識別發出請求的應用程式</code>為何？<code>健康狀況</code>？<code>應用程式的第三套件是否有重大資安缺漏</code>？再近一步判斷其擁有得權限，才能放行請求。</li></ul></li><li><strong>Using Micro-Segmentation 使用微分割</strong><ul><li><strong>說明</strong>：將<code>資源放置在受到網關安全元件保護的獨立網絡段</code>，保護資源免受未經授權的訪問。</li><li><strong>感想</strong>：使用微分割的做法主要透過網路安全元件如防火牆等，透過將網段分區的方式，在每個網段透過這些元進行控制與監控。但因為本研究的目的介於應用程式與資料庫之間，<code>為了能夠更清楚的取得兩者之間的資料流，因此不適合使用此方法</code>。</li></ul></li><li><strong>Using Network Infrastructure and Software Defined Perimeters 使用網絡基礎設施和軟體定義的周界</strong><ul><li><strong>說明</strong>：使用<code>網絡基礎設施實現ZTA</code>，可能包含軟體定義網絡和意圖為基礎的網絡概念，PA充當網絡控制器來設置和重新配置網絡。</li><li><strong>感想</strong>：主要透過類似SDN軟體定義網路的方法來進行網路流量的控制，主要在OSI模型中的網路層（Network Layer），這一層負責處理網路之間的路由和轉發，以及封包在不同網路之間的傳遞，因此<code>應用層級的細節不可見</code>。由於無法深入了解應用程式與資料庫之間的細節，<code>若連線設定不當或未能滿足應用程式的安全需求，可能會導致資料外洩或遭受攻擊</code>。</li></ul></li></ol><h1 id="NIST-零信任架構部署種類">NIST 零信任架構部署種類</h1><p>可以從以下架構看到，NIST SP 800-209 中的零信任架構主要都使以使用者為主體，透過裝置來進行資源存取。</p><table><thead><tr><th><div style="width:80px"> 比較項目 </div></th><th>Agent/Gateway</th><th>Enclave Gateway</th><th>Resource Protal</th><th>App Sandboxing</th></tr></thead><tbody><tr><td>有無Agent</td><td><code>有</code></td><td><code>有</code></td><td><code>無</code></td><td><code>無</code></td></tr><tr><td>PEP位置</td><td><code>單一</code>資源前</td><td><code>資源集或私有雲</code>前/入口</td><td><code>資源集或私有雲</code>前/入口</td><td>裝在<code>資源上</code></td></tr><tr><td>適用情境</td><td>有<code>裝置管理計畫</code>之企業</td><td>具有<code>Legacy應用程式或on-premises數據中心</code>之企業</td><td>適用於<code>BYOD環境</code>，不需要再客戶端設備安裝軟體元件。</td><td>適用<code>無法掃瞄客戶資產</code>(裝置)是否存在漏洞。</td></tr></tbody></table><h2 id="Device-Agent-Gateway-Model">Device Agent / Gateway Model</h2><p><img src="https://i.imgur.com/Z4IezQ5.png" alt=""></p><ul><li>在這個模型中，<strong>PEP (Policy Enforcement Point) 被分成兩個部分</strong>它們分別位於「資源」上或直接作為「資源前端」的一個組件。<ul><li><code>第一部分是&quot;Device Agent&quot;</code>: 它被安裝在企業發放的資產上，用於協調連接。這個代理程式<strong>負責將一些（或全部）流量導向適當的 PEP 以便進行請求評估</strong>。</li><li><code>第二部分是&quot;Gateway&quot;</code>: 它被放置在每個資源的前端，使資源只與這個網關進行通訊，本質上充當資源的代理。這個網關負責與政策管理員進行通訊，並僅允許政策管理員配置的批准通訊路徑。</li></ul></li><li>政策管理員PA 和 政策引擎PE 可以是企業本地設備或雲端服務。</li><li>適用情境：<ul><li><strong>適合使用在已建立堅固裝置管理計畫的企業</strong>，同時擁有可以與網關進行通訊的專屬資源。這個模型也適合不希望實施BYOD政策的企業。</li><li><strong>唯有透過裝置代理（device agent），才能取得存取權限</strong>，而裝置代理可以安裝在企業擁有的資產上。</li></ul></li></ul><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant A as Agent     participant PA as Policy Administrator     participant PE as Policy Engine    participant G as Gateway    A-&gt;&gt;+PA: 存取請求由本地代理接收，轉發給政策管理員PA    PA-&gt;&gt;+PE: 政策管理員PA將請求轉發給政策引擎PE進行評估。    PE--&gt;&gt;-PA: 請求被授權，政策管理員將在控制平面上配置設備代理和相關資源閘道之間的通信通道。    A-&gt;&gt;+G: 設備代理和閘道隨後建立連接，開始傳輸加密的應用程式&#x2F;服務數據。    G--&gt;&gt;-A: 當工作流程完成或由政策管理員觸發安全事件（例如會話逾時、重新驗證失敗）時，設備代理和資源閘道之間的連接將被終止。  </pre></div><h2 id="Enclave-Based-Deployement">Enclave-Based Deployement</h2><div class="note info flat"><p>“Enclave” 是一個安全隔離的計算環境，可以保護敏感數據和應用程式免受未經授權的存取或攻擊。</p></div><p><img src="https://i.imgur.com/R85LkBO.png" alt=""></p><ul><li>是 Device Agent / Gateway Model 的一種變體，企業的資產（裝置）透過<code>使用Agent設備代理連接到Enclave gateway</code>，連接過程基本與Device Agent / Gateway相同。</li><li>Gateway 主要保護不只單一資源，而是多個。</li><li>缺點是網關保護一組資源，可能無法保護每個資源，這可能使得使用者看到他們無權訪問的資源。</li><li>適用環境：<ul><li>適用於具有 legacy 應用程式或on-premises 數據中心的企業，無法為每個資源設置個別的 gateway。</li><li>企業需要建立強大的資產和配置管理，以進行安裝/配置設備代理 Device Agents，這樣才可以允許 subjects 看到有哪些權限可以存取。</li></ul></li></ul><h2 id="Resource-Portal-Based-Deployment">Resource Portal-Based Deployment</h2><p><img src="https://i.imgur.com/wU864uN.png" alt=""></p><ul><li>這個模型相比其他模型的主要優勢在於，<strong>不需要在所有客戶端設備上安裝軟體元件</strong>。</li><li>這個模型也有一些限制：<ul><li>由於只有當設備連接到PEP閘道時才能掃描和分析資產和設備，因此<strong>僅能從請求設備獲得有限的信息</strong>。</li><li>模型可能<code>無法持續監控這些設備</code>，檢測惡意軟體、未打補丁的漏洞和適當的設定。</li><li>此模型中沒有本地代理程式處理請求，因此企業<code>可能無法完全查看或隨意控制資產</code>，只有在它們連接到閘道時才能看到/掃描它們。</li></ul></li><li>適用情境：<ul><li>這使得該模型更<strong>適用於BYOD政策</strong>（Bring Your Own Device，即員工使用自己的裝置進行工作）和<strong>跨組織協作項目</strong>。</li></ul></li></ul><h2 id="Device-Application-Sandboxing">Device Application Sandboxing</h2><p><img src="https://i.imgur.com/moNnJsX.png" alt=""></p><ul><li>是 Device Agent / Gateway Model 的一種變體</li><li>讓審核過的應用程式 <strong>Trusted App 或 Process 在「資產上」運行</strong>，進行區隔管理。</li><li>區隔可以是<code>虛擬機、容器</code>或其他形式的實現，目的是保護應用程式免受可能被入侵的主機或其他應用程式的影響。</li><li>PEP可以是企業的本地服務或雲服務，負責管理應用程式的訪問。</li><li>這個模型的優點是將個別應用程式與資產的其餘部分隔離，有助於防止感染。</li><li>缺點：<ul><li>企業需<strong>維護所有資產的沙箱應用程式</strong>，且可能<code>無法完全了解客戶端資產</code>。</li><li>還需要<strong>確保每個應用程式的安全性</strong>，可能相較於其他架構需要<code>花更多努力</code>。</li><li>無法瞭解客戶端資產（裝置）。</li></ul></li><li>適用環境：<ul><li>無法掃瞄資產assets是否存在漏洞，這個模型可以保護AP防止主機上潛在的惡意軟體。</li></ul></li></ul><h1 id="OMB-5大支柱">OMB - 5大支柱</h1><p>美國聯邦政府發布的ZTA政策就是<strong>參考CISA的陳熟度模型以7個pillar</strong>做區分，分別針對identity, devices, networks, applications, data 給出意見具體闡述滿足零信任架構所應滿足的要求。</p><div class="note warning flat"><p>而這其中，有些要求適用於應用程式應滿足的要求，例如針對應用安全應該要確保第三方元件的安全並且有足夠的安全城市。<code>但是，並無特別列出政府機構之應用服務在存取資源時應滿足的要求</code>，而<strong>資料安全方面也僅僅提出基本的要求</strong>，包含對重點資料座標記、自動化分類、自動化安全回應等。</p></div><details class="toggle" ><summary class="toggle-button" style="">Identity 身份驗證</summary><div class="toggle-content"><h2 id="Identity">Identity</h2><p>良好的身分驗證系統是ZTA的基底，政府機構應該要整合身分驗證系統，並根據需要可以和其他機構聯合訪問(Federation)。<strong>並且擴大對MFA來保護使用者避免credential-theft或是釣魚攻擊</strong>。要求含以下：</p><ol><li>建立SSO服務驗證<ol><li>建立SSO服務給使用者，可以和應用程式和通用平台(雲服務)整合</li><li>確保跨各種平台具有相同級別的強身份驗證。</li><li>SSO應該使用公認的標準像是SAML或OpenId連線</li></ol></li><li>應用層 必須 加強 MFA<ol><li>For agency staff, contractors, and partners: phishing-resistant MFA is required.</li><li>For public users: phishing-resistant MFA must be an option.</li><li>必須使用phishing-resistant method 去存取帳號，像是註冊手機電話for SMS或是voice calls，或是WebAuthn，支援one-time codes</li></ol></li><li>實施安全密碼政策，並檢查密碼是否能夠抵抗以外洩的資料</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">Devices 裝置監控</summary><div class="toggle-content"><h2 id="Devices">Devices</h2><p>針對資產的檢測和監控：</p><ol><li>要提供一套服務以改進對資產(裝置那些)的檢測和監控，全面了解有哪些使用者、裝置、或是任何在系統的互動。</li><li>Continuous Diagnostics and Mitigation (CDM) 計畫要實施，可以參考Cisco提供的<a href="https://www.cisa.gov/resources-tools/programs/continuous-diagnostics-and-mitigation-cdm-program">CDM Program</a></li><li>需要有強大的Endpoint detection and response (EDR) 端點偵測與回應 工具來部屬，</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">Networks 網路安全</summary><div class="toggle-content"><h2 id="Networks">Networks</h2><ul><li>DNS請求加密</li><li>使用HTTPS連線</li><li>網域開啟 MTA Strict Transport Security (MTA-STS)<ul><li>使用MTA-STS 針對傳送到您網域的電子郵件要求進行驗證檢查和加密作業，讓Gmail 的安全性更加完善。</li><li>寄件伺服器支援 MTA-STS，並且收件伺服器在強制執行模式下設有 MTA-STS 政策，就能讓電子郵件的 SMTP 連線更加安全。</li></ul></li><li>每個應用程式應該都要在獨立的網路環境中，應該準備好在不同應用之間建立不受信任的網路安全連線</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Applications 應用程式安全</summary><div class="toggle-content"><h2 id="Applications">Applications</h2><ul><li>應用要做足夠專門嚴格的安全測試</li><li>第三方元件要夠安全</li><li>應用的漏洞報告，不要隱瞞</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Data 資料安全</summary><div class="toggle-content"><h2 id="Data">Data</h2><ul><li>針對<code>重點資料做標記</code>，並<code>進行資料的一些自動化分類</code>或是<code>安全性的回應</code></li><li>必須要有全面和即時的<code>完整logging紀錄</code></li><li>自動化的安全回應:<ul><li>機構應努力採用植根於機器學習的數據敏感性分類，和安全自動化的早期候選者，這些候選者不需要立即使用機器學習，可以先用簡單的技術向是腳本或是正規表達式來應用</li><li>盡可能地提供異常行為早期預警和檢測流程</li></ul></li><li>審核對雲中敏感數據的訪問<ul><li>使用加密來保護靜態數據</li><li>可以通過雲端管理的加密和解密操作，以及相關日誌來幫助檢測</li><li>在成熟的階段，機構應該將審計日誌與其他事件數據來源結合起來，採用更複雜的安全監控方法。</li><li>例如，可以比較數據訪問的時間與用戶啟動事件的時間，以識別可能不是由正常應用程序活動引起的數據庫訪問。</li></ul></li></ul></div></details><h1 id="DOD-ZTA-假設">DOD - ZTA 假設</h1><p>這裡主要參考DoD中的<code>chapter 2. Pillars and Principles</code>，裏面提到零信任安全策略原則，如果有人問你…零信任的核心理念是什麼？你可以回答:</p><ul><li>本文提到「<strong>零信任策略的核心理念是在訪問敏感數據或受保護資源之前，要求持續性的驗證或驗證</strong>」。</li><li>零信任安全模型中，「<strong>我們需要重新思考如何對實施對資源的安全訪問，並且由動態策略來決定</strong>」而這裡的動態策略應考慮到以下，超出了僅僅進行憑證驗證的範圍包含:<ul><li>(1) <code>用戶和端點身份</code>的可觀察狀態: 信心水平是從被驗證主體的多個屬性中建立的（身份，位置，時間，設備安全狀態）</li><li>(2) <code>應用程序/服務</code></li><li>(3) <code>請求</code>的資產</li><li>(4) 其他<code>行為</code>和<code>環境屬性</code></li><li>(5) 允許對訪問請求進行<code>更全面的評估</code>。</li></ul></li></ul><p>在DoD中，主要提到<strong>零信任有五個主要原則</strong>，這些原則代表了基本元素，並影響了零信任中的所有方面。</p><details class="toggle" ><summary class="toggle-button" style="">1. Assume a Hostile Environment 假設環境是危險的</summary><div class="toggle-content"><ul><li>假設在<code>環境內部和外部，都有惡意人士</code>存在。</li><li><strong>所有用戶、設備、應用程序、環境和其他非人實體都被視為不受信任</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">2. Presume Breach 假設環境內部已遭受入侵</summary><div class="toggle-content"><ul><li>每天都有數十萬次針對DoD環境的嘗試性網絡攻擊。</li><li>在進行操作和保護資源時，要有一個假設：<code>敵對方已經進入您的環境</code>。</li><li><code>強化對訪問和授權決策的審查</code>，以改善應對結果。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3. Never Trust / Always Verify. 不要信任，始終驗證</summary><div class="toggle-content"><ul><li><code>默認情況下拒絕訪問</code>。</li><li>使用<code>最小特權</code>、<code>多個屬性</code>和<code>動態網絡安全策略</code>，對每個設備、用戶、應用程序/工作負載和數據流<strong>進行身份驗證和明確授權</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">4. Scrutinize Explicitly. 明確審查</summary><div class="toggle-content"><ul><li>所有資源都以<code>安全方式一致地訪問</code>，使用<code>多個屬性</code>（動態和靜態）為資源的情境訪問衍生出信心水平。</li><li>對資源的訪問是有條件的，且基於行動和信心水平的結果，<code>訪問可以動態變更</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">5. Apply Unified Analytics 使用統一分析</summary><div class="toggle-content"><ul><li>對數據、應用程序、資產和服務（DAAS）應用統一分析，包括行為特徵，並<code>log每筆交易</code>。</li></ul></div></details><hr><h1 id="DOD-ZTA-Tenets">DOD - ZTA Tenets</h1><p>上面有點像是基礎元件應包含的部分，以下是 <code>chapter 2.4 Reference Architecture Principles</code> 所描述架構在安全方面應採用的指導原則：</p><details class="toggle" ><summary class="toggle-button" style="">原則 #1: 在網路中不假定任何隱含或明示的受信任區域。 <br> Principle #1: Assume no implicit or explicit trusted zone in networks.</summary><div class="toggle-content"><p>這表示不對網路中的任何區域盲目信任。</p></div></details><details class="toggle" style="border: 1px solid  data"><summary class="toggle-button" style="background-color:  data;color:  and services.">原則 #2: 基於身份的認證和授權將嚴格執行，涵蓋對基礎設施、數據和服務的所有連接和訪問。 <br> Principle #2: Identity-based authentication and authorization are strictly enforced for all connections and access to infrastructure</summary><div class="toggle-content"><p>確保只有經過身份驗證和授權的用戶可以訪問相關資源。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #3: 機器對機器（M2M）的認證和授權將嚴格執行，用於伺服器和應用程序之間的通信。 <br> Principle #3: Machine to machine (M2M) authentication and authorization are strictly enforced for communication between servers and the applications.</summary><div class="toggle-content"><p>這保證伺服器和應用程序之間的通信是安全和可信的。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #4: 通過監控和評估用戶和設備行為生成風險簡介，以用於授權用戶和設備訪問資源時。 <br> Principle #4: Risk profiles、 generated in near-real-time from monitoring and assessment of both user and devices behaviors、 are used in authorizing users and devices to resources.</summary><div class="toggle-content"><p>這意味著根據即時生成的風險值來授權使用者和設備訪問特定資源。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #5: 所有敏感數據在傳輸過程中和靜態存儲時都要進行加密。<br> Principle #5: All sensitive data is encrypted both in transit and at rest.</summary><div class="toggle-content"><p>這確保了數據在傳輸和存儲時的安全性。</p></div></details><details class="toggle" style="border: 1px solid  collected"><summary class="toggle-button" style="background-color:  collected;color:  stored">原則 #6: 所有事件都需要持續監控、收集、存儲和分析，以評估其是否符合安全政策。 <br> Principle #6: All events are to be continuously monitored</summary><div class="toggle-content"><p>這有助於保持對系統行為的實時監控和評估。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">原則 #7: 政策管理和分發是集中化的。 rinciple #7: Policy management and distribution is centralized.</summary><div class="toggle-content"><p>這意味著所有的安全政策都集中管理和分發，確保統一的安全措施。</p></div></details><h1 id="DOD-7-大支柱">DOD - 7 大支柱</h1><p><img src="https://i.imgur.com/mh7I5x8.png" alt=""></p><p>主要會列出，每個支柱的說明、與AP與DB之間應用的相關程度，以及個人的感想。</p><details class="toggle" ><summary class="toggle-button" style="">User 使用者 ⭐️⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：這個支柱關注保護並限制<code>人員</code>和<code>非人員</code>實體對 (Data, Applications, Assets, Services)<code>DAAS的訪問</code>。包含對身份身份驗證，如MFA, 特權訪問管理 (Privileged Access Management ,PAM)，持續<code>對使用者進行身份驗證、授權和監控活動模式</code>，以管理使用者的訪問和特權，同時保護所有互動。</li><li><strong>感想</strong>：內容有提到，這個User Pillar 不僅僅是針對使用者，但要提出一方式已持續對AP進行身份驗證，並監控活動模式。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Device 設備 ⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：強調在企業中，對設備進行<code>持續的實時驗證、檢查、評估和修補</code>。如使用 Mobile Device Managers、comply to connect（遵守規定才可以連線）或 可信平台模塊（TPM），這些解決方案可以幫助進行設備的信心評估，即確定設備是否是受信任的。並且符合組織的安全標準。同時，這些數據還可以在進行授權決策時提供依據，確保只有合法的設備能夠訪問資源。<ul><li>對於每個訪問請求，應進行其他評估（例如，檢查是否受到威脅、軟體版本、保護狀態、加密啟用和正確配置等）。</li><li>在零信任方法中，能夠<code>識別、驗證、監察、授權、隔離、保護、糾正和控制所有設備</code>至關重要。</li></ul></li><li><strong>感想</strong>：應該驗證執行AP的環境設備是否安全。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Network/Environment 網絡/環境 ⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：這個支柱強調<code>對網絡/環境進行分段（邏輯和物理）</code>，以<code>精細的訪問和策略限制</code>來進行隔離和控制（無論是在場內還是場外）。隨著邊界變得更加精細，微分段提供了更大的保護和控制能力。這一支柱的關鍵在於<code>控制特權訪問</code>、<code>管理內部和外部數據流</code>，以及防止橫向移動。</li><li><strong>感想</strong>：感覺著重在進行網路的微分割，確保企業內外網都有經過控制。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Applications and Workload 應用程式和工作負載 ⭐️</summary><div class="toggle-content"><p><strong>說明</strong>：這個支柱包含 on-premises 或是雲端環境的<code>應用程式和工作負載</code>。Application Delivery 的相關技術可以實現額外的保護，像是開發的 source code 和 libraries 應<code>通過 DevSecOps 的開發實踐</code>來審核，確保應用程序從一開始就安全。</p><ul><li><strong>感想</strong>感覺這是AP方面單方面的安全準則。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Data 數據 ⭐️⭐️⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：瞭解組織的數據及其重要性對於成功實施 ZT 架構至關重要。<code>組織需要根據任務重要性對其數據進行分類</code>，並將此信息用於<code>制定全面的數據管理策略</code>，作為其整體 ZT 方法的一部分。<ul><li>通過對一致有效的數據進行<code>摄取</code>、數據<code>分類</code>、開發<code>架構</code>，以及在靜止和傳輸中<code>加密</code>數據，可以實現這一目標。</li><li><code>DRM</code>、<code>DLP</code>、<code>軟體定義環境</code>和<code>細粒度數據標記</code>等解決方案支持對關鍵數據的保護。</li></ul></li><li><strong>感想</strong>：這很重要，才能特顯出資料庫方面的保護以實現零信任。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Visibility and Analytics 可見性和分析 ⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：<code>上下文詳細信息</code>提供了對其他 ZT 支柱的性能、行為和活動基線的更深入理解。<ul><li>這種可見性改善了對<code>異常行為的檢測</code>，並能夠在安全策略和實時<code>訪問決策中進行動態更改</code>。</li><li>此外，其他監控系統，如感測器數據以及遙測數據，將有助於填充環境的情況，並有助於觸發用於回應的警報。</li><li>ZT 企業將捕獲和檢查流量，不僅關注網絡遙測，還會<code>深入分析數據包本身</code>，準確地發現網絡上的流量並觀察當前存在的威脅，更智能地調整防禦。</li></ul></li><li><strong>感想</strong>：比較重要的是要紀錄Log，作為異常行為檢測和訪問決策中進行動態更改。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Automation and Orchestration 自動化和協調 ⭐️⭐️⭐️</summary><div class="toggle-content"><ul><li><strong>說明</strong>：通過基於策略的自動安全流程，在企業範圍內實現快速且規模化的操作。<ul><li>SOAR(Security Orchestration, Automation, and Response)怎麼幫助企業更<code>有效的回應安全事件以降低了響應時間</code>。</li><li>安全協調整合了安全信息和事件管理（SIEM）以及其他自動化安全工具，有助於管理不同的安全系統。</li><li>在 ZT 企業中，<code>自動安全響應需要明確的流程</code>以及對所有環境的<code>一致性安全策略</code>執行，以提供主動的命令和控制。</li></ul></li><li><strong>感想</strong>：著重在怎麼做到自動化的安全響應，透過響應影響策略，實現動態決策。</li></ul></div></details><h2 id="聚合能力與支柱">聚合能力與支柱</h2><div class="note warning flat"><p>這邊會做一個大表格來整理，這樣才能具體知道如何實現Pillar的目標。<br>然後標示出：</p><ul><li>哪些是我們主要探討的</li><li>哪些不是針對應用程式與DATA之間的部分，有需要納入嗎？如果要該如何調整？</li><li>那些不做的部分，有哪些是可以透過補足文獻來補充的。</li></ul></div><p>（圖片放置處）</p><p>上圖展示了七大支柱中，我們應遵循的能力，而這些能力又該如何透過Pillar來滿足，主要可以區分以下兩者：</p><ul><li><strong>Aggregate</strong>:<ul><li>如果在UML的說詞上A指向B，表示 A 擁有 B，但為弱擁有，<code>A 與 B 有各自的生命週期</code>。</li><li>常見用來描述 A 類別擁有 B 的實體，A 與 B 彼此協作，但又可各自單獨存在。</li></ul></li><li><strong>Dependency</strong>:<ul><li>如果在UML的說詞上A指向B，A 使用 B，B 的變化有可能會影響到 A。</li><li>常見描述 A 在使用某些方法時，會將 <code>B 作為參數傳入，但並不持有 B</code>。</li></ul></li></ul><details class="toggle" ><summary class="toggle-button" style="">Aggregate Capabilities 1: Zero Trust Authentication & Authorization</summary><div class="toggle-content"><p>這兩個主要牽涉兩個Pillar的「<code>條件授權能力</code>」Conditional Authorization Capabilities：</p><ul><li><code>User</code><ul><li>侧重于任何被視為人實體或非人實體的對象。</li><li>對系統和資源的授權將<strong>不僅受限於標准角色，還包括屬性狀態、對該實體的分析、特定時間的需求以及訪問資源和數據的理由</strong>。</li></ul></li><li><code>Device</code><ul><li>「條件授權能力」將圍繞系統和執行可接受基準和<code>設備狀態</code>的強制執行。</li><li>系統將持續評估inventories存和遙測數據的當前狀態。進一步的信息將通過<code>狀態掃描和日誌記錄</code>獲取。</li><li><code>系統將能夠實時更新</code>，或者在協調或其他糾正方法的請求下進行更新。</li><li>訪問數據的系統受到的審查程度和要求將與<code>嘗試訪問的數據的安全級別</code>相關。</li></ul></li></ul></div></details><details class="toggle" style="border: 1px solid  Workload and Data Capability"><summary class="toggle-button" style="background-color:  Workload and Data Capability;">Aggregate Capabilities 2: Zero Trust Infrastructure</summary><div class="toggle-content"><p>針對 <code>Infrastructure</code> 的聚合能力主要與 <code>Network and Environments Pillar</code> 有關</p><ul><li>建立在這個支柱上的控制與任何ZT啟用基礎設施的能力有關。</li><li>這不僅可以包括本地基礎設施，還可以包括雲資源。</li><li>可以設計一個宏觀和微觀分割策略，將特定的工作負載分割和隔離，只要這些工作負載被嚴格定義和驗證。這不僅允許所需節點之間的互聯，而且還滿足了軟件定義邊界的連接要求。</li></ul><p>針對保護<code>Application and Workload</code> 的聚合能力主要與 <code>Workloads Pillar</code> 有關</p><ul><li>這個聚合能力包含圍繞工作負載支柱的所有能力。</li><li>這些能力將保護<code>應用程式</code>和為最終用戶<code>提供數據的設備</code>。</li><li>這些能力旨在防止橫向移動，<code>驗證良好的軟體實踐</code>，並將應用程序分割成離散的高度安全的區域。</li><li>對這個區域的連接受到嚴格的審查，並在<code>內部和外部請求之間進行代理</code>。對應用程序呼叫的標準化將有助於適當的實施政策變更和更新。</li></ul><p>針對保護<code>Data</code> 的聚合能力主要與 <code>Data Pillar</code> 有關</p><ul><li>這個聚合能力包含圍繞數據支柱的所有能力。</li><li>這個能力主要在保護資料，飽含標記資料、識別敏感資料、防止外洩或加密敏感資料。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Aggregate Capabilities 3: Analytics and Orchestration</summary><div class="toggle-content"><p>針對<code>Analytics</code>的聚合能力主要與 <code>Visibility &amp; Analytics Pillar</code> 有關：</p><ul><li>在這個支柱下的能力是<strong>連續實體監控、感應器、日誌記錄、事件驅動的分析工具和機器學習的結合</strong>。</li><li>ZT 將<strong>利用機器學習來建立環境數據和分析的基準</strong>。</li><li>機器學習演算法提供基準數據集，通過人工智慧在 ZT 協調中實現 ZT 政策執行。</li></ul><p>針對 <code>Orchestration</code>(協調)的聚合能力主要與 <code>Automation &amp; Orchestration Pillar</code> 有關：</p><ul><li>其焦點將是<code>提供自動化</code>，以<strong>部署政策變更，以確保企業並在敏感數據周圍進行控制</strong>。</li><li>自動化和協調支柱還能夠考慮從軟體定義企業中引入所需目標狀態數據 account for the ingestion of desired target state data from the Software-Defined Enterprise. 。</li><li>雖然早期能力將集中在政策部署上，但隨著技術的演變，<strong>未來的演進將在核心能力中增加人工智慧和機器人流程自動化的能力</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Dependency Capabilities 4: Zero Trust Enabling</summary><div class="toggle-content"><p>以下是成功應用 ZT 安全策略的關鍵：<br><strong>數據治理：</strong></p><ul><li>數據治理是成功應用 ZT 安全策略的關鍵要素。</li><li><code>數據治理提供了管理從數據創建到處理的流程、工具和框架</code>。</li></ul><p><strong>ZT 和風險管理：</strong></p><ul><li>ZT 提供新的發現內容，供風險管理框架（RMF）使用。</li><li>ZTA 導致風險管理框架（RMF）內的流程為 ZT 提供新的發現內容，同時適應 DevSecOps 等現代應用開發實踐。</li><li>影響主要集中在準備、評估和監控步驟。</li><li>準備階段需要大量的發現工作，特別是對數據流的記錄和分割政策的制定。</li><li>隨著 DevSecOps 能力修改應用程序，評估將有所改變。</li><li><code>ZT 需要大量的監控活動，改進反饋給 RMF 過程和事件響應</code>。</li></ul><p><strong>軟體定義企業Software Defined Enterprise：</strong></p><ul><li>軟體定義企業是實現 ZT 架構廣度和深度的關鍵因素。</li><li><code>虛擬化和軟體定義的基礎設施允許隔離數據和應用程序</code>。</li><li>域協調和控制提供企業控制計劃，以推動與 ZT 控制相符的配置和政策。</li></ul></div></details><h2 id="Pillars-Resources-Capability-Mapping">Pillars, Resources &amp; Capability Mapping</h2><p><img src="https://i.imgur.com/4JdywWA.png" alt=""><br>上圖展示「ZT支柱、資源與能力映射」概念展示如何在架構內實施安全措施的操作視角。</p><ul><li><strong>NPE(non-person entity)身份和個人身份獨立追蹤</strong>，允許在執行點之間分離驗證信心水平的驗證路徑。</li><li>認證和授權活動將在企業內的多個專注點上進行，包括使用者和端點、代理、應用程式和數據。</li><li>在每個執行點，<strong>日誌被送往SIEM，進行分析以開發信心水平</strong>。</li><li><strong>設備和使用者的信心水平是獨立開發的，然後在適當情況下進行彙總</strong>，以供策略執行使用。</li><li>如果非人實體或個人實體的<strong>信心分數超過閾值，則它們被授權查看所需數據</strong>。</li><li><strong>數據在途中透過數據防洩（DLP）進行保護</strong>，同時也將數據餵養到SIEM，以確保正確使用數據。</li></ul><details class="toggle" ><summary class="toggle-button" style="">Enterprise Identity Service 企業身份服務</summary><div class="toggle-content"><p>企業身份服務包括三個主要組件：</p><ul><li><strong>聯合企業身份服務（FEIS）Federated Enterprise Identity Service</strong><ul><li>聚合身份憑證和授權，並在聯合組織之間共享，以實現<code>跨域訪問服務</code>。</li></ul></li><li><strong>自動帳戶配置（AAP）Automation Account Provisioning</strong><ul><li>提供身份治理服務，<code>管理用戶權限，執行業務角色</code>，以及基於<code>人員中心活動的帳戶設置和撤銷</code>。</li></ul></li><li><strong>主用戶記錄（MUR）Master User Record</strong><ul><li>實現整體的知識、<code>審計和數據匯總</code>報告，顯示誰可以訪問哪個系統或應用。</li><li>還支<code>援識別內部和外部威脅</code>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Client and Identity Service: ICAM(Identity/Cridential Access Management) 提供德能力</summary><div class="toggle-content"><p><strong>ICAM 提供的能力</strong>：</p><ul><li><strong>持續認證</strong>：一種認證概念，利用多種兼容的認證策略，在用戶和非人實體試圖訪問資源和數據時，以<code>持續的、幾乎即時的方式驗證其身份</code>。</li><li><strong>條件授權</strong>：在授權一個資源時，需要<code>基於請求者的持續信任來決定</code>。這種信任可以受到設備衛生狀況、用戶和實體行為以及其他因素的影響。</li></ul><p>**Comply-to-Connect（C2C）**服務</p><ul><li>在整個網絡基礎設施上運作的一個工具和技術框架，用於<code>發現、識別、描述並報告連接到網絡的所有設備</code>。</li><li>C2C 能力將協調多個工具，<code>防止不符合規定和未經授權的設備和人員連接到網絡</code>，從而保持網絡的安全配置，按照建立的標準和配置保護信息。</li><li>設備衛生：<code>檢查設備的狀態</code>，檢查是否存在惡意軟件或漏洞，以及管理和未受管理資產的安全控制合規性狀態，以確定允許設備訪問資源和數據的風險水平。</li></ul><div class="note info flat"><p>ICAM 是 “Identity, Credential, and Access Management”（身份、憑證和訪問管理）的縮寫，它是一個在資訊技術和資訊安全領域中的概念，旨在確保組織內部和外部的用戶和實體（如設備、系統等）可以安全且適當地訪問敏感資源和數據。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">Data-Centric Enterprise 企業中心數據</summary><div class="toggle-content"><p>企業中心數據主要決策點有分三個部分，主要做Authorization：<br><strong>資源授權決策點 Resource Authorization Point</strong> &amp; <strong>應用授權決策點 Application Authorization Point</strong></p><ul><li>將評估結合的非人實體和用戶，以授權訪問請求。</li><li>與前面的決策點一樣，這將利用信心水平和定義的策略來判斷是否有權訪問。</li></ul><p><strong>應用授權決策點 Application Authorization Point</strong> 的能力：</p><ul><li>保護應用工作負載 Securing Application Workload：能夠保護和管理應用層以及計算容器和虛擬機。能夠識別和控制技術堆棧，以實現更細粒度和準確的訪問決策。</li><li>保護供應鏈 Securing Supply Chain：能夠防止或應對軟體供應鏈攻擊，這種攻擊發生在網絡威脅行為者滲透軟體供應商的網絡，並使用惡意代碼在供應商將軟件發送給客戶之前損害軟件。</li></ul><p><strong>數據授權決策點 Data Authorization Point</strong></p><ul><li>數據所有者使用 ZT 措施通過協調或數據損失防護/災害恢復（DLP/DRP）服務器對<code>數據進行標記</code>。</li><li>數據標記將用於<code>確保所有數據的適當訪問控制得到滿足</code>。</li><li>能力：<ul><li><code>保護數據 Securing Data</code>：流程和技術控制，用於識別、分類、安全處理、保留和處理數據。</li><li><code>數據發現和分類 Data Discovery</code> ：能夠發現、分類、標記和報告數據，包括數據庫中的敏感數據和風險數據。</li><li><code>動態數據遮蔽 Dynamic Data Masking</code>：提供列級安全功能，使用遮蔽策略在查詢時選擇性地遮蔽表和列。<ul><li>列級安全功能（Column-level security）是一種數據安全措施，它允許在數據庫中對單獨的列（也就是數據表的某個特定欄位）進行安全設置和控制。</li></ul></li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">Automation and Orchestration 自動化和協調</summary><div class="toggle-content"><p>內容提到了自動化和協調方面的重點，以及一些相關的能力和技術：<br><strong>自動化和協調：</strong></p><ul><li><strong>政策引擎和自動化 (SOAR)：</strong> 這些術語用於定義處理威脅管理、事件響應、政策執行和安全政策自動化的技術。零信任 (ZT) 架構將需要動態政策執行和自動化。SOAR 將與分析和政策引擎協同工作，以發展信心水平並自動將政策傳遞到執行點。</li><li><strong>能力：</strong><ul><li><strong>軟體定義企業：</strong> 能夠在物理基礎架構上創建虛擬化層，並以自動化的方式在中心進行管理，利用基於政策的訪問控制動態創建、配置、提供和解除虛擬化網絡功能、系統功能、安全功能和工作流程。</li><li><strong>網絡安全協調：</strong> 能夠協調和自動化不同的零信任活動，並將它們與核心系統進行接口和協調。</li></ul></li></ul><div class="note info flat"><p>SOAR代表“Security Orchestration, Automation, and Response”的縮寫，翻譯成中文就是「安全協調、自動化與響應」。它是一種資訊安全技術，旨在將安全運營流程自動化、協調和優化，以更快速、更有效地應對安全事件和威脅。這種技術整合了自動化工具、流程協調和威脅情報，使組織能夠更迅速地識別和應對安全威脅，同時降低人工干預的需要。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">Monitoring and Analysis Services 監控與分析服務</summary><div class="toggle-content"><p>這篇論文主要探討「監控與分析服務」，以下是其中重點的解釋：</p><p><strong>分析與信心評分：</strong></p><ul><li>這個系統通過對事件和事故日誌的系統性分析，使用<code>統計學或其他定義的功能性過濾器或計算方法，來獲取信心分數</code>。</li><li>這些分數表示在特定誤差範圍內，對於給定的分析數據集，對統計參數的估計被確定為真實的概率/百分比值。</li><li>在特定情況下，例如零信任環境中，這<strong>代表用戶或NPE（非人類實體）聲稱自己是誰的概率</strong>。</li><li>能力：<ul><li>分析：系統地應用<code>統計</code>和/或<code>邏輯技術</code>來描述、概括和評估數據。</li></ul></li></ul><p><strong>使用安全信息和事件管理的日誌記錄：</strong></p><ul><li>活動數據被匯總並存<code>儲在安全信息和事件管理（SIEM）系統</code>中，該系統提供安全信息管理（SIM）和安全事件管理（SEM）功能。</li><li>能力：<ul><li>審計/傳感器和遙測：直接<code>驗證（例如通過檢查、檢驗或計算）活動或設備</code>，以確保符合安全要求。實體包括用戶和NPE、傳感器可靠性、合規計劃和共享服務。</li></ul></li></ul></div></details><h1 id="DOD-Learn-from-Use-Case">DOD - Learn from Use Case</h1><div class="note warning flat"><p>主要能夠回答以下文題，才給予紀錄並筆記：</p><ol><li>怎麼確保AP與Database之間滿足零信任架構。</li><li>應該怎麼實現動態的Policy存取控制</li><li>在AP與DB之間如何做到持續性的驗證</li></ol></div><hr><blockquote><p>特色：說明針對 Data Center 應該注重的地方</p></blockquote><p><img src="https://i.imgur.com/j8vFKlW.png" alt=""><br>當今的資料安全方法建立在過時的、孤立的網絡中心策略和方法的基礎上。在這種網絡中心的安全模型中，數據容易受到威脅，因為<strong>僅通過基本的安全實踐（如用戶名/密碼、基於用戶/設備的訪問和僅在靜態時加密）以及標準的基於角色的訪問控制（RBAC）來保護數據，而這種控制很少被更新或驗證</strong>。威脅行為者可以迴避這些基本的保護措施。因此從上述來看，文中提到以下針對數據中心應該要實現的能力：</p><ul><li>Encryption: 數據中心的技術，主要在靜態時、字段和記錄內部、傳輸中數據要進行<code>加密</code>。</li><li>Policy Enforcement 中包含<code>數據標記</code>：<ul><li>用途1: 以提供數位版權管理（<code>DRM</code>）和數據丟失防護（<code>DLP</code>）解決方案的數據。</li><li>用途2: 從而允許創建使用<code>基於屬性的訪問控制（ABAC）</code>的額外動態策略。</li></ul></li></ul><blockquote><p>特色：說明貼標籤 和 其他存取動作應該做的時機點（圖片透過<code>禁止</code>來表達誰負責<code>阻止</code>工作）</p></blockquote><p><img src="https://i.imgur.com/cwTJoro.png" alt=""><br>從上圖中可以看到 PEP 中主要闡述以下幾點來<strong>保護數據存儲（Data Store）中的數據</strong>：</p><ul><li><strong>數據標記（Data Tagging）</strong><ul><li>時機：在創建或導入文檔時進行</li><li>工作：<ul><li>對於組織來說，<strong>了解擁有哪些資料</strong>，資料的特性，以及滿足適當資料保護標準所需的隱私和安全需求非常重要。</li><li>組織可以將數據分類並賦予各種屬性。這些屬性可以用於對數據進行分類，例如個人身份信息（PII）和敏感數據。</li></ul></li></ul></li><li><strong>數據權限管理（DRM）+ 數據遺失防止（DLP）+ 安全信息和事件管理（SIEM）+ 數據存儲 進行協作</strong><ul><li>時機：數據標記後</li><li>保護措施：以下這四種保護措施，再加上前面提到的加密等密碼技術，為資料中心的零信任架構提供了強大的資料保護。<ul><li>SIEM：<code>收集並分析</code>對任何被訪問的數據的<code>訪問和變更</code>。</li><li>DRM：可以<code>允許或阻止</code>對數據的訪問、編輯或複製，</li><li>DLP：可以<code>阻止</code>對數據的訪問和傳輸。</li><li>DDM：如果用戶/端點被認為是值得信賴的，並且已經獲得對數據的訪問權限，動態數據遮罩（DDM）將在訪問和傳輸數據時<code>對數據進行遮罩和修改</code>。</li></ul></li></ul></li></ul><div class="note info flat"><p>可能會好奇，DLP跟DRM都有阻止的作用，那他們的差異是？<br><code>DLP 主要針對未知來源的請求，而DRM則是針對已知來源的請求。</code></p></div><blockquote><p>特色：有提到SIEM跟SOAR的關係等監控機制</p></blockquote><p><img src="https://i.imgur.com/m8gsuSe.png" alt=""></p><ul><li>PEP: PEP 認證後，對加密資料進行解密工作，給請求的 user / device</li><li>SIEM: 任何請求都會被 SIEM 所紀錄，並且進行分析，一但發現可疑的地方就會觸發事件通知SOAR，由 SOAR (Security Orchestration, Automation, and Response) 處理。</li><li>SOAR: 遵循事件響應程序，可以<code>部署緩解策略</code>來<code>終止現有會話</code>、<code>重新加密數據</code>並<code>更新 PEP 上的策略</code>以拒絕未來的請求。</li></ul><blockquote><p>特色：主要提到 PDP，並說明PDP主要處理請求(標籤,DRM,DDM,DLP,加密連線相關)，PEP 則是即時保護資料和接收（加密,標籤,DRM 相關）。</p></blockquote><p><img src="https://i.imgur.com/KAmczyW.png" alt=""></p><ul><li>架構優勢：強調保護資料本身，而非僅限於資料邊界。</li><li>資料請求路由：透過政策決策點（PDP）進行，未滿足政策的請求無法訪問。</li><li>政策更新：PDP政策即時通過設備健康、特權訪問管理和分析保持更新。</li><li>連接管理：PDP政策變更時，PEP可終止現有連接。</li><li>資料保護：多個策略執行點（PEP）持續保護資料，並使用加密、標記、遮罩DDM和防止損失DLP等措施。</li><li>政策協調：ZT架構組件間的政策協調實現深度防禦，維護資料完整性、可用性和機密性。</li></ul><blockquote><p>特色：著重在 Analysis + AI/ML 對於 Policy 的應用。<br><img src="https://i.imgur.com/w48kovr.png" alt=""></p></blockquote><ul><li>ZT 模型中透過 AI 大幅提升環境的可見性、洞察力和自動化能力。</li><li>全面收集與分析：從環境的各個方面集中收集數據並進行分析。</li><li>透過 SIEM 分析，發現威脅則透過SOAR處理。</li><li>未來分析使用：這些信息將被記錄並存儲，以用於未來的機器學習和人工智慧，包括用戶/非特權實體的信心評分、高級威脅檢測、創建和修改基準線，以及與外部情報計劃和其他人工智慧一起進行自動化和編排。</li></ul><h1 id="DOD-零信任架構-Pattern">DOD - 零信任架構 Pattern</h1><div class="note warning flat"><p>應該要根據內容的章節7.1與7.2歸納出所有架構的pattern，並且指出研究適用的Pattern與說明原因。</p></div><h2 id="Domain-Policy-Enforcement-for-Resource-Access">Domain Policy Enforcement for Resource Access</h2><p><img src="https://i.imgur.com/bPpmMu1.png" alt=""></p><ul><li><strong>說明</strong>：主要架構分三段 Resource Domain：Secured User or Device / Secured Network / Secured Application and Data ，<code>每一段都有他們自己的 domain orchestrator 可以想像是設定 policies 的地方</code>，然後Controller進行控制，而做到統一的方式就是透過 Networ + application and data 的 orchestrator 收集資料，並傳送到 Cybersecurity Domain Orchestrator 近一步分析可疑的地方。一但發現威脅，就會透過 automated 調整 policies，以減少威脅。</li><li><strong>優點</strong>：可以根據不同的 Domain <code>精準設定</code> policies，並且透過 Controller 進行控制。這可能更像我的研究內容，針對AP與DB之間的控制措施。</li><li><strong>缺點</strong>：透過分成不同的 Domain Policy Enforcement 在資料傳輸的過程中，可能有<code>授權驗證的不一致性</code>。</li></ul><h2 id="Software-Defined-Perimeter">Software Defined Perimeter</h2><p><img src="https://i.imgur.com/Gip0hBe.png" alt=""></p><ul><li><strong>說明</strong>：其主要特性有二，一個可用來轉發 <code>end-to-end 之間訊息並進行攔截中斷以執行零信任授權的 gateway</code>。另一個主要是說需要在<code>端點上安裝代理</code>，執行身份驗證、健康狀態檢查、扮演類似PEP的角色。而這邊需要注意的是，會<code>透過Broker來進行端點註冊、授權</code>，作為PDP的角色存在。如果授權驗證通過，就會透過 Gateway 建立 Proxy 進行 Direct Link 連接兩個端點的連線。</li><li><strong>優點</strong>：容易做到<code>政策控制的統一性</code>，並且能夠確保所有連接的<code>裝置都是受管控</code>的，因為必須裝 Agent 才得以建立連線。</li><li><strong>缺點</strong>：<code>技術難度</code>感覺較高，需要有完整的註冊流程和建立連線流程，在連線上的考慮更多。</li></ul><h2 id="ZT-Broker-Integration">ZT Broker Integration</h2><p><img src="https://i.imgur.com/WLnOzP0.png" alt=""></p><ul><li><strong>說明</strong>：與Software Defined Perimeter有點類似，所有應用程序都對最終用戶網絡隱藏，並且所有連線都須透過信任代理進行連接。但這可能會與Software Defined Perimeter有一點混淆，他們都有Broker, Agent但是差在哪裡呢？差異大概有以下：<ul><li>Broker 同時作為 PDP 和 PEP ，PEP 和 PDP 可以成對分佈(可以多個)，由單個虛擬服務實現，並且可以進行load balancer實現。</li><li>Broker 可以分散在 edge, 中間層 mid-tier 或是 data center</li><li>Service Proxy 是裝在 Broker 裏面，不是 Resource Application</li><li>並沒有強調要透過 Gateway 來進行連接(Proxy連線)。</li></ul></li><li><strong>優點</strong>：PEP, PDP 可以在多個地方部署、load balancer，甚至是以單個虛擬服務實現，可以更普遍的設置存取控制點在不同的地方。</li><li><strong>缺點</strong>：但是在多個地方同時有PEP,PDP的情況下，可能會造成<code>授權驗證的不一致性</code>，並且 Resource Application 沒有安裝 Agent，<code>不能保證應用程式是受管控</code>的。</li></ul><h2 id="Micro-Macro-Segmentation">Micro / Macro  Segmentation</h2><p>Micro / Macro Segmenetaion 主要是透過第三層網路架構的方式實現ZTA，與本文章想要探討的主題有點不同，因此不會做太多說明與介紹。<br><img src="https://i.imgur.com/2f4DCSy.png" alt=""></p><ul><li><strong>說明</strong>：在這個架構中，主要角色是 Next Generation Firewall，在這種架構中，所有的流量在<code>到達其目的地微分區之前都必須通過NGFW</code>。在某些情境，微分區可以繼續分解成更小的組件，定義進程對進程的微分區，並<code>演變為API微分區</code>。當用戶對三層Web應用程序進行請求時，流量會先經過Web服務的PEP &gt; 再由應用程式PEP評估流量 &gt; 請求返回給用戶之間再進行評估一次。總共三層，這種方式確保了在多層應用架構中，每一個階段的流量都經過了嚴格的策略評估，從而增強了安全性。但是問題是，<code>應用程式到資料庫之間，並沒有任何評估，就變像是相信應用程式</code>。</li></ul><h1 id="DOD-成熟度模型">DOD - 成熟度模型</h1><div class="note warning flat"><p>這邊主要說明若要滿足ZTA的成熟度模型，需要做到哪些事情。</p></div><h2 id="Preparae-for-ZTA">Preparae for ZTA</h2><div class="note info flat"><p>關鍵字：辨識重要資源清單、資料流、網路流量Log</p></div><p>要做的事情主要有兩個部分：</p><ul><li><code>Discovery</code><ul><li>辨識 DAAS (數據、應用程序、資產和服務)</li><li>對照 data flows</li><li>建立 使用者 和 裝置清單</li><li>辨識特權帳戶</li><li>紀錄網路 traffic</li></ul></li><li><code>Assessment</code><ul><li>利用現有標準確定合規狀態</li><li>確定帳戶有適當的權限</li><li>確保網路/環境安全設定滿足最小權限原則</li></ul></li></ul><h2 id="ZTA-Baseline">ZTA Baseline</h2><div class="note info flat"><p>關鍵字：<code>網絡分段</code>、<code>最小權限原則</code>、<code>MFA</code>、<code>資料辨識標籤</code>、<code>加密</code></p></div><p>要做的事情主要有以下：</p><ul><li>確保存取 DAAS 的時候是經由 Cybersecurity policies 所決定的。</li><li>網絡採用拒絕全部/例外允許進行分段 （白名單）</li><li>裝置IT的安全政策要求並管理</li><li>實現最小權限存取</li><li>使用 MFA</li><li>進行 data 辨識，並標示敏感或關鍵資料</li><li>滿足加密要求</li></ul><h2 id="ZTA-Intermediate">ZTA Intermediate</h2><div class="note info flat"><p>關鍵字：<code>細顆粒度</code>、<code>Micro-Segementation</code>、<code>EFIS</code>、<code>PAM</code>、<code>DLP &amp; DRM</code>、<code>UEBA</code></p></div><p>要做的事情主要有以下：</p><ul><li>加強 cybersecurity 政策，基於細顆粒度(user and device attribute)進行控制</li><li>主要網路段使用 Micro-Segementation</li><li>User 基於 Enterprise Federated Identity Service 進行驗證</li><li>透過 Privileged access management (PAM) 增強最小特權</li><li>實施 DLP &amp; DRM</li><li>資料透過 flow analysis 和簡單的自動化進行標籤與分類</li><li>使用者和Entity的行為分析（UEBA, User and Entity Behavior Analytics）建立 baseline policy</li></ul><h2 id="ZTA-Advanced">ZTA Advanced</h2><div class="note info flat"><p>關鍵字：<code>動態決策</code>、<code>持續驗證與授權</code>、<code>user + device 滿足 EFIS</code></p></div><p>要做的事情主要有以下：</p><ul><li>可以做到動態的決定是否可以存取 DAAS，強大的實時分析驅動</li><li>完全的 micro-segmentation</li><li>持續性適應驗證與授權</li><li>User + Device 基於 Enterprise Federated Identity Service 進行驗證</li><li>完全的實施 Just-in-Time 和 Just-Enough 的存取政策</li><li>透過 machine learning 進行資料的標示與分類</li><li>進階分析技術，使威脅檢測能夠自動化並根據事先設計的策略進行協調</li></ul>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> Zero Trust </category>
          
          <category> 畢業論文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碩士論文 </tag>
            
            <tag> Zero Trust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIST SP 800-209 資料儲存安全指引 Security Guidelines for Storage (2) 安全指引</title>
      <link href="/posts/security-for-storage-infra-2/"/>
      <url>/posts/security-for-storage-infra-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>因為之前的篇幅<a href="/security-for-storage-infra">NIST SP 800-209 資料儲存安全指引 Security Guidelines for Storage (1) 威脅與風險</a>擔心太長，因此再建立一的新的Post來進行整理。</p><div class="note info flat"><p>上一篇主要針對資料儲存基礎設施盤點相關的威脅、風險和攻擊面。<br>本篇則是主要整理儲存部署的安全建議。<code>論文的貢獻可以在於強調可以滿足零信任要求與資料儲存相關安全標準SP800-209的相關措施。</code></p></div><h1 id="4-儲存部署安全建議-Security-Guidelines-for-Storage-Deployments">4. 儲存部署安全建議 Security Guidelines for Storage Deployments</h1><p>第4.1至4.12節提供了<strong>存儲基礎架構安全的安全建議和指南</strong>，透過其命名和編號方案旨在確保每個指南都有獨特的識別號。主要的唯一識別號採用“<strong>xx-SS-Ry</strong>”的形式。</p><p>但是，因為本人的論文希望更著重在，AP(客戶端)與資料儲存裝置之間連線時和主機本身的安全措施，<code>因此本章節並不會列出所有的安全建議，僅列出與AP(客戶端)與儲存裝置之間，又或是「儲存基礎設施本身」的安全建議</code>。</p><div class="note info flat"><ol><li>“xx”是與節點標題相關的兩個字母組合：在第4.1節“物理存儲安全”中，主要識別號標記為PS-SS-R1，PS-SS-R2等</li><li>“SS”代表“Storage Security”</li><li>“y”是連續的數字識別號：如果有細項還會透過&quot;a&quot;, &quot;b&quot;表示，例如‘PS-SS-R1.a’（遵循NIST SP 800-53，第3.10節），‘PS-SS-R1.b’（供應鏈保護）等。</li></ol></div><div class="note warning flat"><p>我的感想：<strong>這個章節可以用來整理，如果要檢查AP、AP Host本身、儲存裝置Host本身、儲存裝置之間的安全措施，根據這些安全建立來進行檢查，並作為檢查項目之一，以此來進行授權與存取控制，避免可能的安全威脅</strong>。</p></div><h1 id="4-1-PS-實體儲存安全-Physical-Storage-Security">4.1 (PS) 實體儲存安全 Physical Storage Security</h1><p>實體安全是確保任何資訊科技「基礎建設安全」的「基本要素」。很多時候「<strong>儲存基礎建設的實體安全」要求與「其他基礎建設元素」</strong>（例如電腦和網路設備）<strong>相同（例如設施安全、監控、運輸等）</strong>。</p><ul><li><strong>基礎建設元素</strong>可以參考的相關標準包含：<code> NIST SP 800-53, Rev5 NIST SP 800-171</code> 。</li><li>有關<strong>媒體處置和銷毀</strong>可以參考：<code>ISO 27040, NIST SP 800-88</code> 有更近一步的討論。</li></ul><div class="note info flat"><p>因此本章節主要提供針對<code>儲存基礎建設獨有的實體安全</code>，或其他刊物中較少強調的方面進行條例介紹。</p></div><details class="toggle" ><summary class="toggle-button" style="">要求：PS-SS-R1 確保媒體安全 Media security measures</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px"><code>PS-SS-R1</code></div></th><th>確保媒體安全</th></tr></thead><tbody><tr><td><code>PS-SS-R1.a</code></td><td>建議<strong>遵循NIST SP 800-53, Rev5</strong> 的一些特定指導措施，包括制定政策、限制訪問權限、標記敏感信息、安全存儲、安全傳輸、確保數據</td></tr><tr><td><code>PS-SS-R1.b</code></td><td>建議購買擁有<strong>足夠供應鏈保護的媒體</strong>。</td></tr><tr><td><code>PS-SS-R1.c</code></td><td>對於敏感數據，<strong>「備份實體」媒體儲存與「主要數據儲存」地點應該足夠遠</strong>。</td></tr><tr><td><code>PS-SS-R1.d</code></td><td><strong>整理敏感數據的清單</strong>，並應紀錄的內容包含：敏感級別、分類(與哪些應用和服務相關)、加密級別、如果數據破壞或丟失可能對系統造成的影響、應急的措施與程序、數據與其他應用之間的依賴關係。</td></tr><tr><td><code>PS-SS-R1.e</code></td><td>敏感的<strong>可移動媒體，應使用高級追蹤控制措施</strong>，例如RFID標籤、GPS追蹤設備、防竄改保護。</td></tr><tr><td><code>PS-SS-R1.f</code></td><td><strong>極度敏感</strong>的資訊，應考慮使用自我激活或遠程控制的<strong>自我毀滅機制</strong>，同時應仔細考慮如何保護這些功能以避免被攻攻擊者作為攻擊目標，觸發設備毀損機制。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：PS-SS-R2 保護所有敏感管理裝置 Protect all sensitive administrative equipment</summary><div class="toggle-content"><p>可以**對儲存設施進行存取的「管理工作站」**應該要有以下措施：</p><ol><li><code>有組織批准之安全控制</code>：對於可以「獲取儲存基礎設施」的「敏感工作站」應進行管理訪問，使用經組織批准的安全控制，包含訪問、監控和審計。</li><li><code>與數據保護一樣嚴謹的安全等級</code>：保護「管理工作站」（包含家中所使用的工作站環境）的安全措施至少要與「保護數據」或「使用數據的系統」擁有一樣嚴格的安全措施。</li></ol></div></details><details class="toggle" style="border: 1px solid  including non-obvious storage components"><summary class="toggle-button" style="background-color:  including non-obvious storage components;">要求：PS-SS-R3 資料消除方法應該包括儲存基礎設施中的各個元件 Data sanitization approach should cover storage infrastructure in detail</summary><div class="toggle-content"><ul><li>資料消除方法應該包括儲存基礎設施中的各個元件，而這些元件可能包含敏感資訊，<strong>應確保儲存基礎設施中的元件間都納入組織的資料消除政策</strong>，這些元件包含以下：<ul><li>非揮發性記憶體</li><li>快取對象（儲存陣列、SAN交換器、路由器等）</li><li>韌體/BIOS設定和HBA級別的設置</li></ul></li></ul></div></details><h1 id="4-2-DP-資料保護-Data-Protection">4.2 (DP) 資料保護 Data Protection</h1><p>本章節主要探討資料保護的相關措施、角度、分離程度等進行探討。而相關要求應該要考慮到以下層次：</p><details class="toggle" ><summary class="toggle-button" style="">資料保護不同角度</summary><div class="toggle-content"><p>在這個章節中，主要討論資料保護的目標和相關活動，從不同的角度進行控制，包含以下：</p><ol><li><strong>資料備份和恢復（Data backup and recovery）</strong>：這是確保資料在<code>意外故障或災難性事件後復原</code>的重要控制措施。</li><li><strong>存檔（Archiving）</strong>：這是將資料保留在長期存儲中的控制措施，通常用於保存歷史資料或法規要求的資料。</li><li><strong>複製技術（Replication technologies）</strong>：這是在不同位置或系統之間建立資料複製的控制措施，以確保在主要<code>系統故障時能夠使用備用系統</code>。</li><li><strong>持續資料保護（Continuous data protection）</strong>：這是一種<code>持續監視資料變化</code>並<code>即時備份</code>的控制措施，能夠快速恢復到特定時間點的資料。</li><li><strong>點對點拷貝和快照（Point-in-time copies and snapshots）</strong>：這是在特定時間點上複製資料的控制措施，以便在<code>需要時進行還原或查詢</code>。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">識別區分數據平面</summary><div class="toggle-content"><p>當我們談論儲存管理和保護數據時，<strong>區分不同的數據平面</strong>對於<strong>更好地理解和管理儲存系統至關重要</strong>。這是因為數據平面提供了一種方式來組織和區分數據相關的存取方法、協議、操作和授權，從而確保系統可以在不同層面上有效運作並滿足不同的需求。數據平面的主要類型包含：</p><ol><li><strong>數據消費平面</strong>：該平面涉及<code>執行I/O操作</code>的存取方法和協議，以及相關的網絡連接。這是用戶和應用程序進行數據讀取和寫入的平面。</li><li><strong>數據管理平面</strong>：該平面<code>涉及創建、配置、映射設備</code>以及設備屬性的<code>管理</code>。它關注的是管理儲存系統中數據的元信息和配置信息。</li><li><strong>數據保護平面</strong>：該平面涉及<code>數據的保護和備份</code>。它包括複製、快照、備份、存檔等操作，以確保數據的持久性和容災能力。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">資料平面分離程度</summary><div class="toggle-content"><p>通常情況下，<strong>增加資料平面的細粒度和分離程度可以積極地影響資料資產的安全性</strong>，而設計和實施可能極大地影響，而這些設計和實施包含：</p><ol><li><strong>網路層兩層分離</strong>：例如使用不同的<code>VLAN</code>增加分離程度。</li><li><strong>網路邏輯分離</strong>：<code>獨立的IP子網路</code>增加分離程度。</li><li><strong>過濾和訪問控制列表ACL</strong>：在資料的<code>消費平面添加ACL</code>防止管理操作，增加「消費」與「管理」平面的分離程度。</li><li><strong>授權分離</strong>：限制每個角色的權限，<code>不同平面所使用的角色</code>不同。</li></ol></div></details><div class="note info flat"><p>在該節中，也提供了針對上述每個控制措施的實施相關的嚴謹建議。而且，<code>其他相關的需求還包含在第4.7節“隔離”和第4.8節“還原保證”中，這些需求與資料保護密切相關</code>。</p></div><h2 id="4-2-1-資料備份、恢復和儲存-Data-Backup-and-Recovery-and-Archiving">4.2.1 資料備份、恢復和儲存 Data Backup and Recovery, and Archiving</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R1 建立資料保護計劃或政策的文件</summary><div class="toggle-content"><p>這份文件旨在確保在<strong>部署系統或資料存儲解決方案之前，組織有一個完整的、安全的資料保護計劃</strong>，以應對可能出現的數據損壞、故障或安全問題。這些措施將<code>有助於保護數據的完整性和可用性</code>，同時確保遵守相關的法規要求。</p><table><thead><tr><th><div style="width:100px"><code>DS-SS-R1</code></div></th><th>建立資料保護計劃或政策的文件</th></tr></thead><tbody><tr><td><code>DP-SS-R1.a</code></td><td>層級、頻率和備份數量規格，以滿足組織的恢復目標。應包含如下：<br> - 頻率和保留期：例如，每48小時快照、每日30份備份。<br> - 類型：例如，完整備份、增量備份、連續備份（如文件版本控制、日誌或日誌運送和存檔）、複製、點對點備份等。</td></tr><tr><td><code>DP-SS-R1.b</code></td><td>要使用的媒體類型。</td></tr><tr><td><code>DP-SS-R1.c</code></td><td><strong>加密要求</strong>應用於「備份數據」的加密方法應至少<strong>與「受保護數據」的加密程度相同</strong>。</td></tr><tr><td><code>DP-SS-R1.d</code></td><td>其他保護要求，例如數位簽章、存檔、位置、設施安全（包括防火、防爆和磁干擾保護）、不可變性和鎖定、每個備份集的最低備份数量，以及這些備份的地理分佈。</td></tr><tr><td><code>DP-SS-R1.e</code></td><td>引用適用的法規框架以及相應的控制措施。</td></tr><tr><td><code>DP-SS-R1.f</code></td><td><strong>全面的生命周期管理</strong>，包括根據保護和保留政策跟踪數據副本和備份，包括積極刪除不再需要的數據副本。</td></tr><tr><td><code>DP-SS-R1.g</code></td><td><strong>恢復程序</strong>。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R2 資料保護計劃或政策應盡可能「全面」</summary><div class="toggle-content"><p>資料保護計劃或政策應盡可能「全面」，要求如下：</p><table><thead><tr><th><div style="width:100px"><code>DS-SS-R2</code></div></th><th>資料保護計劃或政策應盡可能「全面」</th></tr></thead><tbody><tr><td><code>DP-SS-R2.a</code></td><td>應<strong>包含企業所有資料資產，無論是本地或雲端</strong>：儘管對於那些沒有重要性的資料，或可以從其他受保護資料來源中，重新建立的資料資產，可以不進行保護，但這樣的例外應有文件紀錄。</td></tr><tr><td><code>DP-SS-R2.b</code></td><td>應<strong>以資料類型進行組織層級</strong>（第一層、第二層）。</td></tr><tr><td><code>DP-SS-R2.c</code></td><td>應考慮<strong>應用程式和業務流程層面的資料完整性</strong>：若是有兩個元件使用相同之資料，進行恢復時需要恢復到相同的時間點才能正常運作，則應該針對這種情境實施「聯邦一致性機制」等解決方案。</td></tr><tr><td><code>DP-SS-R2.d</code></td><td>應考慮到滿足業務或監管要求的<strong>恢復速度</strong>。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R3 對於備份相關的標準作業程序應包含的要求</summary><div class="toggle-content"><p>除了備份計畫或政策之外，與備份相關的標準作業程序應該包括以下內容：</p><table><thead><tr><th><div style="width:100px"><code>DS-SS-R3</code></div></th><th>備份相關的標準作業程序要求</th></tr></thead><tbody><tr><td><code>DP-SS-R3.a</code></td><td>應該<strong>定期檢查備份的執行情況</strong>，並在需要時通知相關人員。</td></tr><tr><td><code>DP-SS-R3.b</code></td><td>定期測試備份：<br> 1. <strong>重要的資料備份可還原性</strong>：應至少每月一次，以驗證其完整性和可還原性。<br> 2. <strong>嚴格要求還原速度的應用程式可用性</strong>：應進行端對端測試環境（例如將數據集完整還原到一個模擬真實還原情況的測試環境中，稱為sandbox recovery environment）。</td></tr><tr><td><code>DP-SS-R3.c</code></td><td>1. <strong>應保持最新的恢復目錄</strong>：追蹤每個副本（包括備份、複製、時間點副本等）的相關資訊，資訊包含防毒工作掃描結果。<br> 2. <strong>對於敏感資料，應定期使用防毒工具</strong>：掃描至少一個過去副本的子集識別是否有被感染的副本。目錄需求可參考CM-SS-R2。</td></tr><tr><td><code>DP-SS-R3.d</code></td><td>定期審查（至少每年一次）<strong>備份計畫和操作程序</strong>，以確保其持續適應當前需求。</td></tr><tr><td><code>DP-SS-R3.e</code></td><td><strong>維護一份審計記錄</strong>，提供必要的資訊以確保操作符合政策要求。</td></tr><tr><td><code>DP-SS-R3.f</code></td><td>應包含必要時所採取<strong>特殊控制措施</strong>（例如，將舊的、有風險的或不再支援的媒體複製到新的媒體中，等等）。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R4 資料保護配置管理的要求</summary><div class="toggle-content"><p>以下要求旨在<strong>確保資料保護配置的安全性、穩定性和一致性</strong>，同時保障系統的高可用性和容錯性。</p><ol><li><strong>集中式管理</strong>：所有與資料保護相關的配置，包括備份、點對點時間複製和複寫等，應該由一個中央管理系統或管理員來統一管理，以確保一致性和效率。</li><li><strong>與資料使用層面分離</strong>：資料保護配置的管理應該與實際的資料使用層面分開。這意味著伺服器和客戶端不應該擁有更改自己資料保護配置的權限，這樣可以防止未經授權的變更和損害。</li><li><strong>防止自我配置</strong>：資料保護系統應該禁止伺服器和客戶端對其自身的資料保護配置進行修改，以保證配置的穩定性和安全性。</li><li><strong>不排除冗余機制</strong>：這項要求明確表示，雖然要集中管理和防止自我配置，但不排除使用冗余機制來保護系統免受單點故障的影響。這樣，即使一部分系統出現故障，其他冗余的部分還可以保持運作。</li></ol></div></details><h2 id="4-2-2-複製和鏡像-Replication-and-Mirroring">4.2.2 複製和鏡像 Replication and Mirroring</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R5 主要與次要儲存的資料保護需一致</summary><div class="toggle-content"><ul><li>同步和非同步「複製」都需要<strong>與主要儲存相同層次的資料保護</strong>。</li><li>包括加密資料在靜止時，以及設定存取限制。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R6 消除不必要的儲存裝置間複製信任</summary><div class="toggle-content"><ul><li>當陣列之間沒有共用複製的卷時，應<strong>禁用它們之間的複製信任</strong>關係。</li><li>陣列之間有共用複製的卷時，應限制它們相互之間的特權，僅限於共用的卷上。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R7 資料在複製和鏡像「傳輸中」的保護</summary><div class="toggle-content"><ul><li>複製和鏡像期間，資料在<strong>傳輸中</strong>的機密性和完整性需要<strong>使用加密保護</strong>。</li><li>當適當的緩解控制措施存在時，可以放寬加密要求（例如在相同機櫃或伺服器房間內進行鏡像）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R8 同步複製的自動I/O暫停</summary><div class="toggle-content"><ul><li>次要儲存伺服器的同步進度落後於主要資料的更新時，應啟用<strong>自動I/O暫停功能</strong>，防止主要儲存裝置上的寫操作。如果繼續允許在主要儲存裝置上進行寫操作，可能會導致<ul><li>資料不一致性、資料遺失風險。</li></ul></li><li>但是<code>需注意</code>：<strong>啟用此功能增加主要儲存裝置受到攻擊的風險</strong>，因為敵對方可能攻擊複製網路路徑來觸發主要儲存裝置的拒絕服務。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R9 刪除過時複製品以減少攻擊面</summary><div class="toggle-content"><ul><li>定期<strong>刪除過時的複製品</strong>，以減少攻擊面。</li></ul></div></details><h2 id="4-2-3-時間點副本-Point-in-Time-Copies">4.2.3 時間點副本 Point-in-Time Copies</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R10 配置點對點複本時應滿足目標要求</summary><div class="toggle-content"><ul><li>確保點對點複本（例如快照）的配置符合<code>目標數據集的恢復點目標（RPO）</code>要求。</li><li>如果業務或合規標準要求在恢復時<strong>最多只能損失五分鐘的已提交數據</strong>，則<strong>快照間隔應為五分鐘或更短</strong>。<ul><li>確保配置足夠數量的每小時快照以滿足保留要求。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R11 刪除過時快照和克隆</summary><div class="toggle-content"><p>定期<strong>刪除過時的快照和克隆</strong>，以減少攻擊面。</p></div></details><h2 id="4-2-4-持續資料保護-Continuous-Data-Protection">4.2.4 持續資料保護 Continuous Data Protection</h2><details class="toggle" ><summary class="toggle-button" style="">要求：DP-SS-R12 使用持續資料保護的安全考量</summary><div class="toggle-content"><ol><li>功能上的優勢：改進的<strong>恢復點目標</strong>（RPO）、更<strong>細緻的保留策略</strong>。</li><li>持續數據保護技術：包括持續數據保護（CDP）、在雲端檔案和對象存儲中對「源數據或副本」進行「<strong>版本控制</strong>」，以及「<strong>事務日誌運送</strong>」。</li><li>協助<strong>改善敏感數據的取證</strong>：回溯到之前的版本可以幫助了解攻擊的特徵、時間等，但可能非常耗時。</li></ol></div></details><h1 id="4-3-AC-身份驗證與數據訪問控制-Authentication-and-Data-Access-Control">4.3 (AC) 身份驗證與數據訪問控制 Authentication and Data Access Control</h1><p><strong>管理用戶及其管理主機</strong>是攻擊者可以利用的攻擊面，特權使用者的不當使用可能導致存儲系統失敗或遭受侵害。實施&quot;<strong>最小權限模型</strong>&quot;並利用特定角色進行管理是重要的。</p><p>根據ISO/IEC 27040標準，應該實施以下角色並在存儲技術中使用：安全管理員、存儲管理員和安全審計員，這些角色的設計有助於確保儲存技術的安全性，並限制特權訪問，降低了存儲系統受到攻擊的風險。<br>好的，我可以幫您做一個表格，來整理這些角色的擁有權限和工作內容。以下是表格的內容：</p><details class="toggle" ><summary class="toggle-button" style="">安全管理員 Security Administrator</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>查看和修改權限</td><td>- 建立和管理<code>帳戶</code><br>- 設置和管理用戶和管理操作的<code>角色和權限</code><br>- 制定與<code>驗證器、憑證和密鑰</code>相關的<code>政策</code><br>- 管理加密和密鑰<br>- 管理<code>審計和日誌記錄</code></td><td>無</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">存儲管理員 Storage Administrator</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>存儲管理員</td><td>查看和修改權限</td><td>- 訪問和管理存儲系統的所有方面</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">安全審計員 Security Auditor</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>安全審計員</td><td>查看權限</td><td>- 進行<code>授權審查</code><br>- <code>驗證安全參數</code>和配置<br>- 檢查<code>審計日誌</code></td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">存儲審核員 Storage Auditor</summary><div class="toggle-content"><table><thead><tr><th>擁有的權限</th><th><div style="width:150px">工作內容</div></th><th>不可做</th></tr></thead><tbody><tr><td>安全審計員</td><td>查看權限</td><td>- 進行<code>授權審查</code><br>- <code>驗證安全參數</code>和配置<br>- 檢查<code>審計日誌</code></td></tr></tbody></table></div></details><h2 id="4-3-1-身份驗證建議-Authentication-Recommendations">4.3.1 身份驗證建議 Authentication Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R1 應確保使用者的唯一識別符號 Unique Identifier for all users</summary><div class="toggle-content"><ol><li>所有使用者（包括管理員）應該擁有一個僅供個人使用的唯一識別符號。</li><li>指派給管理員的識別符號，至少應該符合 NIST 文件 SP800-63A [35] 第 4.2 和 4.5 節中所指定的身份保證級別 3 (IAL 3)。</li><li>唯一的例外是緊急使用帳戶，其安全使用方式在 AC-SS-R16 中有所規定。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R2 集中式認證解決方案 A centralized authentication solution</summary><div class="toggle-content"><ol><li>在大型環境中，應該部署一個集中式認證解決方案（例如 Active Directory、輕量級目錄訪問協議 [LDAP]、單一登錄 [SSO]、經組織批准的雲認證服務），以便密切監控和控制使用者對存儲資源的訪問。</li><li>確保組織的認證政策得到統一執行。</li><li>應該避免使用內建的認證和權限管理功能，最好將其停用。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R3 認證伺服器的配置 Configuration of authentication servers</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px"><code>DS-SS-R3</code></div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R3.a</code></td><td><strong>嚴格控制執行認證服務的伺服器的指派</strong>：將執行認證服務（Authentication Service）的伺服器指定給特定的伺服器，並確保這樣的指派是經過嚴格管理和控制的。</td></tr><tr><td><code>AC-SS-R3.b</code></td><td><strong>應該擁有多個認證伺服器</strong>：以確保可用性，避免單一故障點。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R4 安全連接到集中式身份驗證伺服器 Secure connection to centralized authentication server</summary><div class="toggle-content"><ol><li>集中式身份驗證伺服器與驗證客戶端之間的通訊都應使用最新的安全協議</li><li>例如Transport Layer Security (TLS) 1.2或更高版本。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R5 使用多因素驗證 Use of multi-factor authentication</summary><div class="toggle-content"><ol><li>對於存儲重要數據的基礎架構組件的訪問配置，應該使用至少兩因素驗證</li><li>這些驗證器至少應符合NIST文件SP800-63B [36]第5.1.9節中指定的要求。這項要求對於擔任安全管理員和存儲管理員角色的使用者的訪問應該是強制性的。</li></ol></div></details><h2 id="4-3-2-密碼建議-Password-Recommendations">4.3.2 密碼建議 Password Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R6 安全密碼政策應涵蓋服務帳戶 Secure password policies should cover service accounts</summary><div class="toggle-content"><ol><li>個人張戶與服務帳戶應滿足安全的密碼政策：不僅應用於個人帳戶，還應應用於服務帳戶（例如，簡單網路管理協定（SNMP）、網路資料管理協定（NDMP））和自動化工具使用的帳戶。</li><li>這些密碼<strong>至少應滿足NIST文件SP800-63B</strong> [36]中第5.1.1節所述的記憶的秘密memorized secrets的要求。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R7 密碼長度 Password Length</summary><div class="toggle-content"><ul><li>一個好的密碼應該至少有15個字符，最好是20個字符。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R8 密碼複雜性 Password complexity</summary><div class="toggle-content"><ul><li>一個好的密碼應該結合大寫和小寫字母、數字和特殊字符。它不應該與用戶名相似，也不應包含重複的字符序列。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R9 密碼到期 Password expiration</summary><div class="toggle-content"><ul><li>所有密碼應該設置到期時間。管理員帳戶的到期時間應該比普通用戶帳戶更短。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R10 密碼重複使用 Password reuse</summary><div class="toggle-content"><ul><li>用戶不應該重複使用最近的至少四個（或更多）密碼，根據組織風險因素來設定這樣的限制。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R11 密碼緩存 Password caching</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px">標準</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R11.a</code></td><td>密碼不應該被緩存在伺服器、桌面或任何其他系統中。</td></tr><tr><td><code>AC-SS-R11.b</code></td><td>應該使用足夠短的生存時間(Time to Live, TTL)或等效的控制機制。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R12 儲存密碼 Saving Passwords</summary><div class="toggle-content"><ul><li>密碼<strong>不應該明文保存在任何地方（例如文件）或腳本</strong>中。</li><li>即使密碼以加密形式儲存，也絕<strong>不能啟用</strong>存儲管理應用程序來本地<strong>記住用戶和密碼以實現自動登錄</strong>，除非通過授權的中央身份驗證服務（如LDAP SSO）管理。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R13 刪除或更改默認密碼 Eliminate or change default passwords</summary><div class="toggle-content"><ul><li>系統安裝或部署時附帶的默認密碼應該立即更改。</li></ul></div></details><h2 id="4-3-3-帳戶管理建議-Account-Management-Recommendations">4.3.3 帳戶管理建議 Account Management Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R14 不與系統使用者關聯的帳戶 Use of accounts not associated with system users</summary><div class="toggle-content"><ul><li>應該<strong>禁用與任何無關聯的帳戶</strong>（例如不在Active Directory中的帳戶，如&quot;guest&quot;，“anonymous”，“nobody”）。</li><li>它們的所有默認配置（例如密碼、權限）應該按照組織範圍的政策進行更改。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R15 帳戶鎖定 Account lockout</summary><div class="toggle-content"><ul><li>在一<strong>定次數的失敗登錄嘗試</strong>後，應該<strong>將使用者鎖定</strong>。</li><li>某些帳戶鎖定的實現包括<strong>在一定時間或電源循環後自動重置（帳戶解鎖）</strong>。</li><li>在<strong>敏感的存儲系統上不應允許自動重置</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R16 用於緊急情況的本地使用者帳戶 A local user account for emergency purposes</summary><div class="toggle-content"><ul><li>應該保留一個單獨的本地使用者帳戶，以便在「<strong>中央身份驗證系統」「不可用時」提供僅限緊急情況的存儲資源訪問</strong>。</li><li>這個帳戶應該符合：<ul><li>所有組織政策（例如密碼長度）</li><li>它的使用應該僅限於特殊受保護的位置</li><li>遵循完善的文件程序，其中包括<strong>相關利益相關者的適當批准和使用通知</strong>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R17 消除或禁用預設使用者帳戶 Eliminate or disable default user accounts</summary><div class="toggle-content"><ul><li>存儲系統安裝時附帶的<strong>預設使用者帳戶</strong>，如果有相關功能，<strong>應立即被消除或禁用</strong>。</li><li>儘管消除或停用預設使用者帳戶功能不存在，或者有正當理由保留其中任何帳戶時，<strong>應滿足AC-SS-R18要求</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R18 – 限制本地和預設使用者帳戶 Limit local and default user accounts</summary><div class="toggle-content"><table><thead><tr><th><div style="width:100px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R18.a</code></td><td><strong>限制</strong>使用此類帳戶及其<strong>擁有的權限</strong>。</td></tr><tr><td><code>AC-SS-R18.b</code></td><td><strong>密碼策略</strong>應適用於所有使用者、本地和預設帳戶，包括具有管理權限的帳戶。</td></tr></tbody></table></div></details><h2 id="4-3-4-權限和會話管理建議-Privilege-and-Session-Management-Recommendations">4.3.4 權限和會話管理建議 Privilege and Session Management Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">AC-SS-R19 角色和責任配置</summary><div class="toggle-content"><ol><li>至少應該對所有儲存資源的訪問實施<strong>ISO標準ISO/IEC 27040</strong> [10] 中的四個角色（即<strong>安全管理員，存儲管理員，安全審核員和存儲審核員</strong>）。</li><li>要確保存儲產品在存儲敏感信息時，具備足夠細緻的角色控制機制，若存儲產品原本沒有這樣的功能，則可以透過補償控制方式來達到相似的效果。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R20 遵循“職責分離”原則</summary><div class="toggle-content"><p>遵循“職責分離”原則來分配特權給角色和將角色分配給用戶。應該至少包含以下：</p><table><thead><tr><th><div style="width:100px">標準</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R20.a</code></td><td>分配給「數據管理」的特權和「數據保護」的特權應分配給不同的角色，這兩個角色不應該指派給同一用戶。</td></tr><tr><td><code>AC-SS-R20.b</code></td><td>分配給「數據管理」的特權和「主機管理」的特權應分配給不同的角色，這兩個角色不應該指派給同一用戶。</td></tr></tbody></table><p>此外：</p><ul><li>數據管理：創建新的儲存卷、或共享資源給用戶等<strong>讓儲存資源正常運作之權限</strong>。</li><li>數據保護：配置、停止或刪除備份，確保<strong>儲存資料的安全與預防數據損失有關之權限</strong>。</li><li>主機管理：在存儲控制器中創建/刪除對象等任務，<strong>管理存儲系統的硬體和基礎架構有關之權限</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R21 最小特權原則</summary><div class="toggle-content"><ul><li>任何角色被指派的特權都應遵循&quot;最小特權&quot;原則</li><li>分配給角色的權限不應該超過其執行的功能所需的權限。在這個情境中，這些權限涉及訪問特定存儲資源，例如塊設備、文件、對象等。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R22 - 安全的會話管理</summary><div class="toggle-content"><ul><li>客戶端和存儲基礎架構系統之間的所有會話都應該根據所需的認證保證等級進行管理，符合[63B]第7節的要求，包括終止和自動登出。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AC-SS-R23 - 實施“每日消息”和“登錄橫幅”通知</summary><div class="toggle-content"><ul><li>在通過用戶界面（UI）、命令行界面（CLI）或應用程序編程接口（API，如果適用）<strong>「登錄」到「任何存儲基礎架構組件」或「系統」之前，應該顯示“每日消息”或“登錄橫幅”通知</strong>。該消息應該包括法律聲明：<ul><li>「<code>警告用戶正在訪問具有敏感數據的受限系統</code>」</li><li>以及「根據組織的安全和隱私政策<code>提供任何其他警告和有意義的消息</code>。」</li></ul></li></ul></div></details><h2 id="4-3-5-SAN-特定建議-SAN-Specific-Recommendations">4.3.5 SAN 特定建議 SAN-Specific Recommendations</h2><div class="note info flat"><ul><li>SAN代表Storage Area Network，翻譯為「儲存區域網路」。簡單來說他用來連接儲存設備與伺服器之間的資料傳輸。</li><li>通常由專門的硬體和軟體組成，並使用光纖通道（Fibre Channel）或者乙太網（Ethernet）等高速連接技術，以實現高效率、低延遲的資料傳輸。</li><li>SAN的儲存資源在伺服器上被視為本地的硬碟，使得伺服器能夠透過SAN存取和管理這些儲存裝置。</li></ul></div><p>與SAN相關的存取控制主題涉及多個方面。有些方面與<strong>網絡配置和管理訪問</strong>有重疊，在其他章節中已經涵蓋了。<br>為了避免重複討論，要全面了解所有存取控制方面，請參考這三節的內容。</p><ul><li>與「網絡基礎設施」（例如交換機、端口、主機緘閉器和網絡接口卡）以及「協議」相關的<strong>存取控制建議</strong>，可以參考第4.6節中有詳細討論</li><li>資料在<strong>傳輸過程中的加密</strong>（存取控制的其中一種機制），可以參考第4.9節中有詳細討論。</li><li><strong>管理訪問</strong>在第4.10節中有詳細討論。</li></ul><p>而本節主要討論「與資料相關」的「存取控制」，涵蓋塊「設備」相關的存取控制、「實施區劃」（zoning）以及加入「光纖通道」的存取控制規範。</p><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R24 - 區塊設備(HDD、SSD、etc)的存取控制</summary><div class="toggle-content"><p>一組主機對於一組存儲區域網（SAN）設備的存取應該透過zoning（軟體或硬體）和masking來限制，以達到最小所需存取權限。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R25 - 區塊設備複製和複本的存取控制</summary><div class="toggle-content"><ul><li>一組主機對於一組經SAN複製的區塊設備、快照和其他類型的時間點複本的存取應該透過分區zoning和masing來限制，以達到最小所需存取權限。</li><li>在許多情況下，被授予存取權限的主機不應該被允許存取複本。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R26 - 默認分區的權限</summary><div class="toggle-content"><ul><li>默認zoning的權限（可能是產品特定的）應該始終配置為“全部拒絕”。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R27 - 分區實施</summary><div class="toggle-content"><p>分區應該在交換式SAN架構中基於合理的邏輯來實施，特別是與「環境」和「流量」類型的相關性，這些應該盡可能地分開：</p><table><thead><tr><th><div style="width:100px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R27.a</code></td><td>環境：開發、測試、生產等。</td></tr><tr><td><code>AC-SS-R27.b</code></td><td>流量類型：數據存取、管理、複製、備份等。</td></tr><tr><td><code>AC-SS-R27.c</code></td><td>主機類型：虛擬化、物理主機。</td></tr><tr><td><code>AC-SS-R27.d</code></td><td>存儲設備類型：磁帶、磁碟。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R28 - 軟體分區實施</summary><div class="toggle-content"><p>當實施軟<strong>體分區時，只允許主機通過簡單名稱服務器（SNS）連接到存儲設備</strong>，通過查閱軟體分區表，而<strong>不是直接使用設備探索</strong>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R29 - 控制可以加入SAN的裝置</summary><div class="toggle-content"><ul><li>在SAN中，有一個政策規範的功能，可以「創建白清單」，<strong>列出可加入該存儲區域網的交換機、數據存儲設備以及主機</strong>，建議在適用的情況下充分利用這一功能。</li></ul></div></details><h2 id="4-3-6-檔案和物件存取建議-File-and-Object-Access-Recommendations">4.3.6 檔案和物件存取建議 File and Object Access Recommendations</h2><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R30 - 限制所有類型的「物件存儲數據」到最低限度</summary><div class="toggle-content"><p>限制所有類型的物件存儲數據（例如，檔案、物件）遵循“最小權限”原則，包括：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AC-SS-R30.a</code></td><td>透過任何協議進行物件儲存數據的存取時，應該基於客戶端的IP和/或相關子網路進行限制，同時要求指定端口/協議。</td></tr><tr><td><code>AC-SS-R30.b</code></td><td>使用更精細的存取控制機制（例如，按角色、ID、標籤、帳戶、虛擬私有雲（VPC）、VPC 端點等）。</td></tr><tr><td><code>AC-SS-R30.c</code></td><td>存取權限只應授予集中管理的用戶和角色，例如企業<strong>目錄中的用戶</strong>或<strong>經批准的商業服務</strong>，而<code>不應授予特定系統的本地用戶</code>。</td></tr><tr><td><code>AC-SS-R30.d</code></td><td>對於任何共享，**默認存取權限應設置為“全部拒絕”**或等效設置。</td></tr><tr><td><code>AC-SS-R30.e</code></td><td><strong>默認共享應禁用或刪除</strong>。如果有特定用途需要使用它們，存取權限應限制為<strong>最低要求</strong>。</td></tr><tr><td><code>AC-SS-R30.f</code></td><td>存取權限（例如讀取、寫入、執行、修改、刪除、查看ACL、更改ACL）應<strong>根據“Need to Know”原則進行個別分配</strong>。</td></tr><tr><td><code>AC-SS-R30.g</code></td><td>如果可用，應使用定義物件存儲ACL的功能，以及使用本地操作系統的用戶、組或管理員權限模型。</td></tr><tr><td><code>AC-SS-R30.h</code></td><td>如果有定義文件級別存取模式的策略定義功能，應加以利用，並且應<strong>實現檢測違規模式的功能，可以發送通知</strong>。</td></tr></tbody></table><div class="note warning flat"><p>補充：“Need to know” 是一個信息安全原則，強調只有在某人必須知道或具有執行特定任務的需求下，他們才能取得相關的敏感信息或資源。這個原則適用於各種情況，包括數據存取權限、網絡訪問權限、機密文件存取等。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R31 - 禁用需要驗證的用戶</summary><div class="toggle-content"><ul><li><strong>需要驗證的用戶應該被禁用（例如，匿名、空、訪客或“公共訪問”用戶）</strong>。</li><li>可以提供例外，以允許組織關鍵功能，例如網絡發現，但在這些情況下，這些用戶應映射到“nobody”用戶組，而不是“ID 0”。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R32 - 定期審核安全設置</summary><div class="toggle-content"><ul><li>定期<strong>審核所有上述存儲數據的安全設置</strong>，包括各種類型的數據（例如文件、對象），以確保沒有偏離。</li><li>審核結果應予以記錄。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R33 - 使用反惡意軟體掃描工具</summary><div class="toggle-content"><ul><li>使用反惡意軟體工具對敏感信息文件進行掃描。</li><li>每當「訪問」包含「敏感信息」的「文件」時，應首<strong>先使用經組織批准的反惡意軟體工具進行掃描</strong>，以確保文件未遭受破壞。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R34 - 進行細粒度的權限分配</summary><div class="toggle-content"><ul><li>進行細粒度的權限分配：<ul><li>對於文件和對象共享系統（例如NFS、CIFS、雲對象存儲），應採用<strong>較細粒度的權限授予</strong>。</li><li>不應使用較粗粒度的方式（例如<strong>對文件或對象進行控制，而非對整個文件夾進行控制</strong>，或者對共享或存儲桶進行控制）。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R35 - 限制root訪問以保護NFS</summary><div class="toggle-content"><ul><li>限制root訪問以保護NFS，這包括使用“nosuid”選項。</li><li>避免使用“no_root_squash”來<strong>防止客戶端上的程序以root用戶身份運行</strong>。</li><li>並且<strong>避免遠程root用戶修改共享文件</strong>。一般情況下，<code>不應允許</code>NFS客戶端在已導出的文件系統上<code>運行“suid”和“sgid”程序</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R36 - 設置noexec設定防止可執行文件執行</summary><div class="toggle-content"><ul><li>要求確保那些被<strong>設置為&quot;read only&quot;模式的NFS共享</strong>，在其<code>掛載配置中添加&quot;noexec&quot;選項</code>，以<strong>防止在該共享上執行可執行文件</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R37 - 不允許導出管理文件系統</summary><div class="toggle-content"><ul><li><strong>不允許導出管理文件系統</strong>：包括<code>‘/’文件系統</code>和<code>受限的操作系統</code>或<code>存儲數組系統文件夾</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R38 - 不應向任何用戶授予完全控制權限</summary><div class="toggle-content"><ul><li>在使用CIFS時，不應向任何用戶授予“完全控制”權限，因為接收者可能使用該權限來修改權限，從而導致特權泄露。</li></ul><div class="note info flat"><p>CIFS代表Common Internet File System（通用互聯網文件系統）。它是一種用於在計算機網絡上分享文件和資源的協議。CIFS最初是由微軟開發的，用於Windows操作系統中的文件共享。</p><p>CIFS協議允許不同的計算機之間進行文件共享，使得用戶可以在網絡上訪問和操作其他計算機上的文件，就像訪問本地文件一樣方便。這使得用戶能夠在不同的計算機之間共享資源，例如文檔、圖片、音頻和視頻等。</p></div></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：AC-SS-R39 - 使用對象保護來防止未經授權的刪除</summary><div class="toggle-content"><ul><li>對於<strong>敏感信息</strong>，如果支持的話，應<code>使用高級控制</code>來防止<code>未經授權的對象刪除</code>。</li><li>（例如對象<strong>刪除時需要多重身份驗證</strong>，或對對象進行鎖定防止刪除）。</li></ul></div></details><h1 id="4-4-AL-審計日誌-Audit-Log">4.4 (AL) 審計日誌 Audit Log</h1><p>儲存基礎架構元件會生成大量的交易或事件的事件日誌記錄。這些事件日誌記錄必須以某種方式進行記錄，以進行事件記錄。</p><ul><li>從<code>安全</code>或<code>合規性</code>的角度來看，重要的是捕獲那些必要的事件日誌記錄，以<strong>證明操作的證據</strong>。</li><li><code>強制說明責任</code>和<code>可追溯性</code>，滿足證據要求，以及對系統進行充分監控。</li></ul><p>以下是與安全相關的審計日誌事件：</p><ol><li><code>管理事件</code> - 與系統權限管理相關知識間。<ul><li>例如，重設使用者密碼，帳戶的創建/刪除，權限修改，角色變更，群組成員變更，特權操作，配置的建立/更改。</li></ul></li><li><code>安全相關事件</code> - 系統安全費制的更改、授權錯誤訊息等可能導致安全事件發生的事件。<ul><li>例如，使用者配置和安全配置的更改，對儲存的失敗/阻塞嘗試，被阻止的登錄嘗試。這些事件通常是有興趣的，儘管其中一些事件可能與管理事件重疊。</li></ul></li><li><code>資料存取事件</code> - 資料存取的相關事件，存取信息對於監控敏感信息（例如，確定對手可能接觸了什麼）是有幫助的。</li></ol><p>以下是審制日誌不檔可能導致的後果：</p><ul><li>安全日誌和分析的不足，使攻擊者能夠隱藏其位置、惡意軟體以及在受害者機器上的活動。</li><li>缺乏可靠的審計日誌，<strong>攻擊可能會長期不被察覺</strong>，而實際造成的損害可能是不可逆轉的。</li><li>由於日誌分析流程的不善或不存在，攻擊者有時可以在目標組織中控制受害者的機器數月或數年，而目標組織中的任何人都不知道，即使可以在未審查的日誌文件中獲取攻擊的證據。</li></ul><p>基於事件日誌數據對於攻擊檢測和鑒識調查的關鍵性，以下是實施審計日誌功能的安全建議：</p><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R1 - 儲存基礎架構的組件應啟用審計記錄</summary><div class="toggle-content"><ul><li>是一個資訊安全要求，指出<code>所有儲存基礎架構的組件應啟用審計記錄</code>，並且<strong>使用可靠的傳送方式和安全的通訊協議</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R2 - 可靠的外部時間同步的要求</summary><div class="toggle-content"><ul><li>Network Time Protocol (NTP)服務對於時間同步至關重要。</li><li>如果NTP服務被停用:<ul><li>相依的系統可能會受到不準確的訊息、事件和警示的時間戳記</li><li>不同裝置之間的時間不一致，以及因此無法進行日誌分析、相關性分析、異常檢測或取證。</li></ul></li><li>在整個環境中建立和<code>使用一個共同且準確的時間來源</code>，有助於確保來自不同來源的事件記錄能夠相關聯。</li><li>以下是有關部署和整合NTP與儲存相關裝置的建議：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>AL-SS-R2.a</code> | 所有裝置（包括日誌伺服器和儲存基礎架構）都應<strong>啟用NTP服務</strong>。|<br>| <code>AL-SS-R2.b</code> | <strong>有裝置</strong>應配置為與<strong>時間來源伺服器</strong>（例如NTP伺服器）進行<strong>時間同步。</strong>|<br>| <code>AL-SS-R2.c</code> | 存取權限只應授予集中管理的用戶和角色，例如企業<strong>目錄中的用戶</strong>或<strong>經批准的商業服務</strong>，而<code>不應授予特定系統的本地用戶</code>。|<br>| <code>AL-SS-R2.d</code> | 建立<strong>至少三個地理位置不同的獨立時間伺服器</strong>，以確保即使其中某個伺服器發生故障或無法使用，其他伺服器仍能提供正確的時間資訊。|<br>| <code>AL-SS-R2.e</code> | 應<strong>使用憑證</strong>來驗證時間來源伺服器的身份已確保時間同步服務的安全性。|<br>| <code>AL-SS-R2.f</code> | - 可以利用存取控制選項，例如 “ntpd” 存取限制，來限制對時間來源伺服器的存取。<br> - 您可以設定存取控制清單，列出被允許或禁止存取時間伺服器的裝置。(例如設定<code>restrict 192.168.2.10</code>只允許此ip進行存取。)|</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R3 - 以集中的方式收集日誌並確保可靠性</summary><div class="toggle-content"><ul><li>通過將日誌寫入<strong>中央日誌伺服器</strong>（例如，syslog 伺服器、雲端日誌服務），降低了日誌丟失或被更改的風險，因為它們在<strong>內部網路中更安全</strong>。以下是有關部署和集成與存儲相關設備的中央日誌記錄的建議：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>AL-SS-R3.a</code> | 應「<code>定義</code>」存儲設備的組織日誌記錄「<code>標準</code>」並以<strong>指定所需的日誌記錄級別</strong>。（更具體的建議請參見AL-SS-R4）|<br>| <code>AL-SS-R3.b</code> | 「所有設備」應根據適用的「組織日誌記錄標準」，配置「<strong>傳輸日誌事件數據」至組織核准的「中央日誌伺服器</strong>」。|<br>| <code>AL-SS-R3.c</code> | 應在所有設備上<strong>監控中央日誌配置</strong>的<code>有效性</code>（例如，日誌服務保持啟動狀態、日誌記錄級別配置符合組織標準、每個設備都配置了經核准的日誌伺服器），對檢測到的異常進行高優先級處理。|<br>| <code>AL-SS-R3.d</code> | 應部署多個syslog伺服器，以<strong>實現連續記錄，並防止單一故障點</strong>。|<br>| <code>AL-SS-R3.e</code> | 每個日誌應至少<strong>保留一份離線副本</strong>。|<br>| <code>AL-SS-R3.f</code> | 為防止在停止並重新啟動所有記錄條目寫入之前丟失條目，應<strong>配置日誌記錄實時寫入磁碟</strong>，並且<strong>不使用緩衝區</strong>，並<strong>使用可靠的協議傳送</strong>。|</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R4 - 日誌記錄等級</summary><div class="toggle-content"><p>存儲審計日誌應包含（但不限於）與所有與「存儲相關」的object、sites和accounts的保護相關的以下事件：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AL-SS-R4.a</code></td><td>敏感環境中，Read-only的API Calls。</td></tr><tr><td><code>AL-SS-R4.b</code></td><td>所有對服務、端口、文件、對象或設備的<code>拒絕訪問嘗試</code>應記錄下來。</td></tr><tr><td><code>AL-SS-R4.c</code></td><td>涵蓋整個<code>密鑰生命周期操作</code>（尤其是加密密鑰）的<code>加密密鑰管理操作</code>，例如密鑰生成、密鑰刪除、證書管理等，尤其是關於密鑰銷毀等事件皆應該紀錄。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R5 - 有關審計日誌保留和保護</summary><div class="toggle-content"><p>有關審計日誌保留和保護，應採取以下措施：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>AL-SS-R5.a</code></td><td>需要<strong>足夠長的時間保留日誌數據</strong>，因為通常需要一段時間才能察覺到已發生或正在發生的入侵事件。</td></tr><tr><td><code>AL-SS-R5.b</code></td><td><strong>分配足夠的存儲空間</strong>，主動監控日誌數據的剩餘空間和異常增長速率，<strong>以防止日誌目的地充滿</strong>。（已知的攻擊模式包括先<strong>充滿日誌以阻礙取證</strong>，適當的監控有助於即時識別此類攻擊。）</td></tr><tr><td><code>AL-SS-R5.c</code></td><td>涵存檔的日誌數據<code>應受到防篡改保護</code>（例如使用WORM或不可變存儲、對象鎖定、多因素身份驗證（MFA）批准刪除）。如果支持，中央日誌服務器也應使用這些存儲選項。</td></tr><tr><td><code>AL-SS-R5.d</code></td><td>通過<strong>指定角色和帳戶</strong>來限制對日誌數據和服務器的訪問。</td></tr><tr><td><code>AL-SS-R5.e</code></td><td><strong>啟用加密</strong>，因為訪問日誌數據可能會為攻擊者提供有關資產和可能攻擊向量的有價值的見解。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AL-SS-R6 - SIEM整合</summary><div class="toggle-content"><ul><li>如果支持，應將<strong>存儲基礎架構日誌</strong>與安全信息和<strong>事件管理SIEM</strong>整合，以進行潛在的威脅檢測。</li></ul></div></details><h1 id="4-5-IR-數據事件應急響應和網絡復原的準備-Preparation-for-Data-Incident-Response-and-Cyber-Recovery">4.5 (IR) 數據事件應急響應和網絡復原的準備 Preparation for Data Incident Response and Cyber Recovery</h1><p>有關事件響應的作用與建立，可以參考NIST的架構來改進關鍵基礎設施的安全[40]。與<code>存儲相關</code>的事件應該作為<strong>組織事件響應流程的一部分來處理</strong>，其中包括隔離、根本原因分析、定義和管理響應計劃、測試以及定期流程審查和更新。以下的建議涵蓋了應考慮的特定方面，涉及存儲基礎設施和數據資產。</p><div class="note info flat"><p>[40] National Institute of Standards and Technology (2018) Framework for Improving Critical Infrastructure Cybersecurity, Version 1.1. (National Institute of Standards and Technology, Gaithersburg, MD). <a href="https://doi.org/10.6028/NIST.CSWP.04162018">https://doi.org/10.6028/NIST.CSWP.04162018</a></p></div><details class="toggle" ><summary class="toggle-button" style="">要求：IR-SS-R1 – 開發針對儲存元件遭到入侵的響應計畫</summary><div class="toggle-content"><p>在組織風險分析、隔離、修復、恢復和測試程序中，應考慮以下要素：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>IR-SS-R1.a</code></td><td>整個<strong>存儲數組</strong>或整個<strong>基於雲的存儲資產</strong>（例如，SAN、NAS、對象存儲、彈性文件系統）的入侵。</td></tr><tr><td><code>IR-SS-R1.b</code></td><td><strong>備份系統</strong>的入侵響應計畫。</td></tr><tr><td><code>IR-SS-R1.c</code></td><td><strong>單個存儲元素</strong>（例如，共享、塊設備）的入侵響應計畫。</td></tr><tr><td><code>IR-SS-R1.d</code></td><td>FC SAN網絡的入侵（包括單個交換機和SAN服務）。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IR-SS-R2 – 在事件管理期間確保恢復資產不可變性</summary><div class="toggle-content"><ul><li>結合下面第4.7節提供的有關<strong>保護網絡復原副本</strong>的建議，這些副本在<strong>事件管理期間</strong>應<code>保持隔離</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IR-SS-R3 – 驗證恢復的計算組件的衛生狀況</summary><div class="toggle-content"><ul><li>確保在將恢復的可執行文件、應用程序、容器和操作系統映像<strong>部署到生產環境之前，它們是不受感染的</strong>。</li></ul></div></details><h1 id="4-6-NC-網路設定指引-Guidelines-for-Network-Configuration">4.6 (NC) 網路設定指引 Guidelines for Network Configuration</h1><p>與存儲相關的網絡主題涉及多個方面，其中一些與數據訪問控制、管理訪問和加密有重疊之處，這些已在其他部分中涵蓋。為了全面了解所有網絡配置方面，請參考所有節的內容。：</p><ol><li>第4.3節中，與<code>數據訪問控制</code>密切相關的某些網絡建議；</li><li>第4.9節中，與<code>網絡和協議</code>相關的<code>加密建議</code>；</li><li>第4.10節中，與<code>管理訪問</code>密切相關的某些網絡建議；</li></ol><div class="note info flat"><p>而本節主要涵蓋的<strong>網絡基礎設施（例如交換機、端口、HBA和NIC配置、分區指南等）和協議</strong>。</p></div><h2 id="4-6-1-FC-SAN-和-NVMEoF">4.6.1 FC SAN 和 NVMEoF</h2><div class="note info flat"><ul><li>FC SAN：是一種存儲區域網絡技術，它使用<strong>光纖通道協議</strong>來連接<strong>主機和存儲設備</strong>。它是一個高性能、可靠且擴展性良好的解決方案，通常用於連接企業級的存儲系統和主機。</li><li>NVMEoF (NVME over Fabric)目的在使用NVMe協議通過網絡訪問遠程存儲設備，而無需通過本地線路直接連接。<ul><li>NVMe（Non-Volatile Memory Express）是一種高效的存儲訪問協議，專門設計用於<strong>快閃存儲器（例如SSD）等非易失性存儲設備</strong>。</li><li>NVMeoF 則是在現有網絡架構上<strong>將NVMe協議擴展到Fabrics</strong>（例如Ethernet或InfiniBand等）的技術。</li><li>這樣，NVMeoF允許主機<strong>使用NVMe協議通過網絡訪問遠程存儲設備</strong>，而無需通過本地線路直接連接。</li><li>這種技術可以在數據中心和雲環境中實現高效、低延遲的存儲訪問，並提供更好的可擴展性和靈活性。</li></ul></li></ul></div><details class="toggle" ><summary class="toggle-button" style="">注意：NC-SS-R1 - 主機和交換機身份驗證</summary><div class="toggle-content"><ul><li>每個<code>主機</code>和<code>存儲交換機</code>應該具有獨特的身份，在加入網絡之前應該<code>進行身份驗證</code>（例如，FC-SP-2 AUTH-A）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：NC-SS-R2 - 使用經批准的PKI機制</summary><div class="toggle-content"><ul><li>使用組織批准且經過認證的<strong>集中式PKI系統來管理交換機證書</strong>（例如，Fibre-Channel Certificate Authentication Protocol或FCAP），而<code>不是使用設備自簽名的證書</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">注意：NC-SS-R3 - 使用混合方法進行zoning</summary><div class="toggle-content"><p>實施一種結合不同類型區域劃分機制的方法，而不僅僅是使用單一類型的劃分（即主機、交換機和存儲設備）：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>NC-SS-R3.a</code></td><td>基於<code>主機</code>的分區機制，主機上的應用程式可以存取和看到可存取的設被或儲存資源有哪些。</td></tr><tr><td><code>NC-SS-R3.b</code></td><td>基於<code>交換機</code>的分區機制，這是指<strong>使用交換機</strong>來<strong>控制設備之間的通信</strong>，使得只有特定的設備可以與其他特定的設備進行交互。</td></tr><tr><td><code>NC-SS-R3.c</code></td><td>基於<code>存儲設備</code>的分區機制，這是指在儲存系統中，<strong>存儲陣列會根據特定的設定</strong>，決定哪些主機（或者更具體地說，哪些主機的HBA端口）可以訪問哪些塊設備，而<strong>其他未列出的主機將被拒絕訪問</strong>。</td></tr><tr><td><code>NC-SS-R3.d</code></td><td>基於<code>功能性</code>的分區機制，區域集合功能就像在存儲網絡中建立了幾個專用的區域，每個區域都有特定的用途，這樣就能更好地管理和控制存儲資源的訪問。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R4 - 遮罩建議</summary><div class="toggle-content"><ul><li>遮罩指的是使block-device對<strong>主機可見或不可見</strong>。</li><li>優先將<strong>遮罩放置在盡可能靠近數據的位置</strong>，盡可能<strong>遠離數據使用者或客戶端</strong>（例如，優先使用數組遮罩而不是交換器遮罩，核心交換器而不是邊緣交換器，以及交換器而不是HBA）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R5 - 交換器配置數據備份</summary><div class="toggle-content"><ul><li>創建<strong>交換器配置數據</strong>的備份，包括區域配置文件。</li><li>該備份應保留在SAN交換器之外，以便在發生錯誤或惡意損壞或刪除時能夠<strong>重新部署</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R6 - 將交換器管理功能限制為最小必要</summary><div class="toggle-content"><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>NC-SS-R6.a</code></td><td>在實施SAN（Storage Area Network）結構時，應該<code>制定明確的政策</code>，指定並<code>最小化授權</code>用於分發配置數據的交換器集合（同時提供可接受的冗餘性）。</td></tr><tr><td><code>NC-SS-R6.b</code></td><td><code>不應啟用</code><strong>不必要的配置管理許可權</strong>和服務，例如密碼分發，將密碼發送給相應的用戶或設備的過程。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R7 - 使用軟性（Soft zoning）與硬性（Hard zoning）區域劃分的考慮</summary><div class="toggle-content"><ul><li>軟性區域劃分：依靠主機的身份來限制存儲區域的訪問，相對不夠安全，但在跨設施且存在物理安全風險的情況下可能更合適。</li><li>硬性區域劃分：則使用物理端口號碼，不依賴主機身份，較為安全，特別適用於物理訪問受到嚴格保護的情況。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R8 - 限制執行管理任務的特定的光纖通道埠</summary><div class="toggle-content"><ul><li><code>限制</code>哪些儲存區域網路（SAN）的<code>光纖通道物理</code>和邏輯埠可以用於管理。</li><li>只有<code>特定的光纖通道埠</code>能夠<code>執行管理任務</code>，例如設置、配置或監控SAN。其他的光纖通道埠則被關閉或限制其功能，以確保它們不能被用來進行管理任務。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R9 - 限制交換器之間的通信</summary><div class="toggle-content"><ul><li>限制<strong>交換器之間的通信</strong>。</li><li>確保只<strong>有必要的交換器之間可以相互通信</strong>。這有助於降低未經授權設備進入儲存區域網路的風險。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R10 - 停用未使用的儲存區域網路（SAN）埠</summary><div class="toggle-content"><ul><li><strong>停用未使用的儲存區域網路</strong>（SAN）埠，以防止意外或有意連接未經授權的設備。</li></ul></div></details><h2 id="4-6-2-IP-儲存網路-IP-Storage-Networking">4.6.2 IP 儲存網路 IP Storage Networking</h2><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R11 – IP儲存網路分隔</summary><div class="toggle-content"><p>本節主要討論IP存儲網絡的分隔原則，旨在保障存儲相關通信在IP網絡上的安全性。以下是該段落的重點總結：</p><ol><li>在存儲相關通信中，應該根據不同的流量類型，在<strong>Network Layer第2層和第3層進行環境和流量的分隔</strong>，以保障安全。</li><li>對於敏感環境，應該最大限度地進行分隔，分隔的依據包括以下：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>NC-SS-R11.a</code> | 流量類型：數據訪問協議、管理、複製、備份、主機和應用網絡等。|<br>| <code>NC-SS-R11.b</code> | 進一步區分不同解決方案、供應商和技術的管理流量。如果使用了兩個或更多的存儲解決方案（例如不同的數組技術、基於伺服器的SAN產品、交換機技術、存儲虛擬化等），每個環境的管理流量應該與其他環境分隔。|<br>| <code>NC-SS-R11.b</code> | 數據訪問協議（例如iSCSI、NFS、特有供應商協議等）。|<br>| <code>NC-SS-R11.b</code> | 訪問數據的伺服器或主機類型：虛擬化主機 vs. 實體主機。|</li></ol><p>這些分隔原則旨在確保IP存儲網絡的安全性，使不同類型的流量和敏感信息在網絡中得到適當的隔離，從而減少潛在的安全風險。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R12 - 子網的分隔</summary><div class="toggle-content"><ul><li>在SAN交換機的IP或是乙太網路管理ports應該要位於獨立的子網中，包含與主機和儲存之間的數據訪問子網，主機間通信子網都要分隔開。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R13 - 啟用設備IP訪問控制</summary><div class="toggle-content"><p>應啟用<code>設備IP訪問控制</code>，在存儲設備上配置相關的安全功能，例如內建防火牆規則、IP過濾和存取控制清單，以實現：</p><table><thead><tr><th><div style="width:130px">要求</div></th><th>要求內容</th></tr></thead><tbody><tr><td><code>NC-SS-R13.a</code></td><td>控制和限制<code>僅允許所需主機</code>或<code>應用</code>訪問其使用的存儲對象。</td></tr><tr><td><code>NC-SS-R13.b</code></td><td>獨立控制管理主機和管理應用程序之間的<code>IP流量</code>，以及相關的存儲管理界面。</td></tr></tbody></table></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R14 - 在網絡層面應用IP訪問控制</summary><div class="toggle-content"><ul><li>使用<strong>路由、防火牆、存取控制清單、虛擬私有雲（VPC）安全組</strong></li><li>基於服務器的SAN客戶端來限制所有流量類型（如數據訪問和管理流量）僅限於允許的IP地址和TCP/UDP端口和協議之間：<br>| <div style="width:130px">要求</div> |  要求內容 |<br>|---------|----------|<br>| <code>NC-SS-R14.a</code> | 主機或應用程序和它們使用的存儲對象之間。|<br>| <code>NC-SS-R14.b</code> | 管理主機和應用程序與它們管理的相關存儲對象的存儲管理界面之間。|</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R15 - 封鎖網際網路或公網的訪問</summary><div class="toggle-content"><ul><li>應封鎖從網際網路或其他公共網路對非公開存儲對象的訪問。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R16 - 對於需要公開訪問的存儲對象，應實施足夠的控制措施</summary><div class="toggle-content"><p>(a) 最小化訪問。<br>(b) 使用物理和邏輯上分隔的存儲子網，最好是與非公開存儲對象使用不同的存儲設備和池。<br>© 考慮防止拒絕服務攻擊。<br>(d) 緩存副本（例如使用內容傳遞網絡（CDN）、副本和代理），至少保留與源數據相同的安全特性。<br>(e) 考慮法規要求（例如機密性、存儲位置限制）。<br>(f) 任何其他適用的安全控制措施（例如加密、身份驗證）。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R17 - 配置SNMP時，所有流量應導向有效的組織內部IP地址作為目的地</summary><div class="toggle-content"><p>在配置SNMP時，所有流量應導向有效的組織內部IP地址作為目的地，應定期審查配置的有效性。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R17 - 考慮使用隔離的不可路由VLAN</summary><div class="toggle-content"><p>對於基於服務器的SAN部署，考慮使用隔離的不可路由VLAN，以保護數據存儲環境並減輕安全擔憂。</p></div></details><h2 id="4-6-3-Protocols-協定">4.6.3 Protocols 協定</h2><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R19 - 禁用不安全的檔案訪問協議版本</summary><div class="toggle-content"><ul><li>需要封鎖過時、不推薦或不安全的協議版本，如SMB v1、NFS 1和2。</li><li>建議在客戶端和伺服器端都停用這些協議，以增加安全性。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R20 - SNMP安全性設定</summary><div class="toggle-content"><p>(a) 如果不使用SNMP，應禁用它。<br>(b) 修改預設的已知社群字串，即使未啟用SNMP。所設定的字串應符合組織的密碼政策。<br>© 對於具有不同機密性的設備，使用不同的社群字串。<br>(d) 使用至少SNMP版本3。<br>(e) 強制執行SNMP的身份驗證和加密功能。<br>(f) 如果不是絕對必要，不要配置具有讀寫訪問權限的SNMP。如果確實需要，要限制和控制讀寫SNMP的使用。<br>(g) 使用存取控制清單來控制通過SNMP對設備的訪問。<br>(h) 定期驗證SNMP陷阱是發送到授權的管理者。<br>(i) 參考美國國土安全部(CISA)的TA17-156A指南，以獲得額外的指導。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R21 - 目錄、域和相似服務的真實性</summary><div class="toggle-content"><ul><li>需要定期審查所有儲存元素（如設備、交換機、管理工作站、管理軟體）中服務的配置，確保只使用核准的配置，並修復任何不一致之處。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R22 - 使用標準和非標準的TCP/IP或UDP埠的考慮</summary><div class="toggle-content"><ul><li>考慮使用非標準埠，可以<strong>隱藏應用程式或服務</strong>，使駭客難以找到正確的埠號。</li><li>使用非標準埠的缺點是安全掃描工具<strong>可能無法識別非標準埠上的可疑活動</strong>，因為這些工具預期在標準埠上有特定行為。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R23 - 啟用FCoE初始化協議（FIP）監聽過濾器</summary><div class="toggle-content"><ul><li>FIP監聽是<strong>防止未經授權的訪問和數據傳輸到FC網絡</strong>的安全機制。</li><li>FCoE轉接器將FC發起器（伺服器）連接到FCoE轉發器（FCF）以啟用相關VLAN上的FIP欺騙。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R24 - 限制iSCSI埠</summary><div class="toggle-content"><p>需要防止iSCSI網絡上的主機訪問除該網絡上為iSCSI指定的TCP埠之外的任何TCP埠。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R25 - 使用iSCSI身份驗證</summary><div class="toggle-content"><ul><li>在建立會話時，使用支援的方法對iSCSI發起者進行身份驗證（例如CHAP、SRP、Kerberos、SPKM1/2）。</li><li>使用雙向驗證而不是單向驗證的CHAP。請注意，身份驗證不提供通道的加密或完整性保護。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R26 - 使用NDMP安全功能</summary><div class="toggle-content"><p>當使用NDMP時，應配置以下安全功能：<br>(a) 控制哪些主機可以啟動NDMP會話。<br>(b) 使用挑戰-回應身份驗證（不使用明文身份驗證選項）。<br>© 記錄NDMP連接嘗試。<br>(d) 符合組織密碼政策的NDMP密碼（例如，長度、複雜性等）。<br>(e) 僅需要使用者的受限NDMP相關權限。<br>(f) 加密的NDMP控制連接。<br>(g) 會話或伺服器的NDMP限流。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R27 - 在LDAP中使用TLS</summary><div class="toggle-content"><ul><li>在設定儲存系統的Active Directory選項時，使用TLS來保護LDAP連接。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：NC-SS-R28 - 其他協議建議</summary><div class="toggle-content"><ul><li>當使用其他協議（如SymAPI、SMI-S、GNS等）時，應考慮適應第4.6.2和4.6.3節中的建議。</li><li>特別是：<ul><li>(a) 將數據訪問和管理的流量與其他環境隔離。</li><li>(b) 限制TCP和UDP埠。</li><li>© 啟用加密。</li></ul></li></ul></div></details><h1 id="4-7-IS-隔離-Isolation">4.7 (IS) 隔離 Isolation</h1><p>當生產數據損壞或丟失時，組織應該能夠通過複製或備份的數據副本來恢復數據。如果損害是惡意攻擊的結果，攻擊者也能夠破壞備份數據副本，那麼對生產環境的攻擊將產生災難性影響，因為組織將無法進行恢復。為了提高備份副本的彈性，<strong>應確保數據資產及其恢復副本之間具有足夠的隔離</strong>。在這個背景下，組織應該區分至少兩種不同的數據保護場景：</p><ol><li><strong>非惡意恢復</strong> - 需要數據副本，以應對<code>自然災害、硬件故障、人為錯誤</code>等情況。這些可以包括本地副本（例如，在進行維護之前拍攝的快照）、災難恢復副本（DR副本）、備份以及長期存檔。這些副本與生產環境越接近，越有可能被映射到計算系統進行測試和災難恢復。</li><li><strong>防止網絡攻擊的恢復</strong> - 需要<code>硬化、鎖定並保持隔離的數據副本</code>。設計應該努力實現這樣一個狀態，即這些副本不受任何影響，包括與其相關聯的生產數據卷或其他類型的副本已被破壞的情況。</li></ol><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R1 – 儲存系統的分隔</summary><div class="toggle-content"><p>(a) 在<strong>私有雲中</strong>，應在指定的<strong>獨立儲存環境中建立防範網絡攻擊的備份副本</strong>。在<strong>公有雲</strong>中，則需要<strong>使用單獨的帳戶（或等效帳戶）來創建這些備份副本</strong>。<br>(b) 長期的備份和儲存系統應該與生產數據儲存系統分開。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R2 – 管理系統的分隔</summary><div class="toggle-content"><ul><li>儲存系統中存儲網絡攻擊恢復副本的管理應該來自<strong>指定的管理系統</strong>，該系統<strong>與生產環境以及與生產相連的其他系統</strong>（包括數據保護機制）<code>分隔</code>。</li><li>生產和常規備份不應該能夠訪問這些管理系統。該系統應該托管在一個僅與隔離網絡相連的專用環境中。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R3 – 網絡攻擊恢復系統和長期備份的存取限制</summary><div class="toggle-content"><p>(a) 對於敏感信息，網絡攻擊<strong>恢復副本</strong>及其系統<strong>不應該對常規的IT人員可見</strong>，<strong>僅應該讓單一人員（如CISO），或非常有限的高管或安全經理使用特別的憑證來訪問</strong>。這確保如果IT管理員的憑證被入侵，攻擊者無法使用這些憑證來訪問網絡攻擊恢復副本。這個受限制的團隊可以訪問網絡攻擊恢復副本，但管理權限只會授予更小的子集，用於授予其他使用者權限。<br>(b) 訪問長期備份的權限應該與用於執行其他儲存管理任務（例如SAN管理、儲存分配）的權限分開，並應包括使用不同的使用者ID、帳號和憑證。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R4 – 離線儲存</summary><div class="toggle-content"><ul><li>網路攻擊恢復的備份應該<code>儲存在離線的地方</code>，而<strong>不是和生產數據存放在同一地點</strong>。</li><li>這樣做可以確保即使攻擊者物理上進入生產地點，或者成功侵入物理位置，也無法訪問或破壞網路攻擊恢復的備份。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R5 – 獨立的完整基準備份</summary><div class="toggle-content"><ul><li>備份系統通常使用增量備份，相對於基準備份捕獲數據的變化。這些增量備份在恢復時必須與基準備份一起使用。對於某些備份方案（如快照），只使用增量備份（即基準備份是生產數據本身）。</li><li>為了正確處理恢復情景，必須**考慮備份之間的依賴關係，並保持不同類型備份之間的充分隔離。**具體來說：</li><li>(a) 複製的災難恢復備份不應依賴於生產基準數據。</li><li>(b) 網路攻擊恢復備份不應依賴於生產基準數據。只有在這些備份從生產基準數據中得到充分隔離並符合IS-SS-R1、IS-SS-R2和IS-SS-R3的建議時，才允許依賴於災難恢復基準數據。</li><li>© <strong>長期儲存的歸檔數據</strong><code>不應依賴於生產和災難恢復基準數據</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R6 – 停用所有不必要的服務和協議</summary><div class="toggle-content"><p>在網路攻擊恢復儲存系統上應停用所有不必要的服務和協議。在只需要應用程序編程接口（API）或命令行界面（CLI）進行管理的環境中，建議也禁用任何交互式網頁界面。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R7 - 從主機或應用程式獨立</summary><div class="toggle-content"><p>(a) 在進行資料恢復時，不應將資料副本掛載、匯出或映射到主機或應用程式，而應該將其還原到隔離的臨時環境（例如離線環境），而不是直接還原到目標主機或應用程式。或者，較不安全的方法是允許目標主機或應用程式在還原過程中有有限的唯讀訪問權限（例如映射或掛載），但在還原完成後應立即移除此類訪問權限。<br>(b) 長期備份的資料副本不應直接掛載、匯出或映射到主機或應用程式。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R8 - 考慮設定空氣隔離 Air Gap</summary><div class="toggle-content"><ul><li>組織應考慮在<code>敏感資料</code>的資料<strong>恢復副本</strong><code>周圍建立空氣隔離</code>（air gap）。</li><li>嚴格的空氣隔離應提供完全的<strong>物理和網路層面分離</strong>。</li><li>某些存儲技術引入較不嚴格的隔離技術，也被稱為&quot;空氣隔離&quot;，可在<strong>定期與生產系統進行同步時關閉數據端口並在有限的時間內打開</strong>。應根據資料的價值和對手的能力來衡量每種技術的有效性。選擇嚴格實施時，應注意繞過已知的空氣隔離系統漏洞，包括：</li><li>(a) 防止空氣隔離系統與其他設備之間的視覺、聽覺和熱信號傳輸（例如保持足夠距離或使用減震和/或足夠的物理距離）。</li><li>(b) 防止空氣隔離設備中的任何潛在無線傳輸功能。</li><li>© 禁用暴露的數據端口（例如USB、網路）。</li><li>(d) 使用電源調節或分離的電路。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R9 - 執行定期隔離審核</summary><div class="toggle-content"><p>應<strong>每年至少一次對上述隔離建議進行檢查</strong>，作為定期審計的一部分，以確保沒有可能犧牲資料恢復副本的隔離性的配置差距或偏差。對於敏感和高價值的存儲系統，可能需要至少每季審計一次，以及在每次重大更改後進行審計，視哪個較先發生。審計結果應該被記錄下來。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：IS-SS-R10 - 考慮使用不可變存儲技術</summary><div class="toggle-content"><p>考慮使用不可變存儲技術，這可以進一步隔離和保護恢復資料（例如保留鎖定、保險庫鎖定、不可變性策略）。</p></div></details><h1 id="4-8-RA-恢復保證-Restoration-Assurance">4.8 (RA) 恢復保證 Restoration Assurance</h1><ul><li>主要在談&quot;恢復保證&quot;，<strong>確保在業務中斷、災難恢復事件或資安攻擊後，能夠成功地復原。</strong></li><li>僅僅擁有恢復流程是不夠的，組織還需要確保所有<code>關鍵資料元件都能夠被保護</code>，並能夠忠實、一致、完整地恢復。</li><li><code>恢復的速度和更新程度</code>也應符合業務和監管要求。</li><li>很多情況下，組織備份了重要系統，但並<strong>不經常檢查這些備份是否能夠實際恢復系統</strong>。然而，由於配置漂移、環境變化，甚至是惡意攻擊導致備份受到破壞，他們最終無法使用備份數據來進行恢復。以下是確保恢復保證的安全建議：</li></ul><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R1 - 確保恢復副本的完整性</summary><div class="toggle-content"><p>所有包含關鍵資料元件的存儲元素應<code>受到保護並備份</code>，以支持災難恢復和資安攻擊恢復。這包括存儲卷、關鍵文件系統、數據庫、軟件映像、證書、加密密鑰、啟動文件、目錄信息、存取控制列表（ACLs）、虛擬化設置和配置文件。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R2 - 保護所有依賴元件</summary><div class="toggle-content"><ul><li>依賴元件，例如<code>Active Directory和DNS，外部密鑰管理系統</code>，應受到保護，以實現完整恢復。</li><li>如果使用自動化構建流程來配置存儲、源代碼存儲庫、構建環境和構建程序，這些應該也要受到保護。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R3 - 所有相關軟件和硬件元件的可用性</summary><div class="toggle-content"><p>用於運行系統的所有相關軟件和硬件元件（例如驅動程序、固件）都應該備份、保護並可供恢復操作使用。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R4 - 選擇備份和數據複製技術 應符合組織的RTO要求</summary><div class="toggle-content"><ul><li>RTO是<code>恢復時間目標</code>，用來衡量期望的恢復速度。</li><li>要全面考慮滿足RTO的能力，包括所有相關的組件（如數據恢復、配置文件、加密密鑰）。</li><li>同時要平<strong>衡實際恢復所需的速度和調整所有相關組件以實現期望恢復速度所需的成本。</strong></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R5 - 進行定期測試恢復以確保達到所需的RTO</summary><div class="toggle-content"><p>定期進行測試恢復操作，確保成功完成並滿足所需的時間範圍。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R6 - 設定回復點目標（RPO）</summary><div class="toggle-content"><ul><li>為每個資料資產<code>設定回復點目標</code>，即在發生故障後可以容忍的資料損失量，以時間來衡量。</li><li>備份和數據複製技術的設計和實施應該支持在這個目標下進行數據恢復。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R7 - 滿足組織的資料資產的數據保留和複製頻率需求</summary><div class="toggle-content"><p>應該確定<code>每個資料資產的數據保留和複製頻率需求</code>（詳見DP-SS-R1以獲取更多細節）。備份和數據複製技術的設計和實施應該支持這些需求。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R8 - 確保遠程副本備份和數據複製處於良好狀態</summary><div class="toggle-content"><ul><li><code>定期驗證備份副本的狀態</code>。</li><li>這包括<strong>檢查是否有相關的錯誤記錄</strong>，以及備份和數據複製媒體是否處於良好狀態。</li><li>驗證頻率應該符合受保護數據的敏感性和價值，但<code>不應少於每年一次</code>。</li><li>將樣本比率保持在備份頻率的1到1.5個數量級較低的範圍內，可以作為一個可靠的基準（例如，每小時備份的樣本每日驗證，每日備份每兩週到每月驗證等）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R9 - 分離數據與應用程式的還原</summary><div class="toggle-content"><p>為了在還原數據時避免恢復受感染的代碼或軟體，應該<code>將數據與應用程式進行分離</code>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R10 - 文件化災難復原計劃</summary><div class="toggle-content"><p>必須<strong>撰寫儲存基礎架構的災難復原計劃</strong>，包括所有資源、與正式生產環境的映射、流程和測試程序。同時也應備份這些文件。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R11 - 數據副本的網路安全措施</summary><div class="toggle-content"><ul><li>對於關鍵任務的資訊，災難復原副本應該<code>使用各種反惡意軟體掃描工具進行掃描</code>，以檢測已知的漏洞和異常。</li><li>最理想情況下，應<code>對所有副本進行掃描</code>。如果不可能，至少<code>對其中一部分副本進行掃描</code>，並記錄這些已經進行掃描且安全的副本。網路安全工具包括防病毒軟體、防惡意軟體、漏洞掃描和安全分析工具。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：RA-SS-R12 - 定期進行審計</summary><div class="toggle-content"><ul><li>述建議應該作為<code>定期審計的一部分進行回顧</code>，以檢查副本的完整性、重新評估依賴性、軟體和硬體要求、支援復原速度的技術適用性、復原點目標 (RPO)、保存期限、健康檢查、災難復原計劃和網路安全措施。</li><li>應該確定並追蹤問題，並進行修復。</li><li>審計的頻率應與所保護數據的敏感性和價值相符，但不得少於每年一次。</li><li>對於敏感和高價值的儲存系統，可能需要每季度進行審計，以及每次進行重大變更後進行審計 - 以先到者為準。</li><li>審計結果應予以文件化。</li></ul></div></details><h1 id="4-9-EN-加密-Encryption">4.9 (EN) 加密 Encryption</h1><div class="note info flat"><p>加密是將數據從<code>可讀形式（明文）轉換為不易被未經授權的人理解的不可讀形式</code>（密文）的過程。這樣可以確保敏感信息不會被未經授權的人存取或理解。</p></div><p>在存儲系統中，加密應該實施<code>端到端</code>，包括：</p><ol><li><code>靜態數據（Data at rest）</code>：物理或邏輯進行儲存的相關設施（例如磁帶、磁盤、光盤等），其<strong>數據應該進行加密</strong>。這不僅包括數據本身，還應該加密元數據，如訪問權限、標籤、路徑和日誌信息等。</li><li><code>數據傳輸（Data in transit）</code>：在<strong>存儲元素之間傳輸</strong>的數據，無論是客戶端讀寫、存儲設備或存儲池之間的複製，或在網絡中傳輸的數據，都應該進行加密，除非整個通信媒介都處於受保護的環境（例如數據中心）。</li><li><code>管理訪問（Administrative access）</code>：包括通過標準和專有協議和API對<strong>存儲元素、存儲網絡和數據</strong>進行<strong>配置或控制</strong>的連接。</li></ol><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R1 - TLS、雜湊 hashing 和 加密 encryption</summary><div class="toggle-content"><ul><li>為了支援存儲客戶端與伺服器之間的加密通信，應該<strong>使用Transport Layer Security (TLS)協議</strong>。</li><li>選擇和配置TLS協議的<strong>實現應遵循相關指南</strong>，包括TLS版本的選擇以及選擇雜湊和加密算法。<ul><li>指南來源包括<code>NIST SP800-52 Rev2</code>和<code>SNIA TLS Specification for Storage Systems Version 1.1</code>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R2 - 不應使用明文協議，如HTTP，Telnet，FTP或RSH</summary><div class="toggle-content"><ul><li>明文協議容易遭受竊聽、攔截等攻擊，因為它們不加密流量或登錄詳細信息。</li><li>在敏感的存儲環境中，<strong>不應允許將HTTP用於重定向到HTTPS的情況</strong>，除非只用於處理錯誤輸入的URL。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R3 - 存儲管理 API 會話加密</summary><div class="toggle-content"><ul><li>應該對所有API和CLI客戶端會話進行加密，可以利用<code>管理軟件</code>或<code>API/CLI軟體組件內的特定配置</code>選項來實現加密。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R4 - 管理員訪問會話的加密</summary><div class="toggle-content"><ul><li>使用HTTP的管理員會話應該<code>使用TLS（HTTPS）來進行加密</code>。</li><li><code>命令列介面（CLI）</code>訪問應該<code>使用SSH而不是Telnet進行加密</code>。</li><li>API訪問期間的身份驗證不應使用明文，<strong>會話本身也應該進行加密</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R5 - 在FIPS環境中啟用FIPS模式</summary><div class="toggle-content"><ul><li>FIPS 140-3規定加密模塊應該是一組硬體、軟體、韌體或其組合，用於實現加密功能或過程，包括加密算法，並可選擇性地進行金鑰生成，並且在定義的加密邊界內。</li><li><strong>FIPS規定某些加密算法是安全</strong>的，並確定在加密模塊稱為符合FIPS標準時<strong>應該使用哪些算法</strong>。</li><li>符合FIPS標準的組織應確保在其符合FIPS標準的存儲基礎設施組件中啟用FIPS模式。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R6 - 敏感數據的靜態加密</summary><div class="toggle-content"><p>靜態加密保護數據免受各種與數據相關的風險（包括未經授權的訪問，媒體丟失或被盜等）。對於敏感數據應該啟用靜態加密。應考慮以下幾點：</p><ol><li><code>使用基礎設施加密</code>：<strong>使用磁碟、存儲陣列或雲存儲提供的內建加密功能</strong>，無論使用供應商提供的金鑰還是組織提供的金鑰，可以保護免受設備丟失、錯置或被盜的威脅。但是，這並不能對抗以下情況：<ol><li><strong>帶內攻擊</strong> - 當攻擊者入侵到已經與存儲關聯的主機（或當可以通過合法方式將存儲映射到未經授權的主機）。</li><li><strong>權限升級攻擊</strong> - 管理員或攻擊者獲得高級權限後可能關閉加密或解密數據。</li></ol></li><li><code>使用端到端加密</code>：數據在其源頭（例如應用程序、數據庫、卷）處進行加密，對存儲基礎設施和管理員只呈現密文。這顯著增加了安全性，但有時會帶來相當大的成本：<ol><li><strong>數據減少機制受影響</strong> - 例如，壓縮和去重可以變得非常不有效。</li><li><strong>管理更加複雜</strong>。</li></ol></li><li><code>使用雙獨立層加密</code>：在可能的情況下，應考慮對敏感數據存儲使用雙獨立層加密。這種配置提高了金鑰被破壞時的韌性，尤其是如果使用不同的加密服務。</li><li><code>應考慮數據保留要求</code>：如果<strong>加密數據被備份或存檔，相關的金鑰應該受到保護</strong>，保護時間應與數據相似。或者，備份數據應重新生成新的密鑰。無論哪種情況，<strong>數據和加密金鑰不應保持在一起</strong>。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R7 - 在傳輸過程中的資料加密</summary><div class="toggle-content"><ul><li>(a) <code>Fibre-Channel上的區塊傳輸</code>：儘管在ANSI/INCITS 545-2019標準中有定義Fibre-Channel的連結加密，但目前大多數主機緘點適配器（HBA）和存儲供應商並不支援。<strong>針對敏感信息，應該使用端到端（主機到存儲）加密</strong>。</li><li>(b) <code>IP區塊傳輸</code>：IP存儲流量面臨與常規IP網絡相同的安全風險。默認情況下，IP區塊傳輸協議不會為每個數據包提供數據保密性、完整性或驗證。類似於連結加密，雖然有IP存儲流量加密的技術規範，但目前的技術並不原生支援。在使用IP區塊傳輸協議（例如iSCSI、FCIP、專有協議）時，應<strong>考慮使用IPsec隧道對暴露在網絡上的段進行保護</strong>。此外，針對敏感信息，應該使用端到端（主機到存儲）加密。</li><li>© <code>檔案和對象存儲訪問</code>：應該在支援的情況下為備份系統和遠程複製啟用傳輸時的資料加密。對於檔案訪問，應該使用SMB加密等機制來加密敏感數據，還可以利用由雲服務提供商提供的NFS加密選項，或者<strong>使用通道加密（例如 ‘stunnel’）的NFS over TLS。確保對象通過HTTPS與TLS進行訪問</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R8 - 存儲系統組件之間的通信應該加密</summary><div class="toggle-content"><ul><li>應該審查<strong>存儲系統組件的交互作用</strong>，並<strong>使用可用的加密選項</strong>。</li><li>應該使用加密來保護存儲<strong>節點和管理器之間的通信</strong>，主動存儲節點與見證設備之間的通信，以及與策略伺服器和防病毒伺服器之間的通信。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：EN-SS-R9 - 加密金鑰管理要求</summary><div class="toggle-content"><ul><li>遵循<code>NIST SP 800-57</code>部分1-3中的一般建議進行金鑰管理，特別是:<ul><li>壽命</li><li>金鑰可以保護的最大數據量</li><li>金鑰管理基礎設施</li><li>重新生成金鑰</li><li>審計</li><li>金鑰的備份和恢復。</li></ul></li></ul></div></details><h1 id="4-10-AA-管理者訪問權限-Administrative-Access">4.10 (AA) 管理者訪問權限 Administrative Access</h1><ul><li>這一節重點關注儲存元素的<code>管理者訪問權限</code>，包括<strong>陣列、網路和架構、管理工具、備份、複寫和雲端儲存</strong>等。</li><li>管理者訪問可以通過<code>直接連接到儲存元件</code>或者<code>透過管理軟體</code>來實現。這兩種連接方式都可以使用不同的界面，包括管理用戶介面（UI）、命令列介面（CLI）和應用程式介面（API）等。</li></ul><p>這一章的某些其他節點涵蓋了與管理者訪問重疊的方面。為了避免重複，額外的相關建議可以在以下兩個部分找到：</p><ul><li>在上面的第4.9 Encryption 中，涉及到加密的相關建議。</li><li>在上面的第4.3 Authentication and Data Access Control 中，涉及到與資料相關的訪問控制，其中的一部分可能也適用於管理者訪問。</li></ul><p>此節提供了有關管理訪問配置的安全指南，以下是重點摘要：</p><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R1 - 限制對SAN交換機管理端口的網絡訪問</summary><div class="toggle-content"><ul><li>將對<code>SAN交換機管理端口</code>的<strong>網絡訪問</strong>限制在<strong>特定指派的設備和管理員</strong>上，通過訪問控制清單（ACL）等機制實現。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R2 - 控制和限制具有管理權限的設備和組件至最低限度</summary><div class="toggle-content"><p>包括CLI服務器、管理控制台、API閘道、見證主機和具有控制權限的存儲設備。特別是：<br>(a) 積極發現具有存儲管理權限的組件，<strong>確保只有被授權的組件擁有這些權限</strong>。如果發現不必要的組件，應立即移除並彙報。<br>(b) 從<strong>被授權的設備中移除不必要的權限和能力</strong>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R3 - 實施最小權限原則</summary><div class="toggle-content"><ul><li>將<code>擁有管理權限的用戶</code>的<strong>權限限制到最低限度</strong>。</li><li>這包括用戶可以執行的最小操作，並且將這些權限的範圍限制在僅涵蓋相關系統或區域。</li><li>完全的管理權限應僅授予需要這些權限的用戶。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R4 - 限制服務帳戶的訪問權限</summary><div class="toggle-content"><ul><li>服務帳戶（例如<code>監控工具使用的帳戶</code>）應限制為<code>僅具有read-only</code>和<code>僅metadata-only訪問權限</code>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R5 - 對所有CLI/API訪問進行身份驗證和授權</summary><div class="toggle-content"><ul><li>對<code>CLI/API</code>使用應<code>進行身份驗證和授權</code>。</li><li>如果無法進行身份驗證或授權，則應通過額外的安全措施保護未經授權的訪問，例如使用特權管理工具來限制控制到最低必要的命令和對象。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R6 – 優先使用API存取控制，而非CLI/shell存取控制</summary><div class="toggle-content"><ul><li>應該<code>優先使用API存取控制</code>，因為<strong>CLI/shell存取具有訪問作業系統和檔案系統</strong>（包括配置文件）的能力。</li><li>若<strong>只有CLI/shell存取選項</strong>，則應<strong>使用安全協定，如SSH</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R7 – 限制管理控制台的作業系統權限</summary><div class="toggle-content"><ul><li>只能通過指定的存儲帳戶提供對管理控制台的訪問，<code>不能使用作業系統管理帳戶</code>（另見AC-SS-R20）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R8 – 管理Web使用者介面</summary><div class="toggle-content"><ul><li>提供管<code>理控制台訪問的 Web</code> 服務應該得到強化，以<strong>滿足或超過組織中其他 Web 應用程序服務器的最低標準</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R9 – 限制主機存儲控制權限</summary><div class="toggle-content"><ul><li>在某些共享數據計算集群配置中（例如集群、地理集群、規模集或存儲虛擬化基礎設施），主機被授予存儲的管理權限，以便控制共享集群數據資源的分配和行為。</li><li>當需要此管理訪問時，應限制授予主機的範圍和權限，僅限於主機需要控制的特定元素（例如LUN、共享、檔案、物件）和需要執行的特定操作。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R10 – 命令裝置或閘控配置</summary><div class="toggle-content"><p>某些存儲數組<strong>允許主機對具有訪問特殊區塊設備的控制權</strong>（例如某些供應商稱為「命令裝置」和「閘控」的設備）進行管理控制。當使用時，<strong>建議遵循以下安全指南</strong>：<br>(a) <code>限制對控制裝置的使用</code>：如果可行，應完全<strong>消除對這些裝置的使用（例如改用API存取）</strong>。如果不能消除，則應<strong>確保它們僅映射到必要的主機（例如管理主機）</strong>。<br>(b) <code>掃描控制裝置</code>：進行網<strong>路掃描以發現控制裝置，並確保它們僅映射到必要且經授權的主機</strong>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R11 – 禁用或限制call home 或 遠端存取</summary><div class="toggle-content"><p>通常call home 或 remote access 被用於收集遙測和診斷數據，供製造商分析和解決技術問題，以及進行自動軟件更新。然而，這些功能也可能成為黑客攻擊的目標，因此<code>如果不需要的話應該禁用</code>，<strong>如果需要的話則應該限制和控制</strong>。<br>(a) 修改默認憑據 - 改變遠端連接的默認憑據。<br>(b) 限制權限 - 只授予必要的最低權限。<br>© 強制加密 - 使用TLS/SSH/IPSEC等安全協議，並使用FIPS批准的加密算法。<br>(d) 使用&quot;允許清單&quot;限制訪問 - 使用允許清單限制特定IP和特定用戶的訪問。<br>(e) 完整記錄遠端訪問 - 為了審計目的，應該完整記錄所有遠端訪問。<br>(f) 啟用內建數據混淆功能 - 對於允許混淆敏感數據（如IP地址，WWN，設備名稱和用戶名）的存儲設備，應該啟用此功能。<br>(g) 限制發送的數據範圍 - 將發送的數據範圍限制為最低要求。<br>(h) 定期審查和批准 - 定期評估定期或自動發送給供應商的數據，確保其中不包含敏感信息，如IP地址，用戶名或實際存儲設備的內容。同時，審查確保連接是通往有效的供應商IP地址的。<br>(i) 授權每個連接 - 如果可能，實施一個在允許每個連接之前請求許可的機制。<br>(j) 限制對網關系統的訪問 - 當供應商通過網關設備、服務器或設備進行遠程訪問時，特別注意保護和限制對網關系統的訪問。<br>(k) 禁用供應商遠程訪問鏈路上的軟件更新 - 在敏感環境中，不應該允許通過供應商遠程連接鏈路進行軟件組件和更新的下載和部署（無論是手動還是自動）。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R12 - 管理網路訪問的限制 Limit network access for management</summary><div class="toggle-content"><ol><li>建議將<code>管理網路與其他流量分開</code>（參見第4.6節和第4.7節）。</li><li>進一步<code>加強管理網路的存取控制</code>，可使用以下機制：<br>(a) 虛擬私人網路（VPN）、IPsec或一個或多個「跳板伺服器」：使用VPN、IPsec或一個或多個「跳板伺服器」或「登入代理伺服器」，這些是位於管理網路中的專用伺服器，只能從網路外部訪問，並且在經過適當的身份驗證和授權後，可以用於連接其他伺服器。<br>(b) 增強日誌記錄和追蹤功能，例如會話記錄。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R13 - 安全保護核心儲存管理檔案和執行檔</summary><div class="toggle-content"><ol><li>儲存管理軟體通常包含<code>配置檔案</code>，<strong>用於控制儲存系統的運作方式</strong>，包括未記載的選項。</li><li>這些敏感目錄和檔案應該具有適當的<code>限制權限</code>，並<code>擁有正確的擁有者和群組成員</code>。</li><li>包括以下內容：<ul><li><code>配置檔案</code>：記錄用戶和角色、網路設定、一致性群組、裝置群組和其他儲存選項。定義一致性和裝置群組的配置檔案通常會從中央管理主機自動傳播到連接到受管理儲存系統的其他主機。因此，如果遭到入侵，可能會影響多個系統。</li><li><code>腳本</code>：用於控制啟動、監控和停止儲存管理服務和守護程序，以及本身的執行檔。應將這些腳本及其他重要的管理相關檔案進行安全保護。</li></ul></li><li>應對配置檔案、腳本和其他重要的管理相關檔案採取以下控制措施：<br>(a) <code>限制存取和權限</code>，並控制關鍵目錄和檔案的擁有權。<br>(b) 對於敏感環境，應考慮<code>監控這些檔案的內容變化</code>，以防止未經授權的更改。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：AA-SS-R14 - 使用經核准的PKI機制進行管理訪問</summary><div class="toggle-content"><ul><li>在儲存設備管理和儲存管理控制台方面，建議使<code>用經組織核准並經認證的集中式PKI系統</code>，而不是使用設備或軟體自簽名憑證。</li></ul></div></details><h1 id="4-11-CM-配置管理-Configuration-Management">4.11 (CM) 配置管理 Configuration Management</h1><p>配置管理的目的是在「整個儲存設備」<code>生命周期</code>內提供對<strong>設定、行為、以及實體和邏輯屬性的可見性和控制</strong>。在儲存安全的背景下，這包括以下內容：</p><ul><li>維護全面且即時的<code>清單</code>，<code>管理變更</code>，以及<code>確保配置</code><strong>持續符合組織的安全基線和目前業界最佳實踐</strong>，同時確保其不受已知風險的影響。</li></ul><p>為了實現這一目標，需要適當的控制、政策、流程和工具。IT 配置管理的全面指南可參考 <code>NIST Special Publication (SP) 800-53</code> [28]。以下段落包含適用於儲存基礎架構的建議。</p><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R1：建立全面的存儲設備清單，包括識別以下所有存儲組件的名稱、地址、位置和軟件、固件或驅動程序版本</summary><div class="toggle-content"><ol><li>數組(Array)</li><li>存儲虛擬化系統(Storage virtualization systems)</li><li>管理控制台(Management consoles)</li><li>監控存儲遠程網絡連接狀態的主機（例如Witness主機）</li><li>安裝了存儲管理軟件或插件的主機</li><li>數據保護設備(Data protection appliances)</li><li>備份客戶端和伺服器(Backup clients and servers)</li><li>存儲網路交換機(Storage network switches)</li><li>存儲適配器或&quot;主機總線適配器 (HBA)&quot;</li><li>I/O多路徑軟件(I/O multipathing software)</li><li>主存儲系統和（複製）目標存儲系統的配對情況</li><li>指定的主機備份伺服器或離地備份的情況</li><li>磁帶庫和磁帶驅動器</li><li>磁碟驅動器和可移動媒體</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R2：建立全面的資料和配置資產清單，包括通過以下資產識別邏輯數據組件和數據訪問配置</summary><div class="toggle-content"><ol><li>存儲池、LUNs、遮罩和分區</li><li>發起者和發起者組</li><li>文件共享和存取控制列表(ACLs)</li><li>物件存儲池、桶等</li><li>備份複本和快照(Replicas and snapshots)</li><li>備份目錄和訪問權限</li><li>備份集（本地、存檔、雲端虛擬化、磁帶、存檔設備等）</li><li>用戶、群組、角色和權限</li><li>主機訪問配置到存儲資產（例如LUNs、文件共享、全局文件系統、物件存儲）</li><li>存儲軟件、虛擬設備等的映像</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R3 - 創建全面的存儲安全策略</summary><div class="toggle-content"><ul><li>存儲安全策略可以作為專用策略，或者作為組織安全策略的一部分。</li><li>策略應基於以下來源：<ul><li>來自該出版物和<code>引用來源</code>的建議。</li><li>內部組織相關的存儲相關安全標準。</li><li>相關供應商的<code>最佳安全實踐</code>。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R4 - 保持存儲安全策略的更新</summary><div class="toggle-content"><ul><li>存儲安全策略應該<code>定期進行審查和更新</code>（至少每年一次）。</li><li>安全基線應根據可用的存儲系統和/或特定存儲設備的<code>最新供應商和行業建議進行更新</code>（最好每季度進行，至少也要每年）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R5 - 定期主動評估存儲安全策略的配置合規性</summary><div class="toggle-content"><ul><li>(a) 確保實際配置<code>符合存儲安全基線</code>，並識別差距。</li><li>(b) 及時<code>追蹤差距</code>的整改。</li><li>© 考慮制定基於數據類型、組織功能和敏感性的存儲安全基線合規性的關鍵績效指標（KPI）。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R6 - 創建「存儲變更」管理流程</summary><div class="toggle-content"><ul><li>可以作為專用流程或組織的一般變更管理流程的一部分。</li><li>涵蓋：</li><li>(a) 規劃、審查和批准存儲配置變更。</li><li>(b) 更新環境文檔和庫存（例如基礎設施、數據、配置）。</li><li>© 在對敏感存儲環境進行任何變更後評估合規性。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">CM-SS-R7 - 檢測未經授權的存儲安全變更</summary><div class="toggle-content"><ul><li>應建立<code>檢測未經授權的存儲配置變更的流程</code>，可以使用日誌記錄、將配置存儲資產與過去狀態進行比較，或者與組織批准的基線進行比較。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R8 - 軟體更新和修補</summary><div class="toggle-content"><p>(a) <code>確保儲存軟體版本更新</code>：應建立定期更新儲存軟體至最新穩定且安全版本的流程。這包括管理軟體、API和CLI套件、數組和HBA固件版本以及作業系統驅動程式。<br>(b) <code>安裝重要的安全更新和修補程式</code>：應建立主動且頻繁地安裝重要和緊急的儲存安全修補程式的流程。<br>© <code>無法取得修補程式的緩解計劃</code> - 如果某些儲存組件存在重要漏洞，而供應商尚未提供更新或修補程式，應暫停使用這些組件，除非可以定義適當的緩解計劃。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R9 - 網路拓撲文件</summary><div class="toggle-content"><p>保持儲存相關的網路文件最新，包括光纖通道（FC）和IP的繪圖。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">要求：CM-SS-R10 - 審核FC SAN安全配置</summary><div class="toggle-content"><p>隨著時間推移，某些安全變更可能無法可靠地傳播到整個光纖通道交換機(fabric)。</p><ul><li><code>應定期審核FC SAN</code>（就像IP和以太網網路一樣），以評估其安全性，識別和優先處理漏洞，並<code>定義改進計劃</code>。</li><li><code>安全審核</code>應至少每年進行一次，在敏感環境中，至少每季進行一次或在任何重大更改後進行 - 以先到者為準。</li><li>審核結果應予以記錄。</li></ul></div></details><h1 id="4-12-ST-存儲安全培訓-Training">4.12 (ST) 存儲安全培訓 Training</h1><details class="toggle" ><summary class="toggle-button" style="">ST-SS-R1：存儲安全培訓計畫</summary><div class="toggle-content"><p>應制定一個存儲安全培訓計畫，並<strong>納入現有的組織培訓活動和時間表</strong>，以滿足以下目標受眾：</p><ol><li><code>資訊安全專業人員</code>：為他們提供存儲安全的基本背景知識。</li><li><code>存儲管理員</code>：讓他們熟悉存儲安全原則，以及組織的政策和安全基準。</li><li><code>管理者</code>：理解數據保護的基本原則。</li></ol></div></details>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> Database </category>
          
          <category> 畢業論文 </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> 碩士論文 </tag>
            
            <tag> Cloud Storage </tag>
            
            <tag> Security </tag>
            
            <tag> NIST SP 800-209 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIST SP 800-209 資料儲存安全指引 Security Guidelines for Storage (1) 威脅與風險</title>
      <link href="/posts/security-for-storage-infra/"/>
      <url>/posts/security-for-storage-infra/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://csrc.nist.gov/publications/detail/sp/800-209/final">NIST SP800-209 Security Guidelines for Storage Infrastructure</a></li><li><a href="https://owasp.org/API-Security/editions/2023/en/0x11-t10/">OWASP API Top 10, 2023</a></li><li><a href="https://owasp.org/Top10/">OWASP Top 10, 2021</a></li><li><a href="https://ithelp.ithome.com.tw/m/articles/10294214">OWSP Top 10,2021</a>：別人整理的，內容簡短。</li><li><a href="https://s.itho.me/ccms_slides/2022/9/29/6f51c8e9-67ba-4267-913d-d4461bba3894.pdf">OWSP Top 10,2021</a>：簡報更加清楚裡面的具體採取措施與威脅。</li></ul><h1 id="前言">前言</h1><p>根據上一篇的內容和研究議題，應該要先了解，本篇主要目的在整理：</p><ul><li>[x] <code>資料儲存的相關威脅與風險有哪些？</code></li><li>[ ] 零信任怎麼預防這些威脅與風險？</li></ul><hr><p>為了能夠整理儲存安全的相關威脅與風險，我整理了NIST所發布針對Cloud Stoage的相關安全標準，NIST SP 800-209的本文檔概述了：</p><ul><li><strong>存儲技術格局的演變、當前的安全威脅以及由此產生的風險</strong>。</li><li>並主要提供<strong>一套全面的安全建議</strong>來應對威脅，涵蓋…<ul><li>信息技術 (IT) 基礎設施常見的安全管理領域: 例如物理安全、身份驗證和授權、變更管理、配置控制以及事件響應和恢復）</li><li>存儲基礎設施特有的安全管理領域: 例如存儲基礎設施、數據保護、隔離、恢復保證和加密。</li></ul></li></ul><div class="note warning flat"><p>我只會挑<code>我覺得有用或是可用的資料進行整理，不會放全部的內容上來，並且會有一些個人的觀點或說法</code>，因此本篇參考即可，<strong>正確內容還是請參考NIST SP800-209為主</strong>。</p></div><h1 id="重點整理">重點整理</h1><p>以下也是我針對這個章節的重點整理，如果想要快速了解，可以閱讀這個章節即可。</p><blockquote><p>Mapping Threats and Risks 總結第三章內容</p></blockquote><table><thead><tr><th><div style="width:130px">威脅</div></th><th>可能的風險</th><th>威脅程度</th></tr></thead><tbody><tr><td><code>後門和未修補的漏洞</code></td><td>- 依據「<strong>弱點類型</strong>」不同有不同風險。<br> -「<strong>憑證被盜或洩露</strong>」威脅所帶來的風險都適用。</td><td>高</td></tr><tr><td><code>特權升級</code></td><td>- 依據「管理者」或「使用者」憑證是否被盜或洩露。 <br>  -「<strong>憑證被盜或洩露</strong>」威脅所帶來的風險都適用。</td><td>高</td></tr><tr><td><code>人為錯誤與故意配置失誤</code></td><td>- 依據人為或配置錯誤的「<strong>種類</strong>」和「<strong>影響範圍</strong>」造成的風險不同。 <br> - 如果是錯誤的配置，<strong>章節3.2所有風險</strong>皆可能發生。</td><td>高</td></tr><tr><td><code>實體媒體的物理偷竊</code></td><td>- 依據竊盜「<strong>範圍</strong>」有不同的風險。<br> - 「<strong>資料洩露和資料曝露</strong>」、「<strong>資料損毀</strong>」、「<strong>備份受損</strong>」、「<strong>數據不可用和阻斷服務</strong>」為可能因偷竊導致的風險。</td><td>中</td></tr><tr><td><code>不安全的映像、軟體和韌體</code></td><td>- 依據影響「<strong>種類</strong>」和「<strong>影響範圍</strong>」造成的風險不同。<br>  - 如果是錯誤的配置，<strong>章節3.2所有風險</strong>皆可能發生。</td><td>高</td></tr><tr><td><code>惡意軟體與勒索軟體的感染</code></td><td>- 惡意軟體可能導致「<strong>權限提權</strong>」、「<strong>憑證被盜或洩露</strong>」威脅。<br> - 依據惡意軟體「<strong>出現的地點</strong>」像是應用系統或是管理系統，都可以影響導致<strong>章節3.2所有風險</strong>皆可能發生。</td><td>高</td></tr><tr><td><code>加密破解</code></td><td>- 可能導致「<strong>數據洩露和暴露</strong>」於 (a) 靜態數據、(b) 傳輸中的數據和 © 用戶/管理員會話中的數據</td><td>中</td></tr><tr><td><code>憑證被盜或洩露</code></td><td>1. <strong>應用系統</strong>(Application System)：「資料洩露和暴露」、「未經授權的數據更改和新增」、「資料損毀」等風險皆有可能。<br> 2. <strong>管理系統</strong>(Administrative System)：「備份損毀」(Compromise of existing and future backups)、「惡意數據混淆和加密」(ransomware attack)、「數據不可用和阻斷服務」(DDOS Attack)、「存儲相關日誌和審計數據的篡改」、不安全的儲存設定參數，皆有可能發生。</td><td>高</td></tr></tbody></table><h1 id="2-11-儲存和資料管理-Storage-and-Data-Management">2.11 儲存和資料管理 Storage and Data Management</h1><p>在裡面提到了，以下的內容，<strong>主要關注的是儲存和資料管理的其他方面，而不是直接涉及「資訊安全」的控制措施</strong>。因此只會簡單介紹一下，以下內容在NIST SP 800-209稍微提到的內容。</p><div class="note info flat"><p>我的感想：上述中，有探討意義的是「資料保護」，裡面提到的三個面向，在information assurance/security的部分可以好好探討。也可以思考「資料分類」與「資料保護」的結合。像是，透過資料分類，來進行存取控制的資料保護。</p></div><details class="toggle" ><summary class="toggle-button" style="">儲存資源配置和資源管理 Storage Resource Configuration and Resource Management</summary><div class="toggle-content"><ul><li>內容：主要說明進行儲存資源配置或管理時生命週期要注意的點，像是針對「物理裝置」的管理與控制，跨多「資產」的變更協調、效能管理和最佳化、資產的管理、事件管理，都是被歸類於此。</li><li>感想：非論文主軸</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料分類或分類 Data Classification or Categorization</summary><div class="toggle-content"><ul><li>提到可以參考資料法規像是PII, PCI-DSS, HIPAA等，針對資料做更細緻的分類，並且針對不同的資料做不同的保護。</li><li>主要可以分以下幾類：<ul><li>敏感性（例如，敏感 vs. 非敏感）</li><li>頻率（例如，經常訪問 vs. 不經常訪問）</li><li>環境（例如，生產環境 vs. 開發環境 vs. 測試環境 vs. 演示環境）。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料消除 Data Sanitization</summary><div class="toggle-content"><ul><li>說明需要根數據的類型和特定，使用適當的資料消除方式。</li><li>提到，資料消除主要可以分以下幾類：<ul><li>Clearn：例如，覆蓋現有數據；</li><li>Purge：例如，對於磁性媒體，使用強磁場進行消磁，對於加密數據，使用密碼擦除；</li><li>Destruct：例如，對媒體進行物理破壞，如燃燒，粉碎等。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料保留 Data Retention</summary><div class="toggle-content"><ul><li>說明在某些情況下，可能需要將特定資料保存一段短期、中期（即少於10年）或長期的時間。</li><li>資料保留通常是透過將資料副本備份至某個媒介來實現的。這可能是為了滿足運營、法律、監管或法定要求。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料保護 Data Protection</summary><div class="toggle-content"><ul><li>是一個綜合性術語，指的是所有「確保資料可訪問、可用、不受損壞、並可供所有經授權的目的使用，且性能達到可接受水平的活動」。</li><li>這些活動需要符合合規要求，包括隱私保護，以及所有物理、管理和技術手段，以確保資料不會被意外或未經授權地洩露、修改或破壞。</li><li>資料保護所涉及的生命周期。這些階段包括：<ul><li>（儲存）靜態資料／端點上的資料 - 存儲於伺服器或用戶端設備上的資料。</li><li>（傳輸過程）過程中的資料 - 在存儲設備之間、用戶端到伺服器或伺服器之間傳輸的資料。</li><li>（正在使用）使用中的資料 - 在查看、修改或在設備之間進行同步時的資料。</li><li>（離開安全範圍）超越安全範圍的資料 - 下載、物理媒體運送等過程中的資料。</li></ul></li><li>資料保護可以分為三個面相：<ol><li>storage: 主要探討「儲存」本身的相關保護，像是備份、恢復、複製、不可變、持續資料保護、snapshot等。</li><li>privacy: 主要探討「資料本身的隱私」但是這個每個地區規則不同，在此不討論。</li><li>information assurance/security: 主要是技術控制措施，每個措施都需要專門的部分來討論其細節。所以也先不討論。</li></ol></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料壓縮 Data Reduction</summary><div class="toggle-content"><ul><li>資料壓縮有兩個常見的方法，這兩種方法可以結合使用。<ul><li>資料去重：資料去重試圖將多個資料副本替換為指向共享副本的引用。有點像是都是相同檔案的話，就把他們指向同一個source就不用複製多個相同的資料了。</li><li>資料壓縮：使用已知的演算法對資料進行編碼，以產生一種使用比未編碼表示法更少的儲存空間的資料表示形式</li></ul></li></ul></div></details><h1 id="3-儲存基礎設施的相關威脅-Threats-Risks-and-Attack-Surfaces">3. 儲存基礎設施的相關威脅 Threats, Risks, and Attack Surfaces</h1><div class="note info flat"><p>威脅 - 潛在引起不需要的事件的原因，可能對系統或組織造成損害。</p></div><p>第三章節主要提供有關存儲系統「安全威脅」、「風險」和「攻擊面」（可能使用的手段手段）的背景資訊。</p><h2 id="3-1-Threat-威脅">3.1 Threat 威脅</h2><p>主要提到九個威脅是Storage Infrastruture可能會碰到的：</p><details class="toggle" ><summary class="toggle-button" style="">3.3.1 憑證被盜或洩露 Credential Theft or Compromise</summary><div class="toggle-content"><ul><li>最常用且<strong>最容易被入侵的是登錄密碼證書</strong>。</li><li>內文指出，有效的憑證盜用都是「<strong>直接取得使用者的密碼，而非猜測</strong>」，因此僅僅依靠密碼的長度和複雜性通常不足以保護系統免受攻擊。舉例來說以下情境皆不適用密碼的複雜度：<ul><li>現代勒索軟件通常會從其捕獲的數據集中收集密碼。</li><li>鍵盤記錄也是一種不受密碼複雜性影響的證書盜竊方法，其中恶意软件可以虛擬地監視使用者輸入密碼[23]。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.2 加密破解 Cracking Encryption</summary><div class="toggle-content"><ul><li>加密金鑰生成利用「隨機性」來建立金鑰。但是仍有各種弱點，從「<strong>弱的加密算法」和「弱的金鑰生成器」到「服務器端的漏洞」、金鑰泄露、基本設計缺陷或漏洞</strong>，以及後門等等 [24]。</li><li>簡單來說就是要注意：使用強大的加密方法很重要，同時也要妥善保護加密金鑰。積極更換加密金鑰可以成為一種策略，以防止金鑰被破解或不夠強大。在金鑰生成方面，金鑰的強度、質量和熵都起著重要作用，且金鑰不應重複使用。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.3 惡意軟體與勒索軟體的感染 Infection of Malware and Ransomware</summary><div class="toggle-content"><ul><li>文中提到，往往攻擊「存儲管理系統」比攻擊「存儲裝置」本身更容易。</li><li>因此<strong>惡意軟體可能因安裝在存儲管理主機上</strong>，造成傷害，如竊取憑證、提升特權、資料損壞、損失或更改，以及破壞未來的備份等。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.4 後門未修補的漏洞 Backdoors and Unpatched Vulnerabilities</summary><div class="toggle-content"><ul><li>後門：通常是軟體機制或功能，由供應商、個別貢獻者（在罕見情況下，可能是國家或惡意行為者）故意創建，原因通常被作者認為是合理的（例如為了改進支援、調試、國家安全等）。</li><li>由於門後具有潛在的危害性，它們並不在官方文檔中記錄，只有被限定的一組人才知道其存在。然而，隨著時間的推移，門後的存在可能會被故意或無意間洩露或被公眾發現。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.5 特權升級 Privilege Escalation</summary><div class="toggle-content"><ul><li>特權升級只利用軟體漏洞、設計或部署缺陷，或是配置錯誤，以至於<strong>獲得對於應用程式或使用者取得受保護資源的訪問權限</strong>。</li><li>特權升級與後門漏洞有很高的關聯，特權升級有兩種形式：<ol><li>垂直特權升級（特權提升）：<strong>低特權</strong>使用者或應用程式訪問<strong>高特權</strong>使用者或應用程式的功能或內容。</li><li>水平特權升級：<strong>普通</strong>使用者訪問為其他<strong>普通</strong>使用者所保留的功能或內容。</li></ol></li><li>對資料庫的影響：<ul><li>在儲存系統中，這種威脅可能導致各種風險，包括資料損壞、資料更改、資料丟失等。</li><li>例如，攻擊者可以使用提升的特權來進入儲存系統，刪除儲存卷，並修改訪問配置。</li><li>這種攻擊還可能危及資料的備份副本（例如，同步/非同步複本、快照）或未來備份的生成。</li><li>特權升級本身可以在各種級別上發生，例如儲存元件（例如，儲存陣列、主機或客戶端）、網路設備或管理系統。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.6 人為錯誤與故意配置失誤 Human Error and Deliberate Misconfiguration</summary><div class="toggle-content"><ul><li>即使存在安全控制，<strong>使用者可能會進行技術上支援的儲存配置更改</strong>，但仍然會造成無法接受的風險。</li><li>可能的人為錯誤包含以下：<ul><li>打字錯誤。</li><li>缺乏對內部安全基準和供應商最佳實踐的了解或熟悉。</li><li>個人或團隊之間的溝通失誤。</li><li>儲存基礎架構的指導或自動化相關的錯誤：<ul><li>直接錯誤，例如腳本和配置文件中的缺陷。</li><li>間接錯誤，例如未意識到的軟體依賴性。</li></ul></li><li>將受限制的物件儲存池映射到公共網路，停止複製或備份進行維護，卻未在之後重新啟用</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.7 實體媒體的物理偷竊 Physical Theft of Storage Media</summary><div class="toggle-content"><ul><li>所有的<strong>數據最終都儲存在一個或多個實體媒體上，而這些媒體容易受到偷竊的威脅</strong>。</li><li>這些媒體，無論是在線或離線，都可能被從其指定的（固定）位置上移除，或者在實體運輸過程中被竊取（例如，正在運輸用於備份的媒體進行歸檔，或者作為數據中心遷移項目的一部分而運送存儲設備。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.8 網路竊聽資料 Network Eavesdropping</summary><div class="toggle-content"><ul><li><strong>資料在傳輸時可能會被攔截</strong>。</li><li>傳輸可以涵蓋許多組件：網路卡（有線或無線）、傳輸電纜（傳輸電力或光線）、中繼器、交換器、路由器等。這些<strong>組件中的任何一個都可能受到破壞</strong>，而且很多形式的破壞是難以或不可能用最先進的工具和方法來檢測的。</li><li>可能針對資料的相關工作：<ul><li>某些傳輸破壞可能可以進行資料的截取（也稱為被動竊聽）</li><li>還可能涉及對傳輸的資料、元數據或控制流量進行插入、刪除或修改</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3.3.9 不安全的映像、軟體和韌體 Insecure Images Software and Firmware</summary><div class="toggle-content"><ul><li>對手可能試圖<strong>干擾儲存設備的軟體分發、更新或安裝過程</strong>，以引入不正確、過時或惡意修改的程式碼（例如二進位檔案、映像、韌體、驅動程式等）。</li><li>軟體更新過程可能依賴於複雜的傳遞鏈路：鏈路中的每個環節都可能成為引入被篡改軟體的目標。<ul><li><strong>發行者（例如供應商、第三方、開源社區）</strong>: 發行者可能被滲透，以感染源碼庫、獲取註冊軟體或設備的存取權限，將經過修改的簽署二進位檔案發布在下載站點或更新伺服器上，</li><li><strong>傳遞方法（例如傳輸或下載、安裝媒體的運送、供應商員工的檔案複製）</strong></li><li>**個別組織保存的本地副本（例如代理伺服器、內部檔案伺服器）**等。</li></ul></li><li>受影響的儲存元件包括: 磁碟驅動器、磁帶驅動器和磁帶庫、網路卡和控制器（例如HBA、網路介面卡或NIC、FCoE適配器等）、交換機和其他網路設備、儲存機箱和陣列、儲存作業系統、用戶端作業系統的儲存元件等。</li></ul></div></details><h2 id="3-2-Risk-風險">3.2 Risk 風險</h2><p>這這章節描述了安全風險的定義，這邊與3.1 Threat相比的差異像是：</p><div class="note warning flat"><p>Threat: 是一些可能會發生的攻擊的地方，或是造成Risk的可能原因，還沒做出傷害使用者或組織名譽的行為（Risk）。<br>Risk: 對資料的機密性 完整性 可用性 已經造成損害，而影響組織的使命、形象、資產和其他相關利益。</p><p>舉例來說，<strong>Threat包含一些「弱密碼、人為設定錯誤」（Threat）等，來造成「資料外洩」（Risk）</strong>。</p></div><div class="note info flat"><p>安全風險被定義為：一個<strong>實體（可能是組織、系統或資訊）受到潛在情況或事件的威脅的程度（影響x機率）</strong>。而這些風險主要涵蓋了<strong>機密性、完整性和可用性</strong>三個方面，這些風險可能影響到。<strong>組織的使命、形象、資產和其他相關利益</strong></p></div><p>相關的安全風險有以下幾點：</p><details class="toggle" ><summary class="toggle-button" style="">資料洩露和資料曝露 Data Breach and Data Exposure</summary><div class="toggle-content"><ul><li>資料洩露是指涉及<strong>敏感且受保護的資訊被複製、傳輸、查閱、故意</strong>向公眾公開，或被未經授權的個人或實體使用的事件。料洩漏的影響可以是廣泛的，從給使用者帶來不便，到將敏感或機密數據暴露出來，導致對組織的聲譽和運營健康造成不可挽回的損害。</li><li>資料洩漏可能是由以兩種所引起：<ul><li><strong>外部來源</strong>引起的，例如黑客或網絡犯罪分子。</li><li><strong>內部人員</strong>引起的，比如惡意內部人員或不滿的員工。</li></ul></li><li>可能的根本原因包括：上述的Threat就有一些包含在內。<ul><li>資料在儲存或傳輸過程中的弱加密（或完全未加密）</li><li>軟體漏洞</li><li>可拆卸媒體的遺失</li><li>媒體的被竊</li><li>錯誤或過於寬鬆的訪問限制</li><li>不正確或不完整的資料清除實施（包括刪除的物件、退休或重新利用的媒體等）</li><li>將資訊發送給錯誤的收件人</li><li>將資料以不正確的方式上傳（例如，將受保護的資料上傳至公開的資料儲存庫）。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">未經授權的數據更改和新增 Unauthorized Data Alteration and Addition</summary><div class="toggle-content"><ul><li><strong>攻擊者獲取了訪問數據存儲基礎設施的權限</strong>，以一種影響未來應用交易或影響數據其他用途的方式<strong>修改數據</strong>。</li><li>數據更改和新增可能來自外部或內部來源，並且可能以隱蔽或容易識別的方式進行。</li><li>這種風險可以使用 “salami attack” 方法實現: 即攻擊者在長時間內從大量交易中偷取少量數據或資金。</li><li>數據更改和新增的影響可能從損失資金到對聲譽和信任的永久損害不等。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">資料損壞 Data Corruption</summary><div class="toggle-content"><ul><li>資料損壞指的是在<strong>寫入、讀取、儲存、傳輸或處理過程中，資料遭受損壞或產生錯誤，導致原始資料出現意外變化</strong>。</li><li>通常情況下，當<strong>資料損壞發生</strong>時，包含該資料的物件在<strong>系統或相關應用程式存取時會產生意外結果(Exception)</strong>。<ul><li>這些結果可能從輕微的資料損失到系統崩潰不等。</li></ul></li><li>具體的情境如下：<ul><li>如果一個文件檔案遭受損壞，使用者可能無法打開它，或者它可能打開時其中一部分或全部資料變得無法理解。</li><li>有些類型的惡意軟體可能會故意損壞或摧毀檔案，通常是透過覆寫檔案內容為無效或垃圾程式碼，或以其他安全方式擦除其內容。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">備份受損 Compromising Backups</summary><div class="toggle-content"><ul><li>資料備份是非常重要的，這包括<strong>保存資料的複本、快照等。透過備份</strong>，當資料損壞或丟失時，我們能夠恢復這些資產。</li><li>備份有幾點是要注意的：<ul><li><strong>資料一致性：備份必須「正確生成」，並且要有適當的「保留頻率」和「更新頻率」</strong>。</li><li><strong>備份安全性：備份的存儲也必須安全，以防止未經授權的存取</strong>。</li></ul></li><li>備份不檔可能造成的故障原因如下。<ul><li>若備份時未考慮到一致性或寫入順序的完整性，可能會導致不正確的配置。</li><li>而保留期限不足或備份更新不及時，可能導致某些舊或新資料無法復原。</li></ul></li><li>攻擊策略：<ul><li><strong>干擾備份過程</strong>：當現有的備份無法受到威脅時，另一種可行的攻擊策略是<strong>干擾備份過程本身，逐漸&quot;毒化&quot;未來的備份</strong>。此時唯一可用的備份已經太老舊，導致無法完全恢復資料。</li><li><strong>專門感染系統或應用程式的備份複本</strong>：例如操作系統映像、軟體套件、韌體，甚至源代碼庫。這樣，當我們嘗試通過重建單個元件或整個環境來應對感染時，至少部分惡意程式碼會被還原到環境中，使攻擊者能夠迅速重新控制系統，或造成更多損害。</li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">惡意數據混淆和加密 Malicious Data Obfuscation and Encryption</summary><div class="toggle-content"><ul><li><strong>「可逆的數據混淆和/或加密」會使「數據」對用戶或組織「變得不可用」</strong>，除非使用僅由攻擊者持有的密鑰進行還原。</li><li>這種風險<strong>通常在勒索軟體攻擊中使用</strong> - 一種將受害者的數據進行加密並要求贖金來恢復對數據的訪問權限的惡意軟體。</li><li>近況：隨然最初是針對用戶裝置或企業伺服器上的數據或文件，但是最近已經發展到其他存儲組件，例如NAS和備份設備[30]。</li><li>影響：這些攻擊通常旨在被識別，並且通常伴隨威脅和贖金指示。數據混淆和加密的影響可能從損失資金到永久損害聲譽和信任。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">數據不可用和阻斷服務 Data Unavailability and Denial of Service</summary><div class="toggle-content"><ul><li><strong>數據客戶無法獲得對其部分或全部數據的訪問</strong>。儘管此類損害可能是可逆的（例如，通過還原被更改或刪除的設置），但它可能會導致系統或服務長時間的中斷和停機。</li><li>數據可用性中斷風險可能原因：<ul><li>由於有意或無意地對「通信路徑」或「訪問配置」造成的損害。</li><li>物理性損害：例如通信路徑中斷。</li><li>邏輯性損害：<ul><li>網絡組件的端點配置錯誤。</li><li>攻擊者可以修改或刪除塊存儲設備的存取控制（SAN）掩碼設置</li><li>暫停 NFS（Network File System）中的導出設置，以致客戶無法訪問其數據。</li></ul></li></ul></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">存儲相關日誌和審計數據的篡改 Tampering of Storage-Related Log and Audit Data</summary><div class="toggle-content"><ul><li>指攻擊者刪除或修改日誌數據（例如時間戳記），以<strong>阻止有效的審計軌跡，以掩蓋攻擊（實時或事後），或者向調查攻擊的人提供虛假信息</strong>。</li><li>攻擊行為：<ul><li><strong>禁用日誌系統</strong>：攻擊者可能試圖暫時或永久地關閉目標系統的日誌功能，從而讓其活動不留痕跡，使其攻擊行為更加不容易被發現和跟蹤。</li><li><strong>將所有空閒空間填滿合成信息</strong>：攻擊者可能會寫入大量的虛假日誌信息，將空閒的日誌空間填滿，使真實的日誌數據無法被正確記錄和存儲，以混淆安全人員的調查和追蹤。</li><li><strong>將日誌數據發送到流氓日誌服務器</strong>：攻擊者可能針對客戶或使用者進行社交工程或欺騙手段，讓客戶將寶貴的日誌數據發送到攻擊者控制的偽冒或流氓日誌服務器，使得攻擊者能夠更容易地掌控敏感信息。</li></ul></li><li>影響：這些行為的目的都是為了干擾、混淆和遮蓋攻擊活動，以保護攻擊者的身份，並阻礙安全人員對攻擊事件進行追蹤和調查。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存作業系統、二進位檔案、韌體和映像的侵入 Compromising Storage OS or Binaries、 Firmware and Images</summary><div class="toggle-content"><ul><li>針對儲存軟體的侵入，包括「<strong>儲存設備」的作業系統、韌體、映像等，所導致的不良後果，提供攻擊者進行遠端訪問的手段</strong>，讀取、複製、更改或摧毀數據及其副本，改變安全設定，暴露數據，改變儲存基礎架構的行為等。</li><li>可能造成的結果：<ul><li>儲存行為的改變可用於<strong>引入各種潛在且難以檢測的攻擊</strong>。</li><li>向儲存客戶端<strong>呈現不正確的數據</strong>（即使存儲的數據完好無損）</li><li>向儲存客戶端提供<strong>不正確的狀態</strong>（例如，對快照和安全設定的存在或狀態進行虛假報告）</li></ul></li></ul></div></details><h2 id="3-3-Attack-Surface-攻擊面">3.3 Attack Surface 攻擊面</h2><div class="note info flat"><p>攻擊面被定義為“未經授權的使用者（攻擊者）可以嘗試「進入環境」並進行「數據輸入」(編輯或添加數據)或「提取數據」(數據竊取)等不同攻擊點（“攻擊向量”）的總和” [31]。</p><p>Attack surfaces are defined as “the sum of the different points (the “attack vectors”) where an unauthorized user (the “attacker”) can try to enter data into or extract data from an environment” [31].</p></div><p>本節將列出與儲存基礎架構相關的常見數位和實體攻擊面。</p><details class="toggle" ><summary class="toggle-button" style="">實體存取 Physical Access</summary><div class="toggle-content"><ul><li><strong>實體存取保護是最後防線</strong>，一但入侵者進入儲存基礎架構，那他們最終可能進行資料竊取、複製或毀損，甚至是修改存取配置已進行遠程存取。</li><li><strong>目標在於入侵實體設備</strong>：入侵資料中心、周邊區域、通訊基礎架構（纜線）、運輸實體物件（主機、磁碟等）。</li><li>進行實體存取的方法可分兩種：</li></ul><ol><li>「顯性存取」：攻擊者假裝成合法人員，進入受保護的實體裝置。</li><li>「尾隨」：攻擊者扮演合法訪客尾隨讓攻擊者進入受保護的實體裝置範圍進行實體存取。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存系統的存取 Access to Storage Operating System</summary><div class="toggle-content"><ul><li>這個攻擊的主要<strong>目標是透過操作「作業系統」來「入侵儲存設備」</strong>。</li><li>可能的威脅：<ul><li>「作業系統」都包含<strong>安全漏洞</strong>，因此應定期更新安全更新和補丁。</li><li>「作業系統」都可能因<strong>配置不檔影響安全性</strong>，攻擊者可以透過多種方法獲取對作業系統的存取，包含：本地登入過程（SSH, rshell, telnet）、通過TCP/IP遠程登入、利用系統漏洞。</li></ul></li><li>如果是「超融合基礎架構（HCI）」，攻擊面可能會更大，因為涉及多個主機作業系統。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">管理主機的存取 Access to Management Hosts</summary><div class="toggle-content"><ul><li>大多儲存元件主要透過「商用作業系統的主機」進行「管理或配置」。</li><li>攻擊者會以下方式滲透到管理主機中：</li></ul><ol><li><strong>透過惡意軟體</strong>，滲透到管理主機。</li><li><strong>操作作業系統的漏洞</strong>，進行攻擊。</li></ol><ul><li>可以進行的攻擊行為包含：入侵可執行檔案、讀取快取資料、安裝竊聽裝置讀取記憶體資料、安裝惡意軟體、獲取配置資訊等。</li><li>透過入侵管理主機可以實現的相關風險包含：資料損壞、資料丟失與竄改、備份破壞、竄改日誌和審計等，因此總結來說，<strong>入侵管理主機造成的損害可能是無限的</strong>。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">管理 API、管理軟體和帶內管理 Management APIs、 Management Software、 and In-Band Management</summary><div class="toggle-content"><ul><li>通常「儲存基礎架構元件」會公開軟體的相關「<strong>管理接口</strong>」像是「使用者介面UI」、「API」或相關管理協議來對相關設備進行管理。</li><li>舉例來說，可能會有「管理接口」包含：訪問協議（SOAP)、REST API等，與外部網路服務進行交互，用於密鑰管理、身份驗證和授權，</li><li>上述所提到的管理接口，接可能產生各種攻擊面，包含：</li></ul><ol><li>帽中管理主機或彖已透過「<strong>管理接口(API)」訪問儲存設備</strong>，就無須滲透管理軟體就可獲訪問權限。</li><li>透過<strong>數據鏈路(Data Link，例如光纖通道)進行Band-Access帶內訪問</strong>，冒充客戶端發送管理命令。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存客戶端 Storage Clients</summary><div class="toggle-content"><ul><li>儲存客戶端通常是「運算元件」或是安裝在運算元件的「應用程式」（<strong>那些會使用儲存協定對資源進行「讀取」</strong>）。</li><li>透過入侵客戶端可能的攻擊手法包含：</li></ul><ol><li>攻擊者可能會<strong>透過客戶端傳送管理命令</strong>對儲存裝置進行危害。</li><li>若客戶端是用來建立備份時，可能因被<strong>入侵而導致未來的備份㔯害</strong>。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">儲存網路 Storage Network</summary><div class="toggle-content"><ul><li>主要是透過<strong>入侵網路元件</strong>（包含host adapter, switches, cables, extendsers），<strong>對資料傳輸路徑的入侵</strong>，可能採取的攻擊行為包含：</li></ul><ol><li><strong>資料</strong>：複製、檢視、重新導向、竊取。</li><li><strong>配置資料</strong>：讀取使用者認證、加密金鑰等。</li><li><strong>網路元件</strong>：透過破壞網路元件，修改有效載荷，對資料損毀或變更與添加。</li><li><strong>實施中間人攻擊MITM</strong>：進行嗅探資料、繞過加密和驗證機制。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">重要個人的計算環境 Compute Environment of Key Individuals</summary><div class="toggle-content"><ul><li>有些「<strong>關鍵用戶</strong>」擁有對「<strong>儲存基礎架構的管理權限</strong>」，例如可以對儲存管理主機進行遠程連線。</li><li><strong>關鍵用戶的電腦環境（例如筆記型電腦、桌機、家用網路等）皆可能被利用作為條版</strong>，以獲取儲存基礎設之的存取權限，對儲存基礎設施造成損害。</li><li>例如透過在孤艦用戶的裝置上安裝惡意軟體，該軟體再安裝鍵盤側錄，攔截登陸憑證。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">電力網絡及其他公用設施 Electrical Network and other Utilities</summary><div class="toggle-content"><ul><li><strong>儲存基礎設施與電力網路相連，因此電力網路可能成為潛在攻擊面</strong>。可能的攻擊包含：<ul><li>突然的電流暴增、閃電：造成的損壞，甚至抹除電磁碟片上的數據。</li><li>透過惡意軟體：（如PowerHammer)透過調節被感染的機器功耗(CPU工作負載)來進行數據外洩。或是透過改變電流流量盜取敏感資訊，例如密碼和加密密鑰。</li><li>線路級別攻擊：透過竊聽被感染計算機的店員電纜擷取惡意軟體外洩的數句。</li><li>非侵入式竊取：透過測量電源電纜上發射的信號，來進行解碼轉換二進位形式進行收集[33]。</li></ul></li><li><strong>其他公用事業、安全和環境控制系統</strong>，可能的攻擊包含：<ul><li>對系統造成風險（例如過熱、洪水、爆炸）</li><li>數據洩漏的風險（例如竊取視頻監控系統以攔截密碼輸入，或屏幕、面板、指示燈的內容，錄製聽覺信號）</li><li>試圖劫持環境系統的內部傳輸能力（例如WiFi、藍牙）以試圖規避空隙隔離和網絡控制。</li></ul></li></ul></div></details><h1 id="統整01：整理威脅與實體攻擊（參考OWASP）">統整01：整理威脅與實體攻擊（參考OWASP）</h1><p>在建立威脅模型之前，我們必須先將威脅中採取的攻擊手法整理得更加清楚，以便於進行威脅模型的建立。</p><p>API安全和資料庫之間有著密切的關聯。<code>OWASP Top 10</code>是由Open Web Application Security Project (OWASP) 發布的最常見的Web應用程式安全風險清單，而在2023年版本中，十大API安全風險被加入其中，反映了API安全在現代應用程式中的重要性。</p><p>另外，<code>NIST SP 800-209</code>提供了有關資料庫安全的指南，特別在<strong>第4.6節</strong>中，提及了與<strong>網絡基礎設施和協議</strong>相關的<code>存取控制建議</code>。這是因為資料庫涉及到數據的存儲、管理和訪問，而網絡基礎設施和協議則是支援數據傳輸和存取的重要組成部分。因此，這邊會參考：<code>OWASP Top 10 2021</code>, <code>OWASP Top 10 2023</code> 進行參考然後 將資料庫可能造成的威脅 與 NIST SP800-209 3.2節中談到真對資料庫的威脅，進行Mapping。</p><h2 id="1-憑證被盜或洩露-Credential-Theft-or-Compromise">1. 憑證被盜或洩露 Credential Theft or Compromise</h2><p>主要防禦方式：</p><ul><li>使⽤安全的加密傳輸協定如 TLS 1.2, TLS 1.3</li><li>使⽤具迭代⽅法之雜湊演算法如 Argon2, scrypt, bcrypt 或 PBKDF2 搭配加鹽來儲存密碼</li><li>以處理、儲存、傳輸⾏為模式分類，執⾏對應的控制措施</li><li>針對包含敏感資料的回應停⽤快取</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.1 憑證被盜或洩露 Credential Theft or Compromise</td><td>NIST SP 800-209 指出，有效的憑證盜用大多「直接取得使用者的密碼，而非猜測」，因此僅僅依靠密碼的長度和複雜性通常不足以保護系統免受攻擊。</td><td>- 章節 4.9 加密 <br> - 章節 4.3 身份驗證與數據訪問控制</td></tr><tr><td>OWASP 2023</td><td>API2:2023 Broken Authentication 無效身分認證</td><td>身份驗證機制若實施不當，能使攻擊者破壞或利用身份驗證權杖，暫時或永久地冒用其他用戶的身份。破壞系統識別用戶端/使用者的能力，會損害 API整體安全。</td><td>- 章節 4.9 加密 <br> - 章節 4.3 身份驗證與數據訪問控制</td></tr></tbody></table><h2 id="2-加密破解-Cracking-Encryption">2. 加密破解 Cracking Encryption</h2><p>主要防禦方式：</p><ul><li>使用強大的加密方法很重要</li><li>同時也要妥善保護加密金鑰。</li><li>積極更換加密金鑰可以成為一種策略，以防止金鑰被破解或不夠強大。</li><li>在金鑰生成方面，金鑰的強度、質量和熵都起著重要作用，且金鑰不應重複使用。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.2 加密破解 Cracking Encryption</td><td>使用 弱的加密算法 和 弱的金鑰生成器 到 服務器端的漏洞、金鑰泄露、基本設計缺陷或漏洞</td><td>- 章節 4.9 Encryption <br> - 要求：EN-SS-R9 - 加密金鑰管理要求 <br> - 要求：EN-SS-R6 - 敏感數據的靜態加密</td></tr><tr><td>OWASP 2021</td><td>A02:2021 加密機制失效 Cryptographic Failures</td><td>此類別通常因資料加密使用較弱的加密算法或弱的金鑰生成器的加密演算法，導致敏感性資料外洩或者系統被破壞。</td><td>- 章節 4.9 Encryption <br> - 要求：EN-SS-R9 - 加密金鑰管理要求 <br> - 要求：EN-SS-R6 - 敏感數據的靜態加密</td></tr></tbody></table><h2 id="3-惡意軟體與勒索軟體的感染-Infection-of-Malware-and-Ransomware">3. 惡意軟體與勒索軟體的感染 Infection of Malware and Ransomware</h2><p>主要防禦方式：</p><ul><li>對於關鍵任務的資訊，災難復原副本應該使用各種反惡意軟體掃描工具進行掃描，以檢測已知的漏洞和異常。</li><li>對於敏感資料，應定期使用防毒工具掃描至少一個過去副本的子集識別是否有被感染的副本。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.3 惡意軟體與勒索軟體的感染 Infection of Malware and Ransomware</td><td>往往攻擊「存儲管理系統」比攻擊「存儲裝置」本身更容易。因此惡意軟體可能因安裝在存儲管理主機上，造成傷害，如竊取憑證、提升特權、資料損壞、損失或更改，以及破壞未來的備份等。</td><td>- 要求 AC-SS-R33 - 使用反惡意軟體掃描工具 <br> - 要求 RA-SS-R11 - 數據副本的網路安全措施 <br> - 要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</td></tr></tbody></table><h2 id="4-後門未修補的漏洞-Backdoors-and-Unpatched-Vulnerabilities">4. 後門未修補的漏洞 Backdoors and Unpatched Vulnerabilities</h2><p>主要防禦方式：</p><ul><li>通常 call home 或 remote access 被用於收集遙測和診斷數據，供製造商分析和解決技術問題，以及進行自動軟件更新。然而，這些功能也可能成為黑客攻擊的目標，因此如果不需要的話應該禁用，如果需要的話則應該限制和控制。</li><li>確保儲存軟體版本更新</li><li>安裝重要的安全更新和修補程式</li><li>制定無法取得修補程式時應採取的緩解計劃</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.4 後門未修補的漏洞 Backdoors and Unpatched Vulnerabilities</td><td>通常是軟體機制或功能，由供應商、個別貢獻者（在罕見情況下，可能是國家或惡意行為者）故意創建，由於門後具有潛在的危害性，它們並不在官方文檔中記錄，只有被限定的一組人才知道其存在。然而，隨著時間的推移，門後的存在可能會被故意或無意間洩露或被公眾發現。</td><td>- 要求：NC-SS-R10 停用未使用的儲存區域網路（SAN）埠 <br> - 章節 4.6 網路設定指引 <br> - 要求：AA-SS-R11 禁用或限制 call home 或 遠端存取 <br> - 要求：CM-SS-R8 軟體更新和修補</td></tr></tbody></table><h2 id="5-特權升級-Privilege-Escalation">5. 特權升級 Privilege Escalation</h2><p>主要防禦方式：</p><ul><li>除公開的資源外，<code>預設為拒絕存取</code></li><li>建⽴<code>存取控制機制</code>，並重複套⽤</li><li>記錄存取控制失效，並設定告警（例如：重覆登⼊失敗）</li><li>對 API 存取進⾏流量限制，降低⾃動攻擊帶來的損害</li><li>具⾝份識別之 Cookie，於<code>登出、超時後被註銷</code></li><li>JWT 使⽤最<code>短存取時間</code>，若⻑時間存取 JWT 建議遵循 OAuth 標準使其失效</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.5 特權升級 Privilege Escalation</td><td>利用軟體漏洞、設計或部署缺陷，或是配置錯誤，以至於獲得對於應用程式或使用者取得受保護資源的訪問權限。</td><td>- 章節 4.3 身份驗證與數據訪問控制 <br> - 要求：AC-SS-R26 - 默認分區的權限</td></tr><tr><td>OWASP 2023</td><td>API3:2023 - Broken Object Property Level Authorization 物件屬性級別授權失效</td><td>物件屬性級別的授權驗證缺失或不當導致資訊外洩或被未授權者篡改。</td><td>同上</td></tr><tr><td>OWASP 2023</td><td>API5:2023 - Broken Function Level Authorization 無效功能權限控管</td><td>複雜的存取控制策略涉及不同的層級、組態和角色，並且在管理和常規功能之間沒有明確的分離，這可能讓攻擊者將APIf請求發送至不應該可存取的端點，且端點沒有設置存取控制所導致授權漏洞。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A01:2021  Broken Access Control 權限控制失效</td><td>控制措施失效會導致未經授權的資訊洩露、修改、毀損，或執⾏超出原權限的業務功能。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A07:2021-Identification and Authentication Failures 認證及驗證機制失效</td><td>以前被稱為Broken Authentication，常見的可能帳號登入登出的設計機制不完善，因此標準化的架構有協助降低次風險發生機率。</td><td>同上</td></tr></tbody></table><h2 id="6-人為錯誤與故意配置失誤-Human-Error-and-Deliberate-Misconfiguration">6. 人為錯誤與故意配置失誤 Human Error and Deliberate Misconfiguration</h2><p>主要防禦方式：</p><ul><li>⾃動化的流程，可以部署及<code>確認環境中各類的安全設定</code></li><li>開發及營運環境，都須有<code>⼀致相同的設定</code>，並且使⽤不同的認證資訊</li><li>伺服器的功能最⼩化、區域化</li><li>依據相關更新，來執⾏安全審視及更動 (請參照 A06:2021-危險或過舊的元件)</li><li>使⽤安全表頭</li><li>當生產數據損壞或丟失時，組織應該能夠通過複製或備份的數據副本來恢復數據，應確保數據資產及其恢復副本之間具有足夠的隔離。</li><li>確保在業務中斷、災難恢復事件或資安攻擊後，能夠成功地復原。</li><li>維護全面且即時的配置管理清單，管理變更，以及確保配置持續符合組織的安全基線和目前業界最佳實踐，同時確保其不受已知風險的影響。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.6 人為錯誤與故意配置失誤 Human Error and Deliberate Misconfiguration</td><td>因使用者進行技術上支援的儲存配置更改，導致無法接受的風險。</td><td>- 章節 4.7 隔離 <br> - 章節 4.8 恢復保證 <br> - 章節 4.11 配置管理</td></tr><tr><td>OWASP 2023</td><td>API4:2023 - Unrestricted Resource Consumption 不受限的資源消耗</td><td>API常設計用來供查詢回傳資料，因此API會請求需要的網路頻寬、CPU、記憶體和儲存等資源。其他資源，如電子郵件/SMS/電話或生物識別驗證，利用API整合由服務提供者提供，並按請求付費。成功的攻擊者可能利用這項風險，造成導致拒絕服務或增加營運成本。</td><td>同上</td></tr><tr><td>OWASP 2023</td><td>API8:2023 - Security Misconfiguration 安全組態錯誤</td><td>API和支援系統通常包含複雜的配置，主要讓API更具彈性及客製化。軟體和DevOps工程師可能會忽視這些配置，或在配置方面未遵循安全最佳實踐，因而打開攻擊大門。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A05:2021- 安全配置錯誤 Security Misconfiguration</td><td>在系統正式環境開了不必要功能、服務、Port，導致有安全風險，XML外部實體攻擊(XXE)目前也被歸類於此類。</td><td>同上</td></tr><tr><td>OWASP 2021</td><td>A08:2021 Software and Data Integrity Failures 軟體及資料完整性失效</td><td>不安全的持續性整合/部署(CI/CD)流程、使⽤缺乏充⾜完整性驗證的⾃動更新。</td><td>同上</td></tr></tbody></table><h2 id="7-實體媒體的物理偷竊-Physical-Theft-of-Storage-Media">7. 實體媒體的物理偷竊 Physical Theft of Storage Media</h2><p>主要防禦方式：</p><ul><li>網路攻擊恢復的備份應該儲存在離線的地方，而不是和生產數據存放在同一地點。</li><li>這樣做可以確保即使攻擊者物理上進入生產地點，或者成功侵入物理位置，也無法訪問或破壞網路攻擊恢復的備份。</li><li>實體安全是確保任何資訊科技「基礎建設安全」的「基本要素」。很多時候「儲存基礎建設的實體安全」要求與「其他基礎建設元素」（例如電腦和網路設備）相同（例如設施安全、監控、運輸等）。<ul><li>基礎建設元素可以參考的相關標準包含： NIST SP 800-53, Rev5 NIST SP 800-171 。</li><li>有關媒體處置和銷毀可以參考：ISO 27040, NIST SP 800-88 有更近一步的討論。</li></ul></li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.7 實體媒體的物理偷竊 Physical Theft of Storage Media</td><td>所有的數據最終都儲存在一個或多個實體媒體上，而這些媒體容易受到偷竊的威脅。無論是在線或離線，都可能被從其指定的（固定）位置上移除，或者在實體運輸過程中被竊取（例如，正在運輸用於備份的媒體進行歸檔，或者作為數據中心遷移項目的一部分而運送存儲設備。</td><td>章節 4.1 實體儲存安全</td></tr></tbody></table><h2 id="8-網路竊聽資料-Network-Eavesdropping">8. 網路竊聽資料 Network Eavesdropping</h2><p>主要防禦方式：</p><ul><li>可以參考 NIST SP 800-209 章節 4.6 網路設定指引，該節主要涵蓋的網絡基礎設施（例如交換機、端口、HBA 和 NIC 配置、分區指南等）和協議。</li></ul><table><thead><tr><th>參考來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>NIST SP 800-209</td><td>3.3.8 網路竊聽資料 Network Eavesdropping</td><td>資料在傳輸時可能會被攔截。傳輸可以涵蓋許多組件：網路卡（有線或無線）、傳輸電纜（傳輸電力或光線）、中繼器、交換器、路由器等。這些組件中的任何一個都可能受到破壞，涉及對傳輸的資料、元數據或控制流量進行插入、刪除或修改。</td><td>章節 4.6 網路設定指引</td></tr></tbody></table><h2 id="9-不安全的映像、軟體和韌體-Insecure-Images-Software-and-Firmware">9. 不安全的映像、軟體和韌體 Insecure Images, Software and Firmware</h2><p>從NIST SP 800-209中，較少有針對應用程式的相關安全建議，但是很多時候，資料的外洩也是因為應用程式的不安全所導致，但是裡面較少談論到如何針對應用程式AP與數據之間的安全性。</p><p>在標準中與應用程式相關的安全建議主要有以下：</p><ul><li>要求 4.2.1 資料備份、恢復和儲存<ul><li>提到資料備份、恢復和儲存方面，應考慮應用程式和業務流程層面的資料完整性</li><li>嚴格要求還原速度的應用程式可用性</li></ul></li><li>要求 NC-SS-R3 - 使用混合方法進行 zoning<ul><li>基於主機的分區機制，主機上的應用程式可以存取和看到可存取的設被或儲存資源有哪些。</li></ul></li><li>要求：RA-SS-R9 - 分離數據與應用程式的還原<ul><li>還原數據時避免恢復受感染的代碼或軟體，應該將數據與應用程式進行分離。</li></ul></li><li>章節 4.3 身份驗證與數據訪問控制<ul><li>應限制應用程式的特權訪問，降低了存儲系統受到攻擊的風險。</li></ul></li></ul><p>而不安全的映像或軟體及韌體方面則是參考以下建議：</p><ul><li>要求 AC-SS-R33 - 使用反惡意軟體掃描工具</li><li>要求 RA-SS-R11 - 數據副本的網路安全措施</li><li>要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</li></ul><table><thead><tr><th>威脅來源</th><th>相關威脅</th><th>說明</th><th><div style="width:130px">NIST SP 800-209 安全建議</div></th></tr></thead><tbody><tr><td>應用程式（客戶端）</td><td>API1:2023 - Broken Object Level Authorization 不安全的物件授權</td><td>API 多半以公開方式處理物件識別，因此產生與物件存取控制相關的大範圍受攻擊面。OWASP建議物件授權應考慮在每項功能設計中，以防未授權的資訊洩露、資料被竄改或破壞。</td><td>- 要求 4.2.1 資料備份、恢復和儲存 <br> - 要求 NC-SS-R3 - 使用混合方法進行 zoning  <br> - 要求：RA-SS-R9 - 分離數據與應用程式的還原 <br> - 章節 4.3 身份驗證與數據訪問控制</td></tr><tr><td>應用程式（客戶端）</td><td>API6:2023 - Unrestricted Access to Sensitive Business Flows 不受限存取敏感商業流程</td><td>因應用程式流程上的問題所導致的威脅，受此影響的API可能是因為自動化流程過度使用所導致。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>API7:2023 - Server Side Request Forgery 伺服器端請求偽造</td><td>當API在未驗證使用者提供的 URI 的情況下獲取遠端資源時，可能會出現伺服器端請求偽造 (SSRF) 缺陷。這使攻擊者能夠強制應用程式將精心設計的請求發送到意想不到的目的地，即使受到防火牆或 VPN 的保護。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>API9:2023 - Improper Inventory Management 庫存管理不當</td><td>API通常比傳統Web應用程式暴露更多的端點，因此正確和更新文檔非常重要。對主機和API版本進行適當的管理也很重要，以減少如廢棄的API版本和暴露的測試端點等維護問題。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>A03:2021 Injection 注入式攻擊</td><td>XSS 攻擊、SQL Injection、Command Injection接屬於此類。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>A04:2021 Insecure Design</td><td>在設計系統及功能時，設計不完全導致產生的安全問題。</td><td>同上</td></tr><tr><td>應用程式（客戶端）</td><td>A10:2021 SSRF 伺服端請求偽造</td><td>當網站伺服器取得遠端資源，卻未驗證由使⽤者提供的網址，此時就會發⽣偽造伺服端請求，即便有防⽕牆、VPN 或其他網路 ACL 保護的情況下，仍得以達成攻擊。雲端服務和其結構的複雜性，偽造伺服端請求的嚴重性將會愈來愈嚴峻。</td><td>同上</td></tr><tr><td>映像、軟體和韌體</td><td>3.3.9 不安全的映像、軟體和韌體 Insecure Images, Software and Firmware</td><td>可能試圖干擾儲存設備的軟體分發、更新或安裝過程，以引入不正確、過時或惡意修改的程式碼。軟體更新過程的每個環節都可能成為引入被篡改軟體的目標。包含：發行者（例如供應商、第三方、開源社區）、傳遞方法（例如傳輸或下載、安裝媒體的運送、供應商員工的檔案複製）、個別組織保存的本地副本（例如代理伺服器、內部檔案伺服器）等。</td><td>- 要求 AC-SS-R33 - 使用反惡意軟體掃描工具 <br> - 要求 RA-SS-R11 - 數據副本的網路安全措施 <br> - 要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</td></tr><tr><td>第三方套件</td><td>API10:2023 Unsafe Consumption of APIs API的不安全使用</td><td>開發人員一般會更信任來自thrid-party API的資料，因此對thrid-party API採取較弱的安全標準。而攻擊者往往會優先攻擊Thrid-Party服務，而不是直接嘗試破壞目標API。</td><td>- 要求 AC-SS-R33 - 使用反惡意軟體掃描工具 <br> - 要求 RA-SS-R11 - 數據副本的網路安全措施 <br> - 要求：DP-SS-R3.c 對於備份相關的標準作業程序應包含的要求</td></tr><tr><td>第三方套件</td><td>A06:2021 Vulnerable and Outdated Components 危險或過舊的元件</td><td>在系統開發使用有已知弱點的元件(作業系統、軟體、套件、函示庫、框架)。</td><td>同上</td></tr><tr><td>第三方套件</td><td>A08:2021 Software and Data Integrity Failures 軟體及資料完整性失效</td><td>反序列化攻擊及第三⽅套件信任問題是此項⽬中之重點，這其中包含程式碼或基礎架構未能保護軟體及資料之完整性、不安全的反序列化、 使⽤不受信任來源之套件、函式庫、模組等。</td><td>同上</td></tr></tbody></table><h2 id="10-資安記錄及監控失效-Security-Logging-and-Monitoring-Failures">10. 資安記錄及監控失效 Security Logging and Monitoring Failures</h2><p>因為 NIST SP 800-209沒有針對資安紀錄有獨立列出威脅，然而在OWASP Top 10 2021的A09，有提及資安紀錄及監控失效的相關威脅，同時 NIST SP 800-209 第四章節中也有提及，針對資安紀錄及監控失效的重要性，而建議採取的相關措施，因此本節在此新添加一威脅面向。</p><table><thead><tr><th>相關威脅</th><th>說明</th><th>防禦方式</th></tr></thead><tbody><tr><td>AA09:2021 資安記錄及監控失效 Security Logging and Monitoring Failures</td><td>此類故障可能會直接影響可見性、事件警報和取證。</td><td>章節 4.4 (AL) 審計日誌</td></tr></tbody></table><h1 id="統整02：設計威脅模型">統整02：設計威脅模型</h1><p>以下威脅模型是<strong>參考NIST SP 800-209 和 OWASP Top 10的常見威脅</strong>，所整理出來的威脅模型。裡面的環境主要簡單描述在資料基礎架構中，系統邊界、資料傳輸、備份監控等，可能會面臨的威脅。可以根據以下威脅，於統整01中的威脅參考相關的威脅描述與相關的安全建議。</p><p><img src="https://i.imgur.com/HOvKOAN.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> Database </category>
          
          <category> 畢業論文 </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> 碩士論文 </tag>
            
            <tag> Cloud Storage </tag>
            
            <tag> Security </tag>
            
            <tag> NIST SP 800-209 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day10 - 如何介入 Connection Pool？</title>
      <link href="/posts/interupt-connection-pool/"/>
      <url>/posts/interupt-connection-pool/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://wearecommunity.io/communities/india-java-user-group/articles/2344">Hikari Connection Pooling with Spring Boot</a></li><li><a href="https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/rds-proxy.html">AWS RDS Proxy</a></li><li><a href="https://github.com/brettwooldridge/HikariCP">Hikrai-Source Code</a></li><li><a href="https://www.ithome.com.tw/news/138554">AWS推出能提升關聯式資料庫應用可擴展性的代理服務</a></li><li><a href="https://blog.csdn.net/fly_duck/article/details/109755842?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109755842-blog-124268396.235%5Ev38%5Epc_relevant_sort&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109755842-blog-124268396.235%5Ev38%5Epc_relevant_sort&amp;utm_relevant_index=2">Hikrari配置設定</a></li><li><a href="https://blog.csdn.net/wangmx1993328/article/details/81865153?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=SpringBoot%20Hikari%20%E8%87%AA%E5%AE%9A%E7%BE%A9datasourc&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-81865153.nonecase&amp;spm=1018.2226.3001.4187">注入是用於監控的Druid dataSource</a></li><li><a href="https://blog.51cto.com/boytnt/5794967">如何指定自己extends Hirkari的DataSource</a></li><li><a href="https://www.modb.pro/db/59110">如何构建实用的RDS Proxy? (一)</a>:有稍微提到怎麼使用Golang實作一個RDS Proxy</li><li><a href="https://github.com/ShannonHung/kingshard">kingshard</a>:一個開源的Mysql Proxy但是已經沒在維護了，是用GO寫的</li><li><a href="https://dev.mysql.com/doc/internals/en/connection-phase.html">MySQL官网连接过程介绍</a>:官方連線協議說明</li><li><a href="https://www.jianshu.com/p/af1c5406c737">mysql握手协议抓包</a>: 有大概說明mysql的協議抓包內容</li><li><a href="https://ithelp.ithome.com.tw/articles/10226783">30-25之資料庫層的擴展 - 讀寫分離架構</a>:資料庫的讀寫分離說明</li></ul><h1 id="前言">前言</h1><p>可以參考我的論文方向，是如何在資料庫中滿足零信任要求，<strong>零信任機制其實核心說白了就是存取控制機制</strong>，在Authentication驗證這個人是誰之時，取得所有相關的上下文，甚至是風險，經過多方考量後，最後做Authorization授權。那既然我們的目的在於，如何在資料庫中滿足零信任要求…</p><blockquote><p>就要去探討到，做驗證和授權的地方在資料庫的哪裡？非Connection莫屬了。<br>但是到底有哪些方式可以介入Connection呢？</p></blockquote><ol><li><p><strong>透過第三方介入connection Pool</strong></p><ul><li>講到驗證和授權，就會想到建立連線時，我們通常會提供driver, username, password, url來建立連線，而<strong>建立連線時最常提到的是Connection Pool，其實說白了就是一個application和datasource建立連線時的中間層，這個中間層可以做很多事情，像是連線池、讀寫分離、快取查詢結果等等</strong>。而我們就是要在這個中間層做驗證和授權。</li><li>簡單介入Connection Pool的方式，像可以改寫一些應用程式的第三方套件，像是Spring Boot使用的HikariDataSource</li></ul></li><li><p><strong>使用Database Proxy</strong></p><ul><li>我第一次看到這個詞是在看Hikari的Source Code時，發現有Proxy的連線設定。後來上網一查，立馬跳出來的就是AWS RDS Proxy。AWS RDS Proxy全名稱Relation Database。</li><li>透過Database Proxy也可以做到驗證和授權，簡單來說他就是介於多個應用程式跟資料庫的中間層。</li><li>與Connection Pool類似都是作為應用程式中間層的存在，但是應用面比較廣，因為他不是只有針對單一應用程式，而是作為所有應用程式的連線資料庫的入口。</li></ul></li></ol><h1 id="使用Database-Proxy">使用Database Proxy</h1><h2 id="AWS-RDS-Proxy">AWS RDS Proxy</h2><p><img src="https://i.imgur.com/N44uCbX.png" alt=""></p><p>AWS RDS Proxy是一個中間層的服務，可以讓應用程式與資料庫之間的連線更加穩定，並且提供了一些功能，像是連線池、讀寫分離、快取查詢結果等等。AWS有許多應用程式，像是AWS Lambda、Fargate、Amazon ECS或EKS，等多個<strong>應用程式中會有大量且快速地開啟或關閉，與資料庫伺服器間的連結的需求，而這樣的操作容易耗盡資料庫的記憶體和運算資源。</strong></p><blockquote><p>連接池：減輕建立新連接時，對資料庫記憶體和運算資源造成的影響</p></blockquote><p>因此才有了RDS Proxy，Amazon <strong>RDS Proxy的執行個體會維護與RDS資料庫執行個體間建立的連接池</strong>，減輕建立新連接時，對資料庫記憶體和運算資源造成的影響，並且在應用程式間共用這些連結，進而提高資料庫的效率以及應用程式的可擴展性。</p><blockquote><p>連線中斷：避免因為資料庫服務中斷，造成應用程式可用性問題</p></blockquote><p>而且RDS Proxy能夠在維持現有連接的狀態下，連接新的資料庫執行個體，因此可以最大程度<strong>減少因為資料庫服務中斷，所造成的應用程式可用性問題</strong>，當<strong>資料庫故障時，RDS Proxy會直接將請求路由到新的資料庫執行個體</strong>，這樣可以使得故障轉移時間減少66％。</p><blockquote><p>身份驗證：避免把權限寫死在程式碼中</p></blockquote><p>RDS Proxy讓使用者可強制資料庫存取使用IAM身份驗證，因此將能<strong>避免資料庫憑證被寫死在程式碼中的安全性風險</strong>，多增加了一道的安全性控制，而且藉由RDS Proxy，使用者還能以AWS Secrets Manager集中管理資料庫憑證。</p><h3 id="操作說明">操作說明</h3><p>其實做Database Proxy的好處就是，<strong>可以在不同應用程式中共享那個Connection來加快速度，在微服務的世界，不同應用存取一個database的需求很大</strong>，但是如果每個應用都要自己建立一個Connection，那麼就會造成資源的浪費，而且也不好管理。因此我們可以透過RDS Proxy來管理這些Connection，讓不同的應用程式共享同一個Connection。</p><p>可以參考以下影片了解Proxy怎麼建立和設定：</p><ul><li><a href="https://youtu.be/ZQOqmMn_8jw">https://youtu.be/ZQOqmMn_8jw</a></li></ul><h2 id="kingshard">kingshard</h2><p>kingshard是一個由Go開發高性能MySQL Proxy項目，可以做到以下幾點，也是可以作為零信任架構的可用功能：</p><ol><li><strong>SQL的讀寫分離</strong>：讀寫分離最簡單的就是所有寫入的都寫入到一台服務，讀取時讀取一台服務。通常是主從式master-slave架構，由master負責寫的服務，會與 slave 進行資料同步。slave主要用來讀的服務。</li><li><strong>透明的Connection Pool，不需要每次做連線</strong>: 透明的連線池，就是在應用程式中不需要額外的程式碼，就可以使用連線池的功能。</li><li><strong>SQL的日誌輸出</strong>：幾本上可以收集這些日誌，近一步做分析利用。</li><li><strong>SQL的黑白名單機制</strong>：支持客戶端IP訪問白名單機制，只有白名單中的IP才能訪問kingshard（支持IP 段）。甚至可以偵測SQL的內容，當偵測到有危險的SQL時，可以直接將該SQL拒絕執行。</li></ol><h3 id="架構說明">架構說明</h3><p><img src="https://i.imgur.com/sqZ62gq.png" alt=""><br>kingshard的整體工作流程如下所述：</p><ol><li>讀取<strong>配置文件並啟動</strong></li><li>在配置文件中<strong>設置的監聽端口監聽客戶端請求</strong></li><li><strong>收到客戶端連接請求後，啟動一個goroutine單獨處理該請求</strong>。</li><li>首選進行登錄驗證，<strong>驗證過程完全兼容MySQL認證協議</strong>，由於用戶名和密碼在配置文件中已經設置好，所以可以利用該信息驗證連接請求是否合法。</li><li>當<strong>用戶名和密碼都正確時，轉入下面的步驟</strong>，否則返回出錯信息給客戶端。</li><li>認證通過後，<strong>客戶端發送SQL語句</strong>。<ol><li>kingshard對<strong>客戶端發送過來的SQL語句，進行詞法和語義分析</strong>。識別出SQL的類型和生成SQL的路由計劃。如果有必要還會改寫SQL。然後<strong>轉發到相應的DB</strong>。</li><li>也有可能不做詞法和語義分析直接轉發到相應的後端DB。如果轉發SQL是分錶且跨多個DB，則每個DB對應啟動一個goroutine發送SQL和接收該DB返回的結果。</li></ol></li><li><strong>接收並合併結果</strong>，然後轉發給客戶端。</li></ol><h1 id="改寫-Hikari-Datasource">改寫 Hikari Datasource</h1><p>除了Proxy之外，如果是<strong>針對特定應用程式，希望連線可以共享，而非每次建立新的Connection則可以考慮改寫Hikari Datasource</strong>。但是這個就不像Proxy那樣方便並且使用廣泛。就像前一篇<a href="/posts/about-jdbc-connection-pool.html">Day09 - 淺入淺出 JDBC, Connection Pool</a>所提到的，有很多第三方套件實作，其中spring boot預設採用Hikari，因為他是效能之冠。但是如果我們希望在<code>getConnection()</code>的時候可以先驗證一下Application的身份，或是在<code>prepareStatement()</code>的時候可以先驗證一下Application的權限，免不了要自己重新定義裡面的實作方法。</p><p>具體來說，可以怎麼重新撰寫自己的實作呢？</p><ul><li>這個連結還算不錯：<a href="https://blog.51cto.com/boytnt/5794967">如何指定自己extends Hirkari的DataSource</a></li></ul><blockquote><p>繼承HikariDataSource</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHikariDataSource</span> <span class="keyword">extends</span> <span class="title class_">HikariDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 這裡可以做一些設定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在config中設定自己的class</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.type=com.test.dao.MyHikariDataSource</span>    <span class="comment">#指定自己的class</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/db</span></span><br><span class="line"><span class="string">spring.datasource.username=USERNAME</span></span><br><span class="line"><span class="string">spring.datasource.password=PASSWORD</span>    </span><br></pre></td></tr></table></figure><h1 id="我的下一步">我的下一步</h1><p>目前比較能知道的是，透過Proxy能夠介入Connection Pool的應用面向更廣，所以接下來幾天要先能夠深入了解：</p><ul><li>[ ] 目前保護資料庫的方式與實施ZTA於Database的必要與</li><li>[ ] 雲端不同proxy的功能比較，安全性的比較功能。<ul><li>[ ] 比較市面上目前有的solution，裡面缺了什麼樣的功能</li><li>[ ] cloudfare zta tunnel 目的是建立安全的database connection, cloudfare 是讓遠端工作者可以安全連線</li></ul></li><li>[ ] 清楚你做出內容的貢獻可以是什麼？</li></ul><p>在了解可以介入Connection Pool的方式後，決定要採用Proxy的方式進行研析，但是這就意味著要深入了解Mysql的連線協議，以及Proxy的實作方式。這個部分我會在下一篇文章中進行介紹。目前規劃如下：</p><ul><li>[ ] 深入了解Mysql協議</li><li>[ ] 學習 Go 語言</li><li>[ ] 深入了解Proxy的實作方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> Database </category>
          
          <category> 畢業論文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Connection Pool </tag>
            
            <tag> 碩士論文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 JDBC, Connection Pool</title>
      <link href="/posts/about-jdbc-connection-pool/"/>
      <url>/posts/about-jdbc-connection-pool/</url>
      
        <content type="html"><![CDATA[<h1 id="參考資料">參考資料</h1><ul><li><a href="https://www.1ju.org/jdbc/jdbc-introduction">JDBC是什麼？</a></li><li><a href="https://medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50">(14) 深入 JDBC、Connection Pool，並導入 H2 DB</a></li><li><a href="https://medium.com/@sawomirkowalski/design-patterns-object-pool-e8269fd45e10">Design Pattern - Object Pool</a></li><li><a href="https://iter01.com/16624.html">深入瞭解資料庫連線池的實現及原理</a></li><li><a href="https://www.linqz.io/2019/03/why-to-use-hikari-connection-pool.html">為什麼hikari這麼快的原因</a></li><li><a href="https://blog.csdn.net/assember/article/details/121976290">spring-boot-starter-jdbc 和 spring-boot-starter-data-jdbc 的区别</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#data-properties">Spring Boot- Data properties</a></li></ul><h1 id="前言">前言</h1><p>JDBC的全名是Java DataBase Connectivity，主要適用於<strong>Java程式語言 和 資料庫 之間連接的API標準</strong>，你也可以說他是Library，這裡的API到底指哪些事情呢？</p><ol><li>連接到資料庫</li><li>創建, 執行 SQL</li></ol><h1 id="JDBC-架構">JDBC 架構</h1><p><img src="https://i.imgur.com/D1mM5vk.png" alt=""><br>JDBC API提供以下接口和類:</p><ul><li><code> Driver Manager</code>: 管理資料庫驅動程式的列表，可以將Java Application的連接請求，與資料庫驅動程式進行配對，以<strong>建立資料庫的連接</strong>。</li><li><code>Driver</code>: <strong>處理與資料庫的通信</strong>，很少會直接與Driver溝通，而是會透過Driver Manager來管理這個對象。</li><li><code>Connection</code>: <strong>連繫數據庫的方法</strong>。</li><li><code>Statement</code>: 用於<strong>執行SQL語句</strong>，並返回結果。</li><li><code>ResultSet</code>: 用於保存從數據庫中<strong>獲取的結果集</strong>。</li><li><code>SQLException</code>: 此類處理數據庫應用程序中<strong>發生的任何錯誤</strong>。</li></ul><blockquote><p>可以透過以下範例，來了解 JDBC API接口的用途：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參考 https://medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50</span></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLDatabaseConnection</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect to your database.</span></span><br><span class="line">  <span class="comment">// Replace server name, username, and password with your credentials</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 載入 SQLServer 的 JDBC Driver</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 編輯連線協定，</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">connectionUrl</span> <span class="operator">=</span></span><br><span class="line">        <span class="string">&quot;jdbc:sqlserver://yourserver.database.windows.net:1433;&quot;</span></span><br><span class="line">        + <span class="string">&quot;database=AdventureWorks;&quot;</span></span><br><span class="line">        + <span class="string">&quot;user=yourusername@yourserver;&quot;</span></span><br><span class="line">        + <span class="string">&quot;password=yourpassword;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用來接住回傳結果</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html</span></span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">      <span class="comment">// 3. 建立連線</span></span><br><span class="line">      <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(connectionUrl);</span><br><span class="line">      <span class="comment">// 4. 建立Statement物件供提交SQL命令使用</span></span><br><span class="line">      <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create and execute a SELECT SQL statement.</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">selectSql</span> <span class="operator">=</span> <span class="string">&quot;SELECT TOP 10 Title, FirstName, LastName from SalesLT.Customer&quot;</span>;</span><br><span class="line">      <span class="comment">// 5. 提交SQL命令，並取得結果</span></span><br><span class="line">      resultSet = statement.executeQuery(selectSql);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Print results from select statement</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        System.out.println(resultSet.getString(<span class="number">2</span>) + <span class="string">&quot; &quot;</span> + resultSet.getString(<span class="number">3</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 結束工作</span></span><br><span class="line">      <span class="comment">// 6. 釋放資源，關閉Connection連線以及Statement</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDBC-連線">JDBC 連線</h1><p>通常要進行資料庫連線，需要以下步驟：</p><ol><li><strong>設定Driver</strong>: 載入 SQLServer 的 JDBC Driver</li><li><strong>建立連線</strong>: (需要呼叫 DriverManager.getConnection())，開啟 TCP socket</li><li><strong>提交SQL</strong>: 建立 Statement ，並提交 SQL 命令列</li><li><strong>關閉連線</strong>: 關閉 TCP socket</li></ol><p>然而每一次需要與資料庫進行溝通時，都要這樣開開關關，對於系統來說就會造成許多不必要的負擔。</p><div class="note info flat"><p>如果我們可以於每次連線時，將那些一直重複的動作提取出來，那麼就可以減少對系統的負擔，並且加快程式的執行效能。<strong>這就是我們接下來要談的Connection Pool</strong>。</p></div><h2 id="Connection-Pool">Connection Pool</h2><p>Connection Pool是使用「Object Pool Pattern」的設計模式來實現的。先讓我們來一段wiki的說明吧！</p><blockquote><p>物件池（英語：object pool pattern）是一種設計模式。<strong>一個物件池包含一組已經初始化過且可以使用的物件</strong>，而可以在有需求時創建和銷毀物件。池的用戶可以從池子中取得物件，對其進行操作處理，並在不需要時歸還給池子而非直接銷毀它。這是一種特殊的工廠物件。</p><footer><strong>wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F">zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F</a></cite></footer></blockquote><p>簡單來說，就是將一些常用的物件，事先建立好，並且放在一個池子裡面，當有需要時，就可以直接從池子裡面取出物件，而不需要每次都重新建立物件。<strong>使用物件池可以獲得顯著的效能提升。從池子中取得物件的時間是可預測的，但新建一個實例所需的時間是不確定。</strong></p><p>下圖顯示了客戶端如何使用池中的連接來連接到數據源。主要工作是：</p><ol><li>管理可用的connection</li><li>分配connection</li><li>關閉connection<br><img src="https://i.imgur.com/5NFJcwZ.png" alt=""></li></ol><p>那我們先來看UML圖吧！</p><ul><li><code>Object Pool Class</code>: 是Singleton，因此有一個private的constructor，並且有一個static的getInstance()方法，用來取得Object Pool的實例。</li><li><code>acquireReusable()</code>: 用來取得Object Pool中的物件，如果沒有物件可以取得，則會建立新的物件。</li><li><code>releaseReusable()</code>: 用來從client手中釋放Object物件，並且把該object拉回可用對象(avaliable)。</li><li><code>setMaxPoolSize()</code>: 用來設定Object Pool的最大容量。</li></ul><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram    class client    class ResuablePool{        - reusable        +BigDecimal balance        +static getInstance() ReusablePool        +acquireReusable() Reusable        +releaseReusable(Reusable reusable)        +setMaxPoolSize(int maxPoolSize)    }    client --&gt; ResuablePool : ResusablePool.getInstance().acquareReusable()  </pre></div><h2 id="JDBC-Connection-Pool-Example">JDBC Connection Pool Example</h2><p>一個簡單的 JDBC Connection Pool 可以參考<a href="https://github.com/MicrosoftDocs/azure-docs.zh-tw/blob/master/articles/mysql/sample-scripts-java-connection-pooling.md">Azure的做法</a>，你可以在裡面看到一個 Connection Pool 是怎麼實做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLConnectionPool</span> &#123;</span><br><span class="line">    <span class="comment">// 連線用的必要資訊</span></span><br><span class="line">    <span class="keyword">private</span> String databaseUrl;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// pool 的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxPoolSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 目前連線的數量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SQL_VERIFYCONN</span> <span class="operator">=</span> <span class="string">&quot;select 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前可用的Connection</span></span><br><span class="line">    Stack&lt;Connection&gt; freePool = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 目前正在使用的Connection</span></span><br><span class="line">    Set&lt;Connection&gt; occupiedPool = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor: 創建一個Connection Pool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseUrl</span></span><br><span class="line"><span class="comment">     *            The connection url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     *            user name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     *            password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize</span></span><br><span class="line"><span class="comment">     *            max size of the connection pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySQLConnectionPool</span><span class="params">(String databaseUrl, String userName,</span></span><br><span class="line"><span class="params">            String password, <span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseUrl = databaseUrl;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.maxPoolSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get an available connection</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> An available connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             Fail to get an available connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沒辦法在建立新的連線 (已達到最大連線數)</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(<span class="string">&quot;The connection pool is full.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回傳freePool中的連線，並且標記該連線為occupied</span></span><br><span class="line">        conn = getConnectionFromPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果conn是空的表示freePool裡面沒有任何object，因此我們需要建立新的連線</span></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            conn = createNewConnectionForPool();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有些database一段時間沒使用會自動斷連線，所以我們可以確認一下從freePool取出的connection是否還有連線著</span></span><br><span class="line">        <span class="comment">// For Azure Database for MySQL, if there is no action on one connection for some</span></span><br><span class="line">        <span class="comment">// time, the connection is lost. By this, make sure the connection is</span></span><br><span class="line">        <span class="comment">// active. Otherwise reconnect it.</span></span><br><span class="line">        conn = makeAvailable(conn);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 這邊注意的是，要使用synchronized才會把singleton的object lock住，確保不會有多個thread同時還回去多個connection</span></span><br><span class="line"><span class="comment">     * client使用完，要還回去Pool中</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Return a connection to the pool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     *            The connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             When the connection is returned already or it isn&#x27;t gotten</span></span><br><span class="line"><span class="comment">     *             from the pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">returnConnection</span><span class="params">(Connection conn)</span></span><br><span class="line">            <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 如果conn是空的，表示client沒有使用connection，因此不需要回傳</span></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 檢查 conn 是否在 occupiedPool 中，並且可以從 occupiedPool 中移除，如果不是，則拋出 SQLException</span></span><br><span class="line">        <span class="keyword">if</span> (!occupiedPool.remove(conn)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SQLException</span>(</span><br><span class="line">                    <span class="string">&quot;The connection is returned already or it isn&#x27;t for this pool&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果沒跳Exception則已經從occupied移除，可以放回 freePool 中</span></span><br><span class="line">        freePool.push(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也要使用synchronized，確保資源被lock住，以正確做檢查freePool是否已經塞滿</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Verify if the connection is full.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if the connection is full</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((freePool.size() == <span class="number">0</span>) &amp;&amp; (connNum &gt;= maxPoolSize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因為connection必須是singleton才不會無謂的一直建立資源</span></span><br><span class="line"><span class="comment">     * 因此有一個private的constructor，確保只有透過getInstance()才能取得實例</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Create a connection for the pool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new created connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             When fail to create a new connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">createNewConnectionForPool</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> createNewConnection();</span><br><span class="line">        connNum++;</span><br><span class="line">        occupiedPool.add(conn);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 創建連線，必須是private，確保只有透過createNewConnectionForPool()才能取得實例</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Crate a new connection</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new created connection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             When fail to create a new connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">createNewConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        conn = DriverManager.getConnection(databaseUrl, userName, password);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 從freePool中取出一個連線，並且放入occupiedPool</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Get a connection from the pool. If there is no free connection, return</span></span><br><span class="line"><span class="comment">     * null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the connection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">getConnectionFromPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先reset </span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 如果有空閒的連線，就從freePool中取出，並且放入佔用中的occupiedPool</span></span><br><span class="line">        <span class="keyword">if</span> (freePool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn = freePool.pop();</span><br><span class="line">            occupiedPool.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回傳連線</span></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 檢查連線是否還連線著，如果沒有則重新連線</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Make sure the connection is available now. Otherwise, reconnect it.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     *            The connection for verification.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the available connection.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             Fail to get an available connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">makeAvailable</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 透過下Query來確認連線是否還連線著</span></span><br><span class="line">        <span class="keyword">if</span> (isConnectionAvailable(conn)) &#123;</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果發現沒有連線，就把該連線從occupiedPool中移除，並且關閉該連線</span></span><br><span class="line">        occupiedPool.remove(conn);</span><br><span class="line">        connNum--;</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然後重新建立一個新的，並且放入occupiedPool</span></span><br><span class="line">        conn = createNewConnection();</span><br><span class="line">        occupiedPool.add(conn);</span><br><span class="line">        connNum++;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 確認一下目前連線是否還連線著，可以透過下Query來確認</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * By running a sql to verify if the connection is available</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     *            The connection for verification</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if the connection is available for now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isConnectionAvailable</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            st.executeQuery(SQL_VERIFYCONN);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Just an Example</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 建立資源池 </span></span><br><span class="line">        <span class="type">MySQLConnectionPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLConnectionPool</span>(</span><br><span class="line">                <span class="string">&quot;jdbc:mysql://mysqlaasdevintic-sha.cloudapp.net:3306/&lt;Your DB name&gt;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&lt;Your user&gt;&quot;</span>, <span class="string">&quot;&lt;Your Password&gt;&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取得連線 </span></span><br><span class="line">            conn = pool.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 準備一個Query來執行</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;show tables&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;There are below tables:&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">tblName</span> <span class="operator">=</span> res.getString(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(tblName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 釋放連線</span></span><br><span class="line">                pool.returnConnection(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="關於第三方套件Connection-Pool">關於第三方套件Connection Pool</h1><p>現在我們可以理解 Connection Pool 的運作原理了，其實已經有許多的第三方套件供我們使用，而且這些第三方的 Connection Pool 套件也已經非常成熟，在效能上以及減少重工的基礎上。</p><blockquote><p>會發展出不同的第三方的 Pool 主要原因就是因為效能，因為 JDBC 針對JDBC Driver 的介面有做了規範，因此各家廠商做出來的 Connection Pool 也都會符合 JDBC Driver Interface 的 API，也就是 API 都相同，差別就在於不同第三方套件的內部實做所影響的效能。</p><footer><strong>Albert</strong><cite><a href="https://medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50">medium.com/learning-from-jhipster/14-%E6%B7%B1%E5%85%A5-jdbc-connection-pool-%E4%B8%A6%E5%B0%8E%E5%85%A5-h2-db-939adee9c50</a></cite></footer></blockquote><p>目前最厲害效能最好的第三方Connection Pool是HikariCP，而且它的效能是其他的Connection Pool的兩倍以上。<br>下圖中：</p><ul><li><strong>Connection Cycle 比較連線速度</strong>，表示從 <code>DataSource.getConnection()</code> 到 <code>Connection.close()</code> 結束。Hikari可以在<strong>1毫秒內完成4萬到5萬次的連線</strong>。</li><li><strong>Statement Cycle 比較執行sql速度</strong>，表示 <code>Connection.prepareStatement()</code> 到 <code>Statement.execute()</code>到 <code>Statement.close()</code>。執行sql的速度上，在<strong>1毫秒內可以完成約1萬5000次的cycle</strong>。比較可以跟的上的大概就只有 Tomcat 的 JDBC Connection Pool ，其他的效能也就不值一提了。</li></ul><blockquote><p>想了解為什麼這麼快可以讀這篇：<a href="https://www.linqz.io/2019/03/why-to-use-hikari-connection-pool.html">為什麼hikari這麼快的原因</a></p></blockquote><p><img src="https://i.imgur.com/0d8CJ8e.png" alt=""></p><h1 id="關於Spring-boot使用的第三方套件">關於Spring boot使用的第三方套件</h1><p>前面說明了JDBC與資料庫進行連線的方式，也說明了 Connection Pool 的重要性。而在 Spring Boot 他幫我們整合了一系列最常使用的工具，當然對於 JDBC 或是 Connection Pool 或是 JPA 等等相關的內容也是一併的簡化配置作業。</p><p>因此現在只需要簡單的 Import Dependencies 並加上 Properties 的設定，就可以快速又方便的與資料庫進行連線。我們如果要透過Java的應用程式跟資料庫做溝通，通常一定會import這個套件<code>spring-boot-starter-jdbc</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是現在主要使用 <code>spring-boot-starter-data-jdbc</code>，多了一個data的單字！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="spring-boot-starter-data-jdbc">spring boot starter (data) jdbc</h2><p>如果我們使用 <code>spring-boot-starter-jdbc</code> 或 <code>spring-boot-starter-data-jpa</code> “starters”，我們會自動獲得對 HikariCP 的依賴關係。 （請參閱下面的快照）<br><img src="https://i.imgur.com/BO5bFfS.png" alt=""></p><p>有沒有data的套件到底差異在哪裡呢？如果你是使用JPA進行開發，那最常用的就是<code>spring-boot-starter-data-jdbc</code>。</p><ul><li><code>spring-boot-starter-jdbc</code>: 這個套件是最基礎的包，如果你只是要使用JDBC的話，那就只需要引入這個套件就可以了。</li><li><code>spring-boot-starter-data-jdbc</code>: 這個套件是在<code>spring-boot-starter-jdbc</code>的基礎上，還提供了<code>curdReporitory</code>的快速開發接口，如果你要使用JPA的話，那就需要引入這個套件。</li></ul><blockquote><p>spring-jdbc (from: <a href="https://blog.csdn.net/assember/article/details/121976290">https://blog.csdn.net/assember/article/details/121976290</a>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunAQuery</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只提供基本的連線</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from mytable&quot;</span>, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject(<span class="string">&quot;select name from mytable&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>spring-data-jdbc 除了基礎的資料庫連接還提供CrudReporitoy</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.repository.CrudRepository;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">CrudRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/08ZhuEH.png" alt=""></p><h2 id="properties設定">properties設定</h2><p>如果你有仔細去看看這個 Starter 的內容，會發現他其實主要包含兩個Dependency：</p><ol><li>spring-JDBC: Spring針對JDBC封裝後的Library，如果使用這個套件必須在Properties(<code>application.yml</code>)設定資料庫的連線資訊。</li><li>HikariCP: Spring Boot將HikariCP做為預設的Connection Pool，並包含在<code>spring-boot-starter-jdbc</code>中。(人家效率太高了)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以參考Spring Boot - Data Properties 的設定方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 如果想指定自己的ConnectionPool應該就要從這裡下手</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">設定ConnectionPool的DataSource</span> <span class="string">(或從classPath中自動檢測)</span> </span><br><span class="line">    <span class="attr">url:</span> <span class="string">設定jdbc連線至資料庫的url</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">設定jdbc連線至資料庫的帳號</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">設定jdbc連線至資料庫的密碼</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">設定JDBC的Driver</span> <span class="string">(或依照url自動檢測)</span></span><br></pre></td></tr></table></figure><h2 id="spring-datasource-type">spring.datasource.type</h2><p>因為導入了<code>spring-boot-starter-data-jdbc</code>，所以我們可以直接使用<code>spring.datasource.type</code>來設定我們要使用的Connection Pool，預設上spring boot會從classpath中自動檢測，如果沒有找到的話就會使用HikariCP。<br>如果你想要知道知道他是如何自動偵測的，或是可以自動偵測哪些 class name，可以參考 <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/DataSourceBuilder.java">DataSourceBuilder.java — Source Code</a>，或參考下方程式碼：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">DataSource</span>&gt; MappedDataSourceProperties&lt;T&gt; <span class="title function_">lookupPooled</span><span class="params">(ClassLoader classLoader,</span></span><br><span class="line"><span class="params">Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">MappedDataSourceProperties&lt;T&gt; result = <span class="literal">null</span>;</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>,</span><br><span class="line">HikariDataSourceProperties::<span class="keyword">new</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;org.apache.tomcat.jdbc.pool.DataSource&quot;</span>,</span><br><span class="line">TomcatPoolDataSourceProperties::<span class="keyword">new</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>,</span><br><span class="line">MappedDbcp2DataSource::<span class="keyword">new</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;oracle.ucp.jdbc.PoolDataSourceImpl&quot;</span>,</span><br><span class="line">OraclePoolDataSourceProperties::<span class="keyword">new</span>, <span class="string">&quot;oracle.jdbc.OracleConnection&quot;</span>);</span><br><span class="line">result = lookup(classLoader, type, result, <span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>,</span><br><span class="line">ComboPooledDataSourceProperties::<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在這個片段程式碼中，我們可以看到 Spring Boot 會自動偵測如下幾個 Connection Pool，但是預設是HikariDataSource</p><ul><li><code>org.springframework.jdbc.datasource.SimpleDriverDataSource</code></li><li><code>com.zaxxer.hikari.HikariDataSource</code></li><li><code>org.apache.tomcat.jdbc.pool.DataSource</code></li><li><code>oracle.ucp.jdbc.PoolDataSourceImpl</code></li><li><code>oracle.jdbc.OracleConnection</code></li><li>etc.</li></ul><blockquote><p>If you use the spring-boot-starter-jdbc or spring-boot-starter-data-jpa “starters”, you automatically get a dependency to HikariCP.</p><footer><strong>spring-doc</strong><cite><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool">docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool</a></cite></footer></blockquote><div class="note danger flat"><p><code>org.springframework.jdbc.datasource.SimpleDriverDataSource</code> 查看他的<a href="https://mvnrepository.com/artifact/org.springframework/spring-jdbc">API說明文件</a>可以發現上面寫<strong>NOTE: This class is not an actual connection pool; it does not actually pool Connections</strong>表示：這個類別並不是真正的Connection Pool，他並不會真的去做Connection Pool的動作。</p></div>]]></content>
      
      
      <categories>
          
          <category> 研究 </category>
          
          <category> Database </category>
          
          <category> 畢業論文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> Connection Pool </tag>
            
            <tag> 碩士論文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh Agent 透過 Wazuh API 來註冊於 Wazuh Server</title>
      <link href="/posts/wazuh-agent-install-api/"/>
      <url>/posts/wazuh-agent-install-api/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://documentation.wazuh.com/current/user-manual/agent-enrollment/via-manager-API/index.html">Enrollment via manager API</a></li></ul><h1 id="前言">前言</h1><p>會想要做這一篇的需求是因為，當有受接管的裝置時，我們<strong>為了讓服務得知請求從哪一個裝置發送的</strong>，所以我們會在每一個<strong>裝置上安裝 Wazuh Agent和自己的用來做裝置綁定的Agent</strong>。裝置綁定的Agent負責在請求內放裝置資訊，並透過數位簽章進行認證，這個裝置綁定的Agent是透過ASP.net去撰寫，而Wazuh Agent則是可以協助我們對裝置的狀態進行監控。</p><div class="note warning flat"><p>我們希望自己製作的Agent自動化的方式來安裝 Wazuh Agent，這時候我們需要透過 Wazuh API 來達成這個需求。然後可以滿足以下要求：</p><ol><li>可以自動註冊</li><li>並且取得agent id</li></ol></div><h1 id="Wazuh-API-Enrollment">Wazuh API Enrollment</h1><blockquote><p>The Wazuh manager API allows users to make an agent enrollment request to the Wazuh manager. This request returns a unique key for the agent, which must be manually imported to the agent.</p><footer><strong>官方原文</strong><cite><a href="https://documentation.wazuh.com/current/user-manual/agent-enrollment/via-manager-API/index.html">documentation.wazuh.com/current/user-manual/agent-enrollment/via-manager-API</a></cite></footer></blockquote><p>簡單來說，如果透過wazuh manager API 來進行註冊，他會<strong>回傳一個唯一的key，這個key必須要手動的匯入到agent裡面</strong>。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant U as User     participant A as Device Agent    participant M as Manager Manager    A-&gt;&gt;+M: API request to enroll    M--&gt;&gt;-A: Return authorization token    A-&gt;&gt;+M: API request with the authorization token    M--&gt;&gt;-A: Return agent key    U-&gt;&gt;A: Import agent key, config the wazuh manager ip.     U-&gt;&gt;A: Restart the agent.  </pre></div><h2 id="0-允許自簽憑證">0. 允許自簽憑證</h2><p>使用管理權限打開 PowerShell。如果管理器 API 通過 HTTPS 運行並且使用自簽名證書，則必須在 PowerShell 中執行以下函數。<strong>請注意，上面的函數僅存在於執行它的 PowerShell 實例中。</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 寫function 允許自簽憑證</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ignore-SelfSignedCerts</span></span> &#123;</span><br><span class="line">    <span class="built_in">add-type</span> <span class="string">@&quot;</span></span><br><span class="line"><span class="string">        using System.Net;</span></span><br><span class="line"><span class="string">        using System.Security.Cryptography.X509Certificates;</span></span><br><span class="line"><span class="string">        public class PolicyCert : ICertificatePolicy &#123;</span></span><br><span class="line"><span class="string">            public PolicyCert() &#123;&#125;</span></span><br><span class="line"><span class="string">            public bool CheckValidationResult(</span></span><br><span class="line"><span class="string">                ServicePoint sPoint, X509Certificate cert,</span></span><br><span class="line"><span class="string">                WebRequest wRequest, int certProb) &#123;</span></span><br><span class="line"><span class="string">                return true;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&quot;@</span></span><br><span class="line">    [<span class="type">System.Net.ServicePointManager</span>]::CertificatePolicy = <span class="built_in">new-object</span> PolicyCert</span><br><span class="line">    [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.SecurityProtocolType</span>]::Tls12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 呼叫剛剛建立好的function </span></span><br><span class="line">Ignore<span class="literal">-SelfSignedCerts</span></span><br></pre></td></tr></table></figure><h2 id="1-取得auth-token">1. 取得auth token</h2><p>使用裝置管理員打開 powershell ，輸入以下指令，來產生跟 wazuh <strong>進行請求時所需要的 Basic Auth Token</strong>，這邊如果沒有修改wazuh的帳號密碼，預設是 wazuh/wazuh</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># powershell 輸入以下指令</span></span><br><span class="line"><span class="comment">## 建立一個環境變數，用來存放 base64 的帳號密碼</span></span><br><span class="line"><span class="variable">$base64AuthInfo</span>=[<span class="type">Convert</span>]::ToBase64String([<span class="type">Text.Encoding</span>]::ASCII.GetBytes((<span class="string">&quot;&#123;0&#125;:&#123;1&#125;&quot;</span> <span class="operator">-f</span> “&lt;API_username&gt;”, “&lt;API_password&gt;”)))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 透過 Invoke-WebRequest 來取得 Auth Token</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="literal">-Headers</span> <span class="selector-tag">@</span>&#123;Authorization=(<span class="string">&quot;Basic &#123;0&#125;&quot;</span> <span class="operator">-f</span> <span class="variable">$base64AuthInfo</span>)&#125; <span class="literal">-Method</span> POST <span class="literal">-Uri</span> https://&lt;MANAGER_IP&gt;:<span class="number">55000</span>/security/user/authenticate | <span class="built_in">Select-Object</span> <span class="literal">-Expand</span> Content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 會得到以下回應 response </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;token&quot;</span>: <span class="string">&quot;eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ3YXp1aCIsImF1ZCI6IldhenVoIEFQSSBSRVNUIiwibmJmIjoxNjg4NzAzODY3LCJleHAiOjE2ODg3MDQ3NjcsInN1YiI6IndhenVoIiwicnVuX2FzIjpmYWxzZSwicmJhY19yb2xlcyI6WzFdLCJyYmFjX21vZGUiOiJ3aGl0ZSJ9.ANmFStLa9Og5PVtz1U2birnOb8np8JEg1goG7FrhDBvrXkcPnEqtdZm3clpTrEZP2eHU7EFQbTKtwpaHksxzmq_kAMP9bgDX3wtkUFJObDDIT42oGF8g5Ik4ccGj6-BMAoJjmFR4TDYqd-Nm5D5sM--fbZUrdrG37Nofhb-aDiwPdWOo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面指令的請求curl的版本長這樣</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -u <span class="string">&quot;wazuh:wazuh&quot;</span> https://&lt;wazuh-manager-ip&gt;:55000/security/user/authenticate</span><br></pre></td></tr></table></figure><h2 id="2-取得-agent-id-和-key">2. 取得 agent id 和 key</h2><p>取得 Auth Token 後，我們就可以透過 Auth Token 來<strong>取得 agent-id 跟 key</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把剛剛取得的 token 存到環境變數</span></span><br><span class="line"><span class="variable">$TOKEN</span> = “&lt;token_generated&gt;”</span><br><span class="line"></span><br><span class="line"><span class="comment"># 幫你的 agent Name 命名 （這裡可以自定義）</span></span><br><span class="line"><span class="variable">$AgentName</span> = <span class="selector-tag">@</span>&#123;<span class="string">&quot;name&quot;</span>=<span class="string">&quot;&lt;agent_name&gt;&quot;</span>&#125; | <span class="built_in">ConvertTo-Json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 Invoke-WebRequest 來取得 agent-id 跟 key</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-UseBasicParsing</span> <span class="literal">-Headers</span> <span class="selector-tag">@</span>&#123;Authorization=(<span class="string">&quot;Bearer &#123;0&#125;&quot;</span> <span class="operator">-f</span> <span class="variable">$TOKEN</span>)&#125; <span class="literal">-Method</span> POST <span class="literal">-ContentType</span> <span class="string">&quot;application/json&quot;</span> <span class="literal">-Uri</span> https://&lt;MANAGER_IP&gt;:<span class="number">55000</span>/agents <span class="literal">-Body</span> <span class="variable">$AgentName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 會得到以下回應 response </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;003&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>: <span class="string">&quot;MDAzIHRlc3QtYWdlbnQgYW55IDdmMDUxOTEyNjE2NzJkNTE0Njg5M2ExMjRkMDE4MWYzMTIzZGQ3YzQ1ZjMwZmJlZGU3N2FmYjgxNmNjYjQwZmM=&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面指令的請求curl的版本長這樣(json body的key是name)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Authorization: Bearer eyJhbGciOiJFUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ3YXp1aCIsImF1ZCI6IldhenVoIEFQSSBSRVNUIiwibmJmIjoxNjg4NzAzODY3LCJleHAiOjE2ODg3MDQ3NjcsInN1YiI6IndhenVoIiwicnVuX2FzIjpmYWxzZSwicmJhY19yb2xlcyI6WzFdLCJyYmFjX21vZGUiOiJ3aGl0ZSJ9.ANmFStLa9Og5PVtz1U2birnOb8np8JEg1goG7FrhDBvrXkcPnEqtdZm3clpTrEZP2eHU7EFQbTKtwpaHksxzmq_kAMP9bgDX3wtkUFJObDDIT42oGF8g5Ik4ccGj6-BMAoJjmFR4TDYqd-Nm5D5sM--fbZUrdrG37Nofhb-aDiwPdWOo&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;test-agent&quot; </span></span><br><span class="line"><span class="string">  &#125;&#x27;</span> \</span><br><span class="line">  https://&lt;wazuh-manager-ip&gt;:55000/agents</span><br></pre></td></tr></table></figure><h2 id="3-編輯-agent-config">3. 編輯 agent config</h2><p>以下步驟可指導如何將密鑰導入 Windows 代理： Wazuh 代理安裝目錄取決於主機的體系結構：</p><ul><li>如果你是 64 位元系統，則設定檔位於 <code>C:\Program Files (x86)\ossec-agent</code></li><li>如果你是 32 位元系統，則設定檔位於 <code>C:\Program Files\ossec-agent</code></li></ul><p>使用裝置管理員打開 CMD 或 PowerShell 作為管理員，並導入金鑰。下面的<strong>執行檔會把Agent的資訊，放進去 client.keys 裡面</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 &amp; 運算子告訴 PowerShell 不要將該指令視為 PowerShell cmdlet 或函式</span></span><br><span class="line"><span class="comment"># 而是執行外部可執行程式或命令。這是為了區分 PowerShell 內部指令和外部指令，以確保正確執行外部程式。</span></span><br><span class="line"><span class="comment"># 把剛剛的 key 帶入並且執行 manage_agents.exe </span></span><br><span class="line">&amp; <span class="string">&quot;C:\Program Files (x86)\ossec-agent\manage_agents.exe&quot;</span> <span class="literal">-i</span> &lt;key&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># The output should look like this: </span></span><br><span class="line">  Agent information:</span><br><span class="line">      ID:<span class="number">003</span></span><br><span class="line">      Name:<span class="built_in">test-agent</span></span><br><span class="line">      IP Address:any</span><br><span class="line">  Confirm adding it?(y/n): y</span><br><span class="line">  Added.</span><br></pre></td></tr></table></figure><p>編輯 <code>C:\Program Files (x86)\ossec-agent\ossec.conf</code>，並且wazuh manager ip 帶入。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;client&gt;</span><br><span class="line">   &lt;server&gt;</span><br><span class="line">     &lt;address&gt;MANAGER_IP&lt;/address&gt; <span class="comment"># 填入 wazuzh server ip 位置</span></span><br><span class="line">     ...</span><br><span class="line">   &lt;/server&gt;</span><br><span class="line"> &lt;/client&gt;</span><br></pre></td></tr></table></figure><h2 id="4-重啟-agent">4. 重啟 agent</h2><p>重新啟動</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># powershell </span></span><br><span class="line"><span class="built_in">Restart-Service</span> <span class="literal">-Name</span> wazuh</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmd </span></span><br><span class="line">net stop wazuh</span><br><span class="line">net <span class="built_in">start</span> wazuh</span><br></pre></td></tr></table></figure><h1 id="Wazuh-PowerShell-Enrollment">Wazuh PowerShell Enrollment</h1><p>可以透過kibana的介面去產指令，或是透過powershell執行以下指令，也可以自動進行註冊，但是你不會知道agent id，除非去讀取 <code>.agent_info</code> 檔案裡面才會填寫 agent id。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分別填入</span></span><br><span class="line"><span class="comment"># wazuh_manager: wazuh manager 的 ip </span></span><br><span class="line"><span class="comment"># WAZUH_AGENT_NAME: agent 註冊的名稱</span></span><br><span class="line"><span class="comment"># WAZUH_AGENT_GROUP: 群組 預設default </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 範例如下</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> https://packages.wazuh.com/<span class="number">4</span>.x/windows/wazuh<span class="literal">-agent-4</span>.<span class="number">4.4</span><span class="literal">-1</span>.msi <span class="literal">-OutFile</span> <span class="variable">$</span>&#123;env:tmp&#125;\wazuh<span class="literal">-agent</span>.msi; msiexec.exe /i <span class="variable">$</span>&#123;env:tmp&#125;\wazuh<span class="literal">-agent</span>.msi /q WAZUH_MANAGER=<span class="string">&#x27;192.168.2.76&#x27;</span> WAZUH_REGISTRATION_SERVER=<span class="string">&#x27;192.168.2.76&#x27;</span> WAZUH_AGENT_GROUP=<span class="string">&#x27;default&#x27;</span> WAZUH_AGENT_NAME=<span class="string">&#x27;win10-ma&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the agent</span></span><br><span class="line">NET <span class="built_in">START</span> WazuhSvc</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><div class="note info flat"><p>如果你想要取得 agent id 並且儲存 agent id 於自己的服務中，在不同的enrollment要注意以下流程。</p></div><p>如果你想透過 API 並且取得 agentID:</p><ol><li>先取得 auth token</li><li>自定義 name，透過 token 開始註冊，取得 agent id, agent key</li></ol><ul><li><strong>這時候可以取得 agent id</strong></li></ul><ol start="3"><li>把 key 載入本地</li><li>修改 conf 設定 wazuh ip</li><li>重新啟動</li><li><strong>去讀取 <code>.agent_info</code>並且取得agent id</strong></li></ol><p>如果你想透過 shell 註冊：</p><ol><li>執行註冊指令</li><li>重新啟動</li><li><strong>去讀取 <code>.agent_info</code>並且取得agent id</strong></li></ol><h2 id="跟註冊agent的整合">跟註冊agent的整合</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant U as User     participant A as Device Agent    participant D as Device Register Server    participant M as Wazuh Manager    U-&gt;&gt;A: execute device agent     A-&gt;&gt;M: request for Enrollment    M--&gt;&gt;A: response agent id and key     A-&gt;&gt;A: start the wazuh Agent    A-&gt;M: check the agent is active or not     M--&gt;&gt;A: response active    A-&gt;&gt;D: regist device with agent id    D-&gt;&gt;D: save the agent id into database    D--&gt;&gt;A: response success  </pre></div>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> wazuh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wazuh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxmox - 開 windows vm</title>
      <link href="/posts/proxmox-window-install/"/>
      <url>/posts/proxmox-window-install/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://blog.sakamoto.cat/zai-proxmox-ve-zhong-an-zhuang-windows10-yu-xiang-guan-qu-dong/">在 Proxmox VE 中安裝 Windows10 與相關驅動</a>: 這篇寫得挺清楚，只是有些我不太確定為什麼要選那個設定，因此有多做一些研究。</li></ul><h1 id="前言">前言</h1><p>在執行 wazuh的警告系統實作時，因為想要下載 Fiddler 來攔截 Alert 發送的訊息，查看是否有 Post 成功。<br>又或是想要安裝一台 windows 來當 wazuh</p><h1 id="下載iso檔案">下載iso檔案</h1><ol><li>需要先下載兩個iso</li></ol><ul><li>一個 windows 10 iso</li><li>一個 <a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.196-1/">驅動程式 iso</a><br><img src="https://i.imgur.com/T2r6DRa.png" alt=""></li></ul><h1 id="vm-規格">vm 規格</h1><ol><li><p>設定 OS 要選擇 GuestOS: Windows，Version: 10/2016/2019<br><img src="https://i.imgur.com/dvpxhtN.png" alt=""></p></li><li><p>設定 System 要<strong>特別勾選 Qemu Agent</strong><br><img src="https://i.imgur.com/MwLDrAW.png" alt=""></p></li><li><p>設定 Disk <strong>選用 SCSI</strong><br><img src="https://i.imgur.com/UVCQIIG.png" alt=""></p></li><li><p>設定 CPU, Memory，這邊可以自己按需求設定（我是設定4顆CPU跟16G RAM因為沒有要跑大服務）<br><img src="https://i.imgur.com/HRsa4V8.png" alt=""><br><img src="https://i.imgur.com/4S7MI0q.png" alt=""></p></li><li><p>Network 選擇 <code>VirtIO</code><br><img src="https://i.imgur.com/8Ad5qFp.png" alt=""></p></li></ol><h1 id="設定-驅動程式-iso">設定 驅動程式 iso</h1><ol><li><p>新增 CD/DVD Drive<br><img src="https://i.imgur.com/Nz1bft2.png" alt=""></p></li><li><p>指定為<a href="#%E4%B8%8B%E8%BC%89iso%E6%AA%94%E6%A1%88">下載iso檔案</a>裡面的驅動程式 iso，匯流排選擇 IDE 即可，並選擇 virtio ISO。<br><img src="https://i.imgur.com/HO4ElxT.png" alt=""></p></li></ol><h1 id="開始進入安裝windows">開始進入安裝windows</h1><ol><li><p>按照 Windows 的安裝進行，直到選擇在哪裡安裝 Windows ，你會發現找不到任何硬碟。<br><img src="https://i.imgur.com/73xNyOL.png" alt=""></p></li><li><p>這時選擇 <code>載入驅動程式</code> ，瀏覽剛剛掛載的 <code>virtio ISO</code> ，選擇 <code>vioscsi</code> -&gt; <code>w10</code> -&gt; <code>amd64</code> 按下確定，變會進行抓取相關驅動。<br><img src="https://i.imgur.com/nJvBe0S.png" alt=""></p></li><li><p>等待驅動載入完成後你就會發現已經找到硬碟了。便可繼續按照 Windows 繼續安裝。<br><img src="https://i.imgur.com/dUbr9h4.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> proxmox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxmox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh的告警系統實作 - ElastAlert 的 POST &amp; EMAIL 警報觸發 教學</title>
      <link href="/posts/elastic-alert-email-guide/"/>
      <url>/posts/elastic-alert-email-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://elastalert.readthedocs.io/en/latest/ruletypes.html#http-post">elastAlert - HTTP POST</a></li><li><a href="https://blog.alantsai.net/posts/2017/12/test-smtp-server-for-sending-mail-in-development">沒有mail server怎麼測試寄送email？快放過你的gmail來看看有那些可以測試用的smtp mail server</a></li><li><a href="https://blog.yowko.com/elastalert-alert/">在elastAlert透過mail發送訊息</a></li></ul><h1 id="前言">前言</h1><p>我們在<a href="elastic-alert-slack-guide">上一篇</a>說明完如何透過 slack 來發送告警通知，本篇的目的這次著重在。</p><ul><li>[x] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[x] 成功觸發發送 email 功能</li><li>[x] 把 Labeling Service 部署到 機器上</li><li>[x] 成功觸發發送 發api進行 labeling 功能</li></ul><h1 id="透過-post-來發送訊息">透過 post 來發送訊息</h1><ul><li>參考根據官方網站說明：<a href="https://elastalert.readthedocs.io/en/latest/ruletypes.html#http-post">https://elastalert.readthedocs.io/en/latest/ruletypes.html#http-post</a></li></ul><div class="note info flat"><p>如果你想要設定 Rule 是可以發送 HTTP POST 的，可以參考以下的設定方式。</p></div><p><strong>HTTP POST的設定Key意思:</strong></p><ul><li><code>http_post_url</code>：設定要發送請求的URL地址。</li><li><code>http_post_payload</code>（可選）：以键值對形式配置的POST请求的内容。<ul><li>例如，ip: clientip 會將Elasticsearch中clientip索引的值映射到名为ip的JSON键。</li><li>如果未定義，則會發送所有Elasticsearch的键值對。</li></ul></li><li><code>http_post_static_payload</code>（可選）：靜態参数的键值對（value不是參考elasticSearch是自己填寫），會跟<code>http_post_payload</code>Elasticsearch的结果一起發送。可以在這裡放是其他純文字的內容。</li><li><code>http_post_headers</code>（可選）：要作為請求的一部分發送header的键值對。</li><li><code>http_post_proxy</code>（可選）：代理的URL，如果需要的话。(前提是，<code>http_post_url</code>有proxy，可以方面查看風包內的訊息)</li><li><code>http_post_timeout</code>（可選）：POST請求的超時值，單位為秒，默認為10秒。如果超時發生將在下次ElastAlert訓環時重試警報。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Shannon-Alert-Test&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;frequency&quot;</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">&quot;wazuh-*&quot;</span></span><br><span class="line"><span class="attr">is_enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer_time:</span> <span class="comment"># 查詢 elasticsearch 的時間區間</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5分鐘內相同的報警不會重複發送</span></span><br><span class="line"><span class="attr">realert:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">terms_size:</span> <span class="number">50</span> <span class="comment"># 每個查詢返回的最大數量 default 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 頻率觸發設定</span></span><br><span class="line"><span class="comment"># 當 48 小時內，滿足 authorization </span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span> <span class="comment"># 將觸發警報的事件數量（含）</span></span><br><span class="line"><span class="attr">timeframe:</span> <span class="comment"># 在 timeframe 時間內內必須發生 num_events 次數</span></span><br><span class="line">  <span class="attr">hours:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">timestamp_field:</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">timestamp_type:</span> <span class="string">&quot;iso&quot;</span></span><br><span class="line"><span class="attr">use_strftime_index:</span> <span class="literal">false</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.description&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用於查找事件的 Elasticsearch 過濾器列表</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">query_string:</span></span><br><span class="line">        <span class="attr">query:</span> <span class="string">&quot;@timestamp:*&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">wildcard:</span></span><br><span class="line">        <span class="attr">rule.groups:</span> <span class="string">&quot;*authentication_fail*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過什麼方式進行通知</span></span><br><span class="line"><span class="attr">alert:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;post&quot;</span> <span class="comment"># 指定事件發生時要進行 Post </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># post 的相關設定</span></span><br><span class="line"><span class="comment">## 我有開一個 api 專門可以提供貼標籤使用 </span></span><br><span class="line"><span class="attr">http_post_url:</span> <span class="string">&quot;http://140.118.9.194:8087/api/risk/label&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">## post payload 會從 elastic field 去抓</span></span><br><span class="line"><span class="attr">http_post_payload:</span></span><br><span class="line">  <span class="attr">targetId:</span> <span class="string">agent.id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## post static payload 會直接成為字串進行傳送</span></span><br><span class="line"><span class="attr">http_post_static_payload:</span></span><br><span class="line">  <span class="attr">targetType:</span> <span class="string">&quot;User&quot;</span></span><br><span class="line">  <span class="attr">riskType:</span> <span class="string">&quot;HostRisk&quot;</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;0.7&quot;</span></span><br><span class="line">  <span class="attr">generator:</span> <span class="string">&quot;DeviceRisk&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic Authorization </span></span><br><span class="line"><span class="attr">http_post_headers:</span></span><br><span class="line">  <span class="attr">authorization:</span> <span class="string">Basic</span> <span class="string">YWRtaW46MTIz</span> <span class="comment">#帳號:密碼 admin:123 </span></span><br></pre></td></tr></table></figure><p>上面發出的訊息類似下面的效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">     -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">     -H <span class="string">&quot;Authorization: Basic YWRtaW46MTIz&quot;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">           &quot;generator&quot;: &quot;DeviceRisk&quot;,</span></span><br><span class="line"><span class="string">           &quot;targetId&quot;: &quot;001&quot;,</span></span><br><span class="line"><span class="string">           &quot;targetType&quot;: &quot;User&quot;,</span></span><br><span class="line"><span class="string">           &quot;riskType&quot;: &quot;HostRisk&quot;,</span></span><br><span class="line"><span class="string">           &quot;value&quot;: &quot;0.7&quot;</span></span><br><span class="line"><span class="string">         &#125;&#x27;</span> \</span><br><span class="line">     http://140.118.9.195:8087/api/risk/label</span><br></pre></td></tr></table></figure><h1 id="透過-Email-來發送訊息">透過 Email 來發送訊息</h1><h2 id="MailTrap-申請">MailTrap 申請</h2><ul><li>參考：<a href="https://blog.alantsai.net/posts/2017/12/test-smtp-server-for-sending-mail-in-development">沒有mail server怎麼測試寄送email？快放過你的gmail來看看有那些可以測試用的smtp mail server</a></li><li>服務申請網址：<a href="https://mailtrap.io/">https://mailtrap.io/</a></li></ul><ol><li>一開始預設會有 Inboxes 那是收訊息的地方，還有關於我們要用的是 SMTP 的設定。<br><img src="https://i.imgur.com/ydiogOV.png" alt=""></li><li>可以看到以下訊息：</li></ol><ul><li>(1): SMTP HOST</li><li>(2): SMTP 帳號</li><li>(3): SMTP 密碼</li><li>(4): 可以切換不同的語言或是工具查看使用這個服務的方式</li><li>(5): 直接看到如何使用的範例程式碼</li><li>(6): 可以直接重新產生帳號和密碼<br><img src="https://i.imgur.com/IHjsMlO.png" alt=""></li></ul><h2 id="ElastAlert-設定">ElastAlert 設定</h2><div class="note info flat"><p>ElastAlert 使用 email 通知時，<strong>如果需要帳號密碼，需要另外用 yaml 檔案格式紀錄帳號與密碼，再將檔案位置指定給 rule 使用</strong>，以下延續之前筆記的路徑規則設定</p></div><ol><li>建立 <code>/opt/elastalert/config/emailauth.yaml</code>把剛剛在MailTrap產生的帳號密碼放入。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">&quot;password&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>調整 docker compoe，把剛剛的 yaml 檔案掛載到 container 裡面<code>/opt/elastalert/config/emailauth.yaml</code>的位置。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elastalert:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elastalert2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jertel/elastalert2</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/config/config.yaml:/opt/elastalert/config.yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/rules:/opt/elastalert/rules</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/certs:/opt/elastalert/certs</span></span><br><span class="line">    <span class="comment"># 差異在這裡</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/config/emailauth.yaml:/opt/elastalert/config/emailauth.yaml</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--verbose</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es_default</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3030:3030&quot;</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:3030&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">40s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">es_default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以查看一下 logs 確認是否有正常運行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f elastalert</span><br></pre></td></tr></table></figure><ol start="3"><li>更正 rule 的 email 通知方式，<code>/opt/elastalert/rules/a.yaml</code>，設定以下內容。更正完不用重新啟動，就會自動套用囉，因為我們有掛載 volume。Host的檔案更改時，container裡面的檔案也會跟著更改。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span> </span><br><span class="line"><span class="attr">alert:</span> <span class="comment"># 警示通知類型 (詳細內容可以參考 [Alerts](https://elastalert.readthedocs.io/en/latest/ruletypes.html#alerts))</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;email&quot;</span></span><br><span class="line"><span class="attr">email:</span> <span class="comment"># email 發送目標</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;b10709036@gapps.ntust.edu.tw&quot;</span></span><br><span class="line"><span class="attr">smtp_host:</span> <span class="string">sandbox.smtp.mailtrap.io</span> </span><br><span class="line"><span class="attr">smtp_port:</span> <span class="number">2525</span> </span><br><span class="line"><span class="attr">smtp_auth_file:</span> <span class="string">/opt/elastalert/config/emailauth.yaml</span> <span class="comment"># email 帳號密碼設定檔位置</span></span><br></pre></td></tr></table></figure><h1 id="補充：想要透過標籤Label來得知裝置使用者">補充：想要透過標籤Label來得知裝置使用者</h1><div class="note warning flat"><p>在wazuh註冊的話只能透過device id來知道裝置身份，<strong>但是我們根本不知道使用者身份呀？</strong>，所以可以透過wazuh的Agent Label設定於<code>ossec.conf</code>，每次發送Alert的時候，添加Label的訊息進去。</p></div><h2 id="設定wazuh的Agent-Label">設定wazuh的Agent Label</h2><div class="note info flat"><p>如果你是Windows可以直接在 <code>C://Program Files (x86)/ossec-agent/ossec.conf</code> 裡面設定，如果是Linux的話，可以在 <code>/var/ossec/etc/ossec.conf</code> 裡面設定。</p></div><ol><li>打開 ossec.conf<br><img src="https://i.imgur.com/bvFevPn.png" alt=""></li><li>在 ossec.conf 設定以下內容：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">labels</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">key</span>=<span class="string">&quot;user.account&quot;</span>&gt;</span>&#123;user.account.id&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">labels</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/9VBJJhj.png" alt=""></p><h2 id="怎麼在rules抓取label內容">怎麼在rules抓取label內容</h2><ol><li><p>先知道 label 會位於 fields 的哪一個位置，可以從 kiabana 的 Discover 看到，他在<code>agent.labels.user.account</code>。<br><img src="https://i.imgur.com/BXQAXix.png" alt=""></p></li><li><p>所以可以在 rule 做以下設定，使得在 alert 的發送訊息中包含使用者資訊，設定如下：</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! User: &#123;3&#125;, AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.labels.user.account&quot;</span> <span class="comment"># 也就是這裡可以抓取labels的訊息</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.description&quot;</span></span><br></pre></td></tr></table></figure><h1 id="結論">結論</h1><p>這樣這篇至少你知道該<strong>如何透過 Email 來發送警報通知</strong>。<br>目前的進度，完成前面兩者，明天會繼續完成email的警報教學：</p><ul><li>[x] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[x] 成功觸發 slack ，並發送訊息</li><li>[x] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[x] 成功觸發發送 email 功能</li><li>[x] 把 Labeling Service 部署到 機器上</li><li>[x] 成功觸發發送 發api進行 labeling 功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> elastic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> alert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh的告警系統實作 - ElastAlert 的 Slack 警報觸發 教學</title>
      <link href="/posts/elastic-alert-slack-guide/"/>
      <url>/posts/elastic-alert-slack-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li><a href="https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html">ElastAlert - Writing Filters For Rules</a></li><li><a href="https://izsk.me/2020/05/29/EFLK-elastalert-rules/">寫了蠻多範例撰寫Rule</a></li><li><a href="https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html">elastAlert-Writing Filter</a></li></ul><h1 id="前言">前言</h1><p>根據<a href="/posts/elast-alert.html">前一篇</a>的內容，我們接下來打算做的事情如下</p><ul><li>[x] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[x] 成功觸發 slack ，並發送訊息</li></ul><h1 id="關於-Filters">關於 Filters</h1><p>參考：<a href="https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html">https://elastalert2.readthedocs.io/en/latest/recipes/writing_filters.html</a></p><blockquote><p>Filters 是什麼？</p></blockquote><p><strong>可以想像是 elasticsearch 的查詢條件，如果滿足的話，就觸發 rule 並執行告警動作。</strong></p><p>在建立 rule 時可以設定 filters，filters 是作為 elasticsearch query DSL(Domain Specific Language) 的部分，DSL 提供基於 json 來定義查詢，</p><blockquote><p>DSL 大概就長這樣（可以透過點擊Filter/Edit Filter/Edit as Query DSL來查看）</p></blockquote><p><img src="https://i.imgur.com/BHRoZcm.png" alt=""><br><img src="https://i.imgur.com/GzBc9Ea.png" alt=""><br><img src="https://i.imgur.com/kEgeL3o.png" alt=""></p><h1 id="測試-Filter-Slack-發送通知功能">測試 Filter + Slack 發送通知功能</h1><p>我們這邊採用 <code>frequency</code> 來進行測試，並使用 wazuh 告警來當作範例。你可能不懂 <code>frequency</code> 可以參考<a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#frequency">官網</a>進行了解，或是這篇<a href="https://izsk.me/2020/05/29/EFLK-elastalert-rules/">寫了蠻多範例撰寫Rule</a>。</p><p>而這裡的前提是你已經透過<a href="/posts/elast-alert.html">Wazuh的告警系統實作 - Docker 安裝 elastAlert</a></p><h2 id="撰寫-yaml">撰寫 yaml</h2><div class="note info flat"><p>情境：如果使用者登入windows時，<strong>只要在64小時內輸入錯1次密碼，導致觸發Authentication_fail的相關alert</strong>，就發送訊息到Slack。</p></div><p>我們想要滿足上述情境，因此撰寫以下 yaml 我們的內容，你可以直接把 <code>a.yaml</code> 的內容做置換。webhook取得連結的方式請參考 <a href="https://api.slack.com/messaging/webhooks">slack 官方說明</a>。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Shannon-Alert-Test&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;frequency&quot;</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">&quot;wazuh-*&quot;</span></span><br><span class="line"><span class="attr">is_enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer_time:</span> <span class="comment"># 查詢 elasticsearch 的時間區間</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5分鐘內相同的報警不會重複發送</span></span><br><span class="line"><span class="attr">realert:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">terms_size:</span> <span class="number">50</span> <span class="comment"># 每個查詢返回的最大數量 default 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 頻率觸發設定</span></span><br><span class="line"><span class="comment"># 當 48 小時內，滿足 authorization </span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span> <span class="comment"># 將觸發警報的事件數量（含）</span></span><br><span class="line"><span class="attr">timeframe:</span> <span class="comment"># 在 timeframe 時間內內必須發生 num_events 次數</span></span><br><span class="line">  <span class="attr">hours:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">timestamp_field:</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">timestamp_type:</span> <span class="string">&quot;iso&quot;</span></span><br><span class="line"><span class="attr">use_strftime_index:</span> <span class="literal">false</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.description&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用於查找事件的 Elasticsearch 過濾器列表</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">query_string:</span></span><br><span class="line">        <span class="attr">query:</span> <span class="string">&quot;@timestamp:*&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">wildcard:</span></span><br><span class="line">        <span class="attr">rule.groups:</span> <span class="string">&quot;*authentication_fail*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過什麼方式進行通知</span></span><br><span class="line"><span class="attr">alert:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;slack&quot;</span></span><br><span class="line"><span class="attr">slack_webhook_url:</span> <span class="string">&#x27;https://hooks.slack.com/services/xxxxx&#x27;</span> <span class="comment"># 請使用你自己的 webhook url </span></span><br><span class="line"><span class="attr">slack_msg_color:</span> <span class="string">&quot;warning&quot;</span></span><br><span class="line"><span class="attr">slack_parse_override:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>這邊值得一提的是， <code>alert_subject_args</code> 可以直接填寫 elasticsearch 看得到的 fields 內容。(如圖1)</p></div><p><img src="https://i.imgur.com/JMusCwQ.png" alt=""></p><h2 id="觸發-windows-登入失敗">觸發 windows 登入失敗</h2><ol><li><p>接下來，你需要一台裝好 wazuh agent 的電腦，這邊我使用 windows10 來進行。你可以透過 kibana 的 agent 註冊功能來快速註冊。<br><img src="https://i.imgur.com/jI22lEp.png" alt=""></p></li><li><p>然後按照指示進行註冊即可<br><img src="https://i.imgur.com/C1ZOoLC.png" alt=""></p></li><li><p>接下來故意登入時，輸入錯誤的密碼<br><img src="https://i.imgur.com/ooPVOud.png" alt=""></p></li><li><p>然後前往 wazuh，進入 agent 的 security events，<strong>確認的確有觸發Authentication failure的事件增加了</strong>。<br><img src="https://i.imgur.com/2xRU5AD.png" alt=""><br><img src="https://i.imgur.com/r0RQ8eo.png" alt=""></p></li><li><p>最後，你也可以透過<code>docker logs -f elastalert</code>查看logs是否有觸發，或是建立 index: <code>elastalert_*</code> 選取 <code>hit</code> field，來確認的確有觸發alert。<br><img src="https://i.imgur.com/5yIWuId.png" alt=""><br><img src="https://i.imgur.com/gJC6dMZ.png" alt=""></p></li></ol><h2 id="Slack-收到通知">Slack 收到通知</h2><p>透過以上設置，他會發送出以下訊息：</p><p><img src="https://i.imgur.com/IiKNMFp.png" alt=""></p><h1 id="結論">結論</h1><p>這樣這篇至少你知道該<strong>如何撰寫 frequent 的 Rule，並且透過 Slack 來發送警報通知</strong>。<br>目前的進度，完成前面兩者，明天會繼續完成email的警報教學：</p><ul><li>[x] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[x] 成功觸發 slack ，並發送訊息</li><li>[ ] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[ ] 成功觸發發送 email 功能</li><li>[ ] 把 Labeling Service 部署到 機器上</li><li>[ ] 成功觸發發送 發api進行 labeling 功能</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> elastic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> alert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh的告警系統實作 - ElastAlert Docker 安裝 elastAlert</title>
      <link href="/posts/elast-alert/"/>
      <url>/posts/elast-alert/</url>
      
        <content type="html"><![CDATA[<h1 id="參考的網站">參考的網站</h1><ul><li><a href="https://help.aliyun.com/document_detail/61336.html?spm=a2c4g.74927.0.0.57bc2193sMQ77k#task-2445099">elastic相關yml設定挺詳細，裡面有談到如何啟用watcher的設定</a></li><li>elasticAlert：<a href="https://github.com/Yelp/elastalert.git">https://github.com/Yelp/elastalert.git</a></li><li><a href="https://api.slack.com/messaging/webhooks">Slack webhook</a></li></ul><h1 id="前言">前言</h1><p>因為計畫需求，我們本有做一套基於風險的存取控制模型，但是該模型要滿足一個要求，需要能夠監控裝置，<strong>當裝置發現異常時，要能夠告警並通知一個貼標籤的服務，那存取控制模型就可以基於標籤和存取策略，適當的拒絕不滿足存取策略的請求</strong>。</p><p>本文章的前提</p><ul><li>對wazuh已經有一定的了解</li><li>並且已經安裝好wazuh, elasticSearch的工具，安裝可以參考:<a href="/posts/install-wazuh.html">Wazuh, elastic, kibana 的無腦串接與安裝教學</a></li></ul><p>因此本篇文章的目的如下：</p><ul><li>[ ] 了解wazuh這套工具是如何做告警？</li><li>[ ] 如果wazuh告警，發送請求該怎麼做？</li></ul><h1 id="關於可以作為告警的工具">關於可以作為告警的工具</h1><ul><li>我想要的功能是：如果滿足特定規則 (e.g. level5以上的alert) 可以做到發送 mail 和 call api</li><li>目前我找到的工具：<ul><li><strong>工具1 Watcher</strong> : elasticsearch 本身有 plugin 可以支援，稱為 elasticSearch Watcher 可以做到上述需求，但是並非開源。</li><li><strong>工具2 elastAlert</strong>: 所以目前想使用 <code>elasticAlert</code> <a href="https://github.com/Yelp/elastalert.git">這個開源</a>的的專案來進行。</li></ul></li></ul><div class="note default flat"><p>具體來說，做告警的方式，就是不斷地去問 elasticSearch 然後如果發現滿足的要求或是條件，就執行某些動作。因為 wazuh 是把 log 透過 filebeat 傳到 elasticSearch 進行儲存，因此我們可以著重在當收到 elasticSearch 的特定訊息時，執行某些動作。</p></div><h1 id="elasticAlert-介紹">elasticAlert 介紹</h1><div class="note info flat"><p>目前 elasticAlert 已經不再維護，以 elasticAlert2 為主，主要更可靠、高度模塊化且易於設置和配置。</p></div><p>參考：<a href="https://elastalert2.readthedocs.io/en/latest/elastalert.html">https://elastalert2.readthedocs.io/en/latest/elastalert.html</a></p><p>ElasticAlert 可以提供常見的監控規則，像是:</p><ul><li>特定時間內發生事件的頻率(<code>frequent</code> type)</li><li>當事件發出率提高或下降時(<code>spike</code> type)</li><li>事件在時間內觸發少於幾次(<code>filatline</code> type)</li><li>滿足白名單或黑名單時(<code>blacklist</code> and <code>whitelist</code> type)</li><li>滿足任何特定filter時(<code>any</code> type)</li><li>在特定時間內，某個欄位值改變時(<code>change</code> type)</li></ul><p>當滿足上述情境時，可以做到像是：Email, Http Post, Jira, Line Notify等等，並且在通知的告警中添加alert link、或是相關資料而我們想要的是Email和Http Post功能，因此本篇教學也會著重在實作這兩個部分。</p><h2 id="安裝教學：使用-docker-啟動">安裝教學：使用 docker 啟動</h2><p>參考官方： <a href="https://elastalert2.readthedocs.io/en/latest/running_elastalert.html#as-a-docker-container">https://elastalert2.readthedocs.io/en/latest/running_elastalert.html#as-a-docker-container</a></p><p>官方我認為沒寫到很完整，因為我還有設置 elasticSearch 需要透過 TLS/SSH 來進行連線，因此比起官網需要多一些設置。</p><div class="note warning flat"><p>請注意：在這邊你會需要使用到 elasticSearch 的 ca.crt，並且請確保該檔案的權限設定為任何人都可以讀取如下：<br>chmod 777 ca.crt</p></div><ol><li>首先你會先需要如下的檔案結構</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我是在 /opt/elastalert 底下進行</span></span><br><span class="line"><span class="built_in">mkdir</span> /opt/elastalert</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── certs</span><br><span class="line">│   └── ca.crt <span class="comment"># 這是 elasticSearch 的 ca.crt 請移動過來 並且進行 chmod 777 否則會出現</span></span><br><span class="line">├── elastalert.yaml </span><br><span class="line">└── rules</span><br><span class="line">    └── a.yml</span><br></pre></td></tr></table></figure><ol><li>開始建立 <code>/opt/elastalert/ealstalert.yaml</code> 檔案，我是參考官網建議的檔案：<a href="https://github.com/jertel/elastalert2/blob/master/examples/config.yaml.example">https://github.com/jertel/elastalert2/blob/master/examples/config.yaml.example</a></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is the folder that contains the rule yaml files</span></span><br><span class="line"><span class="comment"># This can also be a list of directories</span></span><br><span class="line"><span class="comment"># Any .yaml file will be loaded as a rule</span></span><br><span class="line"><span class="attr">rules_folder:</span> <span class="string">/opt/elastalert/rules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How often ElastAlert will query Elasticsearch</span></span><br><span class="line"><span class="comment"># The unit can be anything from weeks to seconds</span></span><br><span class="line"><span class="attr">run_every:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ElastAlert will buffer results from the most recent</span></span><br><span class="line"><span class="comment"># period of time, in case some log sources are not in real time</span></span><br><span class="line"><span class="attr">buffer_time:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Elasticsearch hostname for metadata writeback</span></span><br><span class="line"><span class="comment"># Note that every rule can have its own Elasticsearch host</span></span><br><span class="line"><span class="attr">es_host:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.71</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Elasticsearch port</span></span><br><span class="line"><span class="attr">es_port:</span> <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The AWS region to use. Set this when using AWS-managed elasticsearch</span></span><br><span class="line"><span class="comment">#aws_region: us-east-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The AWS profile to use. Use this if you are using an aws-cli profile.</span></span><br><span class="line"><span class="comment"># See http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html</span></span><br><span class="line"><span class="comment"># for details</span></span><br><span class="line"><span class="comment">#profile: test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional URL prefix for Elasticsearch</span></span><br><span class="line"><span class="comment">#es_url_prefix: elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional prefix for statsd metrics</span></span><br><span class="line"><span class="comment">#statsd_instance_tag: elastalert</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Optional statsd host</span></span><br><span class="line"><span class="comment">#statsd_host: dogstatsd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect with TLS to Elasticsearch</span></span><br><span class="line"><span class="attr">use_ssl:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Verify TLS certificates</span></span><br><span class="line"><span class="attr">verify_certs:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show TLS or certificate related warnings</span></span><br><span class="line"><span class="attr">ssl_show_warn:</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GET request with body is the default option for Elasticsearch.</span></span><br><span class="line"><span class="comment"># If it fails for some reason, you can pass &#x27;GET&#x27;, &#x27;POST&#x27; or &#x27;source&#x27;.</span></span><br><span class="line"><span class="comment"># See https://elasticsearch-py.readthedocs.io/en/master/connection.html?highlight=send_get_body_as#transport</span></span><br><span class="line"><span class="comment"># for details</span></span><br><span class="line"><span class="comment">#es_send_get_body_as: GET</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Option basic-auth username and password for Elasticsearch</span></span><br><span class="line"><span class="attr">es_username:</span> <span class="string">elastic</span></span><br><span class="line"><span class="attr">es_password:</span> <span class="string">4RQwIyVNCBznV4zXGDhX</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use SSL authentication with client certificates client_cert must be</span></span><br><span class="line"><span class="comment"># a pem file containing both cert and key for client</span></span><br><span class="line"><span class="attr">ca_certs:</span> <span class="string">/opt/elastalert/certs/ca.crt</span></span><br><span class="line"><span class="comment">#client_cert: /etc/elasticsearch/certs/elasticsearch.crt</span></span><br><span class="line"><span class="comment">#client_key: /etc/elasticsearch/certs/elasticsearch.key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The index on es_host which is used for metadata storage</span></span><br><span class="line"><span class="comment"># This can be a unmapped index, but it is recommended that you run</span></span><br><span class="line"><span class="comment"># elastalert-create-index to set a mapping</span></span><br><span class="line"><span class="attr">writeback_index:</span> <span class="string">elastalert_status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If an alert fails for some reason, ElastAlert will retry</span></span><br><span class="line"><span class="comment"># sending the alert until this time period has elapsed</span></span><br><span class="line"><span class="attr">alert_time_limit:</span></span><br><span class="line">  <span class="attr">days:</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="建立-opt-rules-a-yaml-檔案">建立 <code>/opt/rules/a.yaml</code> 檔案</h2><div class="note info flat"><p>在這之前你可能會好奇webhook要填寫什麼，你可以透過以下教學建立 webhook<br>可以參考這篇：<a href="https://api.slack.com/messaging/webhooks">https://api.slack.com/messaging/webhooks</a></p></div><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">&quot;Shannon-Alert-Test&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;frequency&quot;</span></span><br><span class="line"><span class="attr">index:</span> <span class="string">&quot;wazuh-*&quot;</span></span><br><span class="line"><span class="attr">is_enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer_time:</span> <span class="comment"># 查詢 elasticsearch 的時間區間</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5分鐘內相同的報警不會重複發送</span></span><br><span class="line"><span class="attr">realert:</span></span><br><span class="line">  <span class="attr">minutes:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">terms_size:</span> <span class="number">50</span> <span class="comment"># 每個查詢返回的最大數量 default 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 頻率觸發設定</span></span><br><span class="line"><span class="comment"># 當 48 小時內，滿足 authorization </span></span><br><span class="line"><span class="attr">num_events:</span> <span class="number">1</span> <span class="comment"># 將觸發警報的事件數量（含）</span></span><br><span class="line"><span class="attr">timeframe:</span> <span class="comment"># 在 timeframe 時間內內必須發生 num_events 次數</span></span><br><span class="line">  <span class="attr">hours:</span> <span class="number">64</span></span><br><span class="line"><span class="attr">timestamp_field:</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">timestamp_type:</span> <span class="string">&quot;iso&quot;</span></span><br><span class="line"><span class="attr">use_strftime_index:</span> <span class="literal">false</span> <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 警告訊息</span></span><br><span class="line"><span class="attr">alert_subject:</span> <span class="string">&quot;Alert! &#123;0&#125; ! AgentID: &#123;1&#125; in time (&#123;2&#125;)&quot;</span></span><br><span class="line"><span class="attr">alert_subject_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;rule.groups&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;agent.id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;@timestamp&quot;</span></span><br><span class="line"><span class="attr">alert_text:</span> <span class="string">&quot;主要原因: &#123;0&#125;&quot;</span></span><br><span class="line"><span class="attr">alert_text_args:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;full_log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用於查找事件的 Elasticsearch 過濾器列表</span></span><br><span class="line"><span class="attr">filter:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">query_string:</span></span><br><span class="line">        <span class="attr">query:</span> <span class="string">&quot;@timestamp:*&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">query:</span></span><br><span class="line">      <span class="attr">wildcard:</span></span><br><span class="line">        <span class="attr">rule.groups:</span> <span class="string">&quot;*authentication_fail*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過什麼方式進行通知</span></span><br><span class="line"><span class="attr">alert:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;slack&quot;</span></span><br><span class="line"><span class="attr">slack_webhook_url:</span> <span class="string">&#x27;https://hooks.slack.com/services/xxxxx&#x27;</span> <span class="comment"># 請使用你自己的 webhook url </span></span><br><span class="line"><span class="attr">slack_msg_color:</span> <span class="string">&quot;warning&quot;</span></span><br><span class="line"><span class="attr">slack_parse_override:</span> <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure><h2 id="透過-docker-指令啟動">透過 docker 指令啟動</h2><p>啟動，跟官方的有一點不一樣，因為我們需要把 <code>ca.crt</code> mount 到容器得的 <code>/opt/elastalert/certs/ca.crt</code>，因為 <code>ealstalert.yaml</code> 是這樣設定的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先前往 /opt/elastalert/ </span></span><br><span class="line"><span class="built_in">cd</span> /opt/elastalert </span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd 會直接帶目前路徑 </span></span><br><span class="line"><span class="comment"># 你會發現我們把3個部分mount進去，分別是 elastalert.yaml, rules, ca.crt </span></span><br><span class="line">docker run --net=es_default -d --name elastalert --restart=always \</span><br><span class="line">-v $(<span class="built_in">pwd</span>)/elastalert.yaml:/opt/elastalert/config.yaml \</span><br><span class="line">-v $(<span class="built_in">pwd</span>)/rules:/opt/elastalert/rules \</span><br><span class="line">-v $(<span class="built_in">pwd</span>)/certs:/opt/elastalert/certs \ </span><br><span class="line">jertel/elastalert2 --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 logs </span></span><br><span class="line">docker logs -f elastalert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 輸出結果應該要類似如下</span></span><br><span class="line">INFO:elastalert:Background configuration change check run at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Background alerts thread 0 pending alerts sent at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Disabled rules are: []</span><br><span class="line">INFO:elastalert:Sleeping <span class="keyword">for</span> 59.99996 seconds</span><br><span class="line">INFO:elastalert:Queried rule a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 / 0 hits</span><br><span class="line">WARNING:elasticsearch:DELETE https://192.168.2.71:9200/_search/scroll [status:404 request:0.001s]</span><br><span class="line">INFO:elastalert:Ran a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 query hits (0 already seen), 0 matches, 0 alerts sent</span><br><span class="line">INFO:elastalert:a range 900</span><br></pre></td></tr></table></figure><h2 id="透過-docker-compose-啟動">透過 docker-compose 啟動</h2><p>你也可以建立 <code>/opt/elastalert/docker-compose.yaml</code> 檔案，內容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elastalert:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elastalert2</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jertel/elastalert2</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/config/config.yaml:/opt/elastalert/config.yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/rules:/opt/elastalert/rules</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/elastalert/certs:/opt/elastalert/certs</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--verbose</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">es_default</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3030:3030&quot;</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:3030&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">40s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">es_default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然後透過以下指令啟動</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先前往 /opt/elastalert/</span></span><br><span class="line"><span class="built_in">cd</span> /opt/elastalert</span><br><span class="line"><span class="comment"># 啟動 docker-compose.yaml 背景執行</span></span><br><span class="line">docker-compose up -d </span><br><span class="line"><span class="comment"># 查看 logs</span></span><br><span class="line">docker-compose logs -f elastalert</span><br><span class="line"><span class="comment"># 輸出結果應該要類似如下</span></span><br><span class="line">INFO:elastalert:Background configuration change check run at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Background alerts thread 0 pending alerts sent at 2023-07-02 17:47 UTC</span><br><span class="line">INFO:elastalert:Disabled rules are: []</span><br><span class="line">INFO:elastalert:Sleeping <span class="keyword">for</span> 59.99996 seconds</span><br><span class="line">INFO:elastalert:Queried rule a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 / 0 hits</span><br><span class="line">WARNING:elasticsearch:DELETE https://192.168.2.71:9200/_search/scroll [status:404 request:0.001s]</span><br><span class="line">INFO:elastalert:Ran a from 2023-07-02 17:33 UTC to 2023-07-02 17:48 UTC: 0 query hits (0 already seen), 0 matches, 0 alerts sent</span><br><span class="line">INFO:elastalert:a range 900</span><br></pre></td></tr></table></figure><h1 id="總結">總結</h1><p>回到文章的開頭想探討的，到目前為止總結如下：</p><ul><li>[x] 了解wazuh這套工具是如何做告警？<ul><li><strong>Ans: Wazuh 本身提供 mail 發訊息功能，但是如果要做更多還是使用 elastic 整合相關告警工具更好</strong></li></ul></li><li>[x] 如果wazuh告警，發送請求該怎麼做？<ul><li><strong>Ans: 目前看到的做法是 (1) elastic 內建的 watcher 但是因為非開源，加上還需要license，因此選擇 (2) elastAlert 開源工具。</strong></li></ul></li></ul><p>接下來東西串好了，elastAlert 可以正常使用，我會優先透過 slack 來測試 Alert 的相關功能</p><ul><li>[ ] <a href="https://blog.yowko.com/elastalert-alert/">寫成docker-compose，可以餐考這篇</a></li><li>[ ] 了解 elastAlert 的 <a href="https://elastalert2.readthedocs.io/en/latest/ruletypes.html#rule-types">Rule types</a> 撰寫方式</li><li>[ ] 成功觸發 slack ，並發送訊息</li><li>[ ] <a href="https://blog.yowko.com/elastalert-alert/">怎麼透過 email 發送訊息</a></li><li>[ ] 成功觸發發送 email 功能</li><li>[ ] 把 Labeling Service 部署到 機器上</li><li>[ ] 成功觸發發送 發api進行 labeling 功能</li></ul><h1 id="坑1-SSLError-Permission-Denied">坑1: SSLError Permission Denied</h1><div class="note info flat"><p>Ans: 本來一直出現以下問題，後來發現是ca.crt的權限讓elastAlert無法讀取。<br><strong>只需要進行 chmod 777 ca.crt 後 再mount到container即可解決</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">&quot;/usr/local/lib/python3.11/site-packages/elasticsearch/connection/http_requests.py&quot;</span>, line 174, <span class="keyword">in</span> perform_request</span><br><span class="line">    raise SSLError(<span class="string">&quot;N/A&quot;</span>, str(e), e)</span><br><span class="line">elasticsearch.exceptions.SSLError: ConnectionError(HTTPSConnectionPool(host=<span class="string">&#x27;192.168.2.71&#x27;</span>, port=9200): Max retries exceeded with url: / (Caused by SSLError(PermissionError(13, <span class="string">&#x27;Permission denied&#x27;</span>)))) caused by: SSLError(HTTPSConnectionPool(host=<span class="string">&#x27;192.168.2.71&#x27;</span>, port=9200): Max retries exceeded with url: / (Caused by SSLError(PermissionError(13, <span class="string">&#x27;Permission denied&#x27;</span>))))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> elastic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> alert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wazuh, elastic, kibana 的無腦串接與安裝教學</title>
      <link href="/posts/install-wazuh/"/>
      <url>/posts/install-wazuh/</url>
      
        <content type="html"><![CDATA[<h1 id="參考連結">參考連結</h1><ul><li>參考wauzh官方安裝教學: <a href="https://documentation.wazuh.com/current/deployment-options/elastic-stack/all-in-one-deployment/index.html#installing-elasticsearch">https://documentation.wazuh.com/current/deployment-options/elastic-stack/all-in-one-deployment/index.html#installing-elasticsearch</a></li><li>參考filebeat安裝: <a href="https://www.elastic.co/guide/en/beats/filebeat/7.17/setup-repositories.html">https://www.elastic.co/guide/en/beats/filebeat/7.17/setup-repositories.html</a></li></ul><h1 id="前言">前言</h1><div class="note danger flat"><p>請注意，我的安裝教學不是用正式環境，<strong>因為certs都是使用相同的，僅供教學快速安裝使用</strong>。</p></div><blockquote><p>注意：目前教學內所使用的wazuh-manager版本是4.4.4，所以如果你的wazuh-manager是其他版本像是4.5，請務必修改以下所有含有4.4的script內容為4.5</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原本為4.4 </span></span><br><span class="line">curl -so /etc/elasticsearch/elasticsearch.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/elasticsearch_all_in_one.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 請更正為4.5</span></span><br><span class="line">curl -so /etc/elasticsearch/elasticsearch.yml https://packages.wazuh.com/4.5/tpl/elastic-basic/elasticsearch_all_in_one.yml</span><br></pre></td></tr></table></figure><div class="note default flat"><p>使用Proxmox開兩台VM規格如下：</p></div><p><img src="https://i.imgur.com/bkrxlnP.png" alt=""></p><p><img src="https://i.imgur.com/FlyHPuj.png" alt=""></p><h1 id="ElasticStack-安裝">ElasticStack 安裝</h1><blockquote><p>filebeat是跟wazuh安裝在一起</p></blockquote><ol><li>安裝需要一些額外的包，例如curl或unzip，將在後續步驟中使用。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install apt-transport-https zip unzip lsb-release curl gnupg</span><br></pre></td></tr></table></figure><ol start="2"><li>Adding the Elastic Stack repository:這兩個指令是用於將Elasticsearch的GPG公鑰導入到系統中，以便於系統驗證Elasticsearch的APT軟件包。具體來說，這兩個指令完成了以下操作：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一個指令使用curl命令下載Elasticsearch的GPG公鑰，然後使用gpg命令將其導入到系統的密鑰環中。其中，--no-default-keyring選項表示不使用默認的密鑰環，--keyring選項表示將GPG公鑰導入到指定的密鑰環中，chmod命令用於修改/elasticsearch.gpg文件的權限，以使其只允許root用戶和群組讀取。</span></span><br><span class="line">curl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | gpg --no-default-keyring --keyring gnupg-ring:/usr/share/keyrings/elasticsearch.gpg --import &amp;&amp; <span class="built_in">chmod</span> 644 /usr/share/keyrings/elasticsearch.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二個指令使用echo命令在/etc/apt/sources.list.d/目錄下創建一個名為elastic-7.x.list的文件，並在該文件中寫入APT存儲庫的URL。其中，[signed-by=/usr/share/keyrings/elasticsearch.gpg]表示使用先前導入的Elasticsearch GPG公鑰對APT存儲庫進行數字簽名驗證，以確保軟件包的完整性和安全性。通過執行這兩個指令，系統可以驗證Elasticsearch APT存儲庫中的軟件包，確保其來源可信且未被修改。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/elasticsearch.gpg] https://artifacts.elastic.co/packages/7.x/apt stable main&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><ol start="3"><li>安裝elasticSearch package</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install elasticsearch=7.17.6</span><br></pre></td></tr></table></figure><ol start="4"><li>Download the configuration file /etc/elasticsearch/elasticsearch.yml as follows:<br><strong>如果要開放給外面的人使用要記得使用network.host=0.0.0.0，否則預設會拒絕一切非127.0.0.1的使用者</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -so /etc/elasticsearch/elasticsearch.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/elasticsearch_all_in_one.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 進去修改elasticsearch.yml </span></span><br><span class="line">vim /etc/elasticsearch/elasticsearch.yml</span><br><span class="line"><span class="comment"># 設定如下</span></span><br><span class="line"><span class="comment"># network.host=0.0.0.0</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Download the configuration file for creating the certificates:<br><strong>instances.yml裡面的ip記得要改成自己的實體ip，否則跨機器的連線會出錯</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 這個命令是在Linux環境中使用curl命令下載名為&quot;instances_aio.yml&quot;的文件並將其保存到&quot;/usr/share/elasticsearch/instances.yml&quot;路徑中。</span></span><br><span class="line"><span class="comment"># &quot;-s&quot;表示&quot;silent&quot;模式，即curl命令不會顯示任何進度或錯誤信息</span></span><br><span class="line"><span class="comment"># &quot;-o&quot;表示指定輸出文件的位置和名稱，&quot;/usr/share/elasticsearch/instances.yml&quot;是指定的路徑和文件名</span></span><br><span class="line">curl -so /usr/share/elasticsearch/instances.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/instances_aio.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正 isntance.yml </span></span><br><span class="line">vim /usr/share/elasticsearch/instances.yml</span><br><span class="line"><span class="comment"># 如下</span></span><br><span class="line">instances:</span><br><span class="line">- name: <span class="string">&quot;elasticsearch&quot;</span></span><br><span class="line">  ip:</span><br><span class="line">  - <span class="string">&quot;&lt;elastic-ip&gt;&quot;</span> <span class="comment"># 改這裡</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具體地說，命令中的&quot;cert&quot;表示要生成一個自簽名憑證</span></span><br><span class="line"><span class="comment"># &quot;ca&quot;表示該憑證是一個CA憑證</span></span><br><span class="line"><span class="comment"># &quot;--pem&quot;表示生成PEM格式的憑證</span></span><br><span class="line"><span class="comment"># &quot;--in instances.yml&quot;表示要使用先前下載的instances.yml文件作為證書的配置文件</span></span><br><span class="line"><span class="comment"># &quot;--keep-ca-key&quot;表示保留CA憑證的私鑰</span></span><br><span class="line"><span class="comment"># &quot;--out ~/certs.zip&quot;表示將生成的證書和密鑰存儲在一個名為certs.zip的壓縮文件中，並存儲在當前用戶的家目錄中。</span></span><br><span class="line">/usr/share/elasticsearch/bin/elasticsearch-certutil cert ca --pem --<span class="keyword">in</span> instances.yml --keep-ca-key --out ~/certs.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解壓縮</span></span><br><span class="line">unzip ~/certs.zip -d ~/certs</span><br></pre></td></tr></table></figure><ol start="6"><li>The next step is to create the directory /etc/elasticsearch/certs, and then copy the CA file, the certificate and the key there:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir是一個用於在Linux中創建新目錄的命令，&quot;-p&quot;選項表示創建多層目錄，即如果上級目錄不存在，則會自動創建。</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/elasticsearch/certs/ca -p</span><br><span class="line"><span class="comment"># 將~/certs/ca/和~/certs/elasticsearch/中的所有文件和目錄複製到&quot;/etc/elasticsearch/certs/&quot;目錄中</span></span><br><span class="line"><span class="built_in">cp</span> -R ~/certs/ca/ ~/certs/elasticsearch/* /etc/elasticsearch/certs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;-R&quot;選項表示遞歸更改所有權和群組，&quot;elasticsearch&quot;表示新擁有者的用戶名，&quot;:&quot;表示分隔符，最後&quot;/etc/elasticsearch/certs&quot;是要更改所有權和群組的目標目錄。</span></span><br><span class="line"><span class="built_in">chown</span> -R elasticsearch: /etc/elasticsearch/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;500&quot;是要設置的權限值，其中&quot;5&quot;表示所有者有可執行和可讀權限，但沒有寫權限，其他用戶沒有任何權限。</span></span><br><span class="line"><span class="built_in">chmod</span> -R 500 /etc/elasticsearch/certs</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;chmod 400&quot;通常用於限制敏感文件的訪問權限，只允許文件所有者讀取，其他人無權限訪問；而&quot;chmod 500&quot;通常用於限制目錄的訪問權限，只允許目錄所有者進入目錄，其他人無權限訪問。</span></span><br><span class="line"><span class="built_in">chmod</span> 400 /etc/elasticsearch/certs/ca/ca.* /etc/elasticsearch/certs/elasticsearch.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把檔案移除</span></span><br><span class="line"><span class="built_in">rm</span> -rf ~/certs/ ~/certs.zip</span><br></pre></td></tr></table></figure><ol start="7"><li>啟動服務並且Generate credentials for all the Elastic Stack pre-built roles and users:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> elasticsearch</span><br><span class="line">systemctl start elasticsearch</span><br><span class="line"></span><br><span class="line"><span class="comment"># create pwd and role </span></span><br><span class="line">/usr/share/elasticsearch/bin/elasticsearch-setup-passwords auto</span><br></pre></td></tr></table></figure><ol start="8"><li>就會看到以下角色與密碼被建立，類似下面的結果：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Changed password for user apm_system</span><br><span class="line">PASSWORD apm_system = rj5cEOP5ahI5lNNDVuG6</span><br><span class="line"></span><br><span class="line">Changed password for user kibana_system</span><br><span class="line">PASSWORD kibana_system = Jqi6Q0UKiOkntBikCBSe</span><br><span class="line"></span><br><span class="line">Changed password for user kibana</span><br><span class="line">PASSWORD kibana = Jqi6Q0UKiOkntBikCBSe</span><br><span class="line"></span><br><span class="line">Changed password for user logstash_system</span><br><span class="line">PASSWORD logstash_system = Y6NzFN8qelmUjEXIsBtr</span><br><span class="line"></span><br><span class="line">Changed password for user beats_system</span><br><span class="line">PASSWORD beats_system = 8Y7JmIyfgyfBvUduyYiM</span><br><span class="line"></span><br><span class="line">Changed password for user remote_monitoring_user</span><br><span class="line">PASSWORD remote_monitoring_user = XBXvJEu2PG5dD8H8L9X7</span><br><span class="line"></span><br><span class="line">Changed password for user elastic</span><br><span class="line">PASSWORD elastic = dWAntWBQeyMIuPNFxydS</span><br></pre></td></tr></table></figure><ol start="9"><li>To check that the installation was made successfully, run the following command replacing &lt;elastic_password&gt; with the password generated in the previous step for elastic user:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET https://localhost:9200 -u elastic:&lt;elastic_password&gt; -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># example </span></span><br><span class="line"><span class="comment"># 使用-u選項指定了用戶名和密碼</span></span><br><span class="line"><span class="comment"># -k 表示忽略SSL證書驗證</span></span><br><span class="line">curl -XGET https://localhost:9200 -u elastic:dWAntWBQeyMIuPNFxydS -k</span><br></pre></td></tr></table></figure><h1 id="安裝Wazuh">安裝Wazuh</h1><ol><li>adding wazuh repository</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packages.wazuh.com/key/GPG-KEY-WAZUH | gpg --no-default-keyring --keyring gnupg-ring:/usr/share/keyrings/wazuh.gpg --import &amp;&amp; <span class="built_in">chmod</span> 644 /usr/share/keyrings/wazuh.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/wazuh.gpg] https://packages.wazuh.com/4.x/apt/ stable main&quot;</span> | <span class="built_in">tee</span> -a /etc/apt/sources.list.d/wazuh.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><ol start="2"><li>安裝wazuh manager</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get install wazuh-manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> wazuh-manager</span><br><span class="line">systemctl start wazuh-manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認版本 是否為 4.4.4，如果不是請記得更新所有4.4的相關包</span></span><br><span class="line">/var/ossec/bin/wazuh-control -j info</span><br></pre></td></tr></table></figure><ol start="3"><li>檢查服務是否有起來</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status wazuh-manager</span><br></pre></td></tr></table></figure><h1 id="安裝Filebeat">安裝Filebeat</h1><ol><li>安裝filebeat</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://artifacts.elastic.co/packages/oss-7.x/apt stable main&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt-get install filebeat=7.17.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># filebeat 傳送至 elasticSearch的設定</span></span><br><span class="line">curl -so /etc/filebeat/filebeat.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/filebeat_all_in_one.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>Download the alerts template for Elasticsearch:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># filebeat 傳送wazuh相關訊息的json</span></span><br><span class="line">curl -so /etc/filebeat/wazuh-template.json https://raw.githubusercontent.com/wazuh/wazuh/4.4/extensions/elasticsearch/7.x/wazuh-template.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># g表示群組（group）</span></span><br><span class="line"><span class="comment"># o表示其他人（others）</span></span><br><span class="line"><span class="comment"># 而+r表示添加讀取權限（read）。</span></span><br><span class="line"><span class="built_in">chmod</span> go+r /etc/filebeat/wazuh-template.json</span><br></pre></td></tr></table></figure><ol start="3"><li>Download the Wazuh module for Filebeat:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packages.wazuh.com/4.x/filebeat/wazuh-filebeat-0.2.tar.gz | tar -xvz -C /usr/share/filebeat/module</span><br></pre></td></tr></table></figure><ol start="4"><li>更改filebeat.yaml裡面elastic的ip和帳號密碼</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">/etc/filebeat/filebeat.yml</span></span><br><span class="line"><span class="comment"># Replace elasticsearch_password with the previously generated password for elastic user.</span></span><br><span class="line"><span class="attr">output.elasticsearch.password:</span> <span class="string">&lt;elasticsearch_password&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Copy the certificates into <code>/etc/filebeat/certs/</code> (我這邊是透過scp把vm2的certs.zip copy過去)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy 檔案 從 vm2 到 vm1</span></span><br><span class="line">scp &#123;vm2_user_name&#125;@&#123;vm2-ip&#125;:/home/user/certs.zip ~/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解壓縮</span></span><br><span class="line">unzip ~/certs.zip -d ~/certs</span><br><span class="line"><span class="comment"># mkdir是一個用於在Linux中創建新目錄的命令，&quot;-p&quot;選項表示創建多層目錄，即如果上級目錄不存在，則會自動創建。</span></span><br><span class="line"><span class="built_in">mkdir</span> /etc/elasticsearch/certs/ca -p</span><br><span class="line"><span class="comment"># 將~/certs/ca/和~/certs/elasticsearch/中的所有文件和目錄複製到&quot;/etc/elasticsearch/certs/&quot;目錄中</span></span><br><span class="line"><span class="built_in">cp</span> -R ~/certs/ca/ ~/certs/elasticsearch/* /etc/elasticsearch/certs/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把ca.crt放入filebeat的certs</span></span><br><span class="line"><span class="built_in">cp</span> -r /etc/elasticsearch/certs/ca/ /etc/filebeat/certs/</span><br><span class="line"><span class="comment"># 把elasticSearch的crt, key當作filebeat的 （正常應該要產filebeat的）</span></span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.crt /etc/filebeat/certs/filebeat.crt</span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.key /etc/filebeat/certs/filebeat.key</span><br></pre></td></tr></table></figure><ol start="6"><li>Enable and start the Filebeat service:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> filebeat</span><br><span class="line">systemctl start filebeat</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line">filebeat <span class="built_in">test</span> output</span><br></pre></td></tr></table></figure><h1 id="安裝Kibana">安裝Kibana</h1><ol><li>要先安裝這些repository apt-get才會是安裝特定或是最新版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://artifacts.elastic.co/GPG-KEY-elasticsearch | gpg --no-default-keyring --keyring gnupg-ring:/usr/share/keyrings/elasticsearch.gpg --import &amp;&amp; <span class="built_in">chmod</span> 644 /usr/share/keyrings/elasticsearch.gpg</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/elasticsearch.gpg] https://artifacts.elastic.co/packages/7.x/apt stable main&quot;</span> | <span class="built_in">tee</span> /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get install kibana=7.17.6</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>這邊我都是使用elasticSearch.key跟crt當作kibana的key還有crt，certs.zip就沿用elasticSearch的</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 把ca.crt放入filebeat的certs</span></span><br><span class="line"><span class="built_in">cp</span> -r /etc/elasticsearch/certs/ca/ /etc/kibana/certs/ca/</span><br><span class="line"><span class="comment"># 把elasticSearch的crt, key當作filebeat的 （正常應該要產filebeat的）</span></span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.crt /etc/kibana/certs/kibana.crt</span><br><span class="line"><span class="built_in">cp</span> /etc/elasticsearch/certs/elasticsearch.key /etc/kibana/certs/kibana.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改變一下檔案權限</span></span><br><span class="line"><span class="built_in">chown</span> -R kibana: /etc/kibana/certs</span><br><span class="line"><span class="built_in">chmod</span> -R 500 /etc/kibana/certs</span><br><span class="line"><span class="built_in">chmod</span> 400 /etc/kibana/certs/ca/ca.* /etc/kibana/certs/kibana.*</span><br><span class="line"><span class="built_in">rm</span> -rf ~/certs ~/certs.zip</span><br></pre></td></tr></table></figure><ol start="3"><li>幫kibana下載wazuh的模板</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -so /etc/kibana/kibana.yml https://packages.wazuh.com/4.4/tpl/elastic-basic/kibana.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># Edit the /etc/kibana/kibana.yml file:</span></span><br><span class="line">server.host: &lt;kibana_ip&gt; <span class="comment"># 改成裝kibana的實體機ip</span></span><br><span class="line"><span class="comment">#  # 改成裝elasticsearch的實體機ip或dns name</span></span><br><span class="line">elasticsearch.hosts: <span class="string">&quot;https://&lt;elasticsearch_DN&gt;:9200&quot;</span></span><br><span class="line">elasticsearch.password: &lt;elasticsearch_password&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the /usr/share/kibana/data directory:</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/share/kibana/data</span><br><span class="line"><span class="built_in">chown</span> -R kibana:kibana /usr/share/kibana</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install the Wazuh Kibana plugin:</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/kibana</span><br><span class="line">sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/4.x/ui/kibana/wazuh_kibana-4.4.4_7.17.6-1.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">setcap</span> <span class="string">&#x27;cap_net_bind_service=+ep&#x27;</span> /usr/share/kibana/node/bin/node</span><br></pre></td></tr></table></figure><ol start="4"><li>啟動的時候就會開始把/usr/share/kibana裡面所需要的東西wazuh相關的plugin下載</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> kibana</span><br><span class="line">systemctl start kibana</span><br></pre></td></tr></table></figure><ol start="5"><li>等到啟動之後，就可以去修改wazuh.yml檔案，這樣才會call對，檔案位置在 <code>/usr/share/kibana/data/wazuh/config/wazuh.yml</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/share/kibana/data/wazuh/config/wazuh.yml</span><br><span class="line"><span class="comment"># 修改內容如下</span></span><br><span class="line">hosts:</span><br><span class="line">  - default:</span><br><span class="line">      url: https://localhost <span class="comment"># 把這裡改成 wazuh 的 ip </span></span><br><span class="line">      port: 55000</span><br><span class="line">      username: wazuh-wui</span><br><span class="line">      password: wazuh-wui</span><br><span class="line">      run_as: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ol start="6"><li>Access the web interface using the password generated during the Elasticsearch installation process:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL: https://&lt;kibana_ip&gt;</span><br><span class="line">user: elastic</span><br><span class="line">password: &lt;PASSWORD_elastic&gt;</span><br></pre></td></tr></table></figure><h1 id="踩坑1-wazuh-版本太新-kibana-太舊的問題">踩坑1: wazuh 版本太新 kibana 太舊的問題</h1><div class="note info flat"><p>wazuh API 4.4.4 但是 App 是 4.3.10 的版本不對，這是因為 kibana 的 wazuh plugin</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先使用 su 權限</span></span><br><span class="line">sudo su </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前 kibana 有安裝的 plugin 看 wazuh 是否為 4.3.10 我們要更新為 4.4.4 </span></span><br><span class="line">/usr/share/kibana/bin/kibana-plugin list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是 4.3 的版本就太舊了，先移除</span></span><br><span class="line">/usr/share/kibana/bin/kibana-plugin remove wazuh </span><br><span class="line"></span><br><span class="line"><span class="comment"># 再重裝</span></span><br><span class="line">sudo -u kibana /usr/share/kibana/bin/kibana-plugin install https://packages.wazuh.com/4.x/ui/kibana/wazuh_kibana-4.4.4_7.17.6-1.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">setcap</span> <span class="string">&#x27;cap_net_bind_service=+ep&#x27;</span> /usr/share/kibana/node/bin/node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重啟</span></span><br><span class="line">systemctl restart kibana</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> wazuh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elastic </tag>
            
            <tag> wazuh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>簡單介紹Istio</title>
      <link href="/posts/istio-intro/"/>
      <url>/posts/istio-intro/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Istio">What is Istio?</h1><div class="note info flat"><p><strong>1. Is a service mesh, implement network mechanism</strong></p></div><ul><li>service mesh 基本上是透過在 Pod 上面做 Sidecar</li><li>把<strong>網路相關的工作剝離</strong>出來，讓工程師可以專注在開發上</li><li>而網路的控管像是 Gatewway，<strong>經過 pod 的 request 都是經由 Sidecar 轉發給 pod</strong>。</li></ul><div class="note info flat"><p><strong>2. Integrate with many observability tools</strong></p></div><ul><li>不只可以做網路，還可以整合各種第三方的觀察工具</li><li>(e.g. Prometheus, Kiali, Grafana, etc.)。</li></ul><div class="note info flat"><p><strong>3. Handle microservice challenges</strong></p></div><ul><li>在 microservice 架構下當 service/pod 一多，要去管控各個 service 間的網路連線是非常頭痛的</li><li>但是透過Istio可以負責解決網路的事情，並由control plane統一管理和設定。</li></ul><blockquote><p>可以從上方看到，每個Pod裡面有兩個container，一個是Service另一個是Proxy，而Istio主要就是透過Control Plane來控制Proxy進行網路流量的操控與設定。<br><img src="https://i.imgur.com/XregvWQ.png" alt=""></p></blockquote><div class="note danger flat"><p>注意：Sidecar不是只負責把網路相關的工作剝離，<strong>Sidecar是一種附加在Pod內的容器</strong>，用於提供額外的功能或服務，<strong>與主要應用容器共同運行並共享相同的生命周期</strong>。像是如果要收集pod的log，通常就會需要fluentd的Sidecar共享pod的產生log的資料夾，把log傳送給elasticSearch。</p></div><h1 id="Istio-的主要核心">Istio 的主要核心</h1><p>Istio 主要有兩個核心元件：</p><ol><li><strong>Envoy: 就在Proxy旁邊</strong><ul><li>目的：Istio使用Envoy Agent作為與data plane交互的Istio元件，被部署為服務的Sidecar。主要<strong>協調Service Mesh中所有服務進去和出去的流量</strong>。</li><li>功能：動態的service discover, load balance, TLS, Http/2和gRPC agent, health check, 金絲雀發布 等等。</li><li>貢獻：可以允許Istio執行決策並且提取豐富的數據，並發送數據到監控系統中提供整個Mesh的行為信息。</li></ul></li><li><strong>Istiod: 就在Control Plane</strong><ul><li>目的：<strong>提供service discover, 配置和憑證管理</strong>負責實現強大的服務隊服務的用戶認證，可以用來升級服務網格中未加密的流量，對不穩定的layer 3 (network)或是 layer 4 (Transport layer, TCP)來執行策略。</li></ul></li></ol><h1 id="Istio-如何做到安全">Istio 如何做到安全?</h1><p><img src="https://i.imgur.com/aSHY5pr.png" alt=""></p><ul><li>在 <code>Control Plane</code> 可以看到 <code>Istiod</code> 負責：<ul><li>憑證與授權管理</li><li>網路設定</li><li>授權政策設定</li></ul></li></ul><blockquote><p>使用Istio有以下特色</p></blockquote><ol><li><strong>Secure by default</strong> : 透過Sidecar的方式應用程式代碼和基礎設施不需更改。</li><li><strong>Defense in depth</strong>：與現有安全系統集成以提供多層防禦。</li><li><strong>Zero-trust network</strong>：在不受信任的網路上建構安全解決方案。</li><li><strong>Secure Endpoints, Communication, Platform, Data</strong></li><li><strong>Do Identity, Policy, AAA, Encryption</strong></li></ol><blockquote><p>Istio 的安全元件</p></blockquote><ol><li><strong>CA</strong>：用於密鑰和憑證管理的頒發機構CA。</li><li><strong>配置API服務器</strong>：把認證策略, 授權策略, 安全命名分發給agent。</li><li><strong>Sidecar和邊緣agent作為PEP</strong>：保護客戶端和服務之間的通信安全。而PEP用Envoy實現。</li><li><strong>一組Envoy Agent Extension</strong>：用於監控和審計。</li></ol><h2 id="Istio-身份和憑證管理">Istio 身份和憑證管理</h2><div class="note danger flat"><p>注意：以下內容的<code>istio-agent</code>是指Sidecar容器中的<code>pilot-agent</code> process。</p></div><p><img src="https://i.imgur.com/hNRESzY.png" alt=""></p><ol><li><code>Istio-agent</code> 在啟動時，創建pk 和 CSR 並且把 CSR和憑證送到 <code>istiod</code> 簽名。</li><li><code>Istiod CA</code> 驗證CSR裡面的憑證，在成功驗證後簽署CSR以生成證書。</li><li>當工作附載啟動時，Envoy 通過 <code>Secret Discover Service (SDS) API</code> 向同容器內的 <code>istio-agent</code> 發送憑證和pk請求。</li><li><code>Istio-agent</code>透過<code>Envoy SDS API</code> 將從 <code>istiod</code> 收到的證書和密鑰發送給Envoy。</li><li><code>Istio-agent</code> 監控工作負載憑證的過期時間，會定期重複做憑證和pk的輪換。</li></ol><h2 id="Istio-的政策授權">Istio 的政策授權</h2><p>畢竟Istio的重點在控制Pod服務的網路流量，因此要對於特定情況的流量應該作接受還是拒絕，仍然要政策的設置與規則引擎的判斷。<strong>Istio有提供政策的設置，若要建立授權策略需要創建 <code>AuthorizationPolicy</code> 的自定義資源</strong>。一個授權策略包含：</p><ul><li><code>Selector</code> 選擇器：用來指定策略的執行目標。</li><li><code>Action</code> 操作：指定允許還是拒絕請求。</li><li><code>Rules</code> 規則集：指定何時觸發動作。<ul><li><code>From</code>：指定請求的來源</li><li><code>To</code>：指定請求的操作</li><li><code>When</code>：指定規則所需的條件</li></ul></li></ul><blockquote><p>以下是策略設定的範例：</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">security.istio.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AuthorizationPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">httpbin</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">selector:</span></span><br><span class="line">   <span class="attr">matchLabels:</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">httpbin</span></span><br><span class="line">     <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"> <span class="attr">action:</span> <span class="string">ALLOW</span></span><br><span class="line"> <span class="attr">rules:</span></span><br><span class="line"><span class="string">//</span> <span class="string">允許兩個來源：服務帳戶</span> <span class="string">cluster.local/ns/default/sa/sleep</span> <span class="string">和命名空間dev</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">source:</span></span><br><span class="line">       <span class="attr">principals:</span> [<span class="string">&quot;cluster.local/ns/default/sa/sleep&quot;</span>]</span><br><span class="line">   <span class="bullet">-</span> <span class="attr">source:</span></span><br><span class="line">       <span class="attr">namespaces:</span> [<span class="string">&quot;dev&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">可以對</span> <span class="attr">namespace:</span> <span class="string">foo</span> <span class="string">中帶有標籤</span> <span class="attr">app:</span> <span class="string">httpbin</span> <span class="string">和</span> <span class="string">version:v1</span> <span class="string">進行GET動作</span></span><br><span class="line">   <span class="attr">to:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">operation:</span></span><br><span class="line">       <span class="attr">methods:</span> [<span class="string">&quot;GET&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">使用有效的JWT</span> <span class="string">Token發送請求時</span></span><br><span class="line">   <span class="attr">when:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">request.auth.claims[iss]</span></span><br><span class="line">     <span class="attr">values:</span> [<span class="string">&quot;https://accounts.google.com&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="Istio-的政策驗證流程">Istio 的政策驗證流程</h2><ul><li>在對Server端的Envoy Agent進入流量實施訪問控制，</li><li>每個Envoy Agent會運行一個授權的引擎，該引擎會根據當前的策略，評估上下文。</li><li>然後返回授權結果Allow或Deny。</li><li>而策略是使用<code>.yaml</code>文件指定Istio授權策略。</li><li>如果沒有相關的授權策略，Istio允許所有請求。</li><li>支援<code>Custom</code>操作，可以根據需求設定策略執行不同的操作。</li><li>檢查順序的匹配規則是：<code>Custom</code> &gt; <code>Deny</code> &gt; <code>Allow</code>，會先檢查是否有策略的操作被應用，檢查策略的規則是否滿足。如果其中一層的不匹配就執行到下一層(可以參考下圖)。</li></ul><p><img src="https://i.imgur.com/ke1kccL.png" alt=""></p><h1 id="參考資料">參考資料</h1><ul><li><a href="https://medium.com/hobo-engineer/%E7%AD%86%E8%A8%98-%E6%B7%BA%E5%85%A5%E6%B7%BA%E5%87%BA-istio-1-%E6%9E%B6%E6%A7%8B%E7%B0%A1%E8%AA%AA-a8d6aaf6977d">筆記 淺入淺出 Istio (1) — 架構簡說</a></li><li><a href="https://istio.io/latest/zh/docs/concepts/security/">Istio &gt; Security</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Istio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> istio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次搞懂Java中的equals()和hashCode()</title>
      <link href="/posts/equals-hashCode/"/>
      <url>/posts/equals-hashCode/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><div class="note info flat"><p>如果你想要自定義物件判斷是否相等的邏輯，就改<code>equals</code>吧！<br>如果你想要修改HashMap或是HashSet中，不重複物件的邏輯，那就修改<code>hashCode</code>吧！</p></div><p>在物件導向的世界裡面，勢必逃不了自己建立的物件（你可能把某些功能包起來，放在某個class裡面）又或是想要建立一個<code>Employee.class</code>這樣的類別，方便你建立員工的資料存入資料庫中。</p><p>而這些<code>xxxx.class</code>都其實繼承Object，可以說是Object是所有Java類別的超類(Abstract Class)，而我會想寫這篇的原因是因為，剛好碰到<strong>需要自定義<code>HashSet</code>的需求，修改放入Set的自定義物件時，判斷物件是否相等的邏輯</strong>。</p><p>什麼意思呢？簡單來說，在程式語言中，我希望不要採用Object本身的<code>hashCode</code>和<code>equals</code>方法，<strong>我希望只要某些屬性的值一樣，我就視這個物件已經存在於Set裡面</strong>。而不是比較記憶體中的位置、所有屬性的value都要一樣等，<strong>我希望自定義物件相等的邏輯判斷</strong>。</p><p>如果你好奇…</p><ol><li>我複寫equals的方法為什麼還要管hashCode?</li><li>equals跟hashCode的關係是什麼？</li></ol><p>那你可以參考這個篇文章，繼續看下去。</p><h1 id="equals-是什麼？">equals 是什麼？</h1><p>可以從原始碼中看到一長串的東西，沒關係你可以跳過，讓我來跟你娓娓道來 …<br><img src="https://i.imgur.com/bs2kH6g.png" alt=""></p><h2 id="equals-的特性">equals 的特性</h2><div class="note warning flat"><p>他裡面說了啥？面試這個應該要說得出來以下幾種特性呦！</p></div><p>簡單來說，equals主要遵循了以下規則來判斷物件的相等性：</p><ol><li><strong>自反性Reflexive</strong>： 我就是我<ul><li><code>x.equals(x)</code> 應該總是返回 true。</li></ul></li><li><strong>對稱性Symmetric</strong>： 我是你 你就是我 順序沒差<ul><li>如果 <code>x.equals(y)</code> 返回 <code>true</code>，則 <code>y.equals(x)</code> 也應返回 <code>true</code>。這意味著比較的順序不重要。</li></ul></li><li><strong>傳遞性Transitive</strong>: 爺爺的精神跟孫子是一樣的<ul><li>相較於Symmetric更深一層，如果 <code>x.equals(y)</code> 返回 <code>true</code>，且 <code>y.equals(z)</code> 返回 <code>true</code>，則 <code>x.equals(z)</code> 也應返回 <code>true</code>。</li><li>換句話說，如果兩個物件分別與第三個物件相等，則它們之間也應該相等。</li></ul></li><li><strong>一致性Consistent</strong>：只要內容不變還是一樣<ul><li>只要比較時使用的信息未被修改，多次調用 x.equals(y) 應始終返回相同的結果。</li></ul></li><li><strong>與 null 的比較</strong>：永遠不同<ul><li>對於任何非 null 的引用值 x，x.equals(null) 應該返回 false。物件不應該與 null 相等。</li></ul></li></ol><h2 id="到底怎麼樣算equals">到底怎麼樣算equals?</h2><div class="note info flat"><p>你說的我都懂：但是我怎麼知道 equals 到底是比什麼？</p></div><p>按照原本equals的內容，如果滿足下面三個條件的話，我就說<strong>這兩個物件是一樣的</strong>：</p><ol><li><strong>位置</strong> 一樣</li><li><strong>類別</strong> 一樣</li><li><strong>屬性</strong> 一樣</li></ol><p>上面的例子中，你可能最不懂的是<strong>比較位置</strong>…<br>舉例來說，下面有一個程式範例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次 new 的時候就是 assign 一個新位置給他 </span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;shannon&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;shannon&quot;</span>);</span><br><span class="line">        <span class="comment">// 這時就會返回 false </span></span><br><span class="line">        System.out.println(emp1.equals(emp2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是這種感覺：當new一個物件的時候，就會給他安排在不同的位置，所以他們當然就是獨立的個體囉，<strong>就像是同名同姓的人住在不同地區一樣，但是他們還是不同人</strong>。<br><img src="https://i.imgur.com/KwIZqYj.png" alt=""></p><p>但是如果你把程式改成這樣：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次 new 的時候就是 assign 一個新位置給他 </span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;shannon&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp2</span> <span class="operator">=</span> emp1;</span><br><span class="line">        <span class="comment">// 這時就會返回 true </span></span><br><span class="line">        System.out.println(emp1.equals(emp2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/4QAp0qe.png" alt=""></p><h2 id="為啥要改寫equals">為啥要改寫equals?</h2><div class="note info flat"><p>今天你不想要，判斷位置，我希望<strong>只要屬性值一樣，就識別這兩個物件是一樣的</strong><br>這時候你可以考慮override <code>equlas</code> 方法</p></div><ul><li>簡單來說，我有一個<code>IdNumber.class</code>，用來記錄身分證資料，因此我只需要知道<code>id</code>如果一樣的話，一定是同一個人，不用多說。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果“位置”一樣就不用看了 肯定同一個人</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果“類別”不可為null，同時如果&quot;類別&quot;不一樣，也太怪了，一定不是同個人</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 注意：上面這段絕對不要使用 instanceof !(o instanceof IdNumber) </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比較自定義類別的各種“屬性值”</span></span><br><span class="line">        <span class="comment">// 透過Objects.equals 判斷 就不用寫成這樣：(o.id != null &amp;&amp; o.id.equals(that.id))</span></span><br><span class="line">        <span class="type">IdNumber</span> <span class="variable">that</span> <span class="operator">=</span> (IdNumber) o</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id,that.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 這時候就能打破「位置」的框架了，只針對「屬性」還有「類別」來比較。</span></span><br><span class="line">        <span class="type">IdNumber</span> <span class="variable">id1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdNumber</span>(<span class="string">&quot;A123&quot;</span>);</span><br><span class="line">        <span class="type">IdNumber</span> <span class="variable">id2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdNumber</span>(<span class="string">&quot;A123&quot;</span>);</span><br><span class="line">        System.out.println(id1.equals(id2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>這時候你可能會不太了解為什麼不要使用<code>instanceof</code>來進行類別的比較？<br>因為在父類別層次進行比較時，會出現問題</p></div><p>Ans:<br><strong>違反對稱性</strong>：user 不是 employee 的子類，但是<code>employee</code>是<code>user</code>的子類，我們希望不管<code>employee</code>還是<code>user</code>放在被比較的那方，還是比較方，結果應該都要一樣！<br>因此才<strong>使用<code>getClass</code>來進行類別的比較，不考慮父類別之間的關係</strong>，反正class不一樣，我一率覺得這是不一樣的物件，拒絕！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// Parent class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// Child class definition</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print: parent.getClass() = class Parent</span></span><br><span class="line">        System.out.println(<span class="string">&quot;parent.getClass() = &quot;</span> + parent.getClass());</span><br><span class="line">        <span class="comment">// print: child.getClass() = class Child</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child.getClass() = &quot;</span> + child.getClass());</span><br><span class="line">        <span class="comment">// print: child.getClass() == parent.getClass() ? false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;child.getClass() == parent.getClass() ? &quot;</span> + (child.getClass() == parent.getClass()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="關於HashCode">關於HashCode ?</h1><p>hashCode也叫雜湊碼（雜湊碼），它用來計算物件中所有屬性的雜湊值，哪裡會使用到呢？從字面上就可以看到，<code>Hash</code>有關的，就會呼叫到這個函式。例如，<code>HashMap</code>或是<code>HashSet</code>。在 Java 或 Kotlin 語言中，<code>hashCode()</code> 方法的主要目的是用來在使用哈希表（如 <code>HashMap</code> 或 <code>HashSet</code>）時<strong>提供一種快速查找的方式</strong>。</p><h2 id="hash-的特性">hash 的特性</h2><p>在計算機科學中，雜湊（Hash）是一種特殊的函數，具有以下幾個主要特性：</p><ol><li>確定性（Deterministic）：<ul><li>對於<strong>同一個輸入，Hash 函數每次運算都將產生同一個輸出</strong>。也就是說，如果你有一個輸入 A，每次將 A 輸入 Hash 函數，你都會得到同樣的結果。</li></ul></li><li>快速計算（Fast to Compute）：<ul><li>對任何給定的輸入，計算其 Hash 值都應該是非常迅速的。</li></ul></li><li>不可逆性（Irreversibility）：<ul><li>當知道了 Hash 函數的輸出，<strong>我們卻無法推算出其對應的輸入。這是密碼學中特別重要的一個特性</strong>。</li></ul></li><li>隨輸入微小變化產生大變化（Avalanche Effect）：<ul><li>即使<strong>輸入的微小變化，也應該導致 Hash 值的劇烈變化</strong>。這有助於確保相似的輸入在經過雜湊後得到的結果將顯著不同。</li></ul></li></ol><h2 id="儲存物件於哈希表">儲存物件於哈希表</h2><p>當您在哈希表(<code>HashMap</code> 或是 <code>HashSet</code>)中存儲物件時，<code>hashCode()</code> 方法被用來<strong>確定物件應該被存放在哈希表的哪個位置</strong>。這通常通過將物件的 <code>hashCode()</code> 返回值對哈希表的大小進行取模運算來實現。</p><blockquote><p>透過hashCode檢索儲存於哈希表的物件</p></blockquote><ol><li>當您試圖<strong>從哈希表中檢索物件時，<code>hashCode()</code> 方法也會被調用以確定應該在哪裡查找該物件</strong>。</li><li>如果哈希碼與表中存儲的任何物件的哈希碼不匹配，那麼哈希表可以<strong>立即確定該物件不在表中，而無需進行進一步的比較</strong>。</li><li>如果在該哈希碼對應的位置找到了一個或多個物件，哈希表將使用 <code>equals()</code> 方法來確定哪一個物件（如果有的話）與查詢的物件匹配。這是因為多個不同的物件可能會有相同的哈希碼（也就是所謂的哈希碰撞）。</li></ol><p>這就是為什麼當我們在自定義類別中覆寫 <code>equals()</code> 方法時，<strong>我們應該始終確保也覆寫 <code>hashCode()</code> 方法，並確保如果兩個物件根據 <code>equals()</code> 方法是相等的</strong>，那麼它們的 <code>hashCode()</code> 方法也應該返回相同的值。如果這兩種方法之間的契約被違反，那麼依賴這些方法的資料結構（如 <code>HashMap</code> 和 <code>HashSet</code>）可能無法正確地工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Player(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> (Player) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, player.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 我們用 name 來進行 hash </span></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;Player&gt; players = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Bob&quot;</span>));</span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Charlie&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to add a new player with the same name as Alice</span></span><br><span class="line">        players.add(<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 這時候 players 只會有三個 因為 name 是一樣的</span></span><br><span class="line">        System.out.println(player.getSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="參考連結">參考連結</h1><ul><li><a href="https://tw511.com/a/01/30684.html">Java中的equals()和hashCode() - 超細節篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 物件導向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>德國簽證教學, 可能碰到的問題, 要準備什麼文件？</title>
      <link href="/posts/germany-visa/"/>
      <url>/posts/germany-visa/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E7%B0%BD%E8%AD%89%E5%9C%B0%E9%BB%9E">簽證地點</a></li><li><a href="#%E5%BE%B7%E5%9C%8B%E7%B0%BD%E8%AD%89%E6%96%87%E4%BB%B6%E6%BA%96%E5%82%99">德國簽證文件準備</a><ul><li><a href="#q-%E7%95%99%E5%AD%B8%E7%94%9F%E9%9C%80%E8%A6%81%E6%BA%96%E5%82%99%E4%BB%80%E9%BA%BC%E8%B3%87%E6%96%99%E5%92%8C%E6%96%87%E4%BB%B6">Q: 留學生需要準備什麼資料和文件？</a></li><li><a href="#q-%E8%A6%AA%E8%87%AA%E5%89%8D%E5%BE%80%E7%94%B3%E8%AB%8B%E6%99%82%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E9%BA%BC">Q: 親自前往申請時要注意什麼？</a></li><li><a href="#q-%E7%B0%BD%E8%AD%89%E4%B8%AD%E9%97%9C%E6%96%BC%E4%BF%9D%E9%9A%AA%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E9%BA%BC">Q: 簽證中關於保險需要注意什麼？</a></li><li><a href="#q-%E9%97%9C%E6%96%BC%E7%B0%BD%E8%AD%89%E5%BE%8C%E5%B1%85%E4%BD%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85">Q: 關於簽證後居住的注意事項？</a></li><li><a href="#q-%E5%8F%AF%E6%8C%81%E5%AD%B8%E7%94%9F%E7%B0%BD%E8%AD%89%E6%96%BC%E6%B1%82%E5%AD%B8%E6%9C%9F%E9%96%93%E5%B7%A5%E4%BD%9C">Q: 可持學生簽證於求學期間工作？</a></li></ul></li><li><a href="#%E5%AF%A6%E9%9A%9B%E5%89%8D%E5%BE%80%E7%8B%80%E6%B3%81">實際前往狀況</a></li><li><a href="#%E7%95%B6%E5%A4%A9%E6%9C%89%E5%93%AA%E4%BA%9B%E7%83%8F%E9%BE%8D">當天有哪些烏龍</a></li><li><a href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%BA%90">參考資源</a></li></ul><h1 id="背景">背景</h1><blockquote><p>為什麼申請簽證？</p></blockquote><p>因為台科大資管系剛好2023/3月與德國HKAs談雙聯。申請上後，2023/9準備前往德國雙聯，大約為期一年的時間，因此需要申請大概為期一年的簽證，然後在這邊做記錄說申請簽證的整個準備過程和心得。</p><h1 id="簽證地點">簽證地點</h1><blockquote><p>💡 請注意以下資訊：</p></blockquote><ul><li><a href="https://goo.gl/maps/D19qwdiukaNkBea39">德國在台協會辦公時間、電話、地址及交通指南</a><ul><li>住址：11049臺北市信義路五段7號33樓 (33F, No. 7, Xinyi Rd., Sec.5, Taipei 11049)</li><li>時間：需提前30分鐘到101(算上迷路時間)</li><li>要帶錢：約3000台幣(當時付了$2450 NTD)</li><li>提前時間：三個月</li></ul></li></ul><h1 id="德國簽證文件準備">德國簽證文件準備</h1><h2 id="Q-留學生需要準備什麼資料和文件？">Q: 留學生需要準備什麼資料和文件？</h2><blockquote><p>切記注意：<strong>不要把以下文件訂起來</strong>，但是如果有把順序排好的話，作業流程會快很多。<br>順序大概是：申請表格 &gt; 護照影印 &gt; 德國學校入學通知（最好有開學日）&gt; 台灣學校相關文件 &gt; 保險+凍結帳戶 &gt; 自傳與動機</p></blockquote><p><a href="https://taipei.diplo.de/tw-zh-tw/service/visa-einreise/-/2453292">單國德國長期簽證 - 於德國境內就讀高等學院簽證 - 德國外交部 (diplo.de)</a></p><ul><li>[x]  0 預約好的email信件，要列印出來給他們看。（但實際前往，他們並無要求要，只是以防萬一）</li><li>[x]  1 <strong>有效護照</strong>正本(須於最近十年內核發，持照人已於簽名處簽名, 至少須有兩頁以上空白頁面)</li><li>[x]  2 完整填寫好的**申請表格 (<a href="https://videx-national.diplo.de/videx/visum-erfassung/#/videx-langfristiger-aufenthalt">表格</a>) (**兩份) 不用貼照片</li><li>[x]  3 <strong>護照個人基本資料頁影本</strong>，兩份</li><li>[x]  4 三張最新且符合生物特徵之<strong>證件照</strong>(須於三個月內拍攝)</li><li>[x]  5 <strong>德國高等學院入學許可</strong>, 兩份</li><li>[x]  6 (以防萬一) <strong>交換學生</strong>須額外 檢附：<ul><li>目前就讀之台灣學校所核發的<strong>英文版在學證明</strong>，<strong>兩份</strong></li><li>目前就讀之台灣學校所核發的<strong>英文版成績單</strong>，<strong>兩份</strong></li></ul></li><li>[x]  7 依據入學許可 - <strong>授課語言能力證明,</strong> 兩份<ul><li>德語能力證明：例如 DSH, Goethe-Zertifikat, TestDaF</li><li>英語能力證明：例如 , IELTS, TOEFL,TOEIC</li></ul></li><li>[x]  8 <strong>財力證明</strong> (需檢附第一年之財力證明。交換學生部份，請檢附總停留時間之財力證明)<ul><li><strong>每月</strong> 至少<strong>934</strong> 歐元，兩份</li><li>以簽證申請者為名開立之<strong>限制提領帳戶(Sperrkonto)</strong></li><li>存款金額至少11.208歐元(=12x934歐元)</li><li>如果是Expatro就要記得提供06的文件喔</li></ul></li><li>[x]  9 <strong>至目前為止之中學學歷證明/高等學院學歷證明/技職教育結業證明，及在特定狀況下，其他與德國學業相關之資格證明</strong>，(正本及影本兩份)<ul><li>(若您已於高等學院就讀，但尚未取得學位，請檢附：英文版註冊證明及成績單)</li><li>我猜：大學畢業證書</li></ul></li><li>[x]  10 <strong>德文</strong>或<strong>英文</strong>動機信,兩份 （Personal Statement)<ul><li>請詳細闡述至德國求學原因及該學業對於日後職業未來之影響</li></ul></li><li>[x]  11 <strong>唯簽證可被核發前，才會要求您提供</strong><ul><li>預計入境德國日期</li><li>適用於德國境內之保險證明</li></ul></li><li>[x]  12 (不確定以防萬一) 快遞免責同意出<ul><li><a href="https://taipei.diplo.de/blob/1988392/0335790923e5be9d5f6387262f1bea2a/haftungsausschlusserklaerung-data.pdf">haftungsausschlusserklaerung-data.pdf (diplo.de)</a></li></ul></li></ul><h2 id="Q-親自前往申請時要注意什麼？">Q: 親自前往申請時要注意什麼？</h2><ul><li><strong>請您不要將簽證申請文件釘在一起!</strong></li><li><strong>簽證處理費用</strong>為75歐元（<strong>2,544.73新臺幣</strong>），您可於面試當下以台幣現金支付。簽證申請一旦被受理，則費用將無法被退還 – 不論日後審核結果為何!</li><li><strong>處理完整簽證申請之工作天，基本上大約為五週</strong><br>；可能依個案不同而更久。德國在台協會無法干涉或是加快外事單位簽證審核程序。因此，德國在台協會請您於簽證申請過程中，不要詢問任何簽證進度相關問題。<strong>當您的簽證申請流程結束時，本會將立即以信件方式通知您</strong></li></ul><h2 id="Q-簽證中關於保險需要注意什麼？">Q: 簽證中關於保險需要注意什麼？</h2><ul><li>您的健保必須於入境德國那一天生效。最理想的狀況是，您購買所謂的Incoming保險，此類保險於您入境德國的那一天生效，在您生病或受傷時，提供足夠的保障。</li><li>並且在您正式註冊為學生後，直接自動轉換成德國境內的公立或私人學生健保，在這轉換的過程中，您的保險不會有任何的間斷。</li></ul><h2 id="Q-關於簽證後居住的注意事項？">Q: 關於簽證後居住的注意事項？</h2><ul><li>依據外事單位許可，我們可核發<strong>九十天或六個月不等</strong>之<strong>學生簽證</strong></li><li>入境德國後，您須持該簽證向當地外事單位提出長期居留證申請。</li><li>對於交換學生，大部份我們可核發停留德國總時間(一或兩個學期)簽證。</li><li>所有移居德國的人必須於兩週內於居住地所在之戶政單位辦理入戶登記。</li></ul><h2 id="Q-可持學生簽證於求學期間工作？">Q: 可持學生簽證於求學期間工作？</h2><ul><li>可以，於高等學院辦理註冊後，您可持學生簽證/居留證工作，或從事學生工讀，一年總計最多可達120個全天或240個半天。</li><li>該工作許可並不適用於學前準備課程(例如語言班)之停留。德國外事單位可額外增定限制條件，例如只能於學校放假期間(寒暑假期間)工作。</li></ul><h1 id="實際前往狀況">實際前往狀況</h1><ol><li>先去一樓，左轉機台<strong>領訪客證</strong>，可以上網查教學，但具體來說如下：<ul><li>會先透過機台找到德國在台協會的公司，然後點下去</li><li>會自動撥話，然後機台會直接聯絡他們，<strong>他們會問你：是誰？然後預約幾點的？</strong></li><li>確認完訊息之後，機台就會吐訪客證拉！</li></ul></li><li>因為德國在台協會在33樓，所以<strong>你要先去35樓，在轉電梯到33樓！</strong>（p.s. 101的電梯就跟迷宮一樣…）</li><li>開電梯門後，左轉走到底。就會看到一個警衛，警衛會要求你把手機關起來到保險箱，接下來就是等待。</li><li><strong>等待的過程中不會有號碼牌</strong>因為我是預約9:45a.m.，所以當他們如果叫10:45分有沒有預約的同學，你就要舉手讓他們知道！</li><li>輪到你的時候，他就會幫你檢查表格有沒有填錯，問一些問題拉～，基本上15分鐘就可以處理好。</li></ol><h1 id="當天有哪些烏龍">當天有哪些烏龍</h1><ol><li><p>問題：德國在台協會<strong>會把你的護照收走</strong>…</p><ul><li>因為他們需要把簽證貼在你的護照，所以會收走護照</li><li>剛好我下週要去日本，這嚇死我了！如果你有需要，一定要提前跟他們說，否則要重新等待（本來我15分鐘處理好，結果等了1小時才離開）</li><li>他們會要求你簽名同意書，然後就可以領走護照了。</li><li>之後回國後，要把護照寄回去德國在台協會，最好一起把編號（辦理完成他們會給你編號讓你知道進度）也給他們。</li></ul></li><li><p>問題：如果你還<strong>不確定錄取哪一間學校，真的不要去辦簽證</strong>…</p><ul><li>當天我看到一個女生，她申請了很多間學校，只有一間確定入取但是其他還不知道</li><li>但是，協會會把申請文件送到當地的特定州，所以如果你上A學校，但是Ｂ不確定，所以你簽證送到Ａ地，但是後續Ｂ錄取了，你想去Ｂ地，這是不可以的喔！你就要重新申請！</li></ul></li><li><p>問題：<strong>請務必提早預約</strong>，越早越好但是不要太早超過三個月喔！</p><ul><li>拜託，一定要提早預約！我自己是預計八月底過去，所以我四月就預約了，那時候空位超多的拉！</li><li>但是當五月底到的時候，基本上就沒有可以預約的時間了。</li></ul></li></ol><h1 id="參考資源">參考資源</h1><ul><li><a href="https://youtu.be/mFzOomf8FJg">德國簽證申請當天流程 ❗｜實際的情形如何? ｜學生簽證 &amp; 長期簽證｜該準備甚麼 ? ｜如何搶申請預約｜財務證明怎麼辦理｜德國在臺協會在 101 !? ｜需要會德文嗎？｜我沒有注意到的是 …</a></li><li><a href="https://jacky88210.wordpress.com/2017/09/17/%E6%BC%AB%E9%95%B7%E5%BE%B7%E5%9C%8B%E9%95%B7%E6%9C%9F%E7%B0%BD%E8%AD%89%E4%B9%8B%E8%B7%AF%F0%9F%87%A9%F0%9F%87%AA/">漫長德國長期簽證之路🇩🇪</a></li><li><a href="https://outgoing-iep.nccu.edu.tw/sites/default/files/109356007_ep1_%E9%9B%BB%E5%AD%90%E5%A0%B1%E4%B8%80_%E7%B0%BD%E8%AD%89%EF%BC%88%E5%90%AB%E8%BE%A6%E7%90%86%E6%99%82%E7%A8%8B%EF%BC%89.pdf">簽證教學(含辦理時程).pdf</a></li><li><a href="https://taipei.diplo.de/tw-zh-tw/service/visa-einreise/-/1695744?view=">單國德國長期簽證</a></li><li><a href="https://www.dcard.tw/f/studyabroad/p/236782389">2021德國交換簽證申請 - 留學板 | Dcard</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 留學 </category>
          
          <category> 簽證申請 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 簽證 </tag>
            
            <tag> 德國 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇blog - Hexo架設的樣式設計 - 基於Butterfly</title>
      <link href="/posts/first-blog/"/>
      <url>/posts/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><div class="note info flat"><p>這是我在建立過程中，設置的一些小細節，如果我的文章有幫助到你的話，希望可以在下面留言:D<br>給我一個“讚”～</p></div><h1 id="latex-Katex-in-Butterfly-Theme-Hexo">latex - Katex in Butterfly Theme Hexo</h1><ul><li>Ref: <a href="https://www.wzhecnu.cn/2021/08/31/blog/math-tex/">https://www.wzhecnu.cn/2021/08/31/blog/math-tex/</a></li></ul><p>因為撰寫ML的相關技術文章，但是碰了不少壁，最後終於成功可以在文章中使用Latex撰寫。</p><ol><li>先下載和解除相關套件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save <span class="comment"># 卸载 marked 插件</span></span><br><span class="line">npm un hexo-renderer-kramed --save <span class="comment"># 卸载 kramed 插件</span></span><br><span class="line">npm i hexo-renderer-markdown-it --save <span class="comment"># 安装渲染插件</span></span><br><span class="line">npm install @neilsustc/markdown-it-katex --save <span class="comment"># 安装katex插件</span></span><br></pre></td></tr></table></figure><ol start="2"><li>設定<code>_config.butterfly.yml</code></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KaTeX</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span> <span class="comment"># 如果使用 false 就要在每個 post 的標頭添加 katex: true </span></span><br><span class="line">  <span class="attr">hide_scrollbar:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>我是參考到github上的<a href="https://github.com/jerryc127/hexo-theme-butterfly/issues/515">issues</a>，裡面偶然看到<a href="https://github.com/hexojs/hexo-renderer-markdown-it#options">hexo-renderer-makrdown-it</a>，才發現需要在 <code>_config.yml</code> 追加以下設定：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Katex</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">preset:</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">langPrefix:</span> <span class="string">&#x27;language-&#x27;</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="attr">enable_rules:</span></span><br><span class="line">  <span class="attr">disable_rules:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">     <span class="attr">name:</span> <span class="string">&#x27;@neilsustc/markdown-it-katex&#x27;</span></span><br><span class="line">     <span class="attr">options:</span></span><br><span class="line">       <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">anchors:</span> </span><br><span class="line">    <span class="attr">level:</span> <span class="number">1</span> <span class="comment"># 這底是最重要的不然一級毛點會失效 </span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">&#x27;header-anchor&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSide:</span> <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    <span class="attr">permalinkSymbol:</span> <span class="string">&#x27;¶&#x27;</span></span><br><span class="line">    <span class="attr">case:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">  <span class="attr">images:</span></span><br><span class="line">    <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">prepend_root:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">post_asset:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">inline:</span> <span class="literal">false</span>  <span class="comment"># https://markdown-it.github.io/markdown-it/#MarkdownIt.renderInline</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在文章中啟用katex可以設定如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</span></span><br><span class="line">---</span><br><span class="line">title: All basic concept of Mechine Learning - ML 的重點知識整理</span><br><span class="line"><span class="built_in">date</span>: 2023-09-30 11:36:29</span><br><span class="line">abbrlink: <span class="string">&#x27;ML&#x27;</span></span><br><span class="line">katex: <span class="literal">true</span> <span class="comment"># 設定為true如果你的_config.yml設定per_page是false</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">$\bar&#123;y&#125;$ <span class="comment">#要使用 $ 把公式包圍起來</span></span><br></pre></td></tr></table></figure><h1 id="調整-blog-中圖片大小">調整 blog 中圖片大小</h1><ul><li>Ref: <a href="https://github.com/bobcn/hexo_resize_image.js">https://github.com/bobcn/hexo_resize_image.js</a></li><li>Ref: <a href="https://bobcn.github.io/2018/03/24/hexo_reset_image_size/">https://bobcn.github.io/2018/03/24/hexo_reset_image_size/</a></li></ul><ol><li>先在自己的 <code>/source/js/</code> 底下建立一個 <code>hexo_resize_image.js</code> 檔案。</li><li>貼上以下內容：</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set_image_size</span>(<span class="params">image, width, height</span>) </span><br><span class="line">&#123;</span><br><span class="line">    image.<span class="title function_">setAttribute</span>(<span class="string">&quot;width&quot;</span>, width + <span class="string">&quot;px&quot;</span>);</span><br><span class="line">    image.<span class="title function_">setAttribute</span>(<span class="string">&quot;height&quot;</span>, height + <span class="string">&quot;px&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hexo_resize_image</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> imgs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = imgs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> img = imgs[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> src = img.<span class="title function_">getAttribute</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fields = src.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=\?)\d*x\d*/g</span>);</span><br><span class="line">        <span class="keyword">if</span> (fields &amp;&amp; fields.<span class="property">length</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> values = fields[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (values.<span class="property">length</span> == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> width = values[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">var</span> height = values[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!(width.<span class="property">length</span> &amp;&amp; height.<span class="property">length</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> n_width = img.<span class="property">naturalWidth</span>;</span><br><span class="line">                    <span class="keyword">var</span> n_height = img.<span class="property">naturalHeight</span>;</span><br><span class="line">                    <span class="keyword">if</span> (width.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        height = n_height*width/n_width;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (height.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        width = n_width*height/n_height;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">set_image_size</span>(img, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fields = src.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=\?)\d*/g</span>);</span><br><span class="line">        <span class="keyword">if</span> (fields &amp;&amp; fields.<span class="property">length</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> scale = <span class="built_in">parseFloat</span>(fields[<span class="number">0</span>].<span class="title function_">toString</span>());</span><br><span class="line">            <span class="keyword">var</span> width = scale/<span class="number">100.0</span>*img.<span class="property">naturalWidth</span>;</span><br><span class="line">            <span class="keyword">var</span> height = scale/<span class="number">100.0</span>*img.<span class="property">naturalHeight</span>;</span><br><span class="line">            <span class="title function_">set_image_size</span>(img, width, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = hexo_resize_image;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>_config.butterfly.yml</code> 做以下設置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;/js/hexo_resize_image.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="mermaid-循序圖繪製">mermaid 循序圖繪製</h1><blockquote><p>參考：<a href="https://butterfly.js.org/posts/4aa8abbe/#tag-hide">https://butterfly.js.org/posts/4aa8abbe/#tag-hide</a></p></blockquote><p>使用mermaid標籤可以繪製Flowchart（流程圖）、Sequence diagram（時序圖 ）、Class Diagram（類別圖）、State Diagram（狀態圖）、Gantt（甘特圖）和Pie Chart（圓形圖），具體可以查<a href="https://mermaid-js.github.io/mermaid/#/">mermaid文檔</a></p><p>主題配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid</span></span><br><span class="line"><span class="comment"># see https://github.com/mermaid-js/mermaid</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># built-in themes: default/forest/dark/neutral</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail!</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    John-&gt;&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;&gt;John: Jolly good!</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    participant Alice    participant Bob    Alice-&gt;&gt;John: Hello John, how are you?    loop Healthcheck        John-&gt;&gt;John: Fight against hypochondria    end    Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail!    John--&gt;&gt;Alice: Great!    John-&gt;&gt;Bob: How about you?    Bob--&gt;&gt;John: Jolly good!  </pre></div><h1 id="hidden-toggle">hidden toggle</h1><blockquote><p>參考：<a href="https://butterfly.js.org/posts/4aa8abbe/#tag-hide">https://butterfly.js.org/posts/4aa8abbe/#tag-hide</a></p></blockquote><p>( display 不能包含英文逗號，可用‚)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% hideToggle Butterfly安裝方法 %&#125;</span><br><span class="line">在你的博客根目錄裏</span><br><span class="line"></span><br><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"></span><br><span class="line">如果想要安裝比較新的dev分支，可以</span><br><span class="line"></span><br><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br><span class="line"></span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure><details class="toggle" ><summary class="toggle-button" style="">Butterfly安裝方法</summary><div class="toggle-content"><p>在你的博客根目錄裏</p><p>git clone -b master <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p><p>如果想要安裝比較新的dev分支，可以</p><p>git clone -b dev <a href="https://github.com/jerryc127/hexo-theme-butterfly.git">https://github.com/jerryc127/hexo-theme-butterfly.git</a> themes/Butterfly</p></div></details><h1 id="URL網址連結-abbrlink">URL網址連結 abbrlink</h1><blockquote><p>hexo 默認生成的文章地址路徑是 【網站名稱／年／月／日／文章名稱】<br>這種鏈接對搜索爬蟲是很不友好的，第一它的 url 結構超過了三層，太深了。</p><footer><strong>@Qmike</strong><cite><a href="https://qmike.top/posts/2a1b5a62">參考連結</a></cite></footer></blockquote><p>Step1: 安裝 abbrlink 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>Step2: 修改 hexo 根目錄下 <code>config.yml</code> 中的 <code>permalink</code> 的值：</p><ul><li>插件可以參考<a href="https://github.com/rozbo/hexo-abbrlink">官方文檔</a>。</li><li>作用是將文章的鏈接轉換成數字後字母，即將博客網站的網頁轉成.html 永久鏈接的格式，有利於搜索引擎的收錄。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://shannonhung.github.io</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br></pre></td></tr></table></figure><p>Step3: 在 config.yml 最底下添加 abbrlink config</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment"># support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment"># support dec(default) and hex</span></span><br><span class="line"><span class="comment"># 不用添加其它代碼</span></span><br></pre></td></tr></table></figure><p>Check: 配置完成後，網站的鏈接應該類似這樣：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qmike.top/posts/77940e6f.html        # 有.html後綴 </span><br></pre></td></tr></table></figure><h1 id="客製化css樣式設定">客製化css樣式設定</h1><blockquote><p>前提是你使用Butterfly的template</p></blockquote><ol><li>先於 專案的根目錄建立 /source/css/style.css (不是theme的喔，因為我希望盡量跟theme解開耦合，才方便更新)</li><li>建立好後，去 _config.butterfly.yml 檔案做以下設定，目的是為了引用剛剛建立的style.css</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/style.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>然後開始設定css</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>, <span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠標樣式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/default.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/pointer.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滾動條樣式 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">    transparent <span class="number">75%</span>,</span><br><span class="line">    transparent</span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="post-title">post/title</h1><h2 id="樣式設計">樣式設計</h2><ol><li>前往<code>_config.butterfly.yml</code>設置以下內容，<code>prefix-icon</code>可以參考<a href="https://fontawesome.com/v5/cheatsheet">fontawesome</a>網站，並且貼上unicode。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beautify:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># site/post</span></span><br><span class="line">  <span class="attr">title-prefix-icon:</span> <span class="string">&#x27;\f52d&#x27;</span> <span class="comment"># &#x27;\f0c1&#x27;</span></span><br><span class="line">  <span class="attr">title-prefix-icon-color:</span> <span class="string">&#x27;#F47466&#x27;</span>  <span class="comment"># &#x27;#F47466&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>就會有以下效果囉：滑鼠點擊過去會反白<br><img src="https://i.imgur.com/eT3MdCA.png" alt=""></li></ol><h1 id="複製連結-錨點">複製連結+錨點</h1><ol><li>如果想要title有錨點可以供別人進行複製，可以做以下設定</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="attr">anchor:</span></span><br><span class="line">  <span class="attr">button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">always_show:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">&#x27;\f0c1&#x27;</span> <span class="comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span></span><br><span class="line">  <span class="attr">auto_update:</span> <span class="literal">true</span> <span class="comment"># when you scroll in post, the URL will update according to header id.</span></span><br></pre></td></tr></table></figure><ol start="2"><li>就會有以下效果囉：可以複製當前的錨點<br><img src="https://i.imgur.com/Cn3qgYh.png" alt=""></li></ol><h1 id="留言板功能">留言板功能</h1><h2 id="github-建立-client-app">github 建立 client app</h2><ol><li>前往自己github頁面<code>/Setting/Developer Setting</code>(在旁邊sidebar最下面)</li><li>先去建立<code>OAuth Application</code><br><img src="https://i.imgur.com/82HFDmz.png" alt=""></li><li>創建完成，取得Client ID和Client secrets，第一次創建application需要點擊Generate a new client secret來生成第一個secret</li></ol><h2 id="config-butterfly-yml設定gitalk與啟用">_config.butterfly.yml設定gitalk與啟用</h2><ul><li>client_id—你的Client ID</li><li>client_secret—你的Client secrets</li><li>repo—你的公開靜態網頁repo名稱</li><li>owner—你的帳號名稱</li><li>admin—你的帳號名稱</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitalk</span></span><br><span class="line"><span class="comment"># https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">shannonhung.github.io</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="string">ShannonHung</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="string">ShannonHung</span></span><br><span class="line">  <span class="attr">option:</span></span><br></pre></td></tr></table></figure><blockquote><p>以gitalk啟用留言系統</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">Gitalk</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in post&#x27;s top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Pag</span></span><br></pre></td></tr></table></figure><h2 id="front-matter啟用留言板">front-matter啟用留言板</h2><p>在butterfly Front-matter的comments變數設定true or false(啟用/關閉)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="不同樣式的Quote">不同樣式的Quote</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p>default 提示块标籤</p></div><div class="note primary no-icon flat"><p>primary 提示块标籤</p></div><div class="note success flat"><p>success 提示块标籤</p></div><div class="note info flat"><p>info 提示块标籤</p></div><div class="note warning flat"><p>warning 提示块标籤</p></div><div class="note danger flat"><p>danger 提示块标籤</p></div><h1 id="如何改變自己css？">如何改變自己css？</h1><ol><li><p>請在 <code>source</code> 底下建立 <code>style.css</code></p><ul><li>建立完後檔案會放置在： <code>source/css/style.css</code></li></ul></li><li><p>在 <code>_config.butterfly.yml</code> 中複寫以下資訊：</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/style.css&quot;&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>如果你想要我主體中的一些樣式可以參考…</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景渐变 */</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(-<span class="number">225deg</span>, <span class="number">#edd5bd6f</span> <span class="number">0%</span>, <span class="number">#f9c7998d</span> <span class="number">48%</span>, <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>, <span class="number">0.149</span>) <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* footer */</span></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>, <span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 粗體字 特效 */</span></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">153</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 鼠標樣式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/default.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">https://cdn.jsdelivr.net/gh/constown/HexoCustomFile/public/cursors/pointer.cur</span>),</span><br><span class="line">    default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 滾動條樣式 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(</span><br><span class="line">    <span class="number">45deg</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">25%</span>,</span><br><span class="line">    transparent <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">    <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">    transparent <span class="number">75%</span>,</span><br><span class="line">    transparent</span><br><span class="line">  );</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="幫你的post添加背景">幫你的post添加背景</h1><ol><li><p>可以去 unsplash 找一張圖片!上面有圖片的 code<br><img src="https://i.imgur.com/m9AEQQK.png" alt=""></p></li><li><p>開新的分頁，輸入 <code>https://source.unsplash.com/圖片的code</code>，他會幫你引導到新的圖片網址，複製那個圖片網址。</p></li><li><p>貼上post上面的header</p></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 一次搞懂Java中的equals()和hashCode()</span><br><span class="line">abbrlink: equals-hashCode</span><br><span class="line">date: 2023-06-20 15:21:48</span><br><span class="line">cover: &#123;貼在這裡&#125; ＃貼這裡</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Java</span><br><span class="line"><span class="bullet">  -</span> 物件導向</span><br><span class="line"><span class="section">categories: [&quot;技術&quot;, &quot;Java&quot;]</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h1 id="主要參考了哪些網站">主要參考了哪些網站</h1><ul><li><a href="https://chanchandev.com/note/Hexo/hexo-introduction/2335841689/#%E5%BB%BA%E7%AB%8B-Hexo-%E5%B0%88%E6%A1%88-1">最一開始</a></li><li><a href="https://blog.boshkuo.com/hexo-advanced-supplementary-3/">用來設置butterfly的相關樣式</a></li><li><a href="https://israynotarray.com/hexo/20201012/473855281/">為了能方便用vscode貼上圖片</a></li><li><a href="https://hexo.io/zh-cn/docs/asset-folders.html">貼上相關圖片用</a></li><li><a href="https://blog.boshkuo.com/hexo-from-scratch-7/">Google Analysis</a><ul><li>需要注意的是因為我使用<a href="https://butterfly.js.org/">Butterfly Theme</a>所以設置相對簡單，只需要去<code>_config.butterfly.yml</code> 尋找key: <code>google_analytics</code> 並且把id貼上即可</li><li>設定_config.butterfly.yml 的教學可以<a href="https://butterfly.js.org/posts/21cfbf15/#%E5%8D%87%E7%B4%9A%E5%BB%BA%E8%AD%B0">參考這篇</a></li></ul></li><li>sitemap配置相關參考文章<ul><li><a href="https://qmike.top/posts/2a1b5a62">https://qmike.top/posts/2a1b5a62</a></li><li><a href="https://blog.boshkuo.com/hexo-advanced-supplementary-5/">https://blog.boshkuo.com/hexo-advanced-supplementary-5/</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技術 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
